(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [886],
  {
    425: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => o });
      let i = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_from", type: "address" },
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ],
        n = [
          {
            type: "function",
            name: "approve",
            stateMutability: "nonpayable",
            inputs: [
              { name: "spender", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ type: "bool" }],
          },
        ],
        s = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "sender", type: "address" },
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ];
      var a = r(45553);
      let o = {
        getERC20Abi: (e) => (a.o.USDT_CONTRACT_ADDRESSES.includes(e) ? s : i),
        getSwapAbi: () => n,
      };
    },
    669: (e, t, r) => {
      let i = r(46342).getSymbolSize;
      (t.getRowColCoords = function (e) {
        if (1 === e) return [];
        let t = Math.floor(e / 7) + 2,
          r = i(e),
          n = 145 === r ? 26 : 2 * Math.ceil((r - 13) / (2 * t - 2)),
          s = [r - 7];
        for (let e = 1; e < t - 1; e++) s[e] = s[e - 1] - n;
        return s.push(6), s.reverse();
      }),
        (t.getPositions = function (e) {
          let r = [],
            i = t.getRowColCoords(e),
            n = i.length;
          for (let e = 0; e < n; e++)
            for (let t = 0; t < n; t++)
              (0 !== e || 0 !== t) &&
                (0 !== e || t !== n - 1) &&
                (e !== n - 1 || 0 !== t) &&
                r.push([i[e], i[t]]);
          return r;
        });
    },
    890: (e, t, r) => {
      "use strict";
      r.d(t, {
        Vw: () => m,
        DO: () => s,
        CC: () => o,
        sd: () => a,
        Fe: () => n,
        Ht: () => c,
        uH: () => d,
        Id: () => g,
        qj: () => y,
        O8: () => h,
        po: () => w,
        Ow: () => u,
        fd: () => p,
        ZJ: () => f,
        DH: () => l,
      });
      let i =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      function n(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function s(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function a(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.createHasher");
        n(e.outputLen), n(e.blockLen);
      }
      function o(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function c(e, t) {
        s(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      function l(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function d(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      function h(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function u(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let p =
        68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0]
          ? (e) => e
          : function (e) {
              for (let r = 0; r < e.length; r++) {
                var t;
                e[r] =
                  (((t = e[r]) << 24) & 0xff000000) |
                  ((t << 8) & 0xff0000) |
                  ((t >>> 8) & 65280) |
                  ((t >>> 24) & 255);
              }
              return e;
            };
      function f(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e) throw Error("string expected");
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          s(e),
          e
        );
      }
      function g(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          s(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let n = e[t];
          r.set(n, i), (i += n.length);
        }
        return r;
      }
      class m {}
      function y(e) {
        let t = (t) => e().update(f(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function w(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        if (i && "function" == typeof i.randomBytes)
          return Uint8Array.from(i.randomBytes(e));
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    1220: (e, t, r) => {
      "use strict";
      r.d(t, {
        B1: () => u,
        BX: () =>
          function e(t = {}) {
            let r, s, c;
            if (!n(t)) throw Error("object required");
            let u = d.get(t);
            if (u) return u;
            let p = l[0],
              f = new Set(),
              g = (e, t = ++l[0]) => {
                p !== t && ((m = p = t), f.forEach((r) => r(e, t)));
              },
              m = p,
              y = (e) => (t, r) => {
                let i = [...t];
                (i[1] = [e, ...i[1]]), g(i, r);
              },
              w = new Map(),
              b = !0,
              v = new Proxy(
                t,
                ((r = () => b),
                (s = (e, t) => {
                  let r = !o.has(t) && a.get(t);
                  if (r) {
                    if (w.has(e)) throw Error("prop listener already exists");
                    if (f.size) {
                      let t = r[2](y(e));
                      w.set(e, [r, t]);
                    } else w.set(e, [r]);
                  }
                }),
                (c = (e) => {
                  var t;
                  let r = w.get(e);
                  r && (w.delete(e), null == (t = r[1]) || t.call(r));
                }),
                {
                  deleteProperty(e, t) {
                    let r = Reflect.get(e, t);
                    c(t);
                    let i = Reflect.deleteProperty(e, t);
                    return i && g(["delete", [t], r]), i;
                  },
                  set(t, l, u, p) {
                    let f,
                      m = !r() && Reflect.has(t, l),
                      y = Reflect.get(t, l, p);
                    if (m && (h(y, u) || (d.has(u) && h(y, d.get(u)))))
                      return !0;
                    c(l), n(u) && (u = (0, i.Ai)(u) || u);
                    let w =
                      !a.has(u) &&
                      n((f = u)) &&
                      !o.has(f) &&
                      (Array.isArray(f) || !(Symbol.iterator in f)) &&
                      !(f instanceof WeakMap) &&
                      !(f instanceof WeakSet) &&
                      !(f instanceof Error) &&
                      !(f instanceof Number) &&
                      !(f instanceof Date) &&
                      !(f instanceof String) &&
                      !(f instanceof RegExp) &&
                      !(f instanceof ArrayBuffer) &&
                      !(f instanceof Promise)
                        ? e(u)
                        : u;
                    return (
                      s(l, w),
                      Reflect.set(t, l, w, p),
                      g(["set", [l], u, y]),
                      !0
                    );
                  },
                })
              );
            d.set(t, v);
            let C = [
              t,
              (e = l[0]) => (
                m !== e &&
                  ((m = e),
                  w.forEach(([t]) => {
                    let r = t[1](e);
                    r > p && (p = r);
                  })),
                p
              ),
              (e) => (
                f.add(e),
                1 === f.size &&
                  w.forEach(([e, t], r) => {
                    if (t) throw Error("remove already exists");
                    let i = e[2](y(r));
                    w.set(r, [e, i]);
                  }),
                () => {
                  f.delete(e),
                    0 === f.size &&
                      w.forEach(([e, t], r) => {
                        t && (t(), w.set(r, [e]));
                      });
                }
              ),
            ];
            return (
              a.set(v, C),
              Reflect.ownKeys(t).forEach((e) => {
                let r = Object.getOwnPropertyDescriptor(t, e);
                "value" in r && r.writable && (v[e] = t[e]);
              }),
              (b = !1),
              v
            );
          },
        KR: () => f,
        P9: () => p,
        h2: () => g,
      });
      var i = r(73022);
      let n = (e) => "object" == typeof e && null !== e,
        s = (e, t) => {
          let r = c.get(e);
          if ((null == r ? void 0 : r[0]) === t) return r[1];
          let n = Array.isArray(e)
            ? []
            : Object.create(Object.getPrototypeOf(e));
          return (
            (0, i.OC)(n, !0),
            c.set(e, [t, n]),
            Reflect.ownKeys(e).forEach((t) => {
              if (Object.getOwnPropertyDescriptor(n, t)) return;
              let r = Reflect.get(e, t),
                { enumerable: c } = Reflect.getOwnPropertyDescriptor(e, t),
                l = { value: r, enumerable: c, configurable: !0 };
              if (o.has(r)) (0, i.OC)(r, !1);
              else if (a.has(r)) {
                let [e, t] = a.get(r);
                l.value = s(e, t());
              }
              Object.defineProperty(n, t, l);
            }),
            Object.preventExtensions(n)
          );
        },
        a = new WeakMap(),
        o = new WeakSet(),
        c = new WeakMap(),
        l = [1],
        d = new WeakMap(),
        h = Object.is;
      function u(e, t, r) {
        let i,
          n = a.get(e);
        n || console.warn("Please use proxy object");
        let s = [],
          o = n[2],
          c = !1,
          l = o((e) => {
            if ((s.push(e), r)) return void t(s.splice(0));
            i ||
              (i = Promise.resolve().then(() => {
                (i = void 0), c && t(s.splice(0));
              }));
          });
        return (
          (c = !0),
          () => {
            (c = !1), l();
          }
        );
      }
      function p(e) {
        let t = a.get(e);
        t || console.warn("Please use proxy object");
        let [r, i] = t;
        return s(r, i());
      }
      function f(e) {
        return o.add(e), e;
      }
      function g() {
        return {
          proxyStateMap: a,
          refSet: o,
          snapCache: c,
          versionHolder: l,
          proxyCache: d,
        };
      }
    },
    1418: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(45166);
      var s = r(71084),
        a = r(8821),
        o = r(47327),
        c = r(20296);
      let l = (0, c.AH)`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
    border-radius: ${({ borderRadius: e }) => e[16]};
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  :host([data-variant='generated']) {
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.imageSrc = void 0),
            (this.alt = void 0),
            (this.address = void 0),
            (this.size = "xl");
        }
        render() {
          let e = {
            inherit: "inherit",
            xxs: "3",
            xs: "5",
            sm: "6",
            md: "8",
            mdl: "8",
            lg: "10",
            xl: "16",
            xxl: "20",
          };
          return (
            (this.style.cssText = `
    --local-width: var(--apkt-spacing-${e[this.size ?? "xl"]});
    --local-height: var(--apkt-spacing-${e[this.size ?? "xl"]});
    `),
            (0, i.qy)`${this.visualTemplate()}`
          );
        }
        visualTemplate() {
          if (this.imageSrc)
            return (
              (this.dataset.variant = "image"),
              (0, i.qy)`<wui-image src=${this.imageSrc} alt=${
                this.alt ?? "avatar"
              }></wui-image>`
            );
          if (this.address) {
            this.dataset.variant = "generated";
            let e = a.Z.generateAvatarColors(this.address);
            return (
              (this.style.cssText += `
 ${e}`),
              null
            );
          }
          return (this.dataset.variant = "default"), null;
        }
      };
      (h.styles = [s.W5, l]),
        d([(0, n.MZ)()], h.prototype, "imageSrc", void 0),
        d([(0, n.MZ)()], h.prototype, "alt", void 0),
        d([(0, n.MZ)()], h.prototype, "address", void 0),
        d([(0, n.MZ)()], h.prototype, "size", void 0),
        (h = d([(0, o.E)("wui-avatar")], h));
    },
    1507: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964);
      r(24772);
      var a = r(71084),
        o = r(47327);
      r(47824);
      var c = r(20296);
      let l = (0, c.AH)`
  :host {
    width: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: ${({ spacing: e }) => e[3]};
    width: 100%;
    background-color: transparent;
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  wui-text {
    text-transform: capitalize;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    }
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.logo = "google"),
            (this.name = "Continue with google"),
            (this.disabled = !1);
        }
        render() {
          return (0, i.qy)`
      <button ?disabled=${this.disabled} tabindex=${(0, s.J)(this.tabIdx)}>
        <wui-flex gap="2" alignItems="center">
          <wui-image ?boxed=${!0} logo=${this.logo}></wui-image>
          <wui-text variant="lg-regular" color="primary">${this.name}</wui-text>
        </wui-flex>
        <wui-icon name="chevronRight" size="lg" color="default"></wui-icon>
      </button>
    `;
        }
      };
      (h.styles = [a.W5, a.fD, l]),
        d([(0, n.MZ)()], h.prototype, "logo", void 0),
        d([(0, n.MZ)()], h.prototype, "name", void 0),
        d([(0, n.MZ)()], h.prototype, "tabIdx", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "disabled", void 0),
        (h = d([(0, o.E)("wui-list-social")], h));
    },
    1805: (e, t, r) => {
      "use strict";
      r(18294);
    },
    2354: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => s });
      var i = r(52321),
        n = r(32973);
      let s = (0, n.u$)(
        class extends n.WL {
          constructor(e) {
            if (
              (super(e),
              e.type !== n.OA.ATTRIBUTE ||
                "class" !== e.name ||
                e.strings?.length > 2)
            )
              throw Error(
                "`classMap()` can only be used in the `class` attribute and must be the only part in the attribute."
              );
          }
          render(e) {
            return (
              " " +
              Object.keys(e)
                .filter((t) => e[t])
                .join(" ") +
              " "
            );
          }
          update(e, [t]) {
            if (void 0 === this.st) {
              for (let r in ((this.st = new Set()),
              void 0 !== e.strings &&
                (this.nt = new Set(
                  e.strings
                    .join(" ")
                    .split(/\s/)
                    .filter((e) => "" !== e)
                )),
              t))
                t[r] && !this.nt?.has(r) && this.st.add(r);
              return this.render(t);
            }
            let r = e.element.classList;
            for (let e of this.st) e in t || (r.remove(e), this.st.delete(e));
            for (let e in t) {
              let i = !!t[e];
              i === this.st.has(e) ||
                this.nt?.has(e) ||
                (i
                  ? (r.add(e), this.st.add(e))
                  : (r.remove(e), this.st.delete(e)));
            }
            return i.c0;
          }
        }
      );
    },
    2648: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(48543), t), i.__exportStar(r(25939), t);
    },
    3375: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { Y: () => rv });
      var n,
        s,
        a,
        o,
        c = r(65103),
        l = r(45553),
        d = r(73537),
        h = r(17389);
      !(function (e) {
        (e.assertEqual = (e) => e),
          (e.assertIs = function (e) {}),
          (e.assertNever = function (e) {
            throw Error();
          }),
          (e.arrayToEnum = (e) => {
            let t = {};
            for (let r of e) t[r] = r;
            return t;
          }),
          (e.getValidEnumValues = (t) => {
            let r = e.objectKeys(t).filter((e) => "number" != typeof t[t[e]]),
              i = {};
            for (let e of r) i[e] = t[e];
            return e.objectValues(i);
          }),
          (e.objectValues = (t) =>
            e.objectKeys(t).map(function (e) {
              return t[e];
            })),
          (e.objectKeys =
            "function" == typeof Object.keys
              ? (e) => Object.keys(e)
              : (e) => {
                  let t = [];
                  for (let r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                  return t;
                }),
          (e.find = (e, t) => {
            for (let r of e) if (t(r)) return r;
          }),
          (e.isInteger =
            "function" == typeof Number.isInteger
              ? (e) => Number.isInteger(e)
              : (e) =>
                  "number" == typeof e && isFinite(e) && Math.floor(e) === e),
          (e.joinValues = function (e, t = " | ") {
            return e.map((e) => ("string" == typeof e ? `'${e}'` : e)).join(t);
          }),
          (e.jsonStringifyReplacer = (e, t) =>
            "bigint" == typeof t ? t.toString() : t);
      })(n || (n = {})),
        ((s || (s = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      let u = n.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]),
        p = (e) => {
          switch (typeof e) {
            case "undefined":
              return u.undefined;
            case "string":
              return u.string;
            case "number":
              return isNaN(e) ? u.nan : u.number;
            case "boolean":
              return u.boolean;
            case "function":
              return u.function;
            case "bigint":
              return u.bigint;
            case "symbol":
              return u.symbol;
            case "object":
              if (Array.isArray(e)) return u.array;
              if (null === e) return u.null;
              if (
                e.then &&
                "function" == typeof e.then &&
                e.catch &&
                "function" == typeof e.catch
              )
                return u.promise;
              if ("undefined" != typeof Map && e instanceof Map) return u.map;
              if ("undefined" != typeof Set && e instanceof Set) return u.set;
              if ("undefined" != typeof Date && e instanceof Date)
                return u.date;
              return u.object;
            default:
              return u.unknown;
          }
        },
        f = n.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]);
      class g extends Error {
        constructor(e) {
          super(),
            (this.issues = []),
            (this.addIssue = (e) => {
              this.issues = [...this.issues, e];
            }),
            (this.addIssues = (e = []) => {
              this.issues = [...this.issues, ...e];
            });
          let t = new.target.prototype;
          Object.setPrototypeOf
            ? Object.setPrototypeOf(this, t)
            : (this.__proto__ = t),
            (this.name = "ZodError"),
            (this.issues = e);
        }
        get errors() {
          return this.issues;
        }
        format(e) {
          let t =
              e ||
              function (e) {
                return e.message;
              },
            r = { _errors: [] },
            i = (e) => {
              for (let n of e.issues)
                if ("invalid_union" === n.code) n.unionErrors.map(i);
                else if ("invalid_return_type" === n.code) i(n.returnTypeError);
                else if ("invalid_arguments" === n.code) i(n.argumentsError);
                else if (0 === n.path.length) r._errors.push(t(n));
                else {
                  let e = r,
                    i = 0;
                  for (; i < n.path.length; ) {
                    let r = n.path[i];
                    i === n.path.length - 1
                      ? ((e[r] = e[r] || { _errors: [] }),
                        e[r]._errors.push(t(n)))
                      : (e[r] = e[r] || { _errors: [] }),
                      (e = e[r]),
                      i++;
                  }
                }
            };
          return i(this), r;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, n.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return 0 === this.issues.length;
        }
        flatten(e = (e) => e.message) {
          let t = {},
            r = [];
          for (let i of this.issues)
            i.path.length > 0
              ? ((t[i.path[0]] = t[i.path[0]] || []), t[i.path[0]].push(e(i)))
              : r.push(e(i));
          return { formErrors: r, fieldErrors: t };
        }
        get formErrors() {
          return this.flatten();
        }
      }
      g.create = (e) => new g(e);
      let m = (e, t) => {
          let r;
          switch (e.code) {
            case f.invalid_type:
              r =
                e.received === u.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case f.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(
                e.expected,
                n.jsonStringifyReplacer
              )}`;
              break;
            case f.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${n.joinValues(
                e.keys,
                ", "
              )}`;
              break;
            case f.invalid_union:
              r = "Invalid input";
              break;
            case f.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${n.joinValues(
                e.options
              )}`;
              break;
            case f.invalid_enum_value:
              r = `Invalid enum value. Expected ${n.joinValues(
                e.options
              )}, received '${e.received}'`;
              break;
            case f.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case f.invalid_return_type:
              r = "Invalid function return type";
              break;
            case f.invalid_date:
              r = "Invalid date";
              break;
            case f.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                  ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                  : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : n.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case f.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at least"
                        : "more than"
                    } ${e.minimum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at least" : "over"
                    } ${e.minimum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${e.minimum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${new Date(Number(e.minimum))}`
                  : "Invalid input";
              break;
            case f.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at most"
                        : "less than"
                    } ${e.maximum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at most" : "under"
                    } ${e.maximum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "bigint" === e.type
                  ? `BigInt must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "smaller than or equal to"
                        : "smaller than"
                    } ${new Date(Number(e.maximum))}`
                  : "Invalid input";
              break;
            case f.custom:
              r = "Invalid input";
              break;
            case f.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case f.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case f.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), n.assertNever(e);
          }
          return { message: r };
        },
        y = m;
      function w() {
        return y;
      }
      let b = (e) => {
        let { data: t, path: r, errorMaps: i, issueData: n } = e,
          s = [...r, ...(n.path || [])],
          a = { ...n, path: s },
          o = "";
        for (let e of i
          .filter((e) => !!e)
          .slice()
          .reverse())
          o = e(a, { data: t, defaultError: o }).message;
        return { ...n, path: s, message: n.message || o };
      };
      function v(e, t) {
        let r = b({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            w(),
            m,
          ].filter((e) => !!e),
        });
        e.common.issues.push(r);
      }
      class C {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          "valid" === this.value && (this.value = "dirty");
        }
        abort() {
          "aborted" !== this.value && (this.value = "aborted");
        }
        static mergeArray(e, t) {
          let r = [];
          for (let i of t) {
            if ("aborted" === i.status) return E;
            "dirty" === i.status && e.dirty(), r.push(i.value);
          }
          return { status: e.value, value: r };
        }
        static async mergeObjectAsync(e, t) {
          let r = [];
          for (let e of t) r.push({ key: await e.key, value: await e.value });
          return C.mergeObjectSync(e, r);
        }
        static mergeObjectSync(e, t) {
          let r = {};
          for (let i of t) {
            let { key: t, value: n } = i;
            if ("aborted" === t.status || "aborted" === n.status) return E;
            "dirty" === t.status && e.dirty(),
              "dirty" === n.status && e.dirty(),
              "__proto__" !== t.value &&
                (void 0 !== n.value || i.alwaysSet) &&
                (r[t.value] = n.value);
          }
          return { status: e.value, value: r };
        }
      }
      let E = Object.freeze({ status: "aborted" }),
        x = (e) => ({ status: "dirty", value: e }),
        A = (e) => ({ status: "valid", value: e }),
        _ = (e) => "aborted" === e.status,
        I = (e) => "dirty" === e.status,
        S = (e) => "valid" === e.status,
        k = (e) => "undefined" != typeof Promise && e instanceof Promise;
      !(function (e) {
        (e.errToObj = (e) => ("string" == typeof e ? { message: e } : e || {})),
          (e.toString = (e) =>
            "string" == typeof e ? e : null == e ? void 0 : e.message);
      })(a || (a = {}));
      class N {
        constructor(e, t, r, i) {
          (this._cachedPath = []),
            (this.parent = e),
            (this.data = t),
            (this._path = r),
            (this._key = i);
        }
        get path() {
          return (
            this._cachedPath.length ||
              (this._key instanceof Array
                ? this._cachedPath.push(...this._path, ...this._key)
                : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
          );
        }
      }
      let T = (e, t) => {
        if (S(t)) return { success: !0, data: t.value };
        if (!e.common.issues.length)
          throw Error("Validation failed but no issues detected.");
        return {
          success: !1,
          get error() {
            if (this._error) return this._error;
            let t = new g(e.common.issues);
            return (this._error = t), this._error;
          },
        };
      };
      function O(e) {
        if (!e) return {};
        let {
          errorMap: t,
          invalid_type_error: r,
          required_error: i,
          description: n,
        } = e;
        if (t && (r || i))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: n }
          : {
              errorMap: (e, t) =>
                "invalid_type" !== e.code
                  ? { message: t.defaultError }
                  : void 0 === t.data
                  ? { message: null != i ? i : t.defaultError }
                  : { message: null != r ? r : t.defaultError },
              description: n,
            };
      }
      class P {
        constructor(e) {
          (this.spa = this.safeParseAsync),
            (this._def = e),
            (this.parse = this.parse.bind(this)),
            (this.safeParse = this.safeParse.bind(this)),
            (this.parseAsync = this.parseAsync.bind(this)),
            (this.safeParseAsync = this.safeParseAsync.bind(this)),
            (this.spa = this.spa.bind(this)),
            (this.refine = this.refine.bind(this)),
            (this.refinement = this.refinement.bind(this)),
            (this.superRefine = this.superRefine.bind(this)),
            (this.optional = this.optional.bind(this)),
            (this.nullable = this.nullable.bind(this)),
            (this.nullish = this.nullish.bind(this)),
            (this.array = this.array.bind(this)),
            (this.promise = this.promise.bind(this)),
            (this.or = this.or.bind(this)),
            (this.and = this.and.bind(this)),
            (this.transform = this.transform.bind(this)),
            (this.brand = this.brand.bind(this)),
            (this.default = this.default.bind(this)),
            (this.catch = this.catch.bind(this)),
            (this.describe = this.describe.bind(this)),
            (this.pipe = this.pipe.bind(this)),
            (this.readonly = this.readonly.bind(this)),
            (this.isNullable = this.isNullable.bind(this)),
            (this.isOptional = this.isOptional.bind(this));
        }
        get description() {
          return this._def.description;
        }
        _getType(e) {
          return p(e.data);
        }
        _getOrReturnCtx(e, t) {
          return (
            t || {
              common: e.parent.common,
              data: e.data,
              parsedType: p(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            }
          );
        }
        _processInputParams(e) {
          return {
            status: new C(),
            ctx: {
              common: e.parent.common,
              data: e.data,
              parsedType: p(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            },
          };
        }
        _parseSync(e) {
          let t = this._parse(e);
          if (k(t)) throw Error("Synchronous parse encountered promise.");
          return t;
        }
        _parseAsync(e) {
          return Promise.resolve(this._parse(e));
        }
        parse(e, t) {
          let r = this.safeParse(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        safeParse(e, t) {
          var r;
          let i = {
              common: {
                issues: [],
                async: null != (r = null == t ? void 0 : t.async) && r,
                contextualErrorMap: null == t ? void 0 : t.errorMap,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: p(e),
            },
            n = this._parseSync({ data: e, path: i.path, parent: i });
          return T(i, n);
        }
        async parseAsync(e, t) {
          let r = await this.safeParseAsync(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        async safeParseAsync(e, t) {
          let r = {
              common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: p(e),
            },
            i = this._parse({ data: e, path: r.path, parent: r });
          return T(r, await (k(i) ? i : Promise.resolve(i)));
        }
        refine(e, t) {
          return this._refinement((r, i) => {
            let n = e(r),
              s = () =>
                i.addIssue({
                  code: f.custom,
                  ...("string" == typeof t || void 0 === t
                    ? { message: t }
                    : "function" == typeof t
                    ? t(r)
                    : t),
                });
            return "undefined" != typeof Promise && n instanceof Promise
              ? n.then((e) => !!e || (s(), !1))
              : !!n || (s(), !1);
          });
        }
        refinement(e, t) {
          return this._refinement(
            (r, i) =>
              !!e(r) || (i.addIssue("function" == typeof t ? t(r, i) : t), !1)
          );
        }
        _refinement(e) {
          return new em({
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "refinement", refinement: e },
          });
        }
        superRefine(e) {
          return this._refinement(e);
        }
        optional() {
          return ey.create(this, this._def);
        }
        nullable() {
          return ew.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return Q.create(this, this._def);
        }
        promise() {
          return eg.create(this, this._def);
        }
        or(e) {
          return et.create([this, e], this._def);
        }
        and(e) {
          return en.create(this, e, this._def);
        }
        transform(e) {
          return new em({
            ...O(this._def),
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "transform", transform: e },
          });
        }
        default(e) {
          return new eb({
            ...O(this._def),
            innerType: this,
            defaultValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodDefault,
          });
        }
        brand() {
          return new ex({
            typeName: o.ZodBranded,
            type: this,
            ...O(this._def),
          });
        }
        catch(e) {
          return new ev({
            ...O(this._def),
            innerType: this,
            catchValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodCatch,
          });
        }
        describe(e) {
          return new this.constructor({ ...this._def, description: e });
        }
        pipe(e) {
          return eA.create(this, e);
        }
        readonly() {
          return e_.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      }
      let R = /^c[^\s-]{8,}$/i,
        $ = /^[a-z][a-z0-9]*$/,
        D = /^[0-9A-HJKMNP-TV-Z]{26}$/,
        U =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        M =
          /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        L =
          /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
        B =
          /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        W = (e) => {
          if (e.precision)
            if (e.offset)
              return RegExp(
                `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
              );
            else
              return RegExp(
                `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`
              );
          if (0 === e.precision)
            if (e.offset)
              return RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              );
            else return RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$");
          return e.offset
            ? RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              )
            : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
        };
      class j extends P {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== u.string)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.string,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new C();
          for (let o of this._def.checks)
            if ("min" === o.kind)
              e.data.length < o.value &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  minimum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("max" === o.kind)
              e.data.length > o.value &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  maximum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("length" === o.kind) {
              let i = e.data.length > o.value,
                n = e.data.length < o.value;
              (i || n) &&
                ((t = this._getOrReturnCtx(e, t)),
                i
                  ? v(t, {
                      code: f.too_big,
                      maximum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    })
                  : n &&
                    v(t, {
                      code: f.too_small,
                      minimum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    }),
                r.dirty());
            } else if ("email" === o.kind)
              M.test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  validation: "email",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("emoji" === o.kind)
              i ||
                (i = RegExp(
                  "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                  "u"
                )),
                i.test(e.data) ||
                  (v((t = this._getOrReturnCtx(e, t)), {
                    validation: "emoji",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("uuid" === o.kind)
              U.test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  validation: "uuid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid" === o.kind)
              R.test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid2" === o.kind)
              $.test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid2",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("ulid" === o.kind)
              D.test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  validation: "ulid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("url" === o.kind)
              try {
                new URL(e.data);
              } catch (i) {
                v((t = this._getOrReturnCtx(e, t)), {
                  validation: "url",
                  code: f.invalid_string,
                  message: o.message,
                }),
                  r.dirty();
              }
            else if ("regex" === o.kind)
              (o.regex.lastIndex = 0),
                o.regex.test(e.data) ||
                  (v((t = this._getOrReturnCtx(e, t)), {
                    validation: "regex",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("trim" === o.kind) e.data = e.data.trim();
            else if ("includes" === o.kind)
              e.data.includes(o.value, o.position) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { includes: o.value, position: o.position },
                  message: o.message,
                }),
                r.dirty());
            else if ("toLowerCase" === o.kind) e.data = e.data.toLowerCase();
            else if ("toUpperCase" === o.kind) e.data = e.data.toUpperCase();
            else if ("startsWith" === o.kind)
              e.data.startsWith(o.value) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { startsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("endsWith" === o.kind)
              e.data.endsWith(o.value) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { endsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("datetime" === o.kind)
              W(o).test(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: "datetime",
                  message: o.message,
                }),
                r.dirty());
            else if ("ip" === o.kind) {
              var s, a;
              (s = e.data),
                !(
                  (("v4" === (a = o.version) || !a) && L.test(s)) ||
                  (("v6" === a || !a) && B.test(s))
                ) &&
                  1 &&
                  (v((t = this._getOrReturnCtx(e, t)), {
                    validation: "ip",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            } else n.assertNever(o);
          return { status: r.value, value: e.data };
        }
        _regex(e, t, r) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: f.invalid_string,
            ...a.errToObj(r),
          });
        }
        _addCheck(e) {
          return new j({ ...this._def, checks: [...this._def.checks, e] });
        }
        email(e) {
          return this._addCheck({ kind: "email", ...a.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: "url", ...a.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: "emoji", ...a.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: "uuid", ...a.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: "cuid", ...a.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: "cuid2", ...a.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: "ulid", ...a.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: "ip", ...a.errToObj(e) });
        }
        datetime(e) {
          var t;
          return "string" == typeof e
            ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                message: e,
              })
            : this._addCheck({
                kind: "datetime",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                    ? void 0
                    : e.precision,
                offset: null != (t = null == e ? void 0 : e.offset) && t,
                ...a.errToObj(null == e ? void 0 : e.message),
              });
        }
        regex(e, t) {
          return this._addCheck({ kind: "regex", regex: e, ...a.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...a.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({
            kind: "startsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        endsWith(e, t) {
          return this._addCheck({
            kind: "endsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        min(e, t) {
          return this._addCheck({ kind: "min", value: e, ...a.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: "max", value: e, ...a.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: "length", value: e, ...a.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, a.errToObj(e));
        }
        trim() {
          return new j({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
          });
        }
        toLowerCase() {
          return new j({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
          });
        }
        toUpperCase() {
          return new j({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => "datetime" === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => "email" === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => "url" === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => "emoji" === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => "uuid" === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => "cuid" === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => "cuid2" === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => "ulid" === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => "ip" === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      j.create = (e) => {
        var t;
        return new j({
          checks: [],
          typeName: o.ZodString,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...O(e),
        });
      };
      class F extends P {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== u.number)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.number,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new C();
          for (let i of this._def.checks)
            "int" === i.kind
              ? n.isInteger(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: i.message,
                }),
                r.dirty())
              : "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  minimum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  maximum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? 0 !==
                  (function (e, t) {
                    let r = (e.toString().split(".")[1] || "").length,
                      i = (t.toString().split(".")[1] || "").length,
                      n = r > i ? r : i;
                    return (
                      (parseInt(e.toFixed(n).replace(".", "")) %
                        parseInt(t.toFixed(n).replace(".", ""))) /
                      Math.pow(10, n)
                    );
                  })(e.data, i.value) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : "finite" === i.kind
              ? Number.isFinite(e.data) ||
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_finite,
                  message: i.message,
                }),
                r.dirty())
              : n.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new F({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new F({ ...this._def, checks: [...this._def.checks, e] });
        }
        int(e) {
          return this._addCheck({ kind: "int", message: a.toString(e) });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        finite(e) {
          return this._addCheck({ kind: "finite", message: a.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: a.toString(e),
          })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: a.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) =>
              "int" === e.kind ||
              ("multipleOf" === e.kind && n.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let r of this._def.checks)
            if (
              "finite" === r.kind ||
              "int" === r.kind ||
              "multipleOf" === r.kind
            )
              return !0;
            else
              "min" === r.kind
                ? (null === t || r.value > t) && (t = r.value)
                : "max" === r.kind &&
                  (null === e || r.value < e) &&
                  (e = r.value);
          return Number.isFinite(t) && Number.isFinite(e);
        }
      }
      F.create = (e) =>
        new F({
          checks: [],
          typeName: o.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...O(e),
        });
      class H extends P {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = BigInt(e.data)),
            this._getType(e) !== u.bigint)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.bigint,
                received: t.parsedType,
              }),
              E
            );
          }
          let r = new C();
          for (let i of this._def.checks)
            "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  type: "bigint",
                  minimum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  type: "bigint",
                  maximum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? e.data % i.value !== BigInt(0) &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : n.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new H({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new H({ ...this._def, checks: [...this._def.checks, e] });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      H.create = (e) => {
        var t;
        return new H({
          checks: [],
          typeName: o.ZodBigInt,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...O(e),
        });
      };
      class q extends P {
        _parse(e) {
          if (
            (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== u.boolean)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.boolean,
                received: t.parsedType,
              }),
              E
            );
          }
          return A(e.data);
        }
      }
      q.create = (e) =>
        new q({
          typeName: o.ZodBoolean,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...O(e),
        });
      class z extends P {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== u.date)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.date,
                received: t.parsedType,
              }),
              E
            );
          }
          if (isNaN(e.data.getTime()))
            return v(this._getOrReturnCtx(e), { code: f.invalid_date }), E;
          let r = new C();
          for (let i of this._def.checks)
            "min" === i.kind
              ? e.data.getTime() < i.value &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: i.value,
                  type: "date",
                }),
                r.dirty())
              : "max" === i.kind
              ? e.data.getTime() > i.value &&
                (v((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  maximum: i.value,
                  type: "date",
                }),
                r.dirty())
              : n.assertNever(i);
          return { status: r.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(e) {
          return new z({ ...this._def, checks: [...this._def.checks, e] });
        }
        min(e, t) {
          return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        max(e, t) {
          return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      }
      z.create = (e) =>
        new z({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: o.ZodDate,
          ...O(e),
        });
      class V extends P {
        _parse(e) {
          if (this._getType(e) !== u.symbol) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.symbol,
                received: t.parsedType,
              }),
              E
            );
          }
          return A(e.data);
        }
      }
      V.create = (e) => new V({ typeName: o.ZodSymbol, ...O(e) });
      class Z extends P {
        _parse(e) {
          if (this._getType(e) !== u.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.undefined,
                received: t.parsedType,
              }),
              E
            );
          }
          return A(e.data);
        }
      }
      Z.create = (e) => new Z({ typeName: o.ZodUndefined, ...O(e) });
      class K extends P {
        _parse(e) {
          if (this._getType(e) !== u.null) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.null,
                received: t.parsedType,
              }),
              E
            );
          }
          return A(e.data);
        }
      }
      K.create = (e) => new K({ typeName: o.ZodNull, ...O(e) });
      class G extends P {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return A(e.data);
        }
      }
      G.create = (e) => new G({ typeName: o.ZodAny, ...O(e) });
      class J extends P {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return A(e.data);
        }
      }
      J.create = (e) => new J({ typeName: o.ZodUnknown, ...O(e) });
      class Y extends P {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return (
            v(t, {
              code: f.invalid_type,
              expected: u.never,
              received: t.parsedType,
            }),
            E
          );
        }
      }
      Y.create = (e) => new Y({ typeName: o.ZodNever, ...O(e) });
      class X extends P {
        _parse(e) {
          if (this._getType(e) !== u.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.void,
                received: t.parsedType,
              }),
              E
            );
          }
          return A(e.data);
        }
      }
      X.create = (e) => new X({ typeName: o.ZodVoid, ...O(e) });
      class Q extends P {
        _parse(e) {
          let { ctx: t, status: r } = this._processInputParams(e),
            i = this._def;
          if (t.parsedType !== u.array)
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.array,
                received: t.parsedType,
              }),
              E
            );
          if (null !== i.exactLength) {
            let e = t.data.length > i.exactLength.value,
              n = t.data.length < i.exactLength.value;
            (e || n) &&
              (v(t, {
                code: e ? f.too_big : f.too_small,
                minimum: n ? i.exactLength.value : void 0,
                maximum: e ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message,
              }),
              r.dirty());
          }
          if (
            (null !== i.minLength &&
              t.data.length < i.minLength.value &&
              (v(t, {
                code: f.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message,
              }),
              r.dirty()),
            null !== i.maxLength &&
              t.data.length > i.maxLength.value &&
              (v(t, {
                code: f.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message,
              }),
              r.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, r) =>
                i.type._parseAsync(new N(t, e, t.path, r))
              )
            ).then((e) => C.mergeArray(r, e));
          let n = [...t.data].map((e, r) =>
            i.type._parseSync(new N(t, e, t.path, r))
          );
          return C.mergeArray(r, n);
        }
        get element() {
          return this._def.type;
        }
        min(e, t) {
          return new Q({
            ...this._def,
            minLength: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new Q({
            ...this._def,
            maxLength: { value: e, message: a.toString(t) },
          });
        }
        length(e, t) {
          return new Q({
            ...this._def,
            exactLength: { value: e, message: a.toString(t) },
          });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      Q.create = (e, t) =>
        new Q({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: o.ZodArray,
          ...O(t),
        });
      class ee extends P {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = n.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== u.object) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.object,
                received: t.parsedType,
              }),
              E
            );
          }
          let { status: t, ctx: r } = this._processInputParams(e),
            { shape: i, keys: n } = this._getCached(),
            s = [];
          if (
            !(
              this._def.catchall instanceof Y &&
              "strip" === this._def.unknownKeys
            )
          )
            for (let e in r.data) n.includes(e) || s.push(e);
          let a = [];
          for (let e of n) {
            let t = i[e],
              n = r.data[e];
            a.push({
              key: { status: "valid", value: e },
              value: t._parse(new N(r, n, r.path, e)),
              alwaysSet: e in r.data,
            });
          }
          if (this._def.catchall instanceof Y) {
            let e = this._def.unknownKeys;
            if ("passthrough" === e)
              for (let e of s)
                a.push({
                  key: { status: "valid", value: e },
                  value: { status: "valid", value: r.data[e] },
                });
            else if ("strict" === e)
              s.length > 0 &&
                (v(r, { code: f.unrecognized_keys, keys: s }), t.dirty());
            else if ("strip" === e);
            else
              throw Error(
                "Internal ZodObject error: invalid unknownKeys value."
              );
          } else {
            let e = this._def.catchall;
            for (let t of s) {
              let i = r.data[t];
              a.push({
                key: { status: "valid", value: t },
                value: e._parse(new N(r, i, r.path, t)),
                alwaysSet: t in r.data,
              });
            }
          }
          return r.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of a) {
                    let r = await t.key;
                    e.push({
                      key: r,
                      value: await t.value,
                      alwaysSet: t.alwaysSet,
                    });
                  }
                  return e;
                })
                .then((e) => C.mergeObjectSync(t, e))
            : C.mergeObjectSync(t, a);
        }
        get shape() {
          return this._def.shape();
        }
        strict(e) {
          return (
            a.errToObj,
            new ee({
              ...this._def,
              unknownKeys: "strict",
              ...(void 0 !== e
                ? {
                    errorMap: (t, r) => {
                      var i, n, s, o;
                      let c =
                        null !=
                        (s =
                          null == (n = (i = this._def).errorMap)
                            ? void 0
                            : n.call(i, t, r).message)
                          ? s
                          : r.defaultError;
                      return "unrecognized_keys" === t.code
                        ? {
                            message:
                              null != (o = a.errToObj(e).message) ? o : c,
                          }
                        : { message: c };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new ee({ ...this._def, unknownKeys: "strip" });
        }
        passthrough() {
          return new ee({ ...this._def, unknownKeys: "passthrough" });
        }
        extend(e) {
          return new ee({
            ...this._def,
            shape: () => ({ ...this._def.shape(), ...e }),
          });
        }
        merge(e) {
          return new ee({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
            typeName: o.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(e) {
          return new ee({ ...this._def, catchall: e });
        }
        pick(e) {
          let t = {};
          return (
            n.objectKeys(e).forEach((r) => {
              e[r] && this.shape[r] && (t[r] = this.shape[r]);
            }),
            new ee({ ...this._def, shape: () => t })
          );
        }
        omit(e) {
          let t = {};
          return (
            n.objectKeys(this.shape).forEach((r) => {
              e[r] || (t[r] = this.shape[r]);
            }),
            new ee({ ...this._def, shape: () => t })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof ee) {
              let r = {};
              for (let i in t.shape) {
                let n = t.shape[i];
                r[i] = ey.create(e(n));
              }
              return new ee({ ...t._def, shape: () => r });
            }
            if (t instanceof Q) return new Q({ ...t._def, type: e(t.element) });
            if (t instanceof ey) return ey.create(e(t.unwrap()));
            if (t instanceof ew) return ew.create(e(t.unwrap()));
            if (t instanceof es) return es.create(t.items.map((t) => e(t)));
            else return t;
          })(this);
        }
        partial(e) {
          let t = {};
          return (
            n.objectKeys(this.shape).forEach((r) => {
              let i = this.shape[r];
              e && !e[r] ? (t[r] = i) : (t[r] = i.optional());
            }),
            new ee({ ...this._def, shape: () => t })
          );
        }
        required(e) {
          let t = {};
          return (
            n.objectKeys(this.shape).forEach((r) => {
              if (e && !e[r]) t[r] = this.shape[r];
              else {
                let e = this.shape[r];
                for (; e instanceof ey; ) e = e._def.innerType;
                t[r] = e;
              }
            }),
            new ee({ ...this._def, shape: () => t })
          );
        }
        keyof() {
          return eu(n.objectKeys(this.shape));
        }
      }
      (ee.create = (e, t) =>
        new ee({
          shape: () => e,
          unknownKeys: "strip",
          catchall: Y.create(),
          typeName: o.ZodObject,
          ...O(t),
        })),
        (ee.strictCreate = (e, t) =>
          new ee({
            shape: () => e,
            unknownKeys: "strict",
            catchall: Y.create(),
            typeName: o.ZodObject,
            ...O(t),
          })),
        (ee.lazycreate = (e, t) =>
          new ee({
            shape: e,
            unknownKeys: "strip",
            catchall: Y.create(),
            typeName: o.ZodObject,
            ...O(t),
          }));
      class et extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = this._def.options;
          if (t.common.async)
            return Promise.all(
              r.map(async (e) => {
                let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                };
                return {
                  result: await e._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: r,
                  }),
                  ctx: r,
                };
              })
            ).then(function (e) {
              for (let t of e) if ("valid" === t.result.status) return t.result;
              for (let r of e)
                if ("dirty" === r.result.status)
                  return t.common.issues.push(...r.ctx.common.issues), r.result;
              let r = e.map((e) => new g(e.ctx.common.issues));
              return v(t, { code: f.invalid_union, unionErrors: r }), E;
            });
          {
            let e,
              i = [];
            for (let n of r) {
              let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                },
                s = n._parseSync({ data: t.data, path: t.path, parent: r });
              if ("valid" === s.status) return s;
              "dirty" !== s.status || e || (e = { result: s, ctx: r }),
                r.common.issues.length && i.push(r.common.issues);
            }
            if (e)
              return t.common.issues.push(...e.ctx.common.issues), e.result;
            let n = i.map((e) => new g(e));
            return v(t, { code: f.invalid_union, unionErrors: n }), E;
          }
        }
        get options() {
          return this._def.options;
        }
      }
      et.create = (e, t) =>
        new et({ options: e, typeName: o.ZodUnion, ...O(t) });
      let er = (e) => {
        if (e instanceof ed) return er(e.schema);
        if (e instanceof em) return er(e.innerType());
        if (e instanceof eh) return [e.value];
        if (e instanceof ep) return e.options;
        if (e instanceof ef) return Object.keys(e.enum);
        else if (e instanceof eb) return er(e._def.innerType);
        else if (e instanceof Z) return [void 0];
        else if (e instanceof K) return [null];
        else return null;
      };
      class ei extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== u.object)
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.object,
                received: t.parsedType,
              }),
              E
            );
          let r = this.discriminator,
            i = t.data[r],
            n = this.optionsMap.get(i);
          return n
            ? t.common.async
              ? n._parseAsync({ data: t.data, path: t.path, parent: t })
              : n._parseSync({ data: t.data, path: t.path, parent: t })
            : (v(t, {
                code: f.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r],
              }),
              E);
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(e, t, r) {
          let i = new Map();
          for (let r of t) {
            let t = er(r.shape[e]);
            if (!t)
              throw Error(
                `A discriminator value for key \`${e}\` could not be extracted from all schema options`
              );
            for (let n of t) {
              if (i.has(n))
                throw Error(
                  `Discriminator property ${String(
                    e
                  )} has duplicate value ${String(n)}`
                );
              i.set(n, r);
            }
          }
          return new ei({
            typeName: o.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: i,
            ...O(r),
          });
        }
      }
      class en extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = (e, i) => {
              if (_(e) || _(i)) return E;
              let s = (function e(t, r) {
                let i = p(t),
                  s = p(r);
                if (t === r) return { valid: !0, data: t };
                if (i === u.object && s === u.object) {
                  let i = n.objectKeys(r),
                    s = n.objectKeys(t).filter((e) => -1 !== i.indexOf(e)),
                    a = { ...t, ...r };
                  for (let i of s) {
                    let n = e(t[i], r[i]);
                    if (!n.valid) return { valid: !1 };
                    a[i] = n.data;
                  }
                  return { valid: !0, data: a };
                }
                if (i === u.array && s === u.array) {
                  if (t.length !== r.length) return { valid: !1 };
                  let i = [];
                  for (let n = 0; n < t.length; n++) {
                    let s = e(t[n], r[n]);
                    if (!s.valid) return { valid: !1 };
                    i.push(s.data);
                  }
                  return { valid: !0, data: i };
                }
                if (i === u.date && s === u.date && +t == +r)
                  return { valid: !0, data: t };
                return { valid: !1 };
              })(e.value, i.value);
              return s.valid
                ? ((I(e) || I(i)) && t.dirty(),
                  { status: t.value, value: s.data })
                : (v(r, { code: f.invalid_intersection_types }), E);
            };
          return r.common.async
            ? Promise.all([
                this._def.left._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
              ]).then(([e, t]) => i(e, t))
            : i(
                this._def.left._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                })
              );
        }
      }
      en.create = (e, t, r) =>
        new en({ left: e, right: t, typeName: o.ZodIntersection, ...O(r) });
      class es extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.array)
            return (
              v(r, {
                code: f.invalid_type,
                expected: u.array,
                received: r.parsedType,
              }),
              E
            );
          if (r.data.length < this._def.items.length)
            return (
              v(r, {
                code: f.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              E
            );
          !this._def.rest &&
            r.data.length > this._def.items.length &&
            (v(r, {
              code: f.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: "array",
            }),
            t.dirty());
          let i = [...r.data]
            .map((e, t) => {
              let i = this._def.items[t] || this._def.rest;
              return i ? i._parse(new N(r, e, r.path, t)) : null;
            })
            .filter((e) => !!e);
          return r.common.async
            ? Promise.all(i).then((e) => C.mergeArray(t, e))
            : C.mergeArray(t, i);
        }
        get items() {
          return this._def.items;
        }
        rest(e) {
          return new es({ ...this._def, rest: e });
        }
      }
      es.create = (e, t) => {
        if (!Array.isArray(e))
          throw Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new es({ items: e, typeName: o.ZodTuple, rest: null, ...O(t) });
      };
      class ea extends P {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.object)
            return (
              v(r, {
                code: f.invalid_type,
                expected: u.object,
                received: r.parsedType,
              }),
              E
            );
          let i = [],
            n = this._def.keyType,
            s = this._def.valueType;
          for (let e in r.data)
            i.push({
              key: n._parse(new N(r, e, r.path, e)),
              value: s._parse(new N(r, r.data[e], r.path, e)),
            });
          return r.common.async
            ? C.mergeObjectAsync(t, i)
            : C.mergeObjectSync(t, i);
        }
        get element() {
          return this._def.valueType;
        }
        static create(e, t, r) {
          return new ea(
            t instanceof P
              ? { keyType: e, valueType: t, typeName: o.ZodRecord, ...O(r) }
              : {
                  keyType: j.create(),
                  valueType: e,
                  typeName: o.ZodRecord,
                  ...O(t),
                }
          );
        }
      }
      class eo extends P {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.map)
            return (
              v(r, {
                code: f.invalid_type,
                expected: u.map,
                received: r.parsedType,
              }),
              E
            );
          let i = this._def.keyType,
            n = this._def.valueType,
            s = [...r.data.entries()].map(([e, t], s) => ({
              key: i._parse(new N(r, e, r.path, [s, "key"])),
              value: n._parse(new N(r, t, r.path, [s, "value"])),
            }));
          if (r.common.async) {
            let e = new Map();
            return Promise.resolve().then(async () => {
              for (let r of s) {
                let i = await r.key,
                  n = await r.value;
                if ("aborted" === i.status || "aborted" === n.status) return E;
                ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                  e.set(i.value, n.value);
              }
              return { status: t.value, value: e };
            });
          }
          {
            let e = new Map();
            for (let r of s) {
              let i = r.key,
                n = r.value;
              if ("aborted" === i.status || "aborted" === n.status) return E;
              ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                e.set(i.value, n.value);
            }
            return { status: t.value, value: e };
          }
        }
      }
      eo.create = (e, t, r) =>
        new eo({ valueType: t, keyType: e, typeName: o.ZodMap, ...O(r) });
      class ec extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.set)
            return (
              v(r, {
                code: f.invalid_type,
                expected: u.set,
                received: r.parsedType,
              }),
              E
            );
          let i = this._def;
          null !== i.minSize &&
            r.data.size < i.minSize.value &&
            (v(r, {
              code: f.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message,
            }),
            t.dirty()),
            null !== i.maxSize &&
              r.data.size > i.maxSize.value &&
              (v(r, {
                code: f.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message,
              }),
              t.dirty());
          let n = this._def.valueType;
          function s(e) {
            let r = new Set();
            for (let i of e) {
              if ("aborted" === i.status) return E;
              "dirty" === i.status && t.dirty(), r.add(i.value);
            }
            return { status: t.value, value: r };
          }
          let a = [...r.data.values()].map((e, t) =>
            n._parse(new N(r, e, r.path, t))
          );
          return r.common.async ? Promise.all(a).then((e) => s(e)) : s(a);
        }
        min(e, t) {
          return new ec({
            ...this._def,
            minSize: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new ec({
            ...this._def,
            maxSize: { value: e, message: a.toString(t) },
          });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      ec.create = (e, t) =>
        new ec({
          valueType: e,
          minSize: null,
          maxSize: null,
          typeName: o.ZodSet,
          ...O(t),
        });
      class el extends P {
        constructor() {
          super(...arguments), (this.validate = this.implement);
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== u.function)
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.function,
                received: t.parsedType,
              }),
              E
            );
          function r(e, r) {
            return b({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                w(),
                m,
              ].filter((e) => !!e),
              issueData: { code: f.invalid_arguments, argumentsError: r },
            });
          }
          function i(e, r) {
            return b({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                w(),
                m,
              ].filter((e) => !!e),
              issueData: { code: f.invalid_return_type, returnTypeError: r },
            });
          }
          let n = { errorMap: t.common.contextualErrorMap },
            s = t.data;
          if (this._def.returns instanceof eg) {
            let e = this;
            return A(async function (...t) {
              let a = new g([]),
                o = await e._def.args.parseAsync(t, n).catch((e) => {
                  throw (a.addIssue(r(t, e)), a);
                }),
                c = await Reflect.apply(s, this, o);
              return await e._def.returns._def.type
                .parseAsync(c, n)
                .catch((e) => {
                  throw (a.addIssue(i(c, e)), a);
                });
            });
          }
          {
            let e = this;
            return A(function (...t) {
              let a = e._def.args.safeParse(t, n);
              if (!a.success) throw new g([r(t, a.error)]);
              let o = Reflect.apply(s, this, a.data),
                c = e._def.returns.safeParse(o, n);
              if (!c.success) throw new g([i(o, c.error)]);
              return c.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...e) {
          return new el({ ...this._def, args: es.create(e).rest(J.create()) });
        }
        returns(e) {
          return new el({ ...this._def, returns: e });
        }
        implement(e) {
          return this.parse(e);
        }
        strictImplement(e) {
          return this.parse(e);
        }
        static create(e, t, r) {
          return new el({
            args: e || es.create([]).rest(J.create()),
            returns: t || J.create(),
            typeName: o.ZodFunction,
            ...O(r),
          });
        }
      }
      class ed extends P {
        get schema() {
          return this._def.getter();
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return this._def
            .getter()
            ._parse({ data: t.data, path: t.path, parent: t });
        }
      }
      ed.create = (e, t) => new ed({ getter: e, typeName: o.ZodLazy, ...O(t) });
      class eh extends P {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                received: t.data,
                code: f.invalid_literal,
                expected: this._def.value,
              }),
              E
            );
          }
          return { status: "valid", value: e.data };
        }
        get value() {
          return this._def.value;
        }
      }
      function eu(e, t) {
        return new ep({ values: e, typeName: o.ZodEnum, ...O(t) });
      }
      eh.create = (e, t) =>
        new eh({ value: e, typeName: o.ZodLiteral, ...O(t) });
      class ep extends P {
        _parse(e) {
          if ("string" != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              v(t, {
                expected: n.joinValues(r),
                received: t.parsedType,
                code: f.invalid_type,
              }),
              E
            );
          }
          if (-1 === this._def.values.indexOf(e.data)) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              v(t, {
                received: t.data,
                code: f.invalid_enum_value,
                options: r,
              }),
              E
            );
          }
          return A(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(e) {
          return ep.create(e);
        }
        exclude(e) {
          return ep.create(this.options.filter((t) => !e.includes(t)));
        }
      }
      ep.create = eu;
      class ef extends P {
        _parse(e) {
          let t = n.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
          if (r.parsedType !== u.string && r.parsedType !== u.number) {
            let e = n.objectValues(t);
            return (
              v(r, {
                expected: n.joinValues(e),
                received: r.parsedType,
                code: f.invalid_type,
              }),
              E
            );
          }
          if (-1 === t.indexOf(e.data)) {
            let e = n.objectValues(t);
            return (
              v(r, {
                received: r.data,
                code: f.invalid_enum_value,
                options: e,
              }),
              E
            );
          }
          return A(e.data);
        }
        get enum() {
          return this._def.values;
        }
      }
      ef.create = (e, t) =>
        new ef({ values: e, typeName: o.ZodNativeEnum, ...O(t) });
      class eg extends P {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== u.promise && !1 === t.common.async
            ? (v(t, {
                code: f.invalid_type,
                expected: u.promise,
                received: t.parsedType,
              }),
              E)
            : A(
                (t.parsedType === u.promise
                  ? t.data
                  : Promise.resolve(t.data)
                ).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      }
      eg.create = (e, t) =>
        new eg({ type: e, typeName: o.ZodPromise, ...O(t) });
      class em extends P {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === o.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = this._def.effect || null,
            s = {
              addIssue: (e) => {
                v(r, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return r.path;
              },
            };
          if (((s.addIssue = s.addIssue.bind(s)), "preprocess" === i.type)) {
            let e = i.transform(r.data, s);
            return r.common.issues.length
              ? { status: "dirty", value: r.data }
              : r.common.async
              ? Promise.resolve(e).then((e) =>
                  this._def.schema._parseAsync({
                    data: e,
                    path: r.path,
                    parent: r,
                  })
                )
              : this._def.schema._parseSync({
                  data: e,
                  path: r.path,
                  parent: r,
                });
          }
          if ("refinement" === i.type) {
            let e = (e) => {
              let t = i.refinement(e, s);
              if (r.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return e;
            };
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? E
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      })))
                );
            {
              let i = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? E
                : ("dirty" === i.status && t.dirty(),
                  e(i.value),
                  { status: t.value, value: i.value });
            }
          }
          if ("transform" === i.type)
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  S(e)
                    ? Promise.resolve(i.transform(e.value, s)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            else {
              let e = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              if (!S(e)) return e;
              let n = i.transform(e.value, s);
              if (n instanceof Promise)
                throw Error(
                  "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return { status: t.value, value: n };
            }
          n.assertNever(i);
        }
      }
      (em.create = (e, t, r) =>
        new em({ schema: e, typeName: o.ZodEffects, effect: t, ...O(r) })),
        (em.createWithPreprocess = (e, t, r) =>
          new em({
            schema: t,
            effect: { type: "preprocess", transform: e },
            typeName: o.ZodEffects,
            ...O(r),
          }));
      class ey extends P {
        _parse(e) {
          return this._getType(e) === u.undefined
            ? A(void 0)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      ey.create = (e, t) =>
        new ey({ innerType: e, typeName: o.ZodOptional, ...O(t) });
      class ew extends P {
        _parse(e) {
          return this._getType(e) === u.null
            ? A(null)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      ew.create = (e, t) =>
        new ew({ innerType: e, typeName: o.ZodNullable, ...O(t) });
      class eb extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return (
            t.parsedType === u.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({ data: r, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      }
      eb.create = (e, t) =>
        new eb({
          innerType: e,
          typeName: o.ZodDefault,
          defaultValue:
            "function" == typeof t.default ? t.default : () => t.default,
          ...O(t),
        });
      class ev extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = { ...t, common: { ...t.common, issues: [] } },
            i = this._def.innerType._parse({
              data: r.data,
              path: r.path,
              parent: { ...r },
            });
          return k(i)
            ? i.then((e) => ({
                status: "valid",
                value:
                  "valid" === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new g(r.common.issues);
                        },
                        input: r.data,
                      }),
              }))
            : {
                status: "valid",
                value:
                  "valid" === i.status
                    ? i.value
                    : this._def.catchValue({
                        get error() {
                          return new g(r.common.issues);
                        },
                        input: r.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      }
      ev.create = (e, t) =>
        new ev({
          innerType: e,
          typeName: o.ZodCatch,
          catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
          ...O(t),
        });
      class eC extends P {
        _parse(e) {
          if (this._getType(e) !== u.nan) {
            let t = this._getOrReturnCtx(e);
            return (
              v(t, {
                code: f.invalid_type,
                expected: u.nan,
                received: t.parsedType,
              }),
              E
            );
          }
          return { status: "valid", value: e.data };
        }
      }
      eC.create = (e) => new eC({ typeName: o.ZodNaN, ...O(e) });
      let eE = Symbol("zod_brand");
      class ex extends P {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return this._def.type._parse({ data: r, path: t.path, parent: t });
        }
        unwrap() {
          return this._def.type;
        }
      }
      class eA extends P {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.common.async)
            return (async () => {
              let e = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? E
                : "dirty" === e.status
                ? (t.dirty(), x(e.value))
                : this._def.out._parseAsync({
                    data: e.value,
                    path: r.path,
                    parent: r,
                  });
            })();
          {
            let e = this._def.in._parseSync({
              data: r.data,
              path: r.path,
              parent: r,
            });
            return "aborted" === e.status
              ? E
              : "dirty" === e.status
              ? (t.dirty(), { status: "dirty", value: e.value })
              : this._def.out._parseSync({
                  data: e.value,
                  path: r.path,
                  parent: r,
                });
          }
        }
        static create(e, t) {
          return new eA({ in: e, out: t, typeName: o.ZodPipeline });
        }
      }
      class e_ extends P {
        _parse(e) {
          let t = this._def.innerType._parse(e);
          return S(t) && (t.value = Object.freeze(t.value)), t;
        }
      }
      e_.create = (e, t) =>
        new e_({ innerType: e, typeName: o.ZodReadonly, ...O(t) });
      let eI = (e, t = {}, r) =>
          e
            ? G.create().superRefine((i, n) => {
                var s, a;
                if (!e(i)) {
                  let e =
                      "function" == typeof t
                        ? t(i)
                        : "string" == typeof t
                        ? { message: t }
                        : t,
                    o = null == (a = null != (s = e.fatal) ? s : r) || a,
                    c = "string" == typeof e ? { message: e } : e;
                  n.addIssue({ code: "custom", ...c, fatal: o });
                }
              })
            : G.create(),
        eS = { object: ee.lazycreate };
      !(function (e) {
        (e.ZodString = "ZodString"),
          (e.ZodNumber = "ZodNumber"),
          (e.ZodNaN = "ZodNaN"),
          (e.ZodBigInt = "ZodBigInt"),
          (e.ZodBoolean = "ZodBoolean"),
          (e.ZodDate = "ZodDate"),
          (e.ZodSymbol = "ZodSymbol"),
          (e.ZodUndefined = "ZodUndefined"),
          (e.ZodNull = "ZodNull"),
          (e.ZodAny = "ZodAny"),
          (e.ZodUnknown = "ZodUnknown"),
          (e.ZodNever = "ZodNever"),
          (e.ZodVoid = "ZodVoid"),
          (e.ZodArray = "ZodArray"),
          (e.ZodObject = "ZodObject"),
          (e.ZodUnion = "ZodUnion"),
          (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
          (e.ZodIntersection = "ZodIntersection"),
          (e.ZodTuple = "ZodTuple"),
          (e.ZodRecord = "ZodRecord"),
          (e.ZodMap = "ZodMap"),
          (e.ZodSet = "ZodSet"),
          (e.ZodFunction = "ZodFunction"),
          (e.ZodLazy = "ZodLazy"),
          (e.ZodLiteral = "ZodLiteral"),
          (e.ZodEnum = "ZodEnum"),
          (e.ZodEffects = "ZodEffects"),
          (e.ZodNativeEnum = "ZodNativeEnum"),
          (e.ZodOptional = "ZodOptional"),
          (e.ZodNullable = "ZodNullable"),
          (e.ZodDefault = "ZodDefault"),
          (e.ZodCatch = "ZodCatch"),
          (e.ZodPromise = "ZodPromise"),
          (e.ZodBranded = "ZodBranded"),
          (e.ZodPipeline = "ZodPipeline"),
          (e.ZodReadonly = "ZodReadonly");
      })(o || (o = {}));
      let ek = j.create,
        eN = F.create,
        eT = eC.create,
        eO = H.create,
        eP = q.create,
        eR = z.create,
        e$ = V.create,
        eD = Z.create,
        eU = K.create,
        eM = G.create,
        eL = J.create,
        eB = Y.create,
        eW = X.create,
        ej = Q.create,
        eF = ee.create,
        eH = ee.strictCreate,
        eq = et.create,
        ez = ei.create,
        eV = en.create,
        eZ = es.create,
        eK = ea.create,
        eG = eo.create,
        eJ = ec.create,
        eY = el.create,
        eX = ed.create,
        eQ = eh.create,
        e0 = ep.create,
        e1 = ef.create,
        e2 = eg.create,
        e3 = em.create,
        e5 = ey.create,
        e4 = ew.create,
        e6 = em.createWithPreprocess,
        e8 = eA.create;
      var e9 = Object.freeze({
        __proto__: null,
        defaultErrorMap: m,
        setErrorMap: function (e) {
          y = e;
        },
        getErrorMap: w,
        makeIssue: b,
        EMPTY_PATH: [],
        addIssueToContext: v,
        ParseStatus: C,
        INVALID: E,
        DIRTY: x,
        OK: A,
        isAborted: _,
        isDirty: I,
        isValid: S,
        isAsync: k,
        get util() {
          return n;
        },
        get objectUtil() {
          return s;
        },
        ZodParsedType: u,
        getParsedType: p,
        ZodType: P,
        ZodString: j,
        ZodNumber: F,
        ZodBigInt: H,
        ZodBoolean: q,
        ZodDate: z,
        ZodSymbol: V,
        ZodUndefined: Z,
        ZodNull: K,
        ZodAny: G,
        ZodUnknown: J,
        ZodNever: Y,
        ZodVoid: X,
        ZodArray: Q,
        ZodObject: ee,
        ZodUnion: et,
        ZodDiscriminatedUnion: ei,
        ZodIntersection: en,
        ZodTuple: es,
        ZodRecord: ea,
        ZodMap: eo,
        ZodSet: ec,
        ZodFunction: el,
        ZodLazy: ed,
        ZodLiteral: eh,
        ZodEnum: ep,
        ZodNativeEnum: ef,
        ZodPromise: eg,
        ZodEffects: em,
        ZodTransformer: em,
        ZodOptional: ey,
        ZodNullable: ew,
        ZodDefault: eb,
        ZodCatch: ev,
        ZodNaN: eC,
        BRAND: eE,
        ZodBranded: ex,
        ZodPipeline: eA,
        ZodReadonly: e_,
        custom: eI,
        Schema: P,
        ZodSchema: P,
        late: eS,
        get ZodFirstPartyTypeKind() {
          return o;
        },
        coerce: {
          string: (e) => j.create({ ...e, coerce: !0 }),
          number: (e) => F.create({ ...e, coerce: !0 }),
          boolean: (e) => q.create({ ...e, coerce: !0 }),
          bigint: (e) => H.create({ ...e, coerce: !0 }),
          date: (e) => z.create({ ...e, coerce: !0 }),
        },
        any: eM,
        array: ej,
        bigint: eO,
        boolean: eP,
        date: eR,
        discriminatedUnion: ez,
        effect: e3,
        enum: e0,
        function: eY,
        instanceof: (e, t = { message: `Input not instance of ${e.name}` }) =>
          eI((t) => t instanceof e, t),
        intersection: eV,
        lazy: eX,
        literal: eQ,
        map: eG,
        nan: eT,
        nativeEnum: e1,
        never: eB,
        null: eU,
        nullable: e4,
        number: eN,
        object: eF,
        oboolean: () => eP().optional(),
        onumber: () => eN().optional(),
        optional: e5,
        ostring: () => ek().optional(),
        pipeline: e8,
        preprocess: e6,
        promise: e2,
        record: eK,
        set: eJ,
        strictObject: eH,
        string: ek,
        symbol: e$,
        transformer: e3,
        tuple: eZ,
        undefined: eD,
        union: eq,
        unknown: eL,
        void: eW,
        NEVER: E,
        ZodIssueCode: f,
        quotelessJson: (e) =>
          JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
        ZodError: g,
      });
      let e7 = e9.object({ message: e9.string() });
      function te(e) {
        return e9.literal(d.s1[e]);
      }
      let tt = e9.object({
        serializedMessage: e9.string().optional(),
        accountAddress: e9.string(),
        chainId: e9.string(),
        notBefore: e9.string().optional(),
        domain: e9.string(),
        uri: e9.string(),
        version: e9.string(),
        nonce: e9.string(),
        statement: e9.string().optional(),
        resources: e9.array(e9.string()).optional(),
        requestId: e9.string().optional(),
        issuedAt: e9.string().optional(),
        expirationTime: e9.string().optional(),
      });
      e9.object({
        accessList: e9.array(e9.string()),
        blockHash: e9.string().nullable(),
        blockNumber: e9.string().nullable(),
        chainId: e9.string().or(e9.number()),
        from: e9.string(),
        gas: e9.string(),
        hash: e9.string(),
        input: e9.string().nullable(),
        maxFeePerGas: e9.string(),
        maxPriorityFeePerGas: e9.string(),
        nonce: e9.string(),
        r: e9.string(),
        s: e9.string(),
        to: e9.string(),
        transactionIndex: e9.string().nullable(),
        type: e9.string(),
        v: e9.string(),
        value: e9.string(),
      });
      let tr = e9.object({
          chainId: e9.string().or(e9.number()),
          rpcUrl: e9.optional(e9.string()),
        }),
        ti = e9.object({ email: e9.string().email() }),
        tn = e9.object({ otp: e9.string() }),
        ts = e9.object({
          uri: e9.string(),
          preferredAccountType: e9.optional(e9.string()),
          chainId: e9.optional(e9.string().or(e9.number())),
          siwxMessage: e9.optional(tt),
          rpcUrl: e9.optional(e9.string()),
        }),
        ta = e9.object({
          chainId: e9.optional(e9.string().or(e9.number())),
          preferredAccountType: e9.optional(e9.string()),
          socialUri: e9.optional(e9.string()),
          siwxMessage: e9.optional(tt),
          rpcUrl: e9.optional(e9.string()),
        }),
        to = e9.object({
          provider: e9.enum([
            "google",
            "github",
            "apple",
            "facebook",
            "x",
            "discord",
          ]),
        }),
        tc = e9.object({ email: e9.string().email() }),
        tl = e9.object({ otp: e9.string() }),
        td = e9.object({ otp: e9.string() }),
        th = e9.object({
          themeMode: e9.optional(e9.enum(["light", "dark"])),
          themeVariables: e9.optional(
            e9.record(e9.string(), e9.string().or(e9.number()))
          ),
          w3mThemeVariables: e9.optional(e9.record(e9.string(), e9.string())),
        }),
        tu = e9.object({
          metadata: e9
            .object({
              name: e9.string(),
              description: e9.string(),
              url: e9.string(),
              icons: e9.array(e9.string()),
            })
            .optional(),
          sdkVersion: e9.string().optional(),
          sdkType: e9.string().optional(),
          projectId: e9.string(),
        }),
        tp = e9.object({ type: e9.string() }),
        tf = e9.object({
          action: e9.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]),
        }),
        tg = e9.object({ url: e9.string() }),
        tm = e9.object({ userName: e9.string() }),
        ty = e9.object({
          email: e9.string().optional().nullable(),
          address: e9.string(),
          chainId: e9.string().or(e9.number()),
          accounts: e9
            .array(
              e9.object({
                address: e9.string(),
                type: e9.enum([
                  d.Vl.ACCOUNT_TYPES.EOA,
                  d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          userName: e9.string().optional().nullable(),
          preferredAccountType: e9.optional(e9.string()),
          signature: e9.string().optional(),
          message: e9.string().optional(),
          siwxMessage: e9.optional(tt),
        }),
        tw = e9.object({
          action: e9.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
        }),
        tb = e9.object({
          email: e9.string().email().optional().nullable(),
          address: e9.string(),
          chainId: e9.string().or(e9.number()),
          smartAccountDeployed: e9.optional(e9.boolean()),
          accounts: e9
            .array(
              e9.object({
                address: e9.string(),
                type: e9.enum([
                  d.Vl.ACCOUNT_TYPES.EOA,
                  d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          preferredAccountType: e9.optional(e9.string()),
          signature: e9.string().optional(),
          message: e9.string().optional(),
          siwxMessage: e9.optional(tt),
        }),
        tv = e9.object({ uri: e9.string() }),
        tC = e9.object({ isConnected: e9.boolean() }),
        tE = e9.object({ chainId: e9.string().or(e9.number()) }),
        tx = e9.object({ chainId: e9.string().or(e9.number()) }),
        tA = e9.object({ newEmail: e9.string().email() }),
        t_ = e9.object({ smartAccountEnabledNetworks: e9.array(e9.number()) });
      e9.object({ address: e9.string(), isDeployed: e9.boolean() });
      let tI = e9.object({ version: e9.string().optional() }),
        tS = e9.object({ type: e9.string(), address: e9.string() }),
        tk = e9.any(),
        tN = e9.object({ method: e9.literal("eth_accounts") }),
        tT = e9.object({ method: e9.literal("eth_blockNumber") }),
        tO = e9.object({
          method: e9.literal("eth_call"),
          params: e9.array(e9.any()),
        }),
        tP = e9.object({ method: e9.literal("eth_chainId") }),
        tR = e9.object({
          method: e9.literal("eth_estimateGas"),
          params: e9.array(e9.any()),
        }),
        t$ = e9.object({
          method: e9.literal("eth_feeHistory"),
          params: e9.array(e9.any()),
        }),
        tD = e9.object({ method: e9.literal("eth_gasPrice") }),
        tU = e9.object({
          method: e9.literal("eth_getAccount"),
          params: e9.array(e9.any()),
        }),
        tM = e9.object({
          method: e9.literal("eth_getBalance"),
          params: e9.array(e9.any()),
        }),
        tL = e9.object({
          method: e9.literal("eth_getBlockByHash"),
          params: e9.array(e9.any()),
        }),
        tB = e9.object({
          method: e9.literal("eth_getBlockByNumber"),
          params: e9.array(e9.any()),
        }),
        tW = e9.object({
          method: e9.literal("eth_getBlockReceipts"),
          params: e9.array(e9.any()),
        }),
        tj = e9.object({
          method: e9.literal("eth_getBlockTransactionCountByHash"),
          params: e9.array(e9.any()),
        }),
        tF = e9.object({
          method: e9.literal("eth_getBlockTransactionCountByNumber"),
          params: e9.array(e9.any()),
        }),
        tH = e9.object({
          method: e9.literal("eth_getCode"),
          params: e9.array(e9.any()),
        }),
        tq = e9.object({
          method: e9.literal("eth_getFilterChanges"),
          params: e9.array(e9.any()),
        }),
        tz = e9.object({
          method: e9.literal("eth_getFilterLogs"),
          params: e9.array(e9.any()),
        }),
        tV = e9.object({
          method: e9.literal("eth_getLogs"),
          params: e9.array(e9.any()),
        }),
        tZ = e9.object({
          method: e9.literal("eth_getProof"),
          params: e9.array(e9.any()),
        }),
        tK = e9.object({
          method: e9.literal("eth_getStorageAt"),
          params: e9.array(e9.any()),
        }),
        tG = e9.object({
          method: e9.literal("eth_getTransactionByBlockHashAndIndex"),
          params: e9.array(e9.any()),
        }),
        tJ = e9.object({
          method: e9.literal("eth_getTransactionByBlockNumberAndIndex"),
          params: e9.array(e9.any()),
        }),
        tY = e9.object({
          method: e9.literal("eth_getTransactionByHash"),
          params: e9.array(e9.any()),
        }),
        tX = e9.object({
          method: e9.literal("eth_getTransactionCount"),
          params: e9.array(e9.any()),
        }),
        tQ = e9.object({
          method: e9.literal("eth_getTransactionReceipt"),
          params: e9.array(e9.any()),
        }),
        t0 = e9.object({
          method: e9.literal("eth_getUncleCountByBlockHash"),
          params: e9.array(e9.any()),
        }),
        t1 = e9.object({
          method: e9.literal("eth_getUncleCountByBlockNumber"),
          params: e9.array(e9.any()),
        }),
        t2 = e9.object({ method: e9.literal("eth_maxPriorityFeePerGas") }),
        t3 = e9.object({ method: e9.literal("eth_newBlockFilter") }),
        t5 = e9.object({
          method: e9.literal("eth_newFilter"),
          params: e9.array(e9.any()),
        }),
        t4 = e9.object({
          method: e9.literal("eth_newPendingTransactionFilter"),
        }),
        t6 = e9.object({
          method: e9.literal("eth_sendRawTransaction"),
          params: e9.array(e9.any()),
        }),
        t8 = e9.object({
          method: e9.literal("eth_syncing"),
          params: e9.array(e9.any()),
        }),
        t9 = e9.object({
          method: e9.literal("eth_uninstallFilter"),
          params: e9.array(e9.any()),
        }),
        t7 = e9.object({
          method: e9.literal("personal_sign"),
          params: e9.array(e9.any()),
        }),
        re = e9.object({
          method: e9.literal("eth_signTypedData_v4"),
          params: e9.array(e9.any()),
        }),
        rt = e9.object({
          method: e9.literal("eth_sendTransaction"),
          params: e9.array(e9.any()),
        }),
        rr = e9.object({
          method: e9.literal("solana_signMessage"),
          params: e9.object({ message: e9.string(), pubkey: e9.string() }),
        }),
        ri = e9.object({
          method: e9.literal("solana_signTransaction"),
          params: e9.object({ transaction: e9.string() }),
        }),
        rn = e9.object({
          method: e9.literal("solana_signAllTransactions"),
          params: e9.object({ transactions: e9.array(e9.string()) }),
        }),
        rs = e9.object({
          method: e9.literal("solana_signAndSendTransaction"),
          params: e9.object({
            transaction: e9.string(),
            options: e9
              .object({
                skipPreflight: e9.boolean().optional(),
                preflightCommitment: e9
                  .enum([
                    "processed",
                    "confirmed",
                    "finalized",
                    "recent",
                    "single",
                    "singleGossip",
                    "root",
                    "max",
                  ])
                  .optional(),
                maxRetries: e9.number().optional(),
                minContextSlot: e9.number().optional(),
              })
              .optional(),
          }),
        }),
        ra = e9.object({
          method: e9.literal("wallet_sendCalls"),
          params: e9.array(
            e9.object({
              chainId: e9.string().or(e9.number()).optional(),
              from: e9.string().optional(),
              version: e9.string().optional(),
              capabilities: e9.any().optional(),
              calls: e9.array(
                e9.object({
                  to: e9.string().startsWith("0x"),
                  data: e9.string().startsWith("0x").optional(),
                  value: e9.string().optional(),
                })
              ),
            })
          ),
        }),
        ro = e9.object({
          method: e9.literal("wallet_getCallsStatus"),
          params: e9.array(e9.string()),
        }),
        rc = e9.object({
          method: e9.literal("wallet_getCapabilities"),
          params: e9.array(e9.string().or(e9.number()).optional()).optional(),
        }),
        rl = e9.object({
          method: e9.literal("wallet_grantPermissions"),
          params: e9.array(e9.any()),
        }),
        rd = e9.object({
          method: e9.literal("wallet_revokePermissions"),
          params: e9.any(),
        }),
        rh = e9.object({
          method: e9.literal("wallet_getAssets"),
          params: e9.any(),
        }),
        ru = e9.object({ token: e9.string() }),
        rp = e9.object({ id: e9.string().optional() }),
        rf = {
          appEvent: rp
            .extend({ type: te("APP_SWITCH_NETWORK"), payload: tr })
            .or(rp.extend({ type: te("APP_CONNECT_EMAIL"), payload: ti }))
            .or(rp.extend({ type: te("APP_CONNECT_DEVICE") }))
            .or(rp.extend({ type: te("APP_CONNECT_OTP"), payload: tn }))
            .or(rp.extend({ type: te("APP_CONNECT_SOCIAL"), payload: ts }))
            .or(rp.extend({ type: te("APP_GET_FARCASTER_URI") }))
            .or(rp.extend({ type: te("APP_CONNECT_FARCASTER") }))
            .or(
              rp.extend({ type: te("APP_GET_USER"), payload: e9.optional(ta) })
            )
            .or(
              rp.extend({
                type: te("APP_GET_SOCIAL_REDIRECT_URI"),
                payload: to,
              })
            )
            .or(rp.extend({ type: te("APP_SIGN_OUT") }))
            .or(
              rp.extend({
                type: te("APP_IS_CONNECTED"),
                payload: e9.optional(ru),
              })
            )
            .or(rp.extend({ type: te("APP_GET_CHAIN_ID") }))
            .or(
              rp.extend({ type: te("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })
            )
            .or(rp.extend({ type: te("APP_INIT_SMART_ACCOUNT") }))
            .or(
              rp.extend({ type: te("APP_SET_PREFERRED_ACCOUNT"), payload: tp })
            )
            .or(
              rp.extend({
                type: te("APP_RPC_REQUEST"),
                payload: t7
                  .or(rh)
                  .or(tN)
                  .or(tT)
                  .or(tO)
                  .or(tP)
                  .or(tR)
                  .or(t$)
                  .or(tD)
                  .or(tU)
                  .or(tM)
                  .or(tL)
                  .or(tB)
                  .or(tW)
                  .or(tj)
                  .or(tF)
                  .or(tH)
                  .or(tq)
                  .or(tz)
                  .or(tV)
                  .or(tZ)
                  .or(tK)
                  .or(tG)
                  .or(tJ)
                  .or(tY)
                  .or(tX)
                  .or(tQ)
                  .or(t0)
                  .or(t1)
                  .or(t2)
                  .or(t3)
                  .or(t5)
                  .or(t4)
                  .or(t6)
                  .or(t8)
                  .or(t9)
                  .or(t7)
                  .or(re)
                  .or(rt)
                  .or(rr)
                  .or(ri)
                  .or(rn)
                  .or(rs)
                  .or(ro)
                  .or(ra)
                  .or(rc)
                  .or(rl)
                  .or(rd)
                  .and(
                    e9.object({
                      chainId: e9.string().or(e9.number()).optional(),
                      chainNamespace: e9
                        .enum([
                          "eip155",
                          "solana",
                          "polkadot",
                          "bip122",
                          "cosmos",
                        ])
                        .optional(),
                      rpcUrl: e9.string().optional(),
                    })
                  ),
              })
            )
            .or(rp.extend({ type: te("APP_UPDATE_EMAIL"), payload: tc }))
            .or(
              rp.extend({
                type: te("APP_UPDATE_EMAIL_PRIMARY_OTP"),
                payload: tl,
              })
            )
            .or(
              rp.extend({
                type: te("APP_UPDATE_EMAIL_SECONDARY_OTP"),
                payload: td,
              })
            )
            .or(rp.extend({ type: te("APP_SYNC_THEME"), payload: th }))
            .or(rp.extend({ type: te("APP_SYNC_DAPP_DATA"), payload: tu }))
            .or(rp.extend({ type: te("APP_RELOAD") }))
            .or(rp.extend({ type: te("APP_RPC_ABORT") })),
          frameEvent: rp
            .extend({ type: te("FRAME_SWITCH_NETWORK_ERROR"), payload: e7 })
            .or(
              rp.extend({
                type: te("FRAME_SWITCH_NETWORK_SUCCESS"),
                payload: tx,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_CONNECT_EMAIL_SUCCESS"),
                payload: tf,
              })
            )
            .or(
              rp.extend({ type: te("FRAME_CONNECT_EMAIL_ERROR"), payload: e7 })
            )
            .or(
              rp.extend({
                type: te("FRAME_GET_FARCASTER_URI_SUCCESS"),
                payload: tg,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_GET_FARCASTER_URI_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_CONNECT_FARCASTER_SUCCESS"),
                payload: tm,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_CONNECT_FARCASTER_ERROR"),
                payload: e7,
              })
            )
            .or(rp.extend({ type: te("FRAME_CONNECT_OTP_ERROR"), payload: e7 }))
            .or(rp.extend({ type: te("FRAME_CONNECT_OTP_SUCCESS") }))
            .or(
              rp.extend({ type: te("FRAME_CONNECT_DEVICE_ERROR"), payload: e7 })
            )
            .or(rp.extend({ type: te("FRAME_CONNECT_DEVICE_SUCCESS") }))
            .or(
              rp.extend({
                type: te("FRAME_CONNECT_SOCIAL_SUCCESS"),
                payload: ty,
              })
            )
            .or(
              rp.extend({ type: te("FRAME_CONNECT_SOCIAL_ERROR"), payload: e7 })
            )
            .or(rp.extend({ type: te("FRAME_GET_USER_ERROR"), payload: e7 }))
            .or(rp.extend({ type: te("FRAME_GET_USER_SUCCESS"), payload: tb }))
            .or(
              rp.extend({
                type: te("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
                payload: tv,
              })
            )
            .or(rp.extend({ type: te("FRAME_SIGN_OUT_ERROR"), payload: e7 }))
            .or(rp.extend({ type: te("FRAME_SIGN_OUT_SUCCESS") }))
            .or(
              rp.extend({ type: te("FRAME_IS_CONNECTED_ERROR"), payload: e7 })
            )
            .or(
              rp.extend({ type: te("FRAME_IS_CONNECTED_SUCCESS"), payload: tC })
            )
            .or(
              rp.extend({ type: te("FRAME_GET_CHAIN_ID_ERROR"), payload: e7 })
            )
            .or(
              rp.extend({ type: te("FRAME_GET_CHAIN_ID_SUCCESS"), payload: tE })
            )
            .or(rp.extend({ type: te("FRAME_RPC_REQUEST_ERROR"), payload: e7 }))
            .or(
              rp.extend({ type: te("FRAME_RPC_REQUEST_SUCCESS"), payload: tk })
            )
            .or(rp.extend({ type: te("FRAME_SESSION_UPDATE"), payload: ru }))
            .or(
              rp.extend({ type: te("FRAME_UPDATE_EMAIL_ERROR"), payload: e7 })
            )
            .or(
              rp.extend({ type: te("FRAME_UPDATE_EMAIL_SUCCESS"), payload: tw })
            )
            .or(
              rp.extend({
                type: te("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({ type: te("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })
            )
            .or(
              rp.extend({
                type: te("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
                payload: tA,
              })
            )
            .or(rp.extend({ type: te("FRAME_SYNC_THEME_ERROR"), payload: e7 }))
            .or(rp.extend({ type: te("FRAME_SYNC_THEME_SUCCESS") }))
            .or(
              rp.extend({ type: te("FRAME_SYNC_DAPP_DATA_ERROR"), payload: e7 })
            )
            .or(rp.extend({ type: te("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
            .or(
              rp.extend({
                type: te("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
                payload: t_,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_INIT_SMART_ACCOUNT_ERROR"),
                payload: e7,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
                payload: tS,
              })
            )
            .or(
              rp.extend({
                type: te("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
                payload: e7,
              })
            )
            .or(rp.extend({ type: te("FRAME_READY"), payload: tI }))
            .or(rp.extend({ type: te("FRAME_RELOAD_ERROR"), payload: e7 }))
            .or(rp.extend({ type: te("FRAME_RELOAD_SUCCESS") })),
        };
      function rg(e, t = {}) {
        return "string" == typeof t?.type && t?.type?.includes(e);
      }
      class rm {
        constructor({
          projectId: e,
          isAppClient: t = !1,
          chainId: r = "eip155:1",
          enableLogger: i = !0,
          enableCloudAuthAccount: n = !1,
          rpcUrl: s = l.o.BLOCKCHAIN_API_RPC_URL,
        }) {
          if (
            ((this.iframe = null),
            (this.iframeIsReady = !1),
            (this.initFrame = () => {
              let e = document.getElementById("w3m-iframe");
              this.iframe && !e && document.body.appendChild(this.iframe);
            }),
            (this.events = {
              registerFrameEventHandler: (e, t, r) => {
                function i({ data: r }) {
                  if (!rg(d.s1.FRAME_EVENT_KEY, r)) return;
                  let n = rf.frameEvent.safeParse(r);
                  if (!n.success)
                    return void console.warn(
                      "W3mFrame: invalid frame event",
                      n.error.message
                    );
                  n.data?.id === e &&
                    (t(n.data), window.removeEventListener("message", i));
                }
                h.Q.isClient &&
                  (window.addEventListener("message", i),
                  r.addEventListener("abort", () => {
                    window.removeEventListener("message", i);
                  }));
              },
              onFrameEvent: (e) => {
                h.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    if (!rg(d.s1.FRAME_EVENT_KEY, t)) return;
                    let r = rf.frameEvent.safeParse(t);
                    r.success
                      ? e(r.data)
                      : console.warn(
                          "W3mFrame: invalid frame event",
                          r.error.message
                        );
                  });
              },
              onAppEvent: (e) => {
                h.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    if (!rg(d.s1.APP_EVENT_KEY, t)) return;
                    let r = rf.appEvent.safeParse(t);
                    r.success ||
                      console.warn(
                        "W3mFrame: invalid app event",
                        r.error.message
                      ),
                      e(t);
                  });
              },
              postAppEvent: (e) => {
                if (h.Q.isClient) {
                  if (!this.iframe?.contentWindow)
                    throw Error("W3mFrame: iframe is not set");
                  this.iframe.contentWindow.postMessage(e, "*");
                }
              },
              postFrameEvent: (e) => {
                if (h.Q.isClient) {
                  if (!parent) throw Error("W3mFrame: parent is not set");
                  parent.postMessage(e, "*");
                }
              },
            }),
            (this.projectId = e),
            (this.frameLoadPromise = new Promise((e, t) => {
              this.frameLoadPromiseResolver = { resolve: e, reject: t };
            })),
            (this.rpcUrl = s),
            t &&
              ((this.frameLoadPromise = new Promise((e, t) => {
                this.frameLoadPromiseResolver = { resolve: e, reject: t };
              })),
              h.Q.isClient))
          ) {
            let t = document.createElement("iframe");
            (t.id = "w3m-iframe"),
              (t.src = (function ({
                projectId: e,
                chainId: t,
                enableLogger: r,
                rpcUrl: i = l.o.BLOCKCHAIN_API_RPC_URL,
                enableCloudAuthAccount: n = !1,
              }) {
                let s = new URL(d.hy);
                return (
                  s.searchParams.set("projectId", e),
                  s.searchParams.set("chainId", String(t)),
                  s.searchParams.set("version", d.gS),
                  s.searchParams.set("enableLogger", String(r)),
                  s.searchParams.set("rpcUrl", i),
                  n && s.searchParams.set("enableCloudAuthAccount", "true"),
                  s.toString()
                );
              })({
                projectId: e,
                chainId: r,
                enableLogger: i,
                rpcUrl: this.rpcUrl,
                enableCloudAuthAccount: n,
              })),
              (t.name = "w3m-secure-iframe"),
              (t.style.position = "fixed"),
              (t.style.zIndex = "999999"),
              (t.style.display = "none"),
              (t.style.border = "none"),
              (t.style.animationDelay = "0s, 50ms"),
              (t.style.borderBottomLeftRadius =
                "clamp(0px, var(--apkt-borderRadius-8), 44px)"),
              (t.style.borderBottomRightRadius =
                "clamp(0px, var(--apkt-borderRadius-8), 44px)"),
              (this.iframe = t),
              (this.iframe.onerror = () => {
                this.frameLoadPromiseResolver?.reject(
                  "Unable to load email login dependency"
                );
              }),
              this.events.onFrameEvent((e) => {
                "@w3m-frame/READY" === e.type &&
                  ((this.iframeIsReady = !0),
                  this.frameLoadPromiseResolver?.resolve(void 0));
              });
          }
        }
        get networks() {
          return Object.assign(
            {},
            ...[
              "eip155:1",
              "eip155:5",
              "eip155:11155111",
              "eip155:10",
              "eip155:420",
              "eip155:42161",
              "eip155:421613",
              "eip155:137",
              "eip155:80001",
              "eip155:42220",
              "eip155:1313161554",
              "eip155:1313161555",
              "eip155:56",
              "eip155:97",
              "eip155:43114",
              "eip155:43113",
              "eip155:324",
              "eip155:280",
              "eip155:100",
              "eip155:8453",
              "eip155:84531",
              "eip155:84532",
              "eip155:7777777",
              "eip155:999",
              "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
              "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
              "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
            ].map((e) => ({
              [e]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=${e}&projectId=${this.projectId}`,
                chainId: e,
              },
            }))
          );
        }
      }
      var ry = r(71018);
      class rw {
        constructor(e) {
          let t = (0, ry.iP)({ level: d.OH }),
            { logger: r, chunkLoggerController: i } = (0, ry.D5)({ opts: t });
          (this.logger = (0, ry.U5)(r, this.constructor.name)),
            (this.chunkLoggerController = i),
            "undefined" != typeof window &&
              this.chunkLoggerController?.downloadLogsBlobInBrowser &&
              (window.downloadAppKitLogsBlob ||
                (window.downloadAppKitLogsBlob = {}),
              (window.downloadAppKitLogsBlob.sdk = () => {
                this.chunkLoggerController?.downloadLogsBlobInBrowser &&
                  this.chunkLoggerController.downloadLogsBlobInBrowser({
                    projectId: e,
                  });
              }));
        }
      }
      var rb = r(22669);
      class rv {
        constructor({
          projectId: e,
          chainId: t,
          enableLogger: r = !0,
          onTimeout: i,
          abortController: n,
          getActiveCaipNetwork: s,
          getCaipNetworks: a,
          enableCloudAuthAccount: o,
        }) {
          (this.openRpcRequests = new Map()),
            (this.isInitialized = !1),
            r && (this.w3mLogger = new rw(e)),
            (this.abortController = n),
            (this.getActiveCaipNetwork = s),
            (this.getCaipNetworks = a);
          let c = this.getRpcUrl(t);
          (this.w3mFrame = new rm({
            projectId: e,
            isAppClient: !0,
            chainId: t,
            enableLogger: r,
            rpcUrl: c,
            enableCloudAuthAccount: o,
          })),
            (this.onTimeout = i),
            this.getLoginEmailUsed() && this.createFrame();
        }
        async createFrame() {
          this.w3mFrame.initFrame(),
            (this.initPromise = new Promise((e) => {
              this.w3mFrame.events.onFrameEvent((t) => {
                t.type === d.s1.FRAME_READY &&
                  setTimeout(() => {
                    e();
                  }, 500);
              });
            })),
            await this.initPromise,
            (this.isInitialized = !0),
            (this.initPromise = void 0);
        }
        async init() {
          if (!this.isInitialized) {
            if (this.initPromise) return void (await this.initPromise);
            await this.createFrame();
          }
        }
        getLoginEmailUsed() {
          return !!rb.o.get(d.s1.EMAIL_LOGIN_USED_KEY);
        }
        getEmail() {
          return rb.o.get(d.s1.EMAIL);
        }
        getUsername() {
          return rb.o.get(d.s1.SOCIAL_USERNAME);
        }
        async reload() {
          try {
            await this.appEvent({ type: d.s1.APP_RELOAD });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error reloading iframe"
              ),
              e)
            );
          }
        }
        async connectEmail(e) {
          try {
            h.Q.checkIfAllowedToTriggerEmail(), await this.init();
            let t = await this.appEvent({
              type: d.s1.APP_CONNECT_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting email"
              ),
              e)
            );
          }
        }
        async connectDevice() {
          try {
            return this.appEvent({ type: d.s1.APP_CONNECT_DEVICE });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting device"
              ),
              e)
            );
          }
        }
        async connectOtp(e) {
          try {
            return this.appEvent({ type: d.s1.APP_CONNECT_OTP, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting otp"
              ),
              e)
            );
          }
        }
        async isConnected() {
          try {
            if (!this.getLoginEmailUsed()) return { isConnected: !1 };
            let e = await this.appEvent({ type: d.s1.APP_IS_CONNECTED });
            return e?.isConnected || this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.deleteAuthLoginCache(),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error checking connection"
              ),
              e)
            );
          }
        }
        async getChainId() {
          try {
            let e = await this.appEvent({ type: d.s1.APP_GET_CHAIN_ID });
            return this.setLastUsedChainId(e.chainId), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting chain id"
              ),
              e)
            );
          }
        }
        async getSocialRedirectUri(e) {
          try {
            return (
              await this.init(),
              this.appEvent({
                type: d.s1.APP_GET_SOCIAL_REDIRECT_URI,
                payload: e,
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting social redirect uri"
              ),
              e)
            );
          }
        }
        async updateEmail(e) {
          try {
            let t = await this.appEvent({
              type: d.s1.APP_UPDATE_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email"
              ),
              e)
            );
          }
        }
        async updateEmailPrimaryOtp(e) {
          try {
            return this.appEvent({
              type: d.s1.APP_UPDATE_EMAIL_PRIMARY_OTP,
              payload: e,
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email primary otp"
              ),
              e)
            );
          }
        }
        async updateEmailSecondaryOtp(e) {
          try {
            let t = await this.appEvent({
              type: d.s1.APP_UPDATE_EMAIL_SECONDARY_OTP,
              payload: e,
            });
            return this.setLoginSuccess(t.newEmail), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email secondary otp"
              ),
              e)
            );
          }
        }
        async syncTheme(e) {
          try {
            return this.appEvent({ type: d.s1.APP_SYNC_THEME, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing theme"
              ),
              e)
            );
          }
        }
        async syncDappData(e) {
          try {
            return this.appEvent({ type: d.s1.APP_SYNC_DAPP_DATA, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing dapp data"
              ),
              e)
            );
          }
        }
        async getSmartAccountEnabledNetworks() {
          try {
            let e = await this.appEvent({
              type: d.s1.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
            });
            return (
              this.persistSmartAccountEnabledNetworks(
                e.smartAccountEnabledNetworks
              ),
              e
            );
          } catch (e) {
            throw (
              (this.persistSmartAccountEnabledNetworks([]),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error getting smart account enabled networks"
              ),
              e)
            );
          }
        }
        async setPreferredAccount(e) {
          try {
            return this.appEvent({
              type: d.s1.APP_SET_PREFERRED_ACCOUNT,
              payload: { type: e },
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error setting preferred account"
              ),
              e)
            );
          }
        }
        async connect(e) {
          if (e?.socialUri)
            try {
              await this.init();
              let t = this.getRpcUrl(e.chainId),
                r = await this.appEvent({
                  type: d.s1.APP_CONNECT_SOCIAL,
                  payload: {
                    uri: e.socialUri,
                    preferredAccountType: e.preferredAccountType,
                    chainId: e.chainId,
                    siwxMessage: e.siwxMessage,
                    rpcUrl: t,
                  },
                });
              return (
                r.userName && this.setSocialLoginSuccess(r.userName),
                this.setLoginSuccess(r.email),
                this.setLastUsedChainId(r.chainId),
                (this.user = r),
                r
              );
            } catch (e) {
              throw (
                (this.w3mLogger?.logger.error(
                  { error: e },
                  "Error connecting social"
                ),
                e)
              );
            }
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.getUser({
                chainId: t,
                preferredAccountType: e?.preferredAccountType,
                siwxMessage: e?.siwxMessage,
                rpcUrl: this.getRpcUrl(t),
              });
            return (
              this.setLoginSuccess(r.email),
              this.setLastUsedChainId(r.chainId),
              (this.user = r),
              r
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async getUser(e) {
          try {
            await this.init();
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: d.s1.APP_GET_USER,
                payload: { ...e, chainId: t, rpcUrl: this.getRpcUrl(t) },
              });
            return (this.user = r), r;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async connectSocial({ uri: e, chainId: t, preferredAccountType: r }) {
          try {
            await this.init();
            let i = this.getRpcUrl(t),
              n = await this.appEvent({
                type: d.s1.APP_CONNECT_SOCIAL,
                payload: {
                  uri: e,
                  chainId: t,
                  rpcUrl: i,
                  preferredAccountType: r,
                },
              });
            return n.userName && this.setSocialLoginSuccess(n.userName), n;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting social"
              ),
              e)
            );
          }
        }
        async getFarcasterUri() {
          try {
            return (
              await this.init(),
              await this.appEvent({ type: d.s1.APP_GET_FARCASTER_URI })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting farcaster uri"
              ),
              e)
            );
          }
        }
        async connectFarcaster() {
          try {
            let e = await this.appEvent({ type: d.s1.APP_CONNECT_FARCASTER });
            return e.userName && this.setSocialLoginSuccess(e.userName), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting farcaster"
              ),
              e)
            );
          }
        }
        async switchNetwork({ chainId: e }) {
          try {
            let t = this.getRpcUrl(e),
              r = await this.appEvent({
                type: d.s1.APP_SWITCH_NETWORK,
                payload: { chainId: e, rpcUrl: t },
              });
            return this.setLastUsedChainId(r.chainId), r;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error switching network"
              ),
              e)
            );
          }
        }
        async disconnect() {
          try {
            return (
              this.deleteAuthLoginCache(),
              await new Promise(async (e) => {
                let t = setTimeout(() => {
                  e();
                }, 3e3);
                await this.appEvent({ type: d.s1.APP_SIGN_OUT }),
                  clearTimeout(t),
                  e();
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error disconnecting"
              ),
              e)
            );
          }
        }
        async request(e) {
          try {
            if (d.Vl.GET_CHAIN_ID === e.method)
              return this.getLastUsedChainId();
            let t = e.chainNamespace || "eip155",
              r = this.getActiveCaipNetwork(t)?.id;
            (e.chainNamespace = t),
              (e.chainId = r),
              (e.rpcUrl = this.getRpcUrl(r)),
              this.rpcRequestHandler?.(e);
            let i = await this.appEvent({
              type: d.s1.APP_RPC_REQUEST,
              payload: e,
            });
            return this.rpcSuccessHandler?.(i, e), i;
          } catch (t) {
            throw (
              (this.rpcErrorHandler?.(t, e),
              this.w3mLogger?.logger.error({ error: t }, "Error requesting"),
              t)
            );
          }
        }
        onRpcRequest(e) {
          this.rpcRequestHandler = e;
        }
        onRpcSuccess(e) {
          this.rpcSuccessHandler = e;
        }
        onRpcError(e) {
          this.rpcErrorHandler = e;
        }
        onIsConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.s1.FRAME_IS_CONNECTED_SUCCESS &&
              t.payload.isConnected &&
              e();
          });
        }
        onNotConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.s1.FRAME_IS_CONNECTED_ERROR && e(),
              t.type !== d.s1.FRAME_IS_CONNECTED_SUCCESS ||
                t.payload.isConnected ||
                e();
          });
        }
        onConnect(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.s1.FRAME_GET_USER_SUCCESS && e(t.payload);
          });
        }
        onSocialConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.s1.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
          });
        }
        async getCapabilities() {
          try {
            return (
              (await this.request({ method: "wallet_getCapabilities" })) || {}
            );
          } catch {
            return {};
          }
        }
        onSetPreferredAccount(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === d.s1.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
              ? e(t.payload)
              : t.type === d.s1.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
                e({ type: d.Vl.ACCOUNT_TYPES.EOA });
          });
        }
        getAvailableChainIds() {
          return Object.keys(this.w3mFrame.networks);
        }
        async rejectRpcRequests() {
          try {
            await Promise.all(
              Array.from(this.openRpcRequests.values()).map(
                async ({ abortController: e, method: t }) => {
                  d.Vl.SAFE_RPC_METHODS.includes(t) || e.abort(),
                    await this.appEvent({ type: d.s1.APP_RPC_ABORT });
                }
              )
            ),
              this.openRpcRequests.clear();
          } catch (e) {
            this.w3mLogger?.logger.error(
              { error: e },
              "Error aborting RPC request"
            );
          }
        }
        async appEvent(e) {
          let t, r;
          function i(e) {
            return e.replace("@w3m-app/", "");
          }
          let n = [
              d.s1.APP_SYNC_DAPP_DATA,
              d.s1.APP_SYNC_THEME,
              d.s1.APP_SET_PREFERRED_ACCOUNT,
            ],
            s = i(e.type);
          return (
            this.w3mFrame.iframeIsReady ||
              n.includes(e.type) ||
              (r = setTimeout(() => {
                this.onTimeout?.("iframe_load_failed"),
                  this.abortController.abort();
              }, 2e4)),
            await this.w3mFrame.frameLoadPromise,
            clearTimeout(r),
            [
              d.s1.APP_CONNECT_EMAIL,
              d.s1.APP_CONNECT_DEVICE,
              d.s1.APP_CONNECT_OTP,
              d.s1.APP_CONNECT_SOCIAL,
              d.s1.APP_GET_SOCIAL_REDIRECT_URI,
            ]
              .map(i)
              .includes(s) &&
              (t = setTimeout(() => {
                this.onTimeout?.("iframe_request_timeout"),
                  this.abortController.abort();
              }, 12e4)),
            new Promise((i, n) => {
              let a = Math.random().toString(36).substring(7);
              this.w3mLogger?.logger.info?.(
                { event: e, id: a },
                "Sending app event"
              ),
                this.w3mFrame.events.postAppEvent({ ...e, id: a });
              let o = new AbortController();
              "RPC_REQUEST" === s &&
                this.openRpcRequests.set(a, {
                  ...e.payload,
                  abortController: o,
                }),
                o.signal.addEventListener("abort", () => {
                  "RPC_REQUEST" === s
                    ? n(Error("Request was aborted"))
                    : "GET_FARCASTER_URI" !== s &&
                      n(Error("Something went wrong"));
                });
              let c = (e, o) => {
                e.id === a &&
                  (o?.logger.info?.(
                    { framEvent: e, id: a },
                    "Received frame response"
                  ),
                  this.openRpcRequests.delete(e.id),
                  e.type === `@w3m-frame/${s}_SUCCESS`
                    ? (t && clearTimeout(t),
                      r && clearTimeout(r),
                      "payload" in e && i(e.payload),
                      i(void 0))
                    : e.type === `@w3m-frame/${s}_ERROR` &&
                      (t && clearTimeout(t),
                      r && clearTimeout(r),
                      "payload" in e &&
                        n(Error(e.payload?.message || "An error occurred")),
                      n(Error("An error occurred"))));
              };
              this.w3mFrame.events.registerFrameEventHandler(
                a,
                (e) => c(e, this.w3mLogger),
                this.abortController.signal
              );
            })
          );
        }
        setNewLastEmailLoginTime() {
          rb.o.set(d.s1.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setSocialLoginSuccess(e) {
          rb.o.set(d.s1.SOCIAL_USERNAME, e);
        }
        setLoginSuccess(e) {
          e && rb.o.set(d.s1.EMAIL, e),
            rb.o.set(d.s1.EMAIL_LOGIN_USED_KEY, "true"),
            rb.o.delete(d.s1.LAST_EMAIL_LOGIN_TIME);
        }
        deleteAuthLoginCache() {
          rb.o.delete(d.s1.EMAIL_LOGIN_USED_KEY),
            rb.o.delete(d.s1.EMAIL),
            rb.o.delete(d.s1.LAST_USED_CHAIN_KEY),
            rb.o.delete(d.s1.SOCIAL_USERNAME);
        }
        setLastUsedChainId(e) {
          e && rb.o.set(d.s1.LAST_USED_CHAIN_KEY, String(e));
        }
        getLastUsedChainId() {
          let e = rb.o.get(d.s1.LAST_USED_CHAIN_KEY) ?? void 0,
            t = Number(e);
          return isNaN(t) ? e : t;
        }
        persistSmartAccountEnabledNetworks(e) {
          rb.o.set(d.s1.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
        }
        getRpcUrl(e) {
          let t = void 0 === e ? void 0 : "eip155";
          "string" == typeof e &&
            (t = e.includes(":")
              ? c.C.parseCaipNetworkId(e)?.chainNamespace
              : Number.isInteger(Number(e))
              ? "eip155"
              : "solana");
          let r = this.getCaipNetworks(t),
            i = e
              ? r.find(
                  (t) => String(t.id) === String(e) || t.caipNetworkId === e
                )
              : r[0];
          return i?.rpcUrls.default.http?.[0];
        }
      }
    },
    3515: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => n });
      var i = r(66575);
      function n(e) {
        return (0, i.M)({ ...e, state: !0, attribute: !1 });
      }
    },
    4058: (e, t, r) => {
      "use strict";
      r.d(t, { Ci: () => a, J8: () => o, MU: () => c });
      var i = r(59350),
        n = r(13933),
        s = r(24250);
      class a extends n.C {
        constructor({
          body: e,
          cause: t,
          details: r,
          headers: n,
          status: a,
          url: o,
        }) {
          super("HTTP request failed.", {
            cause: t,
            details: r,
            metaMessages: [
              a && `Status: ${a}`,
              `URL: ${(0, s.I)(o)}`,
              e && `Request body: ${(0, i.A)(e)}`,
            ].filter(Boolean),
            name: "HttpRequestError",
          }),
            Object.defineProperty(this, "body", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "headers", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "status", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "url", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = n),
            (this.status = a),
            (this.url = o);
        }
      }
      n.C;
      class o extends n.C {
        constructor({ body: e, error: t, url: r }) {
          super("RPC Request failed.", {
            cause: t,
            details: t.message,
            metaMessages: [
              `URL: ${(0, s.I)(r)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "RpcRequestError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      n.C;
      class c extends n.C {
        constructor({ body: e, url: t }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [
              `URL: ${(0, s.I)(t)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "TimeoutError",
          });
        }
      }
    },
    4486: (e, t, r) => {
      "use strict";
      r.d(t, {
        Ag: () => a,
        E5: () => h,
        Rm: () => l,
        SJ: () => c,
        UW: () => d,
        b2: () => n,
        oX: () => o,
        v2: () => i,
        xw: () => u,
      });
      let i = [
          {
            inputs: [
              {
                components: [
                  { name: "target", type: "address" },
                  { name: "allowFailure", type: "bool" },
                  { name: "callData", type: "bytes" },
                ],
                name: "calls",
                type: "tuple[]",
              },
            ],
            name: "aggregate3",
            outputs: [
              {
                components: [
                  { name: "success", type: "bool" },
                  { name: "returnData", type: "bytes" },
                ],
                name: "returnData",
                type: "tuple[]",
              },
            ],
            stateMutability: "view",
            type: "function",
          },
          {
            inputs: [],
            name: "getCurrentBlockTimestamp",
            outputs: [
              { internalType: "uint256", name: "timestamp", type: "uint256" },
            ],
            stateMutability: "view",
            type: "function",
          },
        ],
        n = [
          {
            name: "query",
            type: "function",
            stateMutability: "view",
            inputs: [
              {
                type: "tuple[]",
                name: "queries",
                components: [
                  { type: "address", name: "sender" },
                  { type: "string[]", name: "urls" },
                  { type: "bytes", name: "data" },
                ],
              },
            ],
            outputs: [
              { type: "bool[]", name: "failures" },
              { type: "bytes[]", name: "responses" },
            ],
          },
          {
            name: "HttpError",
            type: "error",
            inputs: [
              { type: "uint16", name: "status" },
              { type: "string", name: "message" },
            ],
          },
        ],
        s = [
          {
            inputs: [{ name: "dns", type: "bytes" }],
            name: "DNSDecodingFailed",
            type: "error",
          },
          {
            inputs: [{ name: "ens", type: "string" }],
            name: "DNSEncodingFailed",
            type: "error",
          },
          { inputs: [], name: "EmptyAddress", type: "error" },
          {
            inputs: [
              { name: "status", type: "uint16" },
              { name: "message", type: "string" },
            ],
            name: "HttpError",
            type: "error",
          },
          { inputs: [], name: "InvalidBatchGatewayResponse", type: "error" },
          {
            inputs: [{ name: "errorData", type: "bytes" }],
            name: "ResolverError",
            type: "error",
          },
          {
            inputs: [
              { name: "name", type: "bytes" },
              { name: "resolver", type: "address" },
            ],
            name: "ResolverNotContract",
            type: "error",
          },
          {
            inputs: [{ name: "name", type: "bytes" }],
            name: "ResolverNotFound",
            type: "error",
          },
          {
            inputs: [
              { name: "primary", type: "string" },
              { name: "primaryAddress", type: "bytes" },
            ],
            name: "ReverseAddressMismatch",
            type: "error",
          },
          {
            inputs: [
              { internalType: "bytes4", name: "selector", type: "bytes4" },
            ],
            name: "UnsupportedResolverProfile",
            type: "error",
          },
        ],
        a = [
          ...s,
          {
            name: "resolveWithGateways",
            type: "function",
            stateMutability: "view",
            inputs: [
              { name: "name", type: "bytes" },
              { name: "data", type: "bytes" },
              { name: "gateways", type: "string[]" },
            ],
            outputs: [
              { name: "", type: "bytes" },
              { name: "address", type: "address" },
            ],
          },
        ],
        o = [
          ...s,
          {
            name: "reverseWithGateways",
            type: "function",
            stateMutability: "view",
            inputs: [
              { type: "bytes", name: "reverseName" },
              { type: "uint256", name: "coinType" },
              { type: "string[]", name: "gateways" },
            ],
            outputs: [
              { type: "string", name: "resolvedName" },
              { type: "address", name: "resolver" },
              { type: "address", name: "reverseResolver" },
            ],
          },
        ],
        c = [
          {
            name: "text",
            type: "function",
            stateMutability: "view",
            inputs: [
              { name: "name", type: "bytes32" },
              { name: "key", type: "string" },
            ],
            outputs: [{ name: "", type: "string" }],
          },
        ],
        l = [
          {
            name: "addr",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "name", type: "bytes32" }],
            outputs: [{ name: "", type: "address" }],
          },
          {
            name: "addr",
            type: "function",
            stateMutability: "view",
            inputs: [
              { name: "name", type: "bytes32" },
              { name: "coinType", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bytes" }],
          },
        ],
        d = [
          {
            name: "isValidSignature",
            type: "function",
            stateMutability: "view",
            inputs: [
              { name: "hash", type: "bytes32" },
              { name: "signature", type: "bytes" },
            ],
            outputs: [{ name: "", type: "bytes4" }],
          },
        ],
        h = [
          {
            inputs: [
              { name: "_signer", type: "address" },
              { name: "_hash", type: "bytes32" },
              { name: "_signature", type: "bytes" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          {
            inputs: [
              { name: "_signer", type: "address" },
              { name: "_hash", type: "bytes32" },
              { name: "_signature", type: "bytes" },
            ],
            outputs: [{ type: "bool" }],
            stateMutability: "nonpayable",
            type: "function",
            name: "isValidSig",
          },
        ],
        u = [
          {
            type: "event",
            name: "Approval",
            inputs: [
              { indexed: !0, name: "owner", type: "address" },
              { indexed: !0, name: "spender", type: "address" },
              { indexed: !1, name: "value", type: "uint256" },
            ],
          },
          {
            type: "event",
            name: "Transfer",
            inputs: [
              { indexed: !0, name: "from", type: "address" },
              { indexed: !0, name: "to", type: "address" },
              { indexed: !1, name: "value", type: "uint256" },
            ],
          },
          {
            type: "function",
            name: "allowance",
            stateMutability: "view",
            inputs: [
              { name: "owner", type: "address" },
              { name: "spender", type: "address" },
            ],
            outputs: [{ type: "uint256" }],
          },
          {
            type: "function",
            name: "approve",
            stateMutability: "nonpayable",
            inputs: [
              { name: "spender", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ type: "bool" }],
          },
          {
            type: "function",
            name: "balanceOf",
            stateMutability: "view",
            inputs: [{ name: "account", type: "address" }],
            outputs: [{ type: "uint256" }],
          },
          {
            type: "function",
            name: "decimals",
            stateMutability: "view",
            inputs: [],
            outputs: [{ type: "uint8" }],
          },
          {
            type: "function",
            name: "name",
            stateMutability: "view",
            inputs: [],
            outputs: [{ type: "string" }],
          },
          {
            type: "function",
            name: "symbol",
            stateMutability: "view",
            inputs: [],
            outputs: [{ type: "string" }],
          },
          {
            type: "function",
            name: "totalSupply",
            stateMutability: "view",
            inputs: [],
            outputs: [{ type: "uint256" }],
          },
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ type: "bool" }],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "sender", type: "address" },
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ type: "bool" }],
          },
        ];
    },
    4693: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  button {
    background-color: transparent;
    padding: ${({ spacing: e }) => e[1]};
  }

  button:focus-visible {
    box-shadow: 0 0 0 4px ${({ tokens: e }) => e.core.foregroundAccent020};
  }

  button[data-variant='accent']:hover:enabled,
  button[data-variant='accent']:focus-visible {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  button[data-variant='primary']:hover:enabled,
  button[data-variant='primary']:focus-visible,
  button[data-variant='secondary']:hover:enabled,
  button[data-variant='secondary']:focus-visible {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  button[data-size='xs'] > wui-icon {
    width: 8px;
    height: 8px;
  }

  button[data-size='sm'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='xs'],
  button[data-size='sm'] {
    border-radius: ${({ borderRadius: e }) => e[1]};
  }

  button[data-size='md'],
  button[data-size='lg'] {
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  button[data-size='md'] > wui-icon {
    width: 16px;
    height: 16px;
  }

  button[data-size='lg'] > wui-icon {
    width: 20px;
    height: 20px;
  }

  button:disabled {
    background-color: transparent;
    cursor: not-allowed;
    opacity: 0.5;
  }

  button:hover:not(:disabled) {
    background-color: var(--wui-color-accent-glass-015);
  }

  button:focus-visible:not(:disabled) {
    background-color: var(--wui-color-accent-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.size = "md"),
            (this.disabled = !1),
            (this.icon = "copy"),
            (this.iconColor = "default"),
            (this.variant = "accent");
        }
        render() {
          return (0, i.qy)`
      <button data-variant=${this.variant} ?disabled=${
            this.disabled
          } data-size=${this.size}>
        <wui-icon
          color=${
            {
              accent: "accent-primary",
              primary: "inverse",
              secondary: "default",
            }[this.variant] || this.iconColor
          }
          size=${this.size}
          name=${this.icon}
        ></wui-icon>
      </button>
    `;
        }
      };
      (d.styles = [s.W5, s.fD, c]),
        l([(0, n.MZ)()], d.prototype, "size", void 0),
        l([(0, n.MZ)({ type: Boolean })], d.prototype, "disabled", void 0),
        l([(0, n.MZ)()], d.prototype, "icon", void 0),
        l([(0, n.MZ)()], d.prototype, "iconColor", void 0),
        l([(0, n.MZ)()], d.prototype, "variant", void 0),
        (d = l([(0, a.E)("wui-icon-link")], d));
    },
    4768: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => a });
      var i = r(97418),
        n = r(10899),
        s = r(55480);
      let a = {
        getConnectionStatus(e, t) {
          let r = n.a.state.activeConnectorIds[t],
            s = i.x.getConnections(t);
          return r && e.connectorId === r
            ? "connected"
            : s.some(
                (t) =>
                  t.connectorId.toLowerCase() === e.connectorId.toLowerCase()
              )
            ? "active"
            : "disconnected";
        },
        excludeConnectorAddressFromConnections: ({
          connections: e,
          connectorId: t,
          addresses: r,
        }) =>
          e.map((e) => {
            if (t && e.connectorId.toLowerCase() === t.toLowerCase() && r) {
              let t = e.accounts.filter(
                (e) =>
                  !r.some((t) => t.toLowerCase() === e.address.toLowerCase())
              );
              return { ...e, accounts: t };
            }
            return e;
          }),
        excludeExistingConnections(e, t) {
          let r = new Set(e);
          return t.filter((e) => !r.has(e.connectorId));
        },
        getConnectionsByConnectorId: (e, t) =>
          e.filter((e) => e.connectorId.toLowerCase() === t.toLowerCase()),
        getConnectionsData(e) {
          let t = !!s.H.state.remoteFeatures?.multiWallet,
            r = n.a.state.activeConnectorIds[e],
            o = i.x.getConnections(e),
            c = (i.x.state.recentConnections.get(e) ?? []).filter((e) =>
              n.a.getConnectorById(e.connectorId)
            ),
            l = a.excludeExistingConnections(
              [...o.map((e) => e.connectorId), ...(r ? [r] : [])],
              c
            );
          return t
            ? { connections: o, recentConnections: l }
            : {
                connections: o.filter(
                  (e) => e.connectorId.toLowerCase() === r?.toLowerCase()
                ),
                recentConnections: [],
              };
        },
      };
    },
    4959: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => o });
      var i = r(1220),
        n = r(98866),
        s = r(36964);
      let a = (0, i.BX)({
          message: "",
          open: !1,
          triggerRect: { width: 0, height: 0, top: 0, left: 0 },
          variant: "shade",
        }),
        o = (0, s.X)({
          state: a,
          subscribe: (e) => (0, i.B1)(a, () => e(a)),
          subscribeKey: (e, t) => (0, n.u$)(a, e, t),
          showTooltip({ message: e, triggerRect: t, variant: r }) {
            (a.open = !0),
              (a.message = e),
              (a.triggerRect = t),
              (a.variant = r);
          },
          hide() {
            (a.open = !1),
              (a.message = ""),
              (a.triggerRect = { width: 0, height: 0, top: 0, left: 0 });
          },
        });
    },
    5082: (e, t, r) => {
      "use strict";
      r.d(t, { PK: () => c, iq: () => s, uP: () => o, zF: () => a });
      var i = r(19781),
        n = r(13933);
      class s extends n.C {
        constructor({ maxSize: e, size: t }) {
          super("Blob size is too large.", {
            metaMessages: [`Max: ${e} bytes`, `Given: ${t} bytes`],
            name: "BlobSizeTooLargeError",
          });
        }
      }
      class a extends n.C {
        constructor() {
          super("Blob data must not be empty.", { name: "EmptyBlobError" });
        }
      }
      class o extends n.C {
        constructor({ hash: e, size: t }) {
          super(`Versioned hash "${e}" size is invalid.`, {
            metaMessages: ["Expected: 32", `Received: ${t}`],
            name: "InvalidVersionedHashSizeError",
          });
        }
      }
      class c extends n.C {
        constructor({ hash: e, version: t }) {
          super(`Versioned hash "${e}" version is invalid.`, {
            metaMessages: [`Expected: ${i.E}`, `Received: ${t}`],
            name: "InvalidVersionedHashVersionError",
          });
        }
      }
    },
    5089: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964),
        a = r(46747);
      r(99691), r(24772);
      var o = r(71084),
        c = r(47327),
        l = r(20296);
      let d = (0, l.AH)`
  :host {
    position: relative;
    width: 100%;
    display: inline-flex;
    flex-direction: column;
    gap: ${({ spacing: e }) => e[3]};
    color: ${({ tokens: e }) => e.theme.textPrimary};
    caret-color: ${({ tokens: e }) => e.core.textAccentPrimary};
  }

  .wui-input-text-container {
    position: relative;
    display: flex;
  }

  input {
    width: 100%;
    border-radius: ${({ borderRadius: e }) => e[4]};
    color: inherit;
    background: transparent;
    border: 1px solid ${({ tokens: e }) => e.theme.borderPrimary};
    caret-color: ${({ tokens: e }) => e.core.textAccentPrimary};
    padding: ${({ spacing: e }) => e[3]} ${({ spacing: e }) => e[3]}
      ${({ spacing: e }) => e[3]} ${({ spacing: e }) => e[10]};
    font-size: ${({ textSize: e }) => e.large};
    line-height: ${({ typography: e }) => e["lg-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["lg-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
  }

  input[data-size='lg'] {
    padding: ${({ spacing: e }) => e[4]} ${({ spacing: e }) => e[3]}
      ${({ spacing: e }) => e[4]} ${({ spacing: e }) => e[10]};
  }

  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      border: 1px solid ${({ tokens: e }) => e.theme.borderSecondary};
    }
  }

  input:disabled {
    cursor: unset;
    border: 1px solid ${({ tokens: e }) => e.theme.borderPrimary};
  }

  input::placeholder {
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  input:focus:enabled {
    border: 1px solid ${({ tokens: e }) => e.theme.borderSecondary};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    -webkit-box-shadow: 0px 0px 0px 4px ${({ tokens: e }) =>
      e.core.foregroundAccent040};
    -moz-box-shadow: 0px 0px 0px 4px ${({ tokens: e }) =>
      e.core.foregroundAccent040};
    box-shadow: 0px 0px 0px 4px ${({ tokens: e }) =>
      e.core.foregroundAccent040};
  }

  div.wui-input-text-container:has(input:disabled) {
    opacity: 0.5;
  }

  wui-icon.wui-input-text-left-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    left: ${({ spacing: e }) => e[4]};
    color: ${({ tokens: e }) => e.theme.iconDefault};
  }

  button.wui-input-text-submit-button {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: ${({ spacing: e }) => e[3]};
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: ${({ borderRadius: e }) => e[2]};
    color: ${({ tokens: e }) => e.core.textAccentPrimary};
  }

  button.wui-input-text-submit-button:disabled {
    opacity: 1;
  }

  button.wui-input-text-submit-button.loading wui-icon {
    animation: spin 1s linear infinite;
  }

  button.wui-input-text-submit-button:hover {
    background: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  input:has(+ .wui-input-text-submit-button) {
    padding-right: ${({ spacing: e }) => e[12]};
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input[type='search']::-webkit-search-decoration,
  input[type='search']::-webkit-search-cancel-button,
  input[type='search']::-webkit-search-results-button,
  input[type='search']::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  /* -- Keyframes --------------------------------------------------- */
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
`;
      var h = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let u = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.inputElementRef = (0, a._)()),
            (this.disabled = !1),
            (this.loading = !1),
            (this.placeholder = ""),
            (this.type = "text"),
            (this.value = ""),
            (this.size = "md");
        }
        render() {
          return (0, i.qy)` <div class="wui-input-text-container">
        ${this.templateLeftIcon()}
        <input
          data-size=${this.size}
          ${(0, a.K)(this.inputElementRef)}
          data-testid="wui-input-text"
          type=${this.type}
          enterkeyhint=${(0, s.J)(this.enterKeyHint)}
          ?disabled=${this.disabled}
          placeholder=${this.placeholder}
          @input=${this.dispatchInputChangeEvent.bind(this)}
          @keydown=${this.onKeyDown}
          .value=${this.value || ""}
        />
        ${this.templateSubmitButton()}
        <slot class="wui-input-text-slot"></slot>
      </div>
      ${this.templateError()} ${this.templateWarning()}`;
        }
        templateLeftIcon() {
          return this.icon
            ? (0, i.qy)`<wui-icon
        class="wui-input-text-left-icon"
        size="md"
        data-size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`
            : null;
        }
        templateSubmitButton() {
          return this.onSubmit
            ? (0, i.qy)`<button
        class="wui-input-text-submit-button ${this.loading ? "loading" : ""}"
        @click=${this.onSubmit?.bind(this)}
        ?disabled=${this.disabled || this.loading}
      >
        ${
          this.loading
            ? (0, i.qy)`<wui-icon name="spinner" size="md"></wui-icon>`
            : (0, i.qy)`<wui-icon name="chevronRight" size="md"></wui-icon>`
        }
      </button>`
            : null;
        }
        templateError() {
          return this.errorText
            ? (0,
              i.qy)`<wui-text variant="sm-regular" color="error">${this.errorText}</wui-text>`
            : null;
        }
        templateWarning() {
          return this.warningText
            ? (0,
              i.qy)`<wui-text variant="sm-regular" color="warning">${this.warningText}</wui-text>`
            : null;
        }
        dispatchInputChangeEvent() {
          this.dispatchEvent(
            new CustomEvent("inputChange", {
              detail: this.inputElementRef.value?.value,
              bubbles: !0,
              composed: !0,
            })
          );
        }
      };
      (u.styles = [o.W5, o.fD, d]),
        h([(0, n.MZ)()], u.prototype, "icon", void 0),
        h([(0, n.MZ)({ type: Boolean })], u.prototype, "disabled", void 0),
        h([(0, n.MZ)({ type: Boolean })], u.prototype, "loading", void 0),
        h([(0, n.MZ)()], u.prototype, "placeholder", void 0),
        h([(0, n.MZ)()], u.prototype, "type", void 0),
        h([(0, n.MZ)()], u.prototype, "value", void 0),
        h([(0, n.MZ)()], u.prototype, "errorText", void 0),
        h([(0, n.MZ)()], u.prototype, "warningText", void 0),
        h([(0, n.MZ)()], u.prototype, "onSubmit", void 0),
        h([(0, n.MZ)()], u.prototype, "size", void 0),
        h([(0, n.MZ)({ attribute: !1 })], u.prototype, "onKeyDown", void 0),
        (u = h([(0, c.E)("wui-input-text")], u));
    },
    5566: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(2648), t),
        i.__exportStar(r(38053), t),
        i.__exportStar(r(90332), t),
        i.__exportStar(r(25648), t);
    },
    6578: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => a });
      var i = r(1220),
        n = r(98866);
      let s = (0, i.BX)({
          loading: !1,
          open: !1,
          selectedNetworkId: void 0,
          activeChain: void 0,
          initialized: !1,
        }),
        a = {
          state: s,
          subscribe: (e) => (0, i.B1)(s, () => e(s)),
          subscribeOpen: (e) => (0, n.u$)(s, "open", e),
          set(e) {
            Object.assign(s, { ...s, ...e });
          },
        };
    },
    7873: (e, t, r) => {
      let i = r(85268),
        n = r(15063);
      e.exports = {
        blake2b: i.blake2b,
        blake2bHex: i.blake2bHex,
        blake2bInit: i.blake2bInit,
        blake2bUpdate: i.blake2bUpdate,
        blake2bFinal: i.blake2bFinal,
        blake2s: n.blake2s,
        blake2sHex: n.blake2sHex,
        blake2sInit: n.blake2sInit,
        blake2sUpdate: n.blake2sUpdate,
        blake2sFinal: n.blake2sFinal,
      };
    },
    8318: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => o });
      var i = r(45553),
        n = r(93481),
        s = r(10899),
        a = r(67869);
      let o = {
        onSwitchNetwork({ network: e, ignoreSwitchConfirmation: t = !1 }) {
          let r = n.W.state.activeCaipNetwork,
            o = n.W.state.activeChain,
            c = a.I.state.data;
          if (e.id === r?.id) return;
          let l = !!n.W.getAccountData(o)?.address,
            d = !!n.W.getAccountData(e.chainNamespace)?.address,
            h = e.chainNamespace !== o,
            u = s.a.getConnectorId(o) === i.o.CONNECTOR_ID.AUTH,
            p = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
              (t) => t === e.chainNamespace
            );
          t || (u && p)
            ? a.I.push("SwitchNetwork", { ...c, network: e })
            : l && h && !d
            ? a.I.push("SwitchActiveChain", {
                switchToChain: e.chainNamespace,
                navigateTo: "Connect",
                navigateWithReplace: !0,
                network: e,
              })
            : a.I.push("SwitchNetwork", { ...c, network: e });
        },
      };
    },
    8444: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (function (e) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        let t = new Uint8Array(256);
        for (let e = 0; e < t.length; e++) t[e] = 255;
        for (let r = 0; r < e.length; r++) {
          let i = e.charAt(r),
            n = i.charCodeAt(0);
          if (255 !== t[n]) throw TypeError(i + " is ambiguous");
          t[n] = r;
        }
        let r = e.length,
          i = e.charAt(0),
          n = Math.log(r) / Math.log(256),
          s = Math.log(256) / Math.log(r);
        function a(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          let s = 0,
            a = 0,
            o = 0;
          for (; e[s] === i; ) a++, s++;
          let c = ((e.length - s) * n + 1) >>> 0,
            l = new Uint8Array(c);
          for (; s < e.length; ) {
            let i = e.charCodeAt(s);
            if (i > 255) return;
            let n = t[i];
            if (255 === n) return;
            let a = 0;
            for (let e = c - 1; (0 !== n || a < o) && -1 !== e; e--, a++)
              (n += (r * l[e]) >>> 0),
                (l[e] = n % 256 >>> 0),
                (n = (n / 256) >>> 0);
            if (0 !== n) throw Error("Non-zero carry");
            (o = a), s++;
          }
          let d = c - o;
          for (; d !== c && 0 === l[d]; ) d++;
          let h = new Uint8Array(a + (c - d)),
            u = a;
          for (; d !== c; ) h[u++] = l[d++];
          return h;
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            let n = 0,
              a = 0,
              o = 0,
              c = t.length;
            for (; o !== c && 0 === t[o]; ) o++, n++;
            let l = ((c - o) * s + 1) >>> 0,
              d = new Uint8Array(l);
            for (; o !== c; ) {
              let e = t[o],
                i = 0;
              for (let t = l - 1; (0 !== e || i < a) && -1 !== t; t--, i++)
                (e += (256 * d[t]) >>> 0),
                  (d[t] = e % r >>> 0),
                  (e = (e / r) >>> 0);
              if (0 !== e) throw Error("Non-zero carry");
              (a = i), o++;
            }
            let h = l - a;
            for (; h !== l && 0 === d[h]; ) h++;
            let u = i.repeat(n);
            for (; h < l; ++h) u += e.charAt(d[h]);
            return u;
          },
          decodeUnsafe: a,
          decode: function (e) {
            let t = a(e);
            if (t) return t;
            throw Error("Non-base" + r + " character");
          },
        };
      })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    8567: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => i });
      let i = {
        METMASK_CONNECTOR_NAME: "MetaMask",
        TRUST_CONNECTOR_NAME: "Trust Wallet",
        SOLFLARE_CONNECTOR_NAME: "Solflare",
        PHANTOM_CONNECTOR_NAME: "Phantom",
        COIN98_CONNECTOR_NAME: "Coin98",
        MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
        BACKPACK_CONNECTOR_NAME: "Backpack",
        BITGET_CONNECTOR_NAME: "Bitget Wallet",
        FRONTIER_CONNECTOR_NAME: "Frontier",
        XVERSE_CONNECTOR_NAME: "Xverse Wallet",
        LEATHER_CONNECTOR_NAME: "Leather",
        OKX_CONNECTOR_NAME: "OKX Wallet",
        EIP155: r(45553).o.CHAIN.EVM,
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet",
          coinbaseWalletSDK: "com.coinbase.wallet",
        },
        CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
        CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
        CONNECTOR_TYPE_INJECTED: "INJECTED",
        CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
        CONNECTOR_TYPE_AUTH: "AUTH",
        CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
        CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
        getSDKVersionWarningMessage: (e, t) => `
     @@@@@@@           @@@@@@@@@@@@@@@@@@      
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@   @@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@   @@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@  @@@@@@@@@@@@@
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@   @@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@   @@@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@  @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@   @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
      @@@@@            @@@@@@@@@@@@@@@@@@  
      
AppKit SDK version ${e} is outdated. Latest version is ${t}. Please update to the latest version for bug fixes and new features.
            
Changelog: https://github.com/reown-com/appkit/releases
NPM Registry: https://www.npmjs.com/package/@reown/appkit`,
      };
    },
    8821: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => i });
      let i = {
        getSpacingStyles: (e, t) =>
          Array.isArray(e)
            ? e[t]
              ? `var(--apkt-spacing-${e[t]})`
              : void 0
            : "string" == typeof e
            ? `var(--apkt-spacing-${e})`
            : void 0,
        getFormattedDate: (e) =>
          new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
          }).format(e),
        formatCurrency(e = 0, t = {}) {
          let r = Number(e);
          return isNaN(r)
            ? "$0.00"
            : new Intl.NumberFormat("en-US", {
                style: "currency",
                currency: "USD",
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
                ...t,
              }).format(r);
        },
        getHostName(e) {
          try {
            return new URL(e).hostname;
          } catch (e) {
            return "";
          }
        },
        getTruncateString: ({
          string: e,
          charsStart: t,
          charsEnd: r,
          truncate: i,
        }) =>
          e.length <= t + r
            ? e
            : "end" === i
            ? `${e.substring(0, t)}...`
            : "start" === i
            ? `...${e.substring(e.length - r)}`
            : `${e.substring(0, Math.floor(t))}...${e.substring(
                e.length - Math.floor(r)
              )}`,
        generateAvatarColors(e) {
          let t = e
              .toLowerCase()
              .replace(/^0x/iu, "")
              .replace(/[^a-f0-9]/gu, "")
              .substring(0, 6)
              .padEnd(6, "0"),
            r = this.hexToRgb(t),
            i = getComputedStyle(document.documentElement).getPropertyValue(
              "--w3m-border-radius-master"
            ),
            n = 100 - 3 * Number(i?.replace("px", "")),
            s = `${n}% ${n}% at 65% 40%`,
            a = [];
          for (let e = 0; e < 5; e += 1) {
            let t = this.tintColor(r, 0.15 * e);
            a.push(`rgb(${t[0]}, ${t[1]}, ${t[2]})`);
          }
          return `
    --local-color-1: ${a[0]};
    --local-color-2: ${a[1]};
    --local-color-3: ${a[2]};
    --local-color-4: ${a[3]};
    --local-color-5: ${a[4]};
    --local-radial-circle: ${s}
   `;
        },
        hexToRgb(e) {
          let t = parseInt(e, 16);
          return [(t >> 16) & 255, (t >> 8) & 255, 255 & t];
        },
        tintColor(e, t) {
          let [r, i, n] = e;
          return [
            Math.round(r + (255 - r) * t),
            Math.round(i + (255 - i) * t),
            Math.round(n + (255 - n) * t),
          ];
        },
        isNumber: (e) => /^[0-9]+$/u.test(e),
        getColorTheme: (e) =>
          e
            ? e
            : "undefined" != typeof window &&
              window.matchMedia &&
              "function" == typeof window.matchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")?.matches
              ? "dark"
              : "light"
            : "dark",
        splitBalance(e) {
          let t = e.split(".");
          return 2 === t.length ? [t[0], t[1]] : ["0", "00"];
        },
        roundNumber: (e, t, r) =>
          e.toString().length >= t ? Number(e).toFixed(r) : e,
        cssDurationToNumber: (e) =>
          e.endsWith("s")
            ? 1e3 * Number(e.replace("s", ""))
            : e.endsWith("ms")
            ? Number(e.replace("ms", ""))
            : 0,
        maskInput({ value: e, decimals: t, integers: r }) {
          if ("." === (e = e.replace(",", "."))) return "0.";
          let [i = "", n] = e.split(".").map((e) => e.replace(/[^0-9]/gu, "")),
            s = r ? i.substring(0, r) : i,
            a = 2 === s.length ? String(Number(s)) : s,
            o = "number" == typeof t ? n?.substring(0, t) : n;
          return (
            ("string" == typeof o && ("number" != typeof t || t > 0)
              ? [a, o].join(".")
              : a) ?? ""
          );
        },
        capitalize: (e) => (e ? e.charAt(0).toUpperCase() + e.slice(1) : ""),
      };
    },
    10429: (e, t) => {
      let r = new Uint8Array(512),
        i = new Uint8Array(256);
      !(function () {
        let e = 1;
        for (let t = 0; t < 255; t++)
          (r[t] = e), (i[e] = t), 256 & (e <<= 1) && (e ^= 285);
        for (let e = 255; e < 512; e++) r[e] = r[e - 255];
      })(),
        (t.log = function (e) {
          if (e < 1) throw Error("log(" + e + ")");
          return i[e];
        }),
        (t.exp = function (e) {
          return r[e];
        }),
        (t.mul = function (e, t) {
          return 0 === e || 0 === t ? 0 : r[i[e] + i[t]];
        });
    },
    10763: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => l }), r(59335);
      var i = r(45553),
        n = r(93481),
        s = r(55480),
        a = r(67243),
        o = r(75578),
        c = r(19816);
      class l {
        constructor({ provider: e, namespace: t }) {
          (this.id = i.o.CONNECTOR_ID.WALLET_CONNECT),
            (this.name =
              o.L.ConnectorNamesMap[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.type = "WALLET_CONNECT"),
            (this.imageId =
              o.L.ConnectorImageIds[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.getCaipNetworks = n.W.getCaipNetworks.bind(n.W)),
            (this.caipNetworks = this.getCaipNetworks()),
            (this.provider = e),
            (this.chain = t);
        }
        get chains() {
          return this.getCaipNetworks();
        }
        async connectWalletConnect() {
          if (!(await this.authenticate())) {
            let e = this.getCaipNetworks(),
              t = s.H.state.universalProviderConfigOverride,
              r = c.kl.createNamespaces(e, t);
            await this.provider.connect({ optionalNamespaces: r });
          }
          return {
            clientId: await this.provider.client.core.crypto.getClientId(),
            session: this.provider.session,
          };
        }
        async disconnect() {
          await this.provider.disconnect();
        }
        async authenticate() {
          let e = this.chains.map((e) => e.caipNetworkId);
          return a.U.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains: e,
            methods: d,
          });
        }
      }
      let d = [
        "eth_accounts",
        "eth_requestAccounts",
        "eth_sendRawTransaction",
        "eth_sign",
        "eth_signTransaction",
        "eth_signTypedData",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "personal_sign",
        "wallet_switchEthereumChain",
        "wallet_addEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode",
        "wallet_getCallsStatus",
        "wallet_sendCalls",
        "wallet_getCapabilities",
        "wallet_grantPermissions",
        "wallet_revokePermissions",
        "wallet_getAssets",
      ];
    },
    10886: (e, t, r) => {
      "use strict";
      let i, n;
      r.d(t, {
        sX: () => I,
        JS: () => b,
        G8: () => y,
        Ks: () => v,
        uP: () => w,
      });
      var s = r(12319),
        a = r(59233),
        o = r(12115),
        c = r(73022),
        l = r(1220);
      let d = new WeakMap();
      function h(e, t) {
        let r = null == t ? void 0 : t.sync,
          i = (0, o.useMemo)(() => e && new WeakMap(), [e]),
          n = (0, o.useRef)(void 0),
          s = !0,
          a = (0, o.useSyncExternalStore)(
            (0, o.useCallback)(
              (t) => {
                let i = (0, l.B1)(e, t, r);
                return t(), i;
              },
              [e, r]
            ),
            () => {
              let t = (0, l.P9)(e);
              try {
                if (
                  !s &&
                  n.current &&
                  !(0, c.Hq)(n.current, t, i, new WeakMap())
                )
                  return n.current;
              } catch (e) {}
              return t;
            },
            () => (0, l.P9)(e)
          );
        (s = !1),
          (0, o.useLayoutEffect)(() => {
            n.current = a;
          }),
          ((e, t) => {
            let r = (0, o.useRef)(void 0);
            (0, o.useEffect)(() => {
              r.current = (0, c.JR)(e, t, !0);
            }),
              (0, o.useDebugValue)(r.current);
          })(a, i);
        let h = (0, o.useMemo)(() => new WeakMap(), []);
        return (0, c.tz)(a, i, h, d);
      }
      var u = r(45553),
        p = r(93481),
        f = r(97418),
        g = r(10899),
        m = r(58653);
      function y(e) {
        let t = h(p.W.state),
          { activeConnectorIds: r } = h(g.a.state),
          i = e?.namespace || t.activeChain;
        if (!i)
          return {
            allAccounts: [],
            address: void 0,
            caipAddress: void 0,
            status: void 0,
            isConnected: !1,
            embeddedWalletInfo: void 0,
          };
        let n = t.chains.get(i)?.accountState,
          a = g.a.getAuthConnector(i),
          o = r[i];
        return {
          allAccounts: f.x
            .getConnections(i)
            .flatMap((e) =>
              e.accounts.map(({ address: e, type: t, publicKey: r }) =>
                s.w.createAccount(i, e, t || "eoa", r)
              )
            ),
          caipAddress: n?.caipAddress,
          address: s.w.getPlainAddress(n?.caipAddress),
          isConnected: !!n?.caipAddress,
          status: n?.status,
          embeddedWalletInfo:
            a && o === u.o.CONNECTOR_ID.AUTH
              ? {
                  user: n?.user
                    ? { ...n.user, username: m.i.getConnectedSocialUsername() }
                    : void 0,
                  authProvider: n?.socialProvider || "email",
                  accountType: n?.preferredAccountType,
                  isSmartAccountDeployed: !!n?.smartAccountDeployed,
                }
              : void 0,
        };
      }
      function w() {
        return {
          disconnect: async function (e) {
            await f.x.disconnect(e);
          },
        };
      }
      function b() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKit" hook'
          );
        return {
          open: async function (e) {
            return i?.open(e);
          },
          close: async function () {
            await i?.close();
          },
        };
      }
      function v() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKitEvents" hook'
          );
        let [e, t] = (0, o.useState)(i.getEvent());
        return (
          (0, o.useEffect)(() => {
            let e = i?.subscribeEvents((e) => {
              t({ ...e });
            });
            return () => {
              e?.();
            };
          }, []),
          e
        );
      }
      r(19816);
      let C = new Set(["children", "localName", "ref", "style", "className"]),
        E = new WeakMap(),
        x = (e, t, r, i, n) => {
          let s = n?.[t];
          void 0 === s
            ? ((e[t] = r),
              null == r && t in HTMLElement.prototype && e.removeAttribute(t))
            : r !== i &&
              ((e, t, r) => {
                let i = E.get(e);
                void 0 === i && E.set(e, (i = new Map()));
                let n = i.get(t);
                void 0 !== r
                  ? void 0 === n
                    ? (i.set(t, (n = { handleEvent: r })),
                      e.addEventListener(t, n))
                    : (n.handleEvent = r)
                  : void 0 !== n && (i.delete(t), e.removeEventListener(t, n));
              })(e, s, r);
        },
        A = ({
          react: e,
          tagName: t,
          elementClass: r,
          events: i,
          displayName: n,
        }) => {
          let s = new Set(Object.keys(i ?? {})),
            a = e.forwardRef((n, a) => {
              let o = e.useRef(new Map()),
                c = e.useRef(null),
                l = {},
                d = {};
              for (let [e, t] of Object.entries(n))
                C.has(e)
                  ? (l["className" === e ? "class" : e] = t)
                  : s.has(e) || e in r.prototype
                  ? (d[e] = t)
                  : (l[e] = t);
              return (
                e.useLayoutEffect(() => {
                  if (null === c.current) return;
                  let e = new Map();
                  for (let t in d)
                    x(c.current, t, n[t], o.current.get(t), i),
                      o.current.delete(t),
                      e.set(t, n[t]);
                  for (let [e, t] of o.current) x(c.current, e, void 0, t, i);
                  o.current = e;
                }),
                e.useLayoutEffect(() => {
                  c.current?.removeAttribute("defer-hydration");
                }, []),
                (l.suppressHydrationWarning = !0),
                e.createElement(t, {
                  ...l,
                  ref: e.useCallback(
                    (e) => {
                      (c.current = e),
                        "function" == typeof a
                          ? a(e)
                          : null !== a && (a.current = e);
                    },
                    [a]
                  ),
                })
              );
            });
          return (a.displayName = n ?? r.name), a;
        };
      var _ = r(83621);
      function I(e) {
        !n &&
          (i = n =
            new a._({
              ...e,
              sdkVersion: s.w.generateSdkVersion(
                e.adapters ?? [],
                "react",
                "1.8.7"
              ),
            }));
        return n;
      }
      A({ tagName: "appkit-button", elementClass: _.AppKitButton, react: o }),
        A({
          tagName: "appkit-network-button",
          elementClass: _.AppKitNetworkButton,
          react: o,
        }),
        A({
          tagName: "appkit-connect-button",
          elementClass: _.AppKitConnectButton,
          react: o,
        }),
        A({
          tagName: "appkit-account-button",
          elementClass: _.AppKitAccountButton,
          react: o,
        });
    },
    10899: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => C });
      var i = r(1220),
        n = r(98866),
        s = r(76190),
        a = r(45553),
        o = r(52617),
        c = r(73537),
        l = r(71305),
        d = r(19831),
        h = r(58653),
        u = r(36964),
        p = r(72880),
        f = r(93481),
        g = r(55480),
        m = r(67869),
        y = r(45069);
      let w = Object.fromEntries(s.P.map((e) => [e, void 0])),
        b = Object.fromEntries(s.P.map((e) => [e, !0])),
        v = (0, i.BX)({
          allConnectors: [],
          connectors: [],
          activeConnector: void 0,
          filterByNamespace: void 0,
          activeConnectorIds: w,
          filterByNamespaceMap: b,
        }),
        C = (0, u.X)({
          state: v,
          subscribe: (e) =>
            (0, i.B1)(v, () => {
              e(v);
            }),
          subscribeKey: (e, t) => (0, n.u$)(v, e, t),
          initialize(e) {
            e.forEach((e) => {
              let t = h.i.getConnectedConnectorId(e);
              t && C.setConnectorId(t, e);
            });
          },
          setActiveConnector(e) {
            e && (v.activeConnector = (0, i.KR)(e));
          },
          setConnectors(e) {
            e.filter(
              (e) =>
                !v.allConnectors.some(
                  (t) =>
                    t.id === e.id &&
                    C.getConnectorName(t.name) === C.getConnectorName(e.name) &&
                    t.chain === e.chain
                )
            ).forEach((e) => {
              "MULTI_CHAIN" !== e.type && v.allConnectors.push((0, i.KR)(e));
            });
            let t = C.getEnabledNamespaces(),
              r = C.getEnabledConnectors(t);
            v.connectors = C.mergeMultiChainConnectors(r);
          },
          filterByNamespaces(e) {
            Object.keys(v.filterByNamespaceMap).forEach((e) => {
              v.filterByNamespaceMap[e] = !1;
            }),
              e.forEach((e) => {
                v.filterByNamespaceMap[e] = !0;
              }),
              C.updateConnectorsForEnabledNamespaces();
          },
          filterByNamespace(e, t) {
            (v.filterByNamespaceMap[e] = t),
              C.updateConnectorsForEnabledNamespaces();
          },
          updateConnectorsForEnabledNamespaces() {
            let e = C.getEnabledNamespaces(),
              t = C.getEnabledConnectors(e),
              r = C.areAllNamespacesEnabled();
            (v.connectors = C.mergeMultiChainConnectors(t)),
              r ? p.N.clearFilterByNamespaces() : p.N.filterByNamespaces(e);
          },
          getEnabledNamespaces: () =>
            Object.entries(v.filterByNamespaceMap)
              .filter(([e, t]) => t)
              .map(([e]) => e),
          getEnabledConnectors: (e) =>
            v.allConnectors.filter((t) => e.includes(t.chain)),
          areAllNamespacesEnabled: () =>
            Object.values(v.filterByNamespaceMap).every((e) => e),
          mergeMultiChainConnectors(e) {
            let t = C.generateConnectorMapByName(e),
              r = [];
            return (
              t.forEach((e) => {
                let t = e[0],
                  i = t?.id === a.o.CONNECTOR_ID.AUTH;
                e.length > 1 && t
                  ? r.push({
                      name: t.name,
                      imageUrl: t.imageUrl,
                      imageId: t.imageId,
                      connectors: [...e],
                      type: i ? "AUTH" : "MULTI_CHAIN",
                      chain: "eip155",
                      id: t?.id || "",
                    })
                  : t && r.push(t);
              }),
              r
            );
          },
          generateConnectorMapByName(e) {
            let t = new Map();
            return (
              e.forEach((e) => {
                let { name: r } = e,
                  i = C.getConnectorName(r);
                if (!i) return;
                let n = t.get(i) || [];
                n.find((t) => t.chain === e.chain) || n.push(e), t.set(i, n);
              }),
              t
            );
          },
          getConnectorName: (e) => (e && { "Trust Wallet": "Trust" }[e]) || e,
          getUniqueConnectorsByName(e) {
            let t = [];
            return (
              e.forEach((e) => {
                t.find((t) => t.chain === e.chain) || t.push(e);
              }),
              t
            );
          },
          addConnector(e) {
            if (e.id === a.o.CONNECTOR_ID.AUTH) {
              let t = (0, i.P9)(g.H.state),
                r = y.W.getSnapshot().themeMode,
                n = y.W.getSnapshot().themeVariables;
              e?.provider?.syncDappData?.({
                metadata: t.metadata,
                sdkVersion: t.sdkVersion,
                projectId: t.projectId,
                sdkType: t.sdkType,
              }),
                e?.provider?.syncTheme({
                  themeMode: r,
                  themeVariables: n,
                  w3mThemeVariables: (0, o.o)(n, r),
                }),
                C.setConnectors([e]);
            } else C.setConnectors([e]);
          },
          getAuthConnector(e) {
            let t = e || f.W.state.activeChain,
              r = v.connectors.find((e) => e.id === a.o.CONNECTOR_ID.AUTH);
            if (r)
              return r?.connectors?.length
                ? r.connectors.find((e) => e.chain === t)
                : r;
          },
          getAnnouncedConnectorRdns: () =>
            v.connectors
              .filter((e) => "ANNOUNCED" === e.type)
              .map((e) => e.info?.rdns),
          getConnectorById: (e) => v.allConnectors.find((t) => t.id === e),
          getConnector({ id: e, rdns: t, namespace: r }) {
            let i = r || f.W.state.activeChain;
            return v.allConnectors
              .filter((e) => e.chain === i)
              .find((r) => r.explorerId === e || r.info?.rdns === t);
          },
          syncIfAuthConnector(e) {
            if ("ID_AUTH" !== e.id) return;
            let t = (0, i.P9)(g.H.state),
              r = y.W.getSnapshot().themeMode,
              n = y.W.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: t.metadata,
              sdkVersion: t.sdkVersion,
              sdkType: t.sdkType,
              projectId: t.projectId,
            }),
              e.provider.syncTheme({
                themeMode: r,
                themeVariables: n,
                w3mThemeVariables: (0, o.o)(n, r),
              });
          },
          getConnectorsByNamespace(e) {
            let t = v.allConnectors.filter((t) => t.chain === e);
            return C.mergeMultiChainConnectors(t);
          },
          canSwitchToSmartAccount: (e) =>
            f.W.checkIfSmartAccountEnabled() &&
            (0, l.lj)(e) === c.Vl.ACCOUNT_TYPES.EOA,
          selectWalletConnector(e) {
            let t = m.I.state.data?.redirectView,
              r = C.getConnector({ id: e.id, rdns: e.rdns });
            d.W.handleMobileDeeplinkRedirect(
              r?.explorerId || e.id,
              f.W.state.activeChain
            ),
              r
                ? m.I.push("ConnectingExternal", {
                    connector: r,
                    wallet: e,
                    redirectView: t,
                  })
                : m.I.push("ConnectingWalletConnect", {
                    wallet: e,
                    redirectView: t,
                  });
          },
          getConnectors: (e) =>
            e
              ? C.getConnectorsByNamespace(e)
              : C.mergeMultiChainConnectors(v.allConnectors),
          setFilterByNamespace(e) {
            (v.filterByNamespace = e),
              (v.connectors = C.getConnectors(e)),
              p.N.setFilterByNamespace(e);
          },
          setConnectorId(e, t) {
            e &&
              ((v.activeConnectorIds = { ...v.activeConnectorIds, [t]: e }),
              h.i.setConnectedConnectorId(t, e));
          },
          removeConnectorId(e) {
            (v.activeConnectorIds = { ...v.activeConnectorIds, [e]: void 0 }),
              h.i.deleteConnectedConnectorId(e);
          },
          getConnectorId(e) {
            if (e) return v.activeConnectorIds[e];
          },
          isConnected: (e) =>
            e
              ? !!v.activeConnectorIds[e]
              : Object.values(v.activeConnectorIds).some((e) => !!e),
          resetConnectorIds() {
            v.activeConnectorIds = { ...w };
          },
        });
    },
    11870: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => s,
          __asyncDelegator: () => v,
          __asyncGenerator: () => b,
          __asyncValues: () => C,
          __await: () => w,
          __awaiter: () => d,
          __classPrivateFieldGet: () => _,
          __classPrivateFieldSet: () => I,
          __createBinding: () => u,
          __decorate: () => o,
          __exportStar: () => p,
          __extends: () => n,
          __generator: () => h,
          __importDefault: () => A,
          __importStar: () => x,
          __makeTemplateObject: () => E,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => y,
          __values: () => f,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function n(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var s = function () {
        return (s =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var n in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var n = 0, i = Object.getOwnPropertySymbols(e);
            n < i.length;
            n++
          )
            0 > t.indexOf(i[n]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[n]) &&
              (r[i[n]] = e[i[n]]);
        return r;
      }
      function o(e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function d(e, t, r, i) {
        return new (r || (r = Promise))(function (n, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? n(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function h(e, t) {
        var r,
          i,
          n,
          s,
          a = {
            label: 0,
            sent: function () {
              if (1 & n[0]) throw n[1];
              return n[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (s = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (s[Symbol.iterator] = function () {
              return this;
            }),
          s
        );
        function o(s) {
          return function (o) {
            var c = [s, o];
            if (r) throw TypeError("Generator is already executing.");
            for (; a; )
              try {
                if (
                  ((r = 1),
                  i &&
                    (n =
                      2 & c[0]
                        ? i.return
                        : c[0]
                        ? i.throw || ((n = i.return) && n.call(i), 0)
                        : i.next) &&
                    !(n = n.call(i, c[1])).done)
                )
                  return n;
                switch (((i = 0), n && (c = [2 & c[0], n.value]), c[0])) {
                  case 0:
                  case 1:
                    n = c;
                    break;
                  case 4:
                    return a.label++, { value: c[1], done: !1 };
                  case 5:
                    a.label++, (i = c[1]), (c = [0]);
                    continue;
                  case 7:
                    (c = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (
                      !(n = (n = a.trys).length > 0 && n[n.length - 1]) &&
                      (6 === c[0] || 2 === c[0])
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === c[0] && (!n || (c[1] > n[0] && c[1] < n[3]))) {
                      a.label = c[1];
                      break;
                    }
                    if (6 === c[0] && a.label < n[1]) {
                      (a.label = n[1]), (n = c);
                      break;
                    }
                    if (n && a.label < n[2]) {
                      (a.label = n[2]), a.ops.push(c);
                      break;
                    }
                    n[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                c = t.call(e, a);
              } catch (e) {
                (c = [6, e]), (i = 0);
              } finally {
                r = n = 0;
              }
            if (5 & c[0]) throw c[1];
            return { value: c[0] ? c[1] : void 0, done: !0 };
          };
        }
      }
      function u(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          n,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = s.next()).done; )
            a.push(i.value);
        } catch (e) {
          n = { error: e };
        } finally {
          try {
            i && !i.done && (r = s.return) && r.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), n = 0, t = 0; t < r; t++)
          for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
            i[n] = s[a];
        return i;
      }
      function w(e) {
        return this instanceof w ? ((this.v = e), this) : new w(e);
      }
      function b(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          n = r.apply(e, t || []),
          s = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          n[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                s.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = n[e](t)).value instanceof w
              ? Promise.resolve(r.value.v).then(c, l)
              : d(s[0][2], r);
          } catch (e) {
            d(s[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function d(e, t) {
          e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, n) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: w(e[i](t)), done: "return" === i }
                  : n
                  ? n(t)
                  : t;
              }
            : n;
        }
      }
      function C(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, n) {
                var s, a, o;
                (s = i),
                  (a = n),
                  (o = (t = e[r](t)).done),
                  Promise.resolve(t.value).then(function (e) {
                    s({ value: e, done: o });
                  }, a);
              });
            };
        }
      }
      function E(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function x(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function A(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function _(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function I(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    11914: (e, t, r) => {
      "use strict";
      r.d(t, {
        IQ: () => h,
        ME: () => d,
        Nx: () => l,
        Sl: () => o,
        uU: () => c,
      });
      var i = r(35276),
        n = r(16871),
        s = r(42438),
        a = r(55563);
      function o(e, { size: t }) {
        if ((0, n.E)(e) > t)
          throw new i.u({ givenSize: (0, n.E)(e), maxSize: t });
      }
      function c(e, t = {}) {
        let { signed: r } = t;
        t.size && o(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let n = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(n) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * n, "f")}`) - 1n;
      }
      function l(e, t = {}) {
        let r = e;
        if (
          (t.size && (o(r, { size: t.size }), (r = (0, s.B)(r))),
          "0x00" === (0, s.B)(r))
        )
          return !1;
        if ("0x01" === (0, s.B)(r)) return !0;
        throw new i.H2(r);
      }
      function d(e, t = {}) {
        return Number(c(e, t));
      }
      function h(e, t = {}) {
        let r = (0, a.aT)(e);
        return (
          t.size &&
            (o(r, { size: t.size }), (r = (0, s.B)(r, { dir: "right" }))),
          new TextDecoder().decode(r)
        );
      }
    },
    12182: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => f });
      var i = "[big.js] ",
        n = i + "Invalid ",
        s = n + "decimal places",
        a = n + "rounding mode",
        o = i + "Division by zero",
        c = {},
        l = void 0,
        d = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function h(e, t, r, i) {
        var n = e.c;
        if (
          (r === l && (r = e.constructor.RM),
          0 !== r && 1 !== r && 2 !== r && 3 !== r)
        )
          throw Error(a);
        if (t < 1)
          (i =
            (3 === r && (i || !!n[0])) ||
            (0 === t &&
              ((1 === r && n[0] >= 5) ||
                (2 === r && (n[0] > 5 || (5 === n[0] && (i || n[1] !== l))))))),
            (n.length = 1),
            i ? ((e.e = e.e - t + 1), (n[0] = 1)) : (n[0] = e.e = 0);
        else if (t < n.length) {
          if (
            ((i =
              (1 === r && n[t] >= 5) ||
              (2 === r &&
                (n[t] > 5 ||
                  (5 === n[t] && (i || n[t + 1] !== l || 1 & n[t - 1])))) ||
              (3 === r && (i || !!n[0]))),
            (n.length = t),
            i)
          ) {
            for (; ++n[--t] > 9; )
              if (((n[t] = 0), 0 === t)) {
                ++e.e, n.unshift(1);
                break;
              }
          }
          for (t = n.length; !n[--t]; ) n.pop();
        }
        return e;
      }
      function u(e, t, r) {
        var i = e.e,
          n = e.c.join(""),
          s = n.length;
        if (t)
          n =
            n.charAt(0) +
            (s > 1 ? "." + n.slice(1) : "") +
            (i < 0 ? "e" : "e+") +
            i;
        else if (i < 0) {
          for (; ++i; ) n = "0" + n;
          n = "0." + n;
        } else if (i > 0)
          if (++i > s) for (i -= s; i--; ) n += "0";
          else i < s && (n = n.slice(0, i) + "." + n.slice(i));
        else s > 1 && (n = n.charAt(0) + "." + n.slice(1));
        return e.s < 0 && r ? "-" + n : n;
      }
      (c.abs = function () {
        var e = new this.constructor(this);
        return (e.s = 1), e;
      }),
        (c.cmp = function (e) {
          var t,
            r = this.c,
            i = (e = new this.constructor(e)).c,
            n = this.s,
            s = e.s,
            a = this.e,
            o = e.e;
          if (!r[0] || !i[0]) return r[0] ? n : i[0] ? -s : 0;
          if (n != s) return n;
          if (((t = n < 0), a != o)) return (a > o) ^ t ? 1 : -1;
          for (n = -1, s = (a = r.length) < (o = i.length) ? a : o; ++n < s; )
            if (r[n] != i[n]) return (r[n] > i[n]) ^ t ? 1 : -1;
          return a == o ? 0 : (a > o) ^ t ? 1 : -1;
        }),
        (c.div = function (e) {
          var t = this.constructor,
            r = this.c,
            i = (e = new t(e)).c,
            n = this.s == e.s ? 1 : -1,
            a = t.DP;
          if (a !== ~~a || a < 0 || a > 1e6) throw Error(s);
          if (!i[0]) throw Error(o);
          if (!r[0]) return (e.s = n), (e.c = [(e.e = 0)]), e;
          var c,
            d,
            u,
            p,
            f,
            g = i.slice(),
            m = (c = i.length),
            y = r.length,
            w = r.slice(0, c),
            b = w.length,
            v = e,
            C = (v.c = []),
            E = 0,
            x = a + (v.e = this.e - e.e) + 1;
          for (v.s = n, n = x < 0 ? 0 : x, g.unshift(0); b++ < c; ) w.push(0);
          do {
            for (u = 0; u < 10; u++) {
              if (c != (b = w.length)) p = c > b ? 1 : -1;
              else
                for (f = -1, p = 0; ++f < c; )
                  if (i[f] != w[f]) {
                    p = i[f] > w[f] ? 1 : -1;
                    break;
                  }
              if (p < 0) {
                for (d = b == c ? i : g; b; ) {
                  if (w[--b] < d[b]) {
                    for (f = b; f && !w[--f]; ) w[f] = 9;
                    --w[f], (w[b] += 10);
                  }
                  w[b] -= d[b];
                }
                for (; !w[0]; ) w.shift();
              } else break;
            }
            (C[E++] = p ? u : ++u),
              w[0] && p ? (w[b] = r[m] || 0) : (w = [r[m]]);
          } while ((m++ < y || w[0] !== l) && n--);
          return (
            !C[0] && 1 != E && (C.shift(), v.e--, x--),
            E > x && h(v, x, t.RM, w[0] !== l),
            v
          );
        }),
        (c.eq = function (e) {
          return 0 === this.cmp(e);
        }),
        (c.gt = function (e) {
          return this.cmp(e) > 0;
        }),
        (c.gte = function (e) {
          return this.cmp(e) > -1;
        }),
        (c.lt = function (e) {
          return 0 > this.cmp(e);
        }),
        (c.lte = function (e) {
          return 1 > this.cmp(e);
        }),
        (c.minus = c.sub =
          function (e) {
            var t,
              r,
              i,
              n,
              s = this.constructor,
              a = this.s,
              o = (e = new s(e)).s;
            if (a != o) return (e.s = -o), this.plus(e);
            var c = this.c.slice(),
              l = this.e,
              d = e.c,
              h = e.e;
            if (!c[0] || !d[0])
              return (
                d[0] ? (e.s = -o) : c[0] ? (e = new s(this)) : (e.s = 1), e
              );
            if ((a = l - h)) {
              for (
                (n = a < 0) ? ((a = -a), (i = c)) : ((h = l), (i = d)),
                  i.reverse(),
                  o = a;
                o--;

              )
                i.push(0);
              i.reverse();
            } else
              for (
                r = ((n = c.length < d.length) ? c : d).length, a = o = 0;
                o < r;
                o++
              )
                if (c[o] != d[o]) {
                  n = c[o] < d[o];
                  break;
                }
            if (
              (n && ((i = c), (c = d), (d = i), (e.s = -e.s)),
              (o = (r = d.length) - (t = c.length)) > 0)
            )
              for (; o--; ) c[t++] = 0;
            for (o = t; r > a; ) {
              if (c[--r] < d[r]) {
                for (t = r; t && !c[--t]; ) c[t] = 9;
                --c[t], (c[r] += 10);
              }
              c[r] -= d[r];
            }
            for (; 0 === c[--o]; ) c.pop();
            for (; 0 === c[0]; ) c.shift(), --h;
            return (
              c[0] || ((e.s = 1), (c = [(h = 0)])), (e.c = c), (e.e = h), e
            );
          }),
        (c.mod = function (e) {
          var t,
            r = this,
            i = r.constructor,
            n = r.s,
            s = (e = new i(e)).s;
          if (!e.c[0]) throw Error(o);
          return ((r.s = e.s = 1), (t = 1 == e.cmp(r)), (r.s = n), (e.s = s), t)
            ? new i(r)
            : ((n = i.DP),
              (s = i.RM),
              (i.DP = i.RM = 0),
              (r = r.div(e)),
              (i.DP = n),
              (i.RM = s),
              this.minus(r.times(e)));
        }),
        (c.neg = function () {
          var e = new this.constructor(this);
          return (e.s = -e.s), e;
        }),
        (c.plus = c.add =
          function (e) {
            var t,
              r,
              i,
              n = this.constructor;
            if (((e = new n(e)), this.s != e.s))
              return (e.s = -e.s), this.minus(e);
            var s = this.e,
              a = this.c,
              o = e.e,
              c = e.c;
            if (!a[0] || !c[0])
              return c[0] || (a[0] ? (e = new n(this)) : (e.s = this.s)), e;
            if (((a = a.slice()), (t = s - o))) {
              for (
                t > 0 ? ((o = s), (i = c)) : ((t = -t), (i = a)), i.reverse();
                t--;

              )
                i.push(0);
              i.reverse();
            }
            for (
              a.length - c.length < 0 && ((i = c), (c = a), (a = i)),
                t = c.length,
                r = 0;
              t;
              a[t] %= 10
            )
              r = ((a[--t] = a[t] + c[t] + r) / 10) | 0;
            for (r && (a.unshift(r), ++o), t = a.length; 0 === a[--t]; )
              a.pop();
            return (e.c = a), (e.e = o), e;
          }),
        (c.pow = function (e) {
          var t = this,
            r = new t.constructor("1"),
            i = r,
            s = e < 0;
          if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(n + "exponent");
          for (s && (e = -e); 1 & e && (i = i.times(t)), (e >>= 1); )
            t = t.times(t);
          return s ? r.div(i) : i;
        }),
        (c.prec = function (e, t) {
          if (e !== ~~e || e < 1 || e > 1e6) throw Error(n + "precision");
          return h(new this.constructor(this), e, t);
        }),
        (c.round = function (e, t) {
          if (e === l) e = 0;
          else if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(s);
          return h(new this.constructor(this), e + this.e + 1, t);
        }),
        (c.sqrt = function () {
          var e,
            t,
            r,
            n = this.constructor,
            s = this.s,
            a = this.e,
            o = new n("0.5");
          if (!this.c[0]) return new n(this);
          if (s < 0) throw Error(i + "No square root");
          0 === (s = Math.sqrt(+u(this, !0, !0))) || s === 1 / 0
            ? (((t = this.c.join("")).length + a) & 1 || (t += "0"),
              (a = (((a + 1) / 2) | 0) - (a < 0 || 1 & a)),
              (e = new n(
                ((s = Math.sqrt(t)) == 1 / 0
                  ? "5e"
                  : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + a
              )))
            : (e = new n(s + "")),
            (a = e.e + (n.DP += 4));
          do (r = e), (e = o.times(r.plus(this.div(r))));
          while (r.c.slice(0, a).join("") !== e.c.slice(0, a).join(""));
          return h(e, (n.DP -= 4) + e.e + 1, n.RM);
        }),
        (c.times = c.mul =
          function (e) {
            var t,
              r = this.constructor,
              i = this.c,
              n = (e = new r(e)).c,
              s = i.length,
              a = n.length,
              o = this.e,
              c = e.e;
            if (((e.s = this.s == e.s ? 1 : -1), !i[0] || !n[0]))
              return (e.c = [(e.e = 0)]), e;
            for (
              e.e = o + c,
                s < a && ((t = i), (i = n), (n = t), (c = s), (s = a), (a = c)),
                t = Array((c = s + a));
              c--;

            )
              t[c] = 0;
            for (o = a; o--; ) {
              for (a = 0, c = s + o; c > o; )
                (a = t[c] + n[o] * i[c - o - 1] + a),
                  (t[c--] = a % 10),
                  (a = (a / 10) | 0);
              t[c] = a;
            }
            for (a ? ++e.e : t.shift(), o = t.length; !t[--o]; ) t.pop();
            return (e.c = t), e;
          }),
        (c.toExponential = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(s);
            for (r = h(new r.constructor(r), ++e, t); r.c.length < e; )
              r.c.push(0);
          }
          return u(r, !0, !!i);
        }),
        (c.toFixed = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(s);
            for (
              r = h(new r.constructor(r), e + r.e + 1, t), e = e + r.e + 1;
              r.c.length < e;

            )
              r.c.push(0);
          }
          return u(r, !1, !!i);
        }),
        (c[Symbol.for("nodejs.util.inspect.custom")] =
          c.toJSON =
          c.toString =
            function () {
              var e = this.constructor;
              return u(this, this.e <= e.NE || this.e >= e.PE, !!this.c[0]);
            }),
        (c.toNumber = function () {
          var e = +u(this, !0, !0);
          if (!0 === this.constructor.strict && !this.eq(e.toString()))
            throw Error(i + "Imprecise conversion");
          return e;
        }),
        (c.toPrecision = function (e, t) {
          var r = this,
            i = r.constructor,
            s = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 1 || e > 1e6) throw Error(n + "precision");
            for (r = h(new i(r), e, t); r.c.length < e; ) r.c.push(0);
          }
          return u(r, e <= r.e || r.e <= i.NE || r.e >= i.PE, !!s);
        }),
        (c.valueOf = function () {
          var e = this.constructor;
          if (!0 === e.strict) throw Error(i + "valueOf disallowed");
          return u(this, this.e <= e.NE || this.e >= e.PE, !0);
        });
      var p = (function e() {
        function t(r) {
          if (!(this instanceof t)) return r === l ? e() : new t(r);
          if (r instanceof t)
            (this.s = r.s), (this.e = r.e), (this.c = r.c.slice());
          else {
            if ("string" != typeof r) {
              if (!0 === t.strict && "bigint" != typeof r)
                throw TypeError(n + "value");
              r = 0 === r && 1 / r < 0 ? "-0" : String(r);
            }
            !(function (e, t) {
              var r, i, s;
              if (!d.test(t)) throw Error(n + "number");
              for (
                e.s = "-" == t.charAt(0) ? ((t = t.slice(1)), -1) : 1,
                  (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
                  (i = t.search(/e/i)) > 0
                    ? (r < 0 && (r = i),
                      (r += +t.slice(i + 1)),
                      (t = t.substring(0, i)))
                    : r < 0 && (r = t.length),
                  s = t.length,
                  i = 0;
                i < s && "0" == t.charAt(i);

              )
                ++i;
              if (i == s) e.c = [(e.e = 0)];
              else {
                for (; s > 0 && "0" == t.charAt(--s); );
                for (e.e = r - i - 1, e.c = [], r = 0; i <= s; )
                  e.c[r++] = +t.charAt(i++);
              }
            })(this, r);
          }
          this.constructor = t;
        }
        return (
          (t.prototype = c),
          (t.DP = 20),
          (t.RM = 1),
          (t.NE = -7),
          (t.PE = 21),
          (t.strict = !1),
          (t.roundDown = 0),
          (t.roundHalfUp = 1),
          (t.roundHalfEven = 2),
          (t.roundUp = 3),
          t
        );
      })();
      let f = {
        bigNumber: (e) => new p(e ? e : 0),
        multiply(e, t) {
          if (void 0 === e || void 0 === t) return new p(0);
          let r = new p(e),
            i = new p(t);
          return r.times(i);
        },
        toFixed: (e, t = 2) =>
          void 0 === e || "" === e ? new p(0).toFixed(t) : new p(e).toFixed(t),
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e || "" === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
                roundingMode: "floor",
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
                roundingMode: "floor",
              }),
        parseLocalStringToNumber: (e) =>
          void 0 === e || "" === e ? 0 : new p(e.replace(/,/gu, "")).toNumber(),
      };
    },
    12232: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => l });
      var i = r(36117),
        n = r(34430),
        s = r(44839),
        a = r(18085);
      i.extend(s), i.extend(a);
      let o = {
          ...n,
          name: "en-web3-modal",
          relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "%d sec",
            m: "1 min",
            mm: "%d min",
            h: "1 hr",
            hh: "%d hrs",
            d: "1 d",
            dd: "%d d",
            M: "1 mo",
            MM: "%d mo",
            y: "1 yr",
            yy: "%d yr",
          },
        },
        c = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
      i.locale("en-web3-modal", o);
      let l = {
        getMonthNameByIndex: (e) => c[e],
        getYear: (e = new Date().toISOString()) => i(e).year(),
        getRelativeDateFromNow: (e) => i(e).locale("en-web3-modal").fromNow(!0),
        formatDate: (e, t = "DD MMM") => i(e).format(t),
      };
    },
    12319: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => a });
      var i = r(45553),
        n = r(28977),
        s = r(58653);
      let a = {
        isMobile() {
          return (
            !!this.isClient() &&
            !!(
              (window?.matchMedia &&
                "function" == typeof window.matchMedia &&
                window.matchMedia("(pointer:coarse)")?.matches) ||
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
                navigator.userAgent
              )
            )
          );
        },
        checkCaipNetwork: (e, t = "") =>
          e?.caipNetworkId.toLocaleLowerCase().includes(t.toLowerCase()),
        isAndroid() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return a.isMobile() && e.includes("android");
        },
        isIos() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("iphone") || e.includes("ipad");
        },
        isSafari() {
          return (
            !!this.isClient() &&
            window?.navigator.userAgent.toLowerCase().includes("safari")
          );
        },
        isClient: () => "undefined" != typeof window,
        isPairingExpired: (e) => !e || e - Date.now() <= n.oU.TEN_SEC_MS,
        isAllowedRetry: (e, t = n.oU.ONE_SEC_MS) => Date.now() - e >= t,
        copyToClopboard(e) {
          navigator.clipboard.writeText(e);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch (e) {
            return !1;
          }
        },
        isSafeApp() {
          if (a.isClient() && window.self !== window.top)
            try {
              let e = window?.location?.ancestorOrigins?.[0];
              if (e) {
                let t = new URL(e),
                  r = new URL("https://app.safe.global");
                return t.hostname === r.hostname;
              }
            } catch {}
          return !1;
        },
        getPairingExpiry: () => Date.now() + n.oU.FOUR_MINUTES_MS,
        getNetworkId: (e) => e?.split(":")[1],
        getPlainAddress: (e) => e?.split(":")[2],
        wait: async (e) =>
          new Promise((t) => {
            setTimeout(t, e);
          }),
        debounce(e, t = 500) {
          let r;
          return (...i) => {
            r && clearTimeout(r),
              (r = setTimeout(function () {
                e(...i);
              }, t));
          };
        },
        isHttpUrl: (e) => e.startsWith("http://") || e.startsWith("https://"),
        formatNativeUrl(e, t, r = null) {
          if (a.isHttpUrl(e)) return this.formatUniversalUrl(e, t);
          let i = e,
            n = r;
          i &&
            (i.includes("://") ||
              ((i = e.replaceAll("/", "").replaceAll(":", "")),
              (i = `${i}://`)),
            i.endsWith("/") || (i = `${i}/`)),
            n && !n?.endsWith("/") && (n = `${n}/`),
            this.isTelegram() &&
              this.isAndroid() &&
              (t = encodeURIComponent(t));
          let s = encodeURIComponent(t);
          return {
            redirect: `${i}wc?uri=${s}`,
            redirectUniversalLink: n ? `${n}wc?uri=${s}` : void 0,
            href: i,
          };
        },
        formatUniversalUrl(e, t) {
          if (!a.isHttpUrl(e)) return this.formatNativeUrl(e, t);
          let r = e;
          r.endsWith("/") || (r = `${r}/`);
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        getOpenTargetForPlatform(e) {
          return "popupWindow" === e
            ? e
            : this.isTelegram()
            ? s.i.getTelegramSocialProvider()
              ? "_top"
              : "_blank"
            : e;
        },
        openHref(e, t, r) {
          window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        returnOpenHref(e, t, r) {
          return window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        isTelegram: () =>
          "undefined" != typeof window &&
          (!!window.TelegramWebviewProxy ||
            !!window.Telegram ||
            !!window.TelegramWebviewProxyProto),
        isPWA() {
          if ("undefined" == typeof window) return !1;
          let e =
              !!window?.matchMedia &&
              "function" == typeof window.matchMedia &&
              window.matchMedia("(display-mode: standalone)")?.matches,
            t = window?.navigator?.standalone;
          return !!(e || t);
        },
        preloadImage: async (e) =>
          Promise.race([
            new Promise((t, r) => {
              let i = new Image();
              (i.onload = t),
                (i.onerror = r),
                (i.crossOrigin = "anonymous"),
                (i.src = e);
            }),
            a.wait(2e3),
          ]),
        parseBalance(e, t) {
          let r = "0.000";
          if ("string" == typeof e) {
            let t = Number(e);
            if (!isNaN(t)) {
              let e = (Math.floor(1e3 * t) / 1e3).toFixed(3);
              e && (r = e);
            }
          }
          let [i, n] = r.split("."),
            s = i || "0",
            a = n || "000";
          return {
            formattedText: `${s}.${a}${t ? ` ${t}` : ""}`,
            value: s,
            decimals: a,
            symbol: t,
          };
        },
        getApiUrl: () => i.o.W3M_API_URL,
        getBlockchainApiUrl: () => i.o.BLOCKCHAIN_API_RPC_URL,
        getAnalyticsUrl: () => i.o.PULSE_API_URL,
        getUUID: () =>
          crypto?.randomUUID
            ? crypto.randomUUID()
            : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
                let t = (16 * Math.random()) | 0;
                return ("x" === e ? t : (3 & t) | 8).toString(16);
              }),
        parseError: (e) =>
          "string" == typeof e
            ? e
            : "string" == typeof e?.issues?.[0]?.message
            ? e.issues[0].message
            : e instanceof Error
            ? e.message
            : "Unknown error",
        sortRequestedNetworks(e, t = []) {
          let r = {};
          return (
            t &&
              e &&
              (e.forEach((e, t) => {
                r[e] = t;
              }),
              t.sort((e, t) => {
                let i = r[e.id],
                  n = r[t.id];
                return void 0 !== i && void 0 !== n
                  ? i - n
                  : void 0 !== i
                  ? -1
                  : 1 * (void 0 !== n);
              })),
            t
          );
        },
        calculateBalance(e) {
          let t = 0;
          for (let r of e) t += r.value ?? 0;
          return t;
        },
        formatTokenBalance(e) {
          let [t, r] = e.toFixed(2).split(".");
          return { dollars: t, pennies: r };
        },
        isAddress(e, t = "eip155") {
          switch (t) {
            case "eip155":
              if (
                /^(?:0x)?[0-9a-f]{40}$/iu.test(e) &&
                (/^(?:0x)?[0-9a-f]{40}$/iu.test(e) ||
                  /^(?:0x)?[0-9A-F]{40}$/iu.test(e))
              )
                return !0;
              return !1;
            case "solana":
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(e);
            default:
              return !1;
          }
        },
        uniqueBy(e, t) {
          let r = new Set();
          return e.filter((e) => {
            let i = e[t];
            return !r.has(i) && (r.add(i), !0);
          });
        },
        generateSdkVersion(e, t, r) {
          let i =
            0 === e.length
              ? n.oU.ADAPTER_TYPES.UNIVERSAL
              : e.map((e) => e.adapterType).join(",");
          return `${t}-${i}-${r}`;
        },
        createAccount: (e, t, r, i, n) => ({
          namespace: e,
          address: t,
          type: r,
          publicKey: i,
          path: n,
        }),
        isCaipAddress(e) {
          if ("string" != typeof e) return !1;
          let t = e.split(":"),
            r = t[0];
          return 3 === t.filter(Boolean).length && r in i.o.CHAIN_NAME_MAP;
        },
        getAccount: (e) =>
          e
            ? "string" == typeof e
              ? { address: e, chainId: void 0 }
              : { address: e.address, chainId: e.chainId }
            : { address: void 0, chainId: void 0 },
        isMac() {
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("macintosh") && !e.includes("safari");
        },
        formatTelegramSocialLoginUrl(e) {
          let t = `--${encodeURIComponent(window?.location.href)}`,
            r = "state=";
          if ("auth.magic.link" === new URL(e).host) {
            let i = "provider_authorization_url=",
              n = e.substring(e.indexOf(i) + i.length),
              s = this.injectIntoUrl(decodeURIComponent(n), r, t);
            return e.replace(n, encodeURIComponent(s));
          }
          return this.injectIntoUrl(e, r, t);
        },
        injectIntoUrl(e, t, r) {
          let i = e.indexOf(t);
          if (-1 === i)
            throw Error(`${t} parameter not found in the URL: ${e}`);
          let n = e.indexOf("&", i),
            s = t.length,
            a = -1 !== n ? n : e.length,
            o = e.substring(0, i + s),
            c = e.substring(i + s, a);
          return o + (c + r) + e.substring(n);
        },
      };
    },
    12590: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => s,
          __asyncDelegator: () => v,
          __asyncGenerator: () => b,
          __asyncValues: () => C,
          __await: () => w,
          __awaiter: () => d,
          __classPrivateFieldGet: () => _,
          __classPrivateFieldSet: () => I,
          __createBinding: () => u,
          __decorate: () => o,
          __exportStar: () => p,
          __extends: () => n,
          __generator: () => h,
          __importDefault: () => A,
          __importStar: () => x,
          __makeTemplateObject: () => E,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => y,
          __values: () => f,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function n(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var s = function () {
        return (s =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var n in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var n = 0, i = Object.getOwnPropertySymbols(e);
            n < i.length;
            n++
          )
            0 > t.indexOf(i[n]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[n]) &&
              (r[i[n]] = e[i[n]]);
        return r;
      }
      function o(e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function d(e, t, r, i) {
        return new (r || (r = Promise))(function (n, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? n(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function h(e, t) {
        var r,
          i,
          n,
          s,
          a = {
            label: 0,
            sent: function () {
              if (1 & n[0]) throw n[1];
              return n[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (s = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (s[Symbol.iterator] = function () {
              return this;
            }),
          s
        );
        function o(s) {
          return function (o) {
            var c = [s, o];
            if (r) throw TypeError("Generator is already executing.");
            for (; a; )
              try {
                if (
                  ((r = 1),
                  i &&
                    (n =
                      2 & c[0]
                        ? i.return
                        : c[0]
                        ? i.throw || ((n = i.return) && n.call(i), 0)
                        : i.next) &&
                    !(n = n.call(i, c[1])).done)
                )
                  return n;
                switch (((i = 0), n && (c = [2 & c[0], n.value]), c[0])) {
                  case 0:
                  case 1:
                    n = c;
                    break;
                  case 4:
                    return a.label++, { value: c[1], done: !1 };
                  case 5:
                    a.label++, (i = c[1]), (c = [0]);
                    continue;
                  case 7:
                    (c = a.ops.pop()), a.trys.pop();
                    continue;
                  default:
                    if (
                      !(n = (n = a.trys).length > 0 && n[n.length - 1]) &&
                      (6 === c[0] || 2 === c[0])
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === c[0] && (!n || (c[1] > n[0] && c[1] < n[3]))) {
                      a.label = c[1];
                      break;
                    }
                    if (6 === c[0] && a.label < n[1]) {
                      (a.label = n[1]), (n = c);
                      break;
                    }
                    if (n && a.label < n[2]) {
                      (a.label = n[2]), a.ops.push(c);
                      break;
                    }
                    n[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }
                c = t.call(e, a);
              } catch (e) {
                (c = [6, e]), (i = 0);
              } finally {
                r = n = 0;
              }
            if (5 & c[0]) throw c[1];
            return { value: c[0] ? c[1] : void 0, done: !0 };
          };
        }
      }
      function u(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          n,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = s.next()).done; )
            a.push(i.value);
        } catch (e) {
          n = { error: e };
        } finally {
          try {
            i && !i.done && (r = s.return) && r.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), n = 0, t = 0; t < r; t++)
          for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
            i[n] = s[a];
        return i;
      }
      function w(e) {
        return this instanceof w ? ((this.v = e), this) : new w(e);
      }
      function b(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          n = r.apply(e, t || []),
          s = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          n[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                s.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = n[e](t)).value instanceof w
              ? Promise.resolve(r.value.v).then(c, l)
              : d(s[0][2], r);
          } catch (e) {
            d(s[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function d(e, t) {
          e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, n) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: w(e[i](t)), done: "return" === i }
                  : n
                  ? n(t)
                  : t;
              }
            : n;
        }
      }
      function C(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, n) {
                var s, a, o;
                (s = i),
                  (a = n),
                  (o = (t = e[r](t)).done),
                  Promise.resolve(t.value).then(function (e) {
                    s({ value: e, done: o });
                  }, a);
              });
            };
        }
      }
      function E(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function x(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function A(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function _(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function I(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    13933: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => s });
      let i = "2.37.9",
        n = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${i}`,
        };
      class s extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof s
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            a = (t.cause instanceof s && t.cause.docsPath) || t.docsPath,
            o = n.getDocsUrl?.({ ...t, docsPath: a });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(o ? [`Docs: ${o}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(n.version ? [`Version: ${n.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = a),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = i);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
    },
    14744: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => c });
      var i = r(1220),
        n = r(72880),
        s = r(29936);
      let a = {
          eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
          polkadot: "",
          bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
          cosmos: "",
          sui: "",
          stacks: "",
        },
        o = (0, i.BX)({ networkImagePromises: {} }),
        c = {
          async fetchWalletImage(e) {
            if (e)
              return await n.N._fetchWalletImage(e), this.getWalletImageById(e);
          },
          async fetchNetworkImage(e) {
            if (!e) return;
            let t = this.getNetworkImageById(e);
            return (
              t ||
              (o.networkImagePromises[e] ||
                (o.networkImagePromises[e] = n.N._fetchNetworkImage(e)),
              await o.networkImagePromises[e],
              this.getNetworkImageById(e))
            );
          },
          getWalletImageById(e) {
            if (e) return s.j.state.walletImages[e];
          },
          getWalletImage: (e) =>
            e?.image_url
              ? e?.image_url
              : e?.image_id
              ? s.j.state.walletImages[e.image_id]
              : void 0,
          getNetworkImage: (e) =>
            e?.assets?.imageUrl
              ? e?.assets?.imageUrl
              : e?.assets?.imageId
              ? s.j.state.networkImages[e.assets.imageId]
              : void 0,
          getNetworkImageById(e) {
            if (e) return s.j.state.networkImages[e];
          },
          getConnectorImage: (e) =>
            e?.imageUrl
              ? e.imageUrl
              : e?.info?.icon
              ? e.info.icon
              : e?.imageId
              ? s.j.state.connectorImages[e.imageId]
              : void 0,
          getChainImage: (e) => s.j.state.networkImages[a[e]],
          getTokenImage(e) {
            if (e) return s.j.state.tokenImages[e];
          },
        };
    },
    15063: (e, t, r) => {
      let i = r(89699);
      function n(e, t, r, i, n, a) {
        (c[e] = c[e] + c[t] + n),
          (c[i] = s(c[i] ^ c[e], 16)),
          (c[r] = c[r] + c[i]),
          (c[t] = s(c[t] ^ c[r], 12)),
          (c[e] = c[e] + c[t] + a),
          (c[i] = s(c[i] ^ c[e], 8)),
          (c[r] = c[r] + c[i]),
          (c[t] = s(c[t] ^ c[r], 7));
      }
      function s(e, t) {
        return (e >>> t) ^ (e << (32 - t));
      }
      let a = new Uint32Array([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        o = new Uint8Array([
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9,
          15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10,
          14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0,
          15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6,
          10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4,
          10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4,
          8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10,
          2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
        ]),
        c = new Uint32Array(16),
        l = new Uint32Array(16);
      function d(e, t) {
        let r = 0;
        for (r = 0; r < 8; r++) (c[r] = e.h[r]), (c[r + 8] = a[r]);
        for (
          c[12] ^= e.t,
            c[13] ^= e.t / 0x100000000,
            t && (c[14] = ~c[14]),
            r = 0;
          r < 16;
          r++
        ) {
          var i, s;
          l[r] =
            (i = e.b)[(s = 4 * r)] ^
            (i[s + 1] << 8) ^
            (i[s + 2] << 16) ^
            (i[s + 3] << 24);
        }
        for (r = 0; r < 10; r++)
          n(0, 4, 8, 12, l[o[16 * r + 0]], l[o[16 * r + 1]]),
            n(1, 5, 9, 13, l[o[16 * r + 2]], l[o[16 * r + 3]]),
            n(2, 6, 10, 14, l[o[16 * r + 4]], l[o[16 * r + 5]]),
            n(3, 7, 11, 15, l[o[16 * r + 6]], l[o[16 * r + 7]]),
            n(0, 5, 10, 15, l[o[16 * r + 8]], l[o[16 * r + 9]]),
            n(1, 6, 11, 12, l[o[16 * r + 10]], l[o[16 * r + 11]]),
            n(2, 7, 8, 13, l[o[16 * r + 12]], l[o[16 * r + 13]]),
            n(3, 4, 9, 14, l[o[16 * r + 14]], l[o[16 * r + 15]]);
        for (r = 0; r < 8; r++) e.h[r] ^= c[r] ^ c[r + 8];
      }
      function h(e, t) {
        if (!(e > 0 && e <= 32))
          throw Error("Incorrect output length, should be in [1, 32]");
        let r = t ? t.length : 0;
        if (t && !(r > 0 && r <= 32))
          throw Error("Incorrect key length, should be in [1, 32]");
        let i = {
          h: new Uint32Array(a),
          b: new Uint8Array(64),
          c: 0,
          t: 0,
          outlen: e,
        };
        return (
          (i.h[0] ^= 0x1010000 ^ (r << 8) ^ e),
          r > 0 && (u(i, t), (i.c = 64)),
          i
        );
      }
      function u(e, t) {
        for (let r = 0; r < t.length; r++)
          64 === e.c && ((e.t += e.c), d(e, !1), (e.c = 0)),
            (e.b[e.c++] = t[r]);
      }
      function p(e) {
        for (e.t += e.c; e.c < 64; ) e.b[e.c++] = 0;
        d(e, !0);
        let t = new Uint8Array(e.outlen);
        for (let r = 0; r < e.outlen; r++)
          t[r] = (e.h[r >> 2] >> (8 * (3 & r))) & 255;
        return t;
      }
      function f(e, t, r) {
        (r = r || 32), (e = i.normalizeInput(e));
        let n = h(r, t);
        return u(n, e), p(n);
      }
      e.exports = {
        blake2s: f,
        blake2sHex: function (e, t, r) {
          let n = f(e, t, r);
          return i.toHex(n);
        },
        blake2sInit: h,
        blake2sUpdate: u,
        blake2sFinal: p,
      };
    },
    15885: (e, t, r) => {
      "use strict";
      r.d(t, { b4: () => s, gU: () => o, uP: () => a });
      var i = r(11914),
        n = r(50707);
      let s = {
        "0x0": "legacy",
        "0x1": "eip2930",
        "0x2": "eip1559",
        "0x3": "eip4844",
        "0x4": "eip7702",
      };
      function a(e) {
        let t = {
          ...e,
          blockHash: e.blockHash ? e.blockHash : null,
          blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
          chainId: e.chainId ? (0, i.ME)(e.chainId) : void 0,
          gas: e.gas ? BigInt(e.gas) : void 0,
          gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
          maxFeePerBlobGas: e.maxFeePerBlobGas
            ? BigInt(e.maxFeePerBlobGas)
            : void 0,
          maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
          maxPriorityFeePerGas: e.maxPriorityFeePerGas
            ? BigInt(e.maxPriorityFeePerGas)
            : void 0,
          nonce: e.nonce ? (0, i.ME)(e.nonce) : void 0,
          to: e.to ? e.to : null,
          transactionIndex: e.transactionIndex
            ? Number(e.transactionIndex)
            : null,
          type: e.type ? s[e.type] : void 0,
          typeHex: e.type ? e.type : void 0,
          value: e.value ? BigInt(e.value) : void 0,
          v: e.v ? BigInt(e.v) : void 0,
        };
        return (
          e.authorizationList &&
            (t.authorizationList = e.authorizationList.map((e) => ({
              address: e.address,
              chainId: Number(e.chainId),
              nonce: Number(e.nonce),
              r: e.r,
              s: e.s,
              yParity: Number(e.yParity),
            }))),
          (t.yParity = (() => {
            if (e.yParity) return Number(e.yParity);
            if ("bigint" == typeof t.v) {
              if (0n === t.v || 27n === t.v) return 0;
              if (1n === t.v || 28n === t.v) return 1;
              if (t.v >= 35n) return +(t.v % 2n === 0n);
            }
          })()),
          "legacy" === t.type &&
            (delete t.accessList,
            delete t.maxFeePerBlobGas,
            delete t.maxFeePerGas,
            delete t.maxPriorityFeePerGas,
            delete t.yParity),
          "eip2930" === t.type &&
            (delete t.maxFeePerBlobGas,
            delete t.maxFeePerGas,
            delete t.maxPriorityFeePerGas),
          "eip1559" === t.type && delete t.maxFeePerBlobGas,
          t
        );
      }
      let o = (0, n.q)("transaction", a);
    },
    15913: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => o });
      var i = r(65103),
        n = r(62609),
        s = r(83804);
      let a = {
          solana: [
            "solana_signMessage",
            "solana_signTransaction",
            "solana_requestAccounts",
            "solana_getAccounts",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
          ],
          eip155: [
            "eth_accounts",
            "eth_requestAccounts",
            "eth_sendRawTransaction",
            "eth_sign",
            "eth_signTransaction",
            "eth_signTypedData",
            "eth_signTypedData_v3",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "personal_sign",
            "wallet_switchEthereumChain",
            "wallet_addEthereumChain",
            "wallet_getPermissions",
            "wallet_requestPermissions",
            "wallet_registerOnboarding",
            "wallet_watchAsset",
            "wallet_scanQRCode",
            "wallet_getCallsStatus",
            "wallet_showCallsStatus",
            "wallet_sendCalls",
            "wallet_getCapabilities",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "wallet_getAssets",
          ],
          bip122: [
            "sendTransfer",
            "signMessage",
            "signPsbt",
            "getAccountAddresses",
          ],
        },
        o = {
          RPC_ERROR_CODE: { USER_REJECTED: 5e3, USER_REJECTED_METHODS: 5002 },
          getMethodsByChainNamespace: (e) => a[e] || [],
          createDefaultNamespace(e) {
            return {
              methods: this.getMethodsByChainNamespace(e),
              events: ["accountsChanged", "chainChanged"],
              chains: [],
              rpcMap: {},
            };
          },
          applyNamespaceOverrides(e, t) {
            if (!t) return { ...e };
            let r = { ...e },
              i = new Set();
            if (
              (t.methods && Object.keys(t.methods).forEach((e) => i.add(e)),
              t.chains && Object.keys(t.chains).forEach((e) => i.add(e)),
              t.events && Object.keys(t.events).forEach((e) => i.add(e)),
              t.rpcMap &&
                Object.keys(t.rpcMap).forEach((e) => {
                  let [t] = e.split(":");
                  t && i.add(t);
                }),
              i.forEach((e) => {
                r[e] || (r[e] = this.createDefaultNamespace(e));
              }),
              t.methods &&
                Object.entries(t.methods).forEach(([e, t]) => {
                  r[e] && (r[e].methods = t);
                }),
              t.chains &&
                Object.entries(t.chains).forEach(([e, t]) => {
                  r[e] && (r[e].chains = t);
                }),
              t.events &&
                Object.entries(t.events).forEach(([e, t]) => {
                  r[e] && (r[e].events = t);
                }),
              t.rpcMap)
            ) {
              let e = new Set();
              Object.entries(t.rpcMap).forEach(([t, i]) => {
                let [n, s] = t.split(":");
                n &&
                  s &&
                  r[n] &&
                  (r[n].rpcMap || (r[n].rpcMap = {}),
                  e.has(n) || ((r[n].rpcMap = {}), e.add(n)),
                  (r[n].rpcMap[s] = i));
              });
            }
            return r;
          },
          createNamespaces(e, t) {
            let r = e.reduce((e, t) => {
              let { id: r, chainNamespace: i, rpcUrls: n } = t,
                a = n.default.http[0];
              e[i] || (e[i] = this.createDefaultNamespace(i));
              let o = `${i}:${r}`,
                c = e[i];
              switch ((c.chains.push(o), o)) {
                case s.tWt.caipNetworkId:
                  c.chains.push(s.tWt.deprecatedCaipNetworkId);
                  break;
                case s.Rn0.caipNetworkId:
                  c.chains.push(s.Rn0.deprecatedCaipNetworkId);
              }
              return c?.rpcMap && a && (c.rpcMap[r] = a), e;
            }, {});
            return this.applyNamespaceOverrides(r, t);
          },
          resolveReownName: async (e) => {
            let t = await n.f.resolveName(e),
              r = Object.values(t?.addresses) || [];
            return r[0]?.address || !1;
          },
          getChainsFromNamespaces: (e = {}) =>
            Object.values(e).flatMap((e) =>
              Array.from(
                new Set([
                  ...(e.chains || []),
                  ...e.accounts.map((e) => {
                    let [t, r] = e.split(":");
                    return `${t}:${r}`;
                  }),
                ])
              )
            ),
          isSessionEventData: (e) =>
            "object" == typeof e &&
            null !== e &&
            "id" in e &&
            "topic" in e &&
            "params" in e &&
            "object" == typeof e.params &&
            null !== e.params &&
            "chainId" in e.params &&
            "event" in e.params &&
            "object" == typeof e.params.event &&
            null !== e.params.event,
          isUserRejectedRequestError(e) {
            try {
              if ("object" == typeof e && null !== e) {
                let t = "number" == typeof e.code,
                  r = t && e.code === o.RPC_ERROR_CODE.USER_REJECTED_METHODS,
                  i = t && e.code === o.RPC_ERROR_CODE.USER_REJECTED;
                return r || i;
              }
              return !1;
            } catch {
              return !1;
            }
          },
          isOriginAllowed(e, t, r) {
            for (let i of [...t, ...r])
              if (i.includes("*")) {
                let t = i.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
                if (RegExp(`^${t.replace(/\\\*/gu, ".*")}$`, "u").test(e))
                  return !0;
              } else
                try {
                  if (new URL(i).origin === e) return !0;
                } catch (t) {
                  if (i === e) return !0;
                }
            return !1;
          },
          listenWcProvider({
            universalProvider: e,
            namespace: t,
            onConnect: r,
            onDisconnect: n,
            onAccountsChanged: s,
            onChainChanged: a,
            onDisplayUri: c,
          }) {
            r &&
              e.on("connect", () => {
                r(o.getWalletConnectAccounts(e, t));
              }),
              n &&
                e.on("disconnect", () => {
                  n();
                }),
              s &&
                e.on("accountsChanged", (r) => {
                  try {
                    let n = e.session?.namespaces?.[t]?.accounts || [],
                      a = e.rpcProviders?.[t]?.getDefaultChain(),
                      o = r
                        .map((e) => {
                          let r = n.find((r) => r.includes(`${t}:${a}:${e}`));
                          if (!r) return;
                          let { chainId: s, chainNamespace: o } =
                            i.C.parseCaipAddress(r);
                          return { address: e, chainId: s, chainNamespace: o };
                        })
                        .filter((e) => void 0 !== e);
                    o.length > 0 && s(o);
                  } catch (e) {
                    console.warn(
                      "Failed to parse accounts for namespace on accountsChanged event",
                      t,
                      r,
                      e
                    );
                  }
                }),
              a &&
                e.on("chainChanged", (e) => {
                  a(e);
                }),
              c &&
                e.on("display_uri", (e) => {
                  c(e);
                });
          },
          getWalletConnectAccounts(e, t) {
            let r = new Set(),
              n = e?.session?.namespaces?.[t]?.accounts
                ?.map((e) => i.C.parseCaipAddress(e))
                .filter(
                  ({ address: e }) =>
                    !r.has(e.toLowerCase()) && (r.add(e.toLowerCase()), !0)
                );
            return n && n.length > 0 ? n : [];
          },
        };
    },
    16459: (e) => {
      "use strict";
      var t,
        r = "object" == typeof Reflect ? Reflect : null,
        i =
          r && "function" == typeof r.apply
            ? r.apply
            : function (e, t, r) {
                return Function.prototype.apply.call(e, t, r);
              };
      t =
        r && "function" == typeof r.ownKeys
          ? r.ownKeys
          : Object.getOwnPropertySymbols
          ? function (e) {
              return Object.getOwnPropertyNames(e).concat(
                Object.getOwnPropertySymbols(e)
              );
            }
          : function (e) {
              return Object.getOwnPropertyNames(e);
            };
      var n =
        Number.isNaN ||
        function (e) {
          return e != e;
        };
      function s() {
        s.init.call(this);
      }
      (e.exports = s),
        (e.exports.once = function (e, t) {
          return new Promise(function (r, i) {
            var n, s, a;
            function o(r) {
              e.removeListener(t, c), i(r);
            }
            function c() {
              "function" == typeof e.removeListener &&
                e.removeListener("error", o),
                r([].slice.call(arguments));
            }
            g(e, t, c, { once: !0 }),
              "error" !== t &&
                ((n = e),
                (s = o),
                (a = { once: !0 }),
                "function" == typeof n.on && g(n, "error", s, a));
          });
        }),
        (s.EventEmitter = s),
        (s.prototype._events = void 0),
        (s.prototype._eventsCount = 0),
        (s.prototype._maxListeners = void 0);
      var a = 10;
      function o(e) {
        if ("function" != typeof e)
          throw TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof e
          );
      }
      function c(e) {
        return void 0 === e._maxListeners
          ? s.defaultMaxListeners
          : e._maxListeners;
      }
      function l(e, t, r, i) {
        if (
          (o(r),
          void 0 === (s = e._events)
            ? ((s = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== s.newListener &&
                (e.emit("newListener", t, r.listener ? r.listener : r),
                (s = e._events)),
              (a = s[t])),
          void 0 === a)
        )
          (a = s[t] = r), ++e._eventsCount;
        else if (
          ("function" == typeof a
            ? (a = s[t] = i ? [r, a] : [a, r])
            : i
            ? a.unshift(r)
            : a.push(r),
          (n = c(e)) > 0 && a.length > n && !a.warned)
        ) {
          a.warned = !0;
          var n,
            s,
            a,
            l = Error(
              "Possible EventEmitter memory leak detected. " +
                a.length +
                " " +
                String(t) +
                " listeners added. Use emitter.setMaxListeners() to increase limit"
            );
          (l.name = "MaxListenersExceededWarning"),
            (l.emitter = e),
            (l.type = t),
            (l.count = a.length),
            console && console.warn && console.warn(l);
        }
        return e;
      }
      function d() {
        if (!this.fired)
          return (this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 == arguments.length)
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments);
      }
      function h(e, t, r) {
        var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r },
          n = d.bind(i);
        return (n.listener = r), (i.wrapFn = n), n;
      }
      function u(e, t, r) {
        var i = e._events;
        if (void 0 === i) return [];
        var n = i[t];
        return void 0 === n
          ? []
          : "function" == typeof n
          ? r
            ? [n.listener || n]
            : [n]
          : r
          ? (function (e) {
              for (var t = Array(e.length), r = 0; r < t.length; ++r)
                t[r] = e[r].listener || e[r];
              return t;
            })(n)
          : f(n, n.length);
      }
      function p(e) {
        var t = this._events;
        if (void 0 !== t) {
          var r = t[e];
          if ("function" == typeof r) return 1;
          if (void 0 !== r) return r.length;
        }
        return 0;
      }
      function f(e, t) {
        for (var r = Array(t), i = 0; i < t; ++i) r[i] = e[i];
        return r;
      }
      function g(e, t, r, i) {
        if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
        else if ("function" == typeof e.addEventListener)
          e.addEventListener(t, function n(s) {
            i.once && e.removeEventListener(t, n), r(s);
          });
        else
          throw TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof e
          );
      }
      Object.defineProperty(s, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || n(e))
            throw RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          a = e;
        },
      }),
        (s.init = function () {
          (void 0 === this._events ||
            this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (s.prototype.setMaxListeners = function (e) {
          if ("number" != typeof e || e < 0 || n(e))
            throw RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          return (this._maxListeners = e), this;
        }),
        (s.prototype.getMaxListeners = function () {
          return c(this);
        }),
        (s.prototype.emit = function (e) {
          for (var t = [], r = 1; r < arguments.length; r++)
            t.push(arguments[r]);
          var n = "error" === e,
            s = this._events;
          if (void 0 !== s) n = n && void 0 === s.error;
          else if (!n) return !1;
          if (n) {
            if ((t.length > 0 && (a = t[0]), a instanceof Error)) throw a;
            var a,
              o = Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw ((o.context = a), o);
          }
          var c = s[e];
          if (void 0 === c) return !1;
          if ("function" == typeof c) i(c, this, t);
          else
            for (var l = c.length, d = f(c, l), r = 0; r < l; ++r)
              i(d[r], this, t);
          return !0;
        }),
        (s.prototype.addListener = function (e, t) {
          return l(this, e, t, !1);
        }),
        (s.prototype.on = s.prototype.addListener),
        (s.prototype.prependListener = function (e, t) {
          return l(this, e, t, !0);
        }),
        (s.prototype.once = function (e, t) {
          return o(t), this.on(e, h(this, e, t)), this;
        }),
        (s.prototype.prependOnceListener = function (e, t) {
          return o(t), this.prependListener(e, h(this, e, t)), this;
        }),
        (s.prototype.removeListener = function (e, t) {
          var r, i, n, s, a;
          if ((o(t), void 0 === (i = this._events) || void 0 === (r = i[e])))
            return this;
          if (r === t || r.listener === t)
            0 == --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete i[e],
                i.removeListener &&
                  this.emit("removeListener", e, r.listener || t));
          else if ("function" != typeof r) {
            for (n = -1, s = r.length - 1; s >= 0; s--)
              if (r[s] === t || r[s].listener === t) {
                (a = r[s].listener), (n = s);
                break;
              }
            if (n < 0) return this;
            0 === n
              ? r.shift()
              : (function (e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(r, n),
              1 === r.length && (i[e] = r[0]),
              void 0 !== i.removeListener &&
                this.emit("removeListener", e, a || t);
          }
          return this;
        }),
        (s.prototype.off = s.prototype.removeListener),
        (s.prototype.removeAllListeners = function (e) {
          var t, r, i;
          if (void 0 === (r = this._events)) return this;
          if (void 0 === r.removeListener)
            return (
              0 == arguments.length
                ? ((this._events = Object.create(null)),
                  (this._eventsCount = 0))
                : void 0 !== r[e] &&
                  (0 == --this._eventsCount
                    ? (this._events = Object.create(null))
                    : delete r[e]),
              this
            );
          if (0 == arguments.length) {
            var n,
              s = Object.keys(r);
            for (i = 0; i < s.length; ++i)
              "removeListener" !== (n = s[i]) && this.removeAllListeners(n);
            return (
              this.removeAllListeners("removeListener"),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            );
          }
          if ("function" == typeof (t = r[e])) this.removeListener(e, t);
          else if (void 0 !== t)
            for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
          return this;
        }),
        (s.prototype.listeners = function (e) {
          return u(this, e, !0);
        }),
        (s.prototype.rawListeners = function (e) {
          return u(this, e, !1);
        }),
        (s.listenerCount = function (e, t) {
          return "function" == typeof e.listenerCount
            ? e.listenerCount(t)
            : p.call(e, t);
        }),
        (s.prototype.listenerCount = p),
        (s.prototype.eventNames = function () {
          return this._eventsCount > 0 ? t(this._events) : [];
        });
    },
    16871: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => n });
      var i = r(60587);
      function n(e) {
        return (0, i.q)(e, { strict: !1 })
          ? Math.ceil((e.length - 2) / 2)
          : e.length;
      }
    },
    17389: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => a });
      let i = {
        transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
        signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
      };
      var n = r(73537),
        s = r(22669);
      let a = {
        checkIfAllowedToTriggerEmail() {
          let e = s.o.get(n.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) {
              let e = Math.ceil((3e4 - t) / 1e3);
              throw Error(`Please try again after ${e} seconds`);
            }
          }
        },
        getTimeToNextEmailLogin() {
          let e = s.o.get(n.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) return Math.ceil((3e4 - t) / 1e3);
          }
          return 0;
        },
        checkIfRequestExists: (e) =>
          n.Vl.NOT_SAFE_RPC_METHODS.includes(e.method) ||
          n.Vl.SAFE_RPC_METHODS.includes(e.method),
        getResponseType: (e) =>
          "string" == typeof e &&
          (e?.match(i.transactionHash) || e?.match(i.signedMessage))
            ? n.s1.RPC_RESPONSE_TYPE_TX
            : n.s1.RPC_RESPONSE_TYPE_OBJECT,
        checkIfRequestIsSafe: (e) => n.Vl.SAFE_RPC_METHODS.includes(e.method),
        isClient: "undefined" != typeof window,
      };
    },
    17679: (e, t, r) => {
      "use strict";
      r.d(t, { t: () => s });
      var i = r(55563),
        n = r(34561);
      function s(e) {
        let { kzg: t } = e,
          r = e.to ?? ("string" == typeof e.blobs[0] ? "hex" : "bytes"),
          s =
            "string" == typeof e.blobs[0]
              ? e.blobs.map((e) => (0, i.aT)(e))
              : e.blobs,
          a =
            "string" == typeof e.commitments[0]
              ? e.commitments.map((e) => (0, i.aT)(e))
              : e.commitments,
          o = [];
        for (let e = 0; e < s.length; e++) {
          let r = s[e],
            i = a[e];
          o.push(Uint8Array.from(t.computeBlobKzgProof(r, i)));
        }
        return "bytes" === r ? o : o.map((e) => (0, n.My)(e));
      }
    },
    18085: function (e) {
      e.exports = function (e, t, r) {
        r.updateLocale = function (e, t) {
          var i = r.Ls[e];
          if (i)
            return (
              (t ? Object.keys(t) : []).forEach(function (e) {
                i[e] = t[e];
              }),
              i
            );
        };
      };
    },
    18294: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691), r(45166);
      var s = r(71084),
        a = r(47327);
      r(84042);
      var o = r(20296);
      let c = (0, o.AH)`
  :host {
    position: relative;
    background-color: ${({ tokens: e }) => e.theme.foregroundTertiary};
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host([data-image='true']) {
    background-color: transparent;
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host([data-size='sm']) {
    width: 32px;
    height: 32px;
  }

  :host([data-size='md']) {
    width: 40px;
    height: 40px;
  }

  :host([data-size='lg']) {
    width: 56px;
    height: 56px;
  }

  :host([name='Extension'])::after {
    border: 1px solid ${({ colors: e }) => e.accent010};
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid ${({ colors: e }) => e.accent010};
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 32px;
    height: 32px;
  }

  wui-icon[data-parent-size='md'] {
    width: 40px;
    height: 40px;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid ${({ tokens: e }) => e.theme.backgroundPrimary};
    padding: 1px;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.size = "md"),
            (this.name = ""),
            (this.installed = !1),
            (this.badgeSize = "xs");
        }
        render() {
          let e = "1";
          return (
            "lg" === this.size
              ? (e = "4")
              : "md" === this.size
              ? (e = "2")
              : "sm" === this.size && (e = "1"),
            (this.style.cssText = `
       --local-border-radius: var(--apkt-borderRadius-${e});
   `),
            (this.dataset.size = this.size),
            this.imageSrc && (this.dataset.image = "true"),
            this.walletIcon && (this.dataset.walletIcon = this.walletIcon),
            (0, i.qy)`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `
          );
        }
        templateVisual() {
          return this.imageSrc
            ? (0,
              i.qy)`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`
            : this.walletIcon
            ? (0,
              i.qy)`<wui-icon size="md" color="default" name=${this.walletIcon}></wui-icon>`
            : (0, i.qy)`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="wallet"
    ></wui-icon>`;
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)()], d.prototype, "size", void 0),
        l([(0, n.MZ)()], d.prototype, "name", void 0),
        l([(0, n.MZ)()], d.prototype, "imageSrc", void 0),
        l([(0, n.MZ)()], d.prototype, "walletIcon", void 0),
        l([(0, n.MZ)({ type: Boolean })], d.prototype, "installed", void 0),
        l([(0, n.MZ)()], d.prototype, "badgeSize", void 0),
        (d = l([(0, a.E)("wui-wallet-image")], d));
    },
    18635: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => h });
      var i = r(55480),
        n = r(10899),
        s = r(58653),
        a = r(12319),
        o = r(72880),
        c = r(79355),
        l = r(48981),
        d = r(91867);
      let h = {
        filterOutDuplicatesByRDNS(e) {
          let t = i.H.state.enableEIP6963 ? n.a.state.connectors : [],
            r = s.i.getRecentWallets(),
            o = t.map((e) => e.info?.rdns).filter(Boolean),
            c = r.map((e) => e.rdns).filter(Boolean),
            l = o.concat(c);
          if (l.includes("io.metamask.mobile") && a.w.isMobile()) {
            let e = l.indexOf("io.metamask.mobile");
            l[e] = "io.metamask";
          }
          return e.filter(
            (e) =>
              !(
                (e?.rdns && l.includes(String(e.rdns))) ||
                (!e?.rdns && t.some((t) => t.name === e.name))
              ) && !0
          );
        },
        filterOutDuplicatesByIds(e) {
          let t = n.a.state.connectors.filter(
              (e) => "ANNOUNCED" === e.type || "INJECTED" === e.type
            ),
            r = s.i.getRecentWallets(),
            i = t.map((e) => e.explorerId),
            a = r.map((e) => e.id),
            o = i.concat(a);
          return e.filter((e) => !o.includes(e?.id));
        },
        filterOutDuplicateWallets(e) {
          let t = this.filterOutDuplicatesByRDNS(e);
          return this.filterOutDuplicatesByIds(t);
        },
        markWalletsAsInstalled(e) {
          let { connectors: t } = n.a.state,
            { featuredWalletIds: r } = i.H.state,
            s = t
              .filter((e) => "ANNOUNCED" === e.type)
              .reduce((e, t) => (t.info?.rdns && (e[t.info.rdns] = !0), e), {});
          return e
            .map((e) => ({ ...e, installed: !!e.rdns && !!s[e.rdns ?? ""] }))
            .sort((e, t) => {
              let i = Number(t.installed) - Number(e.installed);
              if (0 !== i) return i;
              if (r?.length) {
                let i = r.indexOf(e.id),
                  n = r.indexOf(t.id);
                if (-1 !== i && -1 !== n) return i - n;
                if (-1 !== i) return -1;
                if (-1 !== n) return 1;
              }
              return 0;
            });
        },
        getConnectOrderMethod(e, t) {
          let r =
              e?.connectMethodsOrder || i.H.state.features?.connectMethodsOrder,
            s = t || n.a.state.connectors;
          if (r) return r;
          let { injected: a, announced: c } = l.g.getConnectorsByType(
              s,
              o.N.state.recommended,
              o.N.state.featured
            ),
            h = a.filter(l.g.showConnector),
            u = c.filter(l.g.showConnector);
          return h.length || u.length
            ? ["wallet", "email", "social"]
            : d.o.DEFAULT_CONNECT_METHOD_ORDER;
        },
        isExcluded(e) {
          let t =
              !!e.rdns &&
              o.N.state.excludedWallets.some((t) => t.rdns === e.rdns),
            r =
              !!e.name &&
              o.N.state.excludedWallets.some((t) =>
                c.y.isLowerCaseMatch(t.name, e.name)
              );
          return t || r;
        },
        markWalletsWithDisplayIndex: (e) =>
          e.map((e, t) => ({ ...e, display_index: t })),
      };
    },
    19511: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.IWatch = void 0);
      class r {}
      t.IWatch = r;
    },
    19542: (e, t) => {
      t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7,
      };
      let r = { N1: 3, N2: 3, N3: 40, N4: 10 };
      (t.isValid = function (e) {
        return null != e && "" !== e && !isNaN(e) && e >= 0 && e <= 7;
      }),
        (t.from = function (e) {
          return t.isValid(e) ? parseInt(e, 10) : void 0;
        }),
        (t.getPenaltyN1 = function (e) {
          let t = e.size,
            i = 0,
            n = 0,
            s = 0,
            a = null,
            o = null;
          for (let c = 0; c < t; c++) {
            (n = s = 0), (a = o = null);
            for (let l = 0; l < t; l++) {
              let t = e.get(c, l);
              t === a
                ? n++
                : (n >= 5 && (i += r.N1 + (n - 5)), (a = t), (n = 1)),
                (t = e.get(l, c)) === o
                  ? s++
                  : (s >= 5 && (i += r.N1 + (s - 5)), (o = t), (s = 1));
            }
            n >= 5 && (i += r.N1 + (n - 5)), s >= 5 && (i += r.N1 + (s - 5));
          }
          return i;
        }),
        (t.getPenaltyN2 = function (e) {
          let t = e.size,
            i = 0;
          for (let r = 0; r < t - 1; r++)
            for (let n = 0; n < t - 1; n++) {
              let t =
                e.get(r, n) +
                e.get(r, n + 1) +
                e.get(r + 1, n) +
                e.get(r + 1, n + 1);
              (4 === t || 0 === t) && i++;
            }
          return i * r.N2;
        }),
        (t.getPenaltyN3 = function (e) {
          let t = e.size,
            i = 0,
            n = 0,
            s = 0;
          for (let r = 0; r < t; r++) {
            n = s = 0;
            for (let a = 0; a < t; a++)
              (n = ((n << 1) & 2047) | e.get(r, a)),
                a >= 10 && (1488 === n || 93 === n) && i++,
                (s = ((s << 1) & 2047) | e.get(a, r)),
                a >= 10 && (1488 === s || 93 === s) && i++;
          }
          return i * r.N3;
        }),
        (t.getPenaltyN4 = function (e) {
          let t = 0,
            i = e.data.length;
          for (let r = 0; r < i; r++) t += e.data[r];
          return Math.abs(Math.ceil((100 * t) / i / 5) - 10) * r.N4;
        }),
        (t.applyMask = function (e, r) {
          let i = r.size;
          for (let n = 0; n < i; n++)
            for (let s = 0; s < i; s++)
              r.isReserved(s, n) ||
                r.xor(
                  s,
                  n,
                  (function (e, r, i) {
                    switch (e) {
                      case t.Patterns.PATTERN000:
                        return (r + i) % 2 == 0;
                      case t.Patterns.PATTERN001:
                        return r % 2 == 0;
                      case t.Patterns.PATTERN010:
                        return i % 3 == 0;
                      case t.Patterns.PATTERN011:
                        return (r + i) % 3 == 0;
                      case t.Patterns.PATTERN100:
                        return (Math.floor(r / 2) + Math.floor(i / 3)) % 2 == 0;
                      case t.Patterns.PATTERN101:
                        return ((r * i) % 2) + ((r * i) % 3) == 0;
                      case t.Patterns.PATTERN110:
                        return (((r * i) % 2) + ((r * i) % 3)) % 2 == 0;
                      case t.Patterns.PATTERN111:
                        return (((r * i) % 3) + ((r + i) % 2)) % 2 == 0;
                      default:
                        throw Error("bad maskPattern:" + e);
                    }
                  })(e, s, n)
                );
        }),
        (t.getBestMask = function (e, r) {
          let i = Object.keys(t.Patterns).length,
            n = 0,
            s = 1 / 0;
          for (let a = 0; a < i; a++) {
            r(a), t.applyMask(a, e);
            let i =
              t.getPenaltyN1(e) +
              t.getPenaltyN2(e) +
              t.getPenaltyN3(e) +
              t.getPenaltyN4(e);
            t.applyMask(a, e), i < s && ((s = i), (n = a));
          }
          return n;
        });
    },
    19781: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => i });
      let i = 1;
    },
    19816: (e, t, r) => {
      "use strict";
      r.d(t, { E1: () => i.E, kl: () => n.k });
      var i = r(72557),
        n = r(15913);
    },
    19831: (e, t, r) => {
      "use strict";
      r.d(t, { O: () => s, W: () => a });
      var i = r(45553),
        n = r(93481);
      let s = {
          PHANTOM: {
            id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
            url: "https://phantom.app",
          },
          SOLFLARE: {
            id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
            url: "https://solflare.com",
          },
          COINBASE: {
            id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
            url: "https://go.cb-w.com",
          },
          BINANCE: {
            id: "2fafea35bb471d22889ccb49c08d99dd0a18a37982602c33f696a5723934ba25",
            appId: "yFK5FCqYprrXDiVFbhyRx7",
            deeplink: "bnc://app.binance.com/mp/app",
            url: "https://app.binance.com/en/download",
          },
        },
        a = {
          handleMobileDeeplinkRedirect(e, t) {
            let r = window.location.href,
              a = encodeURIComponent(r);
            if (e === s.PHANTOM.id && !("phantom" in window)) {
              let e = r.startsWith("https") ? "https" : "http",
                t = r.split("/")[2],
                i = encodeURIComponent(`${e}://${t}`);
              window.location.href = `${s.PHANTOM.url}/ul/browse/${a}?ref=${i}`;
            }
            if (
              (e !== s.SOLFLARE.id ||
                "solflare" in window ||
                (window.location.href = `${s.SOLFLARE.url}/ul/v1/browse/${a}?ref=${a}`),
              t !== i.o.CHAIN.SOLANA ||
                e !== s.COINBASE.id ||
                "coinbaseSolana" in window ||
                (window.location.href = `${s.COINBASE.url}/dapp?cb_url=${a}`),
              t === i.o.CHAIN.BITCOIN &&
                e === s.BINANCE.id &&
                !("binancew3w" in window))
            ) {
              let e = n.W.state.activeCaipNetwork,
                t = window.btoa("/pages/browser/index"),
                r = window.btoa(`url=${a}&defaultChainId=${e?.id ?? 1}`),
                i = new URL(s.BINANCE.deeplink);
              i.searchParams.set("appId", s.BINANCE.appId),
                i.searchParams.set("startPagePath", t),
                i.searchParams.set("startPageQuery", r);
              let o = new URL(s.BINANCE.url);
              o.searchParams.set("_dp", window.btoa(i.toString())),
                (window.location.href = o.toString());
            }
          },
        };
    },
    20296: (e, t, r) => {
      "use strict";
      r.d(t, { AH: () => c, CV: () => a, f: () => o });
      var i = r(83138),
        n = r(81345);
      let s = "--apkt",
        a = {
          createCSSVariables(e) {
            let t = {},
              r = {};
            return (
              !(function e(t, r, i = "") {
                for (let [n, a] of Object.entries(t)) {
                  let t = i ? `${i}-${n}` : n;
                  a && "object" == typeof a && Object.keys(a).length
                    ? ((r[n] = {}), e(a, r[n], t))
                    : "string" == typeof a && (r[n] = `${s}-${t}`);
                }
              })(e, t),
              !(function e(t, r) {
                for (let [i, n] of Object.entries(t))
                  n && "object" == typeof n
                    ? ((r[i] = {}), e(n, r[i]))
                    : "string" == typeof n && (r[i] = `var(${n})`);
              })(t, r),
              { cssVariables: t, cssVariablesVarPrefix: r }
            );
          },
          assignCSSVariables(e, t) {
            let r = {};
            return (
              !(function e(t, i, n) {
                for (let [a, o] of Object.entries(t)) {
                  let t = n ? `${n}-${a}` : a,
                    c = i[a];
                  o && "object" == typeof o
                    ? e(o, c, t)
                    : "string" == typeof c && (r[`${s}-${t}`] = c);
                }
              })(e, t),
              r
            );
          },
          createRootStyles(e, t) {
            let r = {
                ...n.R7,
                tokens: {
                  ...n.R7.tokens,
                  theme: "light" === e ? n.LU.light : n.LU.dark,
                },
              },
              { cssVariables: i } = a.createCSSVariables(r),
              s = a.assignCSSVariables(i, r),
              o = a.generateW3MVariables(t),
              c = a.generateW3MOverrides(t),
              l = a.generateScaledVariables(t),
              d = a.generateBaseVariables(s),
              h = { ...s, ...d, ...o, ...c, ...l },
              u = a.applyColorMixToVariables(t, h),
              p = Object.entries({ ...h, ...u })
                .map(([e, t]) => `${e}:${t.replace("/[:;{}</>]/g", "")};`)
                .join("");
            return `:root {${p}}`;
          },
          generateW3MVariables(e) {
            if (!e) return {};
            let t = {};
            return (
              (t["--w3m-font-family"] = e["--w3m-font-family"] || "KHTeka"),
              (t["--w3m-accent"] = e["--w3m-accent"] || "#0988F0"),
              (t["--w3m-color-mix"] = e["--w3m-color-mix"] || "#000"),
              (t["--w3m-color-mix-strength"] = `${
                e["--w3m-color-mix-strength"] || 0
              }%`),
              (t["--w3m-font-size-master"] =
                e["--w3m-font-size-master"] || "10px"),
              (t["--w3m-border-radius-master"] =
                e["--w3m-border-radius-master"] || "4px"),
              t
            );
          },
          generateW3MOverrides(e) {
            if (!e) return {};
            let t = {};
            if (e["--w3m-accent"]) {
              let r = e["--w3m-accent"];
              (t["--apkt-tokens-core-iconAccentPrimary"] = r),
                (t["--apkt-tokens-core-borderAccentPrimary"] = r),
                (t["--apkt-tokens-core-textAccentPrimary"] = r),
                (t["--apkt-tokens-core-backgroundAccentPrimary"] = r);
            }
            return (
              e["--w3m-font-family"] &&
                (t["--apkt-fontFamily-regular"] = e["--w3m-font-family"]),
              e["--w3m-z-index"] &&
                (t["--apkt-tokens-core-zIndex"] = `${e["--w3m-z-index"]}`),
              t
            );
          },
          generateScaledVariables(e) {
            if (!e) return {};
            let t = {};
            if (e["--w3m-font-size-master"]) {
              let r = parseFloat(e["--w3m-font-size-master"].replace("px", ""));
              (t["--apkt-textSize-h1"] = `${5 * Number(r)}px`),
                (t["--apkt-textSize-h2"] = `${4.4 * Number(r)}px`),
                (t["--apkt-textSize-h3"] = `${3.8 * Number(r)}px`),
                (t["--apkt-textSize-h4"] = `${3.2 * Number(r)}px`),
                (t["--apkt-textSize-h5"] = `${2.6 * Number(r)}px`),
                (t["--apkt-textSize-h6"] = `${2 * Number(r)}px`),
                (t["--apkt-textSize-large"] = `${1.6 * Number(r)}px`),
                (t["--apkt-textSize-medium"] = `${1.4 * Number(r)}px`),
                (t["--apkt-textSize-small"] = `${1.2 * Number(r)}px`);
            }
            if (e["--w3m-border-radius-master"]) {
              let r = parseFloat(
                e["--w3m-border-radius-master"].replace("px", "")
              );
              (t["--apkt-borderRadius-1"] = `${Number(r)}px`),
                (t["--apkt-borderRadius-2"] = `${2 * Number(r)}px`),
                (t["--apkt-borderRadius-3"] = `${3 * Number(r)}px`),
                (t["--apkt-borderRadius-4"] = `${4 * Number(r)}px`),
                (t["--apkt-borderRadius-5"] = `${5 * Number(r)}px`),
                (t["--apkt-borderRadius-6"] = `${6 * Number(r)}px`),
                (t["--apkt-borderRadius-8"] = `${8 * Number(r)}px`),
                (t["--apkt-borderRadius-16"] = `${16 * Number(r)}px`),
                (t["--apkt-borderRadius-20"] = `${20 * Number(r)}px`),
                (t["--apkt-borderRadius-32"] = `${32 * Number(r)}px`),
                (t["--apkt-borderRadius-64"] = `${64 * Number(r)}px`),
                (t["--apkt-borderRadius-128"] = `${128 * Number(r)}px`);
            }
            return t;
          },
          generateColorMixCSS(e, t) {
            if (!e?.["--w3m-color-mix"] || !e["--w3m-color-mix-strength"])
              return "";
            let r = e["--w3m-color-mix"],
              i = e["--w3m-color-mix-strength"];
            if (!i || 0 === i) return "";
            let n = Object.keys(t || {}).filter((e) => {
              let t =
                  e.includes("-tokens-core-background") ||
                  e.includes("-tokens-core-text") ||
                  e.includes("-tokens-core-border") ||
                  e.includes("-tokens-core-foreground") ||
                  e.includes("-tokens-core-icon") ||
                  e.includes("-tokens-theme-background") ||
                  e.includes("-tokens-theme-text") ||
                  e.includes("-tokens-theme-border") ||
                  e.includes("-tokens-theme-foreground") ||
                  e.includes("-tokens-theme-icon"),
                r =
                  e.includes("-borderRadius-") ||
                  e.includes("-spacing-") ||
                  e.includes("-textSize-") ||
                  e.includes("-fontFamily-") ||
                  e.includes("-fontWeight-") ||
                  e.includes("-typography-") ||
                  e.includes("-duration-") ||
                  e.includes("-ease-") ||
                  e.includes("-path-") ||
                  e.includes("-width-") ||
                  e.includes("-height-") ||
                  e.includes("-visual-size-") ||
                  e.includes("-modal-width") ||
                  e.includes("-cover");
              return t && !r;
            });
            if (0 === n.length) return "";
            let s = n
              .map((e) => {
                let n = t?.[e] || "";
                return n.includes("color-mix") ||
                  n.startsWith("#") ||
                  n.startsWith("rgb")
                  ? `${e}: color-mix(in srgb, ${r} ${i}%, ${n});`
                  : `${e}: color-mix(in srgb, ${r} ${i}%, var(${e}-base, ${n}));`;
              })
              .join("");
            return ` @supports (background: color-mix(in srgb, white 50%, black)) {
      :root {
        ${s}
      }
    }`;
          },
          generateBaseVariables(e) {
            let t = {},
              r = e["--apkt-tokens-theme-backgroundPrimary"];
            r && (t["--apkt-tokens-theme-backgroundPrimary-base"] = r);
            let i = e["--apkt-tokens-core-backgroundAccentPrimary"];
            return (
              i && (t["--apkt-tokens-core-backgroundAccentPrimary-base"] = i), t
            );
          },
          applyColorMixToVariables(e, t) {
            let r = {};
            if (
              (t?.["--apkt-tokens-theme-backgroundPrimary"] &&
                (r["--apkt-tokens-theme-backgroundPrimary"] =
                  "var(--apkt-tokens-theme-backgroundPrimary-base)"),
              t?.["--apkt-tokens-core-backgroundAccentPrimary"] &&
                (r["--apkt-tokens-core-backgroundAccentPrimary"] =
                  "var(--apkt-tokens-core-backgroundAccentPrimary-base)"),
              !e?.["--w3m-color-mix"] || !e["--w3m-color-mix-strength"])
            )
              return r;
            let i = e["--w3m-color-mix"],
              n = e["--w3m-color-mix-strength"];
            if (!n || 0 === n) return r;
            let s = Object.keys(t || {}).filter((e) => {
              let t =
                  e.includes("-tokens-core-background") ||
                  e.includes("-tokens-core-text") ||
                  e.includes("-tokens-core-border") ||
                  e.includes("-tokens-core-foreground") ||
                  e.includes("-tokens-core-icon") ||
                  e.includes("-tokens-theme-background") ||
                  e.includes("-tokens-theme-text") ||
                  e.includes("-tokens-theme-border") ||
                  e.includes("-tokens-theme-foreground") ||
                  e.includes("-tokens-theme-icon") ||
                  e.includes("-tokens-theme-overlay"),
                r =
                  e.includes("-borderRadius-") ||
                  e.includes("-spacing-") ||
                  e.includes("-textSize-") ||
                  e.includes("-fontFamily-") ||
                  e.includes("-fontWeight-") ||
                  e.includes("-typography-") ||
                  e.includes("-duration-") ||
                  e.includes("-ease-") ||
                  e.includes("-path-") ||
                  e.includes("-width-") ||
                  e.includes("-height-") ||
                  e.includes("-visual-size-") ||
                  e.includes("-modal-width") ||
                  e.includes("-cover");
              return t && !r;
            });
            return (
              0 === s.length ||
                s.forEach((e) => {
                  let s = t?.[e] || "";
                  e.endsWith("-base") ||
                    ("--apkt-tokens-theme-backgroundPrimary" === e ||
                    "--apkt-tokens-core-backgroundAccentPrimary" === e
                      ? (r[
                          e
                        ] = `color-mix(in srgb, ${i} ${n}%, var(${e}-base))`)
                      : s.includes("color-mix") ||
                        s.startsWith("#") ||
                        s.startsWith("rgb")
                      ? (r[e] = `color-mix(in srgb, ${i} ${n}%, ${s})`)
                      : (r[
                          e
                        ] = `color-mix(in srgb, ${i} ${n}%, var(${e}-base, ${s}))`));
                }),
              r
            );
          },
        },
        { cssVariablesVarPrefix: o } = a.createCSSVariables(n.R7);
      function c(e, ...t) {
        return (0, i.AH)(
          e,
          ...t.map((e) =>
            "function" == typeof e ? (0, i.iz)(e(o)) : (0, i.iz)(e)
          )
        );
      }
    },
    20390: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      class i extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
    },
    20413: (e, t, r) => {
      "use strict";
      r.d(t, {
        B4: () => p,
        CQ: () => v,
        CW: () => b,
        Ei: () => h,
        F8: () => C,
        P5: () => u,
        TH: () => E,
        Vl: () => y,
        Vr: () => w,
        WM: () => f,
        WQ: () => m,
        im: () => g,
        jm: () => o,
        lD: () => s,
        qh: () => d,
        rE: () => c,
        ry: () => l,
        xn: () => a,
      });
      let i = BigInt(0x100000000 - 1),
        n = BigInt(32);
      function s(e, t = !1) {
        let r = e.length,
          a = new Uint32Array(r),
          o = new Uint32Array(r);
        for (let s = 0; s < r; s++) {
          let { h: r, l: c } = (function (e, t = !1) {
            return t
              ? { h: Number(e & i), l: Number((e >> n) & i) }
              : { h: 0 | Number((e >> n) & i), l: 0 | Number(e & i) };
          })(e[s], t);
          [a[s], o[s]] = [r, c];
        }
        return [a, o];
      }
      let a = (e, t, r) => e >>> r,
        o = (e, t, r) => (e << (32 - r)) | (t >>> r),
        c = (e, t, r) => (e >>> r) | (t << (32 - r)),
        l = (e, t, r) => (e << (32 - r)) | (t >>> r),
        d = (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
        h = (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
        u = (e, t, r) => (e << r) | (t >>> (32 - r)),
        p = (e, t, r) => (t << r) | (e >>> (32 - r)),
        f = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        g = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
      function m(e, t, r, i) {
        let n = (t >>> 0) + (i >>> 0);
        return { h: (e + r + ((n / 0x100000000) | 0)) | 0, l: 0 | n };
      }
      let y = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
        w = (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
        b = (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
        v = (e, t, r, i, n) => (t + r + i + n + ((e / 0x100000000) | 0)) | 0,
        C = (e, t, r, i, n) =>
          (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
        E = (e, t, r, i, n, s) =>
          (t + r + i + n + s + ((e / 0x100000000) | 0)) | 0;
    },
    20943: (e, t, r) => {
      "use strict";
      var i,
        n = r(83138),
        s = r(98410),
        a = r(12232),
        o = r(93481),
        c = r(24369),
        l = r(12319),
        d = r(67869),
        h = r(55480),
        u = r(70417),
        p = r(71305),
        f = r(36211);
      r(40575), r(90721), r(48352), r(41163);
      var g = r(78964);
      r(24772);
      var m = r(71084);
      !(function (e) {
        (e.approve = "approved"),
          (e.bought = "bought"),
          (e.borrow = "borrowed"),
          (e.burn = "burnt"),
          (e.cancel = "canceled"),
          (e.claim = "claimed"),
          (e.deploy = "deployed"),
          (e.deposit = "deposited"),
          (e.execute = "executed"),
          (e.mint = "minted"),
          (e.receive = "received"),
          (e.repay = "repaid"),
          (e.send = "sent"),
          (e.sell = "sold"),
          (e.stake = "staked"),
          (e.trade = "swapped"),
          (e.unstake = "unstaked"),
          (e.withdraw = "withdrawn");
      })(i || (i = {}));
      var y = r(47327);
      r(45166), r(84042);
      var w = r(20296);
      let b = (0, w.AH)`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px ${({ tokens: e }) => e.core.glass010};
    background-color: ${({ tokens: e }) => e.core.glass010};
  }

  :host([data-no-images='true']) > wui-flex {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[3]} !important;
  }

  :host > wui-flex wui-image {
    display: block;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }

  wui-flex.status-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
    border-radius: ${({ borderRadius: e }) => e[4]};
    background-color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    box-shadow: 0 0 0 2px ${({ tokens: e }) => e.theme.backgroundPrimary};
    overflow: hidden;
    width: 16px;
    height: 16px;
  }
`;
      var v = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let C = class extends n.WF {
        constructor() {
          super(...arguments),
            (this.images = []),
            (this.secondImage = { type: void 0, url: "" });
        }
        render() {
          let [e, t] = this.images;
          this.images.length || (this.dataset.noImages = "true");
          let r = e?.type === "NFT",
            i = t?.url ? "NFT" === t.type : r;
          return (
            (this.style.cssText = `
    --local-left-border-radius: ${
      r ? "var(--apkt-borderRadius-3)" : "var(--apkt-borderRadius-5)"
    };
    --local-right-border-radius: ${
      i ? "var(--apkt-borderRadius-3)" : "var(--apkt-borderRadius-5)"
    };
    `),
            (0,
            n.qy)`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`
          );
        }
        templateVisual() {
          let [e, t] = this.images,
            r = e?.type;
          return 2 === this.images.length && (e?.url || t?.url)
            ? (0, n.qy)`<div class="swap-images-container">
        ${
          e?.url
            ? (0,
              n.qy)`<wui-image src=${e.url} alt="Transaction image"></wui-image>`
            : null
        }
        ${
          t?.url
            ? (0,
              n.qy)`<wui-image src=${t.url} alt="Transaction image"></wui-image>`
            : null
        }
      </div>`
            : e?.url
            ? (0,
              n.qy)`<wui-image src=${e.url} alt="Transaction image"></wui-image>`
            : "NFT" === r
            ? (0,
              n.qy)`<wui-icon size="inherit" color="default" name="nftPlaceholder"></wui-icon>`
            : (0,
              n.qy)`<wui-icon size="inherit" color="default" name="coinPlaceholder"></wui-icon>`;
        }
        templateIcon() {
          let e,
            t = "accent-primary";
          return ((e = this.getIcon()),
          this.status && (t = this.getStatusColor()),
          e)
            ? (0, n.qy)`
      <wui-flex alignItems="center" justifyContent="center" class="status-box">
        <wui-icon-box size="sm" color=${t} icon=${e}></wui-icon-box>
      </wui-flex>
    `
            : null;
        }
        getDirectionIcon() {
          switch (this.direction) {
            case "in":
              return "arrowBottom";
            case "out":
              return "arrowTop";
            default:
              return;
          }
        }
        getIcon() {
          return this.onlyDirectionIcon
            ? this.getDirectionIcon()
            : "trade" === this.type
            ? "swapHorizontal"
            : "approve" === this.type
            ? "checkmark"
            : "cancel" === this.type
            ? "close"
            : this.getDirectionIcon();
        }
        getStatusColor() {
          switch (this.status) {
            case "confirmed":
              return "success";
            case "failed":
              return "error";
            case "pending":
              return "inverse";
            default:
              return "accent-primary";
          }
        }
      };
      (C.styles = [b]),
        v([(0, s.MZ)()], C.prototype, "type", void 0),
        v([(0, s.MZ)()], C.prototype, "status", void 0),
        v([(0, s.MZ)()], C.prototype, "direction", void 0),
        v(
          [(0, s.MZ)({ type: Boolean })],
          C.prototype,
          "onlyDirectionIcon",
          void 0
        ),
        v([(0, s.MZ)({ type: Array })], C.prototype, "images", void 0),
        v([(0, s.MZ)({ type: Object })], C.prototype, "secondImage", void 0),
        (C = v([(0, y.E)("wui-transaction-visual")], C));
      let E = (0, w.AH)`
  :host {
    width: 100%;
  }

  :host > wui-flex:first-child {
    align-items: center;
    column-gap: ${({ spacing: e }) => e[2]};
    padding: ${({ spacing: e }) => e[1]} ${({ spacing: e }) => e[2]};
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
      var x = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let A = class extends n.WF {
        constructor() {
          super(...arguments),
            (this.type = "approve"),
            (this.onlyDirectionIcon = !1),
            (this.images = []);
        }
        render() {
          return (0, n.qy)`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${(0, g.J)(this.direction)}
          type=${this.type}
          .onlyDirectionIcon=${this.onlyDirectionIcon}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="1">
          <wui-text variant="lg-medium" color="primary">
            ${i[this.type] || this.type}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="sm-medium" color="secondary"><span>${
          this.date
        }</span></wui-text>
      </wui-flex>
    `;
        }
        templateDescription() {
          let e = this.descriptions?.[0];
          return e
            ? (0, n.qy)`
          <wui-text variant="md-regular" color="secondary">
            <span>${e}</span>
          </wui-text>
        `
            : null;
        }
        templateSecondDescription() {
          let e = this.descriptions?.[1];
          return e
            ? (0, n.qy)`
          <wui-icon class="description-separator-icon" size="sm" name="arrowRight"></wui-icon>
          <wui-text variant="md-regular" color="secondary">
            <span>${e}</span>
          </wui-text>
        `
            : null;
        }
      };
      (A.styles = [m.W5, E]),
        x([(0, s.MZ)()], A.prototype, "type", void 0),
        x([(0, s.MZ)({ type: Array })], A.prototype, "descriptions", void 0),
        x([(0, s.MZ)()], A.prototype, "date", void 0),
        x(
          [(0, s.MZ)({ type: Boolean })],
          A.prototype,
          "onlyDirectionIcon",
          void 0
        ),
        x([(0, s.MZ)()], A.prototype, "status", void 0),
        x([(0, s.MZ)()], A.prototype, "direction", void 0),
        x([(0, s.MZ)({ type: Array })], A.prototype, "images", void 0),
        (A = x([(0, y.E)("wui-transaction-list-item")], A)),
        r(40396),
        r(38534),
        r(99691);
      let _ = (0, w.AH)`
  wui-flex {
    position: relative;
    display: inline-flex;
    justify-content: center;
    align-items: center;
  }

  wui-image {
    border-radius: ${({ borderRadius: e }) => e[128]};
  }

  .fallback-icon {
    color: ${({ tokens: e }) => e.theme.iconInverse};
    border-radius: ${({ borderRadius: e }) => e[3]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  .direction-icon,
  .status-image {
    position: absolute;
    right: 0;
    bottom: 0;
    border-radius: ${({ borderRadius: e }) => e[128]};
    border: 2px solid ${({ tokens: e }) => e.theme.backgroundPrimary};
  }

  .direction-icon {
    padding: ${({ spacing: e }) => e["01"]};
    color: ${({ tokens: e }) => e.core.iconSuccess};

    background-color: color-mix(
      in srgb,
      ${({ tokens: e }) => e.core.textSuccess} 30%,
      ${({ tokens: e }) => e.theme.backgroundPrimary} 70%
    );
  }

  /* -- Sizes --------------------------------------------------- */
  :host([data-size='sm']) > wui-image:not(.status-image),
  :host([data-size='sm']) > wui-flex {
    width: 24px;
    height: 24px;
  }

  :host([data-size='lg']) > wui-image:not(.status-image),
  :host([data-size='lg']) > wui-flex {
    width: 40px;
    height: 40px;
  }

  :host([data-size='sm']) .fallback-icon {
    height: 16px;
    width: 16px;
    padding: ${({ spacing: e }) => e[1]};
  }

  :host([data-size='lg']) .fallback-icon {
    height: 32px;
    width: 32px;
    padding: ${({ spacing: e }) => e[1]};
  }

  :host([data-size='sm']) .direction-icon,
  :host([data-size='sm']) .status-image {
    transform: translate(40%, 30%);
  }

  :host([data-size='lg']) .direction-icon,
  :host([data-size='lg']) .status-image {
    transform: translate(40%, 10%);
  }

  :host([data-size='sm']) .status-image {
    height: 14px;
    width: 14px;
  }

  :host([data-size='lg']) .status-image {
    height: 20px;
    width: 20px;
  }

  /* -- Crop effects --------------------------------------------------- */
  .swap-crop-left-image,
  .swap-crop-right-image {
    position: absolute;
    top: 0;
    bottom: 0;
  }

  .swap-crop-left-image {
    left: 0;
    clip-path: inset(0px calc(50% + 1.5px) 0px 0%);
  }

  .swap-crop-right-image {
    right: 0;
    clip-path: inset(0px 0px 0px calc(50% + 1.5px));
  }
`;
      var I = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let S = { sm: "xxs", lg: "md" },
        k = class extends n.WF {
          constructor() {
            super(...arguments),
              (this.type = "approve"),
              (this.size = "lg"),
              (this.statusImageUrl = ""),
              (this.images = []);
          }
          render() {
            return (0,
            n.qy)`<wui-flex>${this.templateVisual()} ${this.templateIcon()}</wui-flex>`;
          }
          templateVisual() {
            switch (((this.dataset.size = this.size), this.type)) {
              case "trade":
                return this.swapTemplate();
              case "fiat":
                return this.fiatTemplate();
              case "unknown":
                return this.unknownTemplate();
              default:
                return this.tokenTemplate();
            }
          }
          swapTemplate() {
            let [e, t] = this.images;
            return 2 === this.images.length && (e || t)
              ? (0, n.qy)`
        <wui-image class="swap-crop-left-image" src=${e} alt="Swap image"></wui-image>
        <wui-image class="swap-crop-right-image" src=${t} alt="Swap image"></wui-image>
      `
              : e
              ? (0, n.qy)`<wui-image src=${e} alt="Swap image"></wui-image>`
              : null;
          }
          fiatTemplate() {
            return (0, n.qy)`<wui-icon
      class="fallback-icon"
      size=${S[this.size]}
      name="dollar"
    ></wui-icon>`;
          }
          unknownTemplate() {
            return (0, n.qy)`<wui-icon
      class="fallback-icon"
      size=${S[this.size]}
      name="questionMark"
    ></wui-icon>`;
          }
          tokenTemplate() {
            let [e] = this.images;
            return e
              ? (0, n.qy)`<wui-image src=${e} alt="Token image"></wui-image> `
              : (0, n.qy)`<wui-icon
      class="fallback-icon"
      name=${"nft" === this.type ? "image" : "coinPlaceholder"}
    ></wui-icon>`;
          }
          templateIcon() {
            return this.statusImageUrl
              ? (0, n.qy)`<wui-image
        class="status-image"
        src=${this.statusImageUrl}
        alt="Status image"
      ></wui-image>`
              : (0, n.qy)`<wui-icon
      class="direction-icon"
      size=${S[this.size]}
      name=${this.getTemplateIcon()}
    ></wui-icon>`;
          }
          getTemplateIcon() {
            return "trade" === this.type ? "arrowClockWise" : "arrowBottom";
          }
        };
      (k.styles = [_]),
        I([(0, s.MZ)()], k.prototype, "type", void 0),
        I([(0, s.MZ)()], k.prototype, "size", void 0),
        I([(0, s.MZ)()], k.prototype, "statusImageUrl", void 0),
        I([(0, s.MZ)({ type: Array })], k.prototype, "images", void 0),
        (k = I([(0, y.E)("wui-transaction-thumbnail")], k));
      let N = (0, w.AH)`
  :host > wui-flex:first-child {
    gap: ${({ spacing: e }) => e[2]};
    padding: ${({ spacing: e }) => e[3]};
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`,
        T = class extends n.WF {
          render() {
            return (0, n.qy)`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px" rounded></wui-shimmer>
        <wui-flex flexDirection="column" gap="1">
          <wui-shimmer width="124px" height="16px" rounded></wui-shimmer>
          <wui-shimmer width="60px" height="14px" rounded></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" rounded></wui-shimmer>
      </wui-flex>
    `;
          }
        };
      (T.styles = [m.W5, N]),
        (T = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, y.E)("wui-transaction-list-item-loader")], T));
      var O = r(73537);
      let P = (0, f.AH)`
  :host {
    min-height: 100%;
  }

  .group-container[last-group='true'] {
    padding-bottom: ${({ spacing: e }) => e["3"]};
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: ${({ borderRadius: e }) => e["3"]};
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;
      var R = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let $ = "last-transaction",
        D = class extends n.WF {
          constructor() {
            super(),
              (this.unsubscribe = []),
              (this.paginationObserver = void 0),
              (this.page = "activity"),
              (this.caipAddress = o.W.state.activeCaipAddress),
              (this.transactionsByYear = c.W.state.transactionsByYear),
              (this.loading = c.W.state.loading),
              (this.empty = c.W.state.empty),
              (this.next = c.W.state.next),
              c.W.clearCursor(),
              this.unsubscribe.push(
                o.W.subscribeKey("activeCaipAddress", (e) => {
                  e &&
                    this.caipAddress !== e &&
                    (c.W.resetTransactions(), c.W.fetchTransactions(e)),
                    (this.caipAddress = e);
                }),
                o.W.subscribeKey("activeCaipNetwork", () => {
                  this.updateTransactionView();
                }),
                c.W.subscribe((e) => {
                  (this.transactionsByYear = e.transactionsByYear),
                    (this.loading = e.loading),
                    (this.empty = e.empty),
                    (this.next = e.next);
                })
              );
          }
          firstUpdated() {
            this.updateTransactionView(), this.createPaginationObserver();
          }
          updated() {
            this.setPaginationObserver();
          }
          disconnectedCallback() {
            this.unsubscribe.forEach((e) => e());
          }
          render() {
            return (0, n.qy)` ${
              this.empty ? null : this.templateTransactionsByYear()
            }
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
          }
          updateTransactionView() {
            c.W.resetTransactions(),
              this.caipAddress &&
                c.W.fetchTransactions(l.w.getPlainAddress(this.caipAddress));
          }
          templateTransactionsByYear() {
            return Object.keys(this.transactionsByYear)
              .sort()
              .reverse()
              .map((e) => {
                let t = parseInt(e, 10),
                  r = Array(12)
                    .fill(null)
                    .map((e, r) => ({
                      groupTitle: f.tt.getTransactionGroupTitle(t, r),
                      transactions: this.transactionsByYear[t]?.[r],
                    }))
                    .filter(({ transactions: e }) => e)
                    .reverse();
                return r.map(({ groupTitle: e, transactions: t }, i) => {
                  let s = i === r.length - 1;
                  return t
                    ? (0, n.qy)`
          <wui-flex
            flexDirection="column"
            class="group-container"
            last-group="${s ? "true" : "false"}"
            data-testid="month-indexes"
          >
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["2", "3", "3", "3"]}
            >
              <wui-text variant="md-medium" color="secondary" data-testid="group-title">
                ${e}
              </wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="2">
              ${this.templateTransactions(t, s)}
            </wui-flex>
          </wui-flex>
        `
                    : null;
                });
              });
          }
          templateRenderTransaction(e, t) {
            let {
              date: r,
              descriptions: i,
              direction: s,
              images: a,
              status: o,
              type: c,
              transfers: l,
              isAllNFT: d,
            } = this.getTransactionListItemProps(e);
            return (0, n.qy)`
      <wui-transaction-list-item
        date=${r}
        .direction=${s}
        id=${t && this.next ? $ : ""}
        status=${o}
        type=${c}
        .images=${a}
        .onlyDirectionIcon=${d || 1 === l.length}
        .descriptions=${i}
      ></wui-transaction-list-item>
    `;
          }
          templateTransactions(e, t) {
            return e.map((r, i) => {
              let s = t && i === e.length - 1;
              return (0, n.qy)`${this.templateRenderTransaction(r, s)}`;
            });
          }
          emptyStateActivity() {
            return (0, n.qy)`<wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["10", "5", "10", "5"]}
      gap="5"
      data-testid="empty-activity-state"
    >
      <wui-icon-box color="default" icon="wallet" size="xl"></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="2">
        <wui-text align="center" variant="lg-medium" color="primary">No Transactions yet</wui-text>
        <wui-text align="center" variant="lg-regular" color="secondary"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
          }
          emptyStateAccount() {
            return (0, n.qy)`<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="4"
      data-testid="empty-account-state"
    >
      <wui-icon-box icon="swapHorizontal" size="lg" color="default"></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="2"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="md-regular" align="center" color="primary">No activity yet</wui-text>
        <wui-text variant="sm-regular" align="center" color="secondary"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
          }
          templateEmpty() {
            return "account" === this.page
              ? (0, n.qy)`${this.emptyStateAccount()}`
              : (0, n.qy)`${this.emptyStateActivity()}`;
          }
          templateLoading() {
            return "activity" === this.page
              ? Array(7)
                  .fill(
                    (0,
                    n.qy)` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `
                  )
                  .map((e) => e)
              : null;
          }
          onReceiveClick() {
            d.I.push("WalletReceive");
          }
          createPaginationObserver() {
            let { projectId: e } = h.H.state;
            (this.paginationObserver = new IntersectionObserver(([t]) => {
              t?.isIntersecting &&
                !this.loading &&
                (c.W.fetchTransactions(l.w.getPlainAddress(this.caipAddress)),
                u.E.sendEvent({
                  type: "track",
                  event: "LOAD_MORE_TRANSACTIONS",
                  properties: {
                    address: l.w.getPlainAddress(this.caipAddress),
                    projectId: e,
                    cursor: this.next,
                    isSmartAccount:
                      (0, p.lj)(o.W.state.activeChain) ===
                      O.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                }));
            }, {})),
              this.setPaginationObserver();
          }
          setPaginationObserver() {
            this.paginationObserver?.disconnect();
            let e = this.shadowRoot?.querySelector(`#${$}`);
            e && this.paginationObserver?.observe(e);
          }
          getTransactionListItemProps(e) {
            let t = a.r.formatDate(e?.metadata?.minedAt),
              r = f.tt.mergeTransfers(e?.transfers),
              i = f.tt.getTransactionDescriptions(e, r),
              n = r?.[0],
              s = !!n && r?.every((e) => !!e.nft_info),
              o = f.tt.getTransactionImages(r);
            return {
              date: t,
              direction: n?.direction,
              descriptions: i,
              isAllNFT: s,
              images: o,
              status: e.metadata?.status,
              transfers: r,
              type: e.metadata?.operationType,
            };
          }
        };
      (D.styles = P),
        R([(0, s.MZ)()], D.prototype, "page", void 0),
        R([(0, s.wk)()], D.prototype, "caipAddress", void 0),
        R([(0, s.wk)()], D.prototype, "transactionsByYear", void 0),
        R([(0, s.wk)()], D.prototype, "loading", void 0),
        R([(0, s.wk)()], D.prototype, "empty", void 0),
        R([(0, s.wk)()], D.prototype, "next", void 0),
        (D = R([(0, f.EM)("w3m-activity-list")], D));
    },
    21129: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(20296),
        a = r(71084),
        o = r(47327);
      let c = (0, i.AH)`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 1.4s linear infinite;
    color: var(--local-color);
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments), (this.color = "primary"), (this.size = "lg");
        }
        render() {
          let e = {
            primary: s.f.tokens.theme.textPrimary,
            secondary: s.f.tokens.theme.textSecondary,
            tertiary: s.f.tokens.theme.textTertiary,
            invert: s.f.tokens.theme.textInvert,
            error: s.f.tokens.core.textError,
            warning: s.f.tokens.core.textWarning,
            "accent-primary": s.f.tokens.core.textAccentPrimary,
          };
          return (
            (this.style.cssText = `
      --local-color: ${"inherit" === this.color ? "inherit" : e[this.color]};
      `),
            (this.dataset.size = this.size),
            (0, i.qy)`<svg viewBox="0 0 16 17" fill="none">
      <path
        d="M8.75 2.65625V4.65625C8.75 4.85516 8.67098 5.04593 8.53033 5.18658C8.38968 5.32723 8.19891 5.40625 8 5.40625C7.80109 5.40625 7.61032 5.32723 7.46967 5.18658C7.32902 5.04593 7.25 4.85516 7.25 4.65625V2.65625C7.25 2.45734 7.32902 2.26657 7.46967 2.12592C7.61032 1.98527 7.80109 1.90625 8 1.90625C8.19891 1.90625 8.38968 1.98527 8.53033 2.12592C8.67098 2.26657 8.75 2.45734 8.75 2.65625ZM14 7.90625H12C11.8011 7.90625 11.6103 7.98527 11.4697 8.12592C11.329 8.26657 11.25 8.45734 11.25 8.65625C11.25 8.85516 11.329 9.04593 11.4697 9.18658C11.6103 9.32723 11.8011 9.40625 12 9.40625H14C14.1989 9.40625 14.3897 9.32723 14.5303 9.18658C14.671 9.04593 14.75 8.85516 14.75 8.65625C14.75 8.45734 14.671 8.26657 14.5303 8.12592C14.3897 7.98527 14.1989 7.90625 14 7.90625ZM11.3588 10.9544C11.289 10.8846 11.2062 10.8293 11.115 10.7915C11.0239 10.7538 10.9262 10.7343 10.8275 10.7343C10.7288 10.7343 10.6311 10.7538 10.54 10.7915C10.4488 10.8293 10.366 10.8846 10.2963 10.9544C10.2265 11.0241 10.1711 11.107 10.1334 11.1981C10.0956 11.2893 10.0762 11.387 10.0762 11.4856C10.0762 11.5843 10.0956 11.682 10.1334 11.7731C10.1711 11.8643 10.2265 11.9471 10.2963 12.0169L11.7106 13.4312C11.8515 13.5721 12.0426 13.6513 12.2419 13.6513C12.4411 13.6513 12.6322 13.5721 12.7731 13.4312C12.914 13.2904 12.9932 13.0993 12.9932 12.9C12.9932 12.7007 12.914 12.5096 12.7731 12.3687L11.3588 10.9544ZM8 11.9062C7.80109 11.9062 7.61032 11.9853 7.46967 12.1259C7.32902 12.2666 7.25 12.4573 7.25 12.6562V14.6562C7.25 14.8552 7.32902 15.0459 7.46967 15.1866C7.61032 15.3272 7.80109 15.4062 8 15.4062C8.19891 15.4062 8.38968 15.3272 8.53033 15.1866C8.67098 15.0459 8.75 14.8552 8.75 14.6562V12.6562C8.75 12.4573 8.67098 12.2666 8.53033 12.1259C8.38968 11.9853 8.19891 11.9062 8 11.9062ZM4.64125 10.9544L3.22688 12.3687C3.08598 12.5096 3.00682 12.7007 3.00682 12.9C3.00682 13.0993 3.08598 13.2904 3.22688 13.4312C3.36777 13.5721 3.55887 13.6513 3.75813 13.6513C3.95738 13.6513 4.14848 13.5721 4.28937 13.4312L5.70375 12.0169C5.84465 11.876 5.9238 11.6849 5.9238 11.4856C5.9238 11.2864 5.84465 11.0953 5.70375 10.9544C5.56285 10.8135 5.37176 10.7343 5.1725 10.7343C4.97324 10.7343 4.78215 10.8135 4.64125 10.9544ZM4.75 8.65625C4.75 8.45734 4.67098 8.26657 4.53033 8.12592C4.38968 7.98527 4.19891 7.90625 4 7.90625H2C1.80109 7.90625 1.61032 7.98527 1.46967 8.12592C1.32902 8.26657 1.25 8.45734 1.25 8.65625C1.25 8.85516 1.32902 9.04593 1.46967 9.18658C1.61032 9.32723 1.80109 9.40625 2 9.40625H4C4.19891 9.40625 4.38968 9.32723 4.53033 9.18658C4.67098 9.04593 4.75 8.85516 4.75 8.65625ZM4.2875 3.88313C4.1466 3.74223 3.95551 3.66307 3.75625 3.66307C3.55699 3.66307 3.3659 3.74223 3.225 3.88313C3.0841 4.02402 3.00495 4.21512 3.00495 4.41438C3.00495 4.61363 3.0841 4.80473 3.225 4.94562L4.64125 6.35813C4.78215 6.49902 4.97324 6.57818 5.1725 6.57818C5.37176 6.57818 5.56285 6.49902 5.70375 6.35813C5.84465 6.21723 5.9238 6.02613 5.9238 5.82688C5.9238 5.62762 5.84465 5.43652 5.70375 5.29563L4.2875 3.88313Z"
        fill="currentColor"
      />
    </svg>`
          );
        }
      };
      (d.styles = [a.W5, c]),
        l([(0, n.MZ)()], d.prototype, "color", void 0),
        l([(0, n.MZ)()], d.prototype, "size", void 0),
        (d = l([(0, o.E)("wui-loading-spinner")], d));
    },
    21471: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => o });
      var i = r(45553),
        n = r(55480),
        s = r(67869),
        a = r(91867);
      let o = {
        getTabsByNamespace: (e) =>
          e && e === i.o.CHAIN.EVM
            ? n.H.state.remoteFeatures?.activity === !1
              ? a.o.ACCOUNT_TABS.filter((e) => "Activity" !== e.label)
              : a.o.ACCOUNT_TABS
            : [],
        isValidReownName: (e) => /^[a-zA-Z0-9]+$/gu.test(e),
        isValidEmail: (e) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/gu.test(e),
        validateReownName: (e) =>
          e
            .replace(/\^/gu, "")
            .toLowerCase()
            .replace(/[^a-zA-Z0-9]/gu, ""),
        hasFooter() {
          let e = s.I.state.view;
          if (a.o.VIEWS_WITH_LEGAL_FOOTER.includes(e)) {
            let { termsConditionsUrl: e, privacyPolicyUrl: t } = n.H.state,
              r = n.H.state.features?.legalCheckbox;
            return (!!e || !!t) && !r;
          }
          return a.o.VIEWS_WITH_DEFAULT_FOOTER.includes(e);
        },
      };
    },
    22588: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => l });
      var i = r(83138),
        n = r(98410),
        s = r(67869),
        a = r(36211);
      r(65110);
      let o = (0, a.AH)`
  :host {
    display: block;
    width: inherit;
  }
`;
      var c = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let l = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.viewState = s.I.state.view),
            (this.history = s.I.state.history.join(",")),
            this.unsubscribe.push(
              s.I.subscribeKey("view", () => {
                (this.history = s.I.state.history.join(",")),
                  document.documentElement.style.setProperty(
                    "--apkt-duration-dynamic",
                    "var(--apkt-durations-lg)"
                  );
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e()),
            document.documentElement.style.setProperty(
              "--apkt-duration-dynamic",
              "0s"
            );
        }
        render() {
          return (0, i.qy)`${this.templatePageContainer()}`;
        }
        templatePageContainer() {
          return (0, i.qy)`<w3m-router-container
      history=${this.history}
      .setView=${() => {
        this.viewState = s.I.state.view;
      }}
    >
      ${this.viewTemplate(this.viewState)}
    </w3m-router-container>`;
        }
        viewTemplate(e) {
          switch (e) {
            case "AccountSettings":
              return (0,
              i.qy)`<w3m-account-settings-view></w3m-account-settings-view>`;
            case "Account":
              return (0, i.qy)`<w3m-account-view></w3m-account-view>`;
            case "AllWallets":
              return (0, i.qy)`<w3m-all-wallets-view></w3m-all-wallets-view>`;
            case "ApproveTransaction":
              return (0,
              i.qy)`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
            case "BuyInProgress":
              return (0,
              i.qy)`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
            case "ChooseAccountName":
              return (0,
              i.qy)`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
            case "Connect":
            default:
              return (0, i.qy)`<w3m-connect-view></w3m-connect-view>`;
            case "Create":
              return (0,
              i.qy)`<w3m-connect-view walletGuide="explore"></w3m-connect-view>`;
            case "ConnectingWalletConnect":
              return (0,
              i.qy)`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
            case "ConnectingWalletConnectBasic":
              return (0,
              i.qy)`<w3m-connecting-wc-basic-view></w3m-connecting-wc-basic-view>`;
            case "ConnectingExternal":
              return (0,
              i.qy)`<w3m-connecting-external-view></w3m-connecting-external-view>`;
            case "ConnectingSiwe":
              return (0,
              i.qy)`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
            case "ConnectWallets":
              return (0,
              i.qy)`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
            case "ConnectSocials":
              return (0,
              i.qy)`<w3m-connect-socials-view></w3m-connect-socials-view>`;
            case "ConnectingSocial":
              return (0,
              i.qy)`<w3m-connecting-social-view></w3m-connecting-social-view>`;
            case "DataCapture":
              return (0, i.qy)`<w3m-data-capture-view></w3m-data-capture-view>`;
            case "DataCaptureOtpConfirm":
              return (0,
              i.qy)`<w3m-data-capture-otp-confirm-view></w3m-data-capture-otp-confirm-view>`;
            case "Downloads":
              return (0, i.qy)`<w3m-downloads-view></w3m-downloads-view>`;
            case "EmailLogin":
              return (0, i.qy)`<w3m-email-login-view></w3m-email-login-view>`;
            case "EmailVerifyOtp":
              return (0,
              i.qy)`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
            case "EmailVerifyDevice":
              return (0,
              i.qy)`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
            case "GetWallet":
              return (0, i.qy)`<w3m-get-wallet-view></w3m-get-wallet-view>`;
            case "Networks":
              return (0, i.qy)`<w3m-networks-view></w3m-networks-view>`;
            case "SwitchNetwork":
              return (0,
              i.qy)`<w3m-network-switch-view></w3m-network-switch-view>`;
            case "ProfileWallets":
              return (0,
              i.qy)`<w3m-profile-wallets-view></w3m-profile-wallets-view>`;
            case "Transactions":
              return (0, i.qy)`<w3m-transactions-view></w3m-transactions-view>`;
            case "OnRampProviders":
              return (0,
              i.qy)`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
            case "OnRampTokenSelect":
              return (0,
              i.qy)`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
            case "OnRampFiatSelect":
              return (0,
              i.qy)`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
            case "UpgradeEmailWallet":
              return (0,
              i.qy)`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
            case "UpdateEmailWallet":
              return (0,
              i.qy)`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
            case "UpdateEmailPrimaryOtp":
              return (0,
              i.qy)`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
            case "UpdateEmailSecondaryOtp":
              return (0,
              i.qy)`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
            case "UnsupportedChain":
              return (0,
              i.qy)`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
            case "Swap":
              return (0, i.qy)`<w3m-swap-view></w3m-swap-view>`;
            case "SwapSelectToken":
              return (0,
              i.qy)`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
            case "SwapPreview":
              return (0, i.qy)`<w3m-swap-preview-view></w3m-swap-preview-view>`;
            case "WalletSend":
              return (0, i.qy)`<w3m-wallet-send-view></w3m-wallet-send-view>`;
            case "WalletSendSelectToken":
              return (0,
              i.qy)`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
            case "WalletSendPreview":
              return (0,
              i.qy)`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
            case "WalletSendConfirmed":
              return (0,
              i.qy)`<w3m-send-confirmed-view></w3m-send-confirmed-view>`;
            case "WhatIsABuy":
              return (0,
              i.qy)`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
            case "WalletReceive":
              return (0,
              i.qy)`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
            case "WalletCompatibleNetworks":
              return (0,
              i.qy)`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
            case "WhatIsAWallet":
              return (0,
              i.qy)`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
            case "ConnectingMultiChain":
              return (0,
              i.qy)`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
            case "WhatIsANetwork":
              return (0,
              i.qy)`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
            case "ConnectingFarcaster":
              return (0,
              i.qy)`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
            case "SwitchActiveChain":
              return (0,
              i.qy)`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
            case "RegisterAccountName":
              return (0,
              i.qy)`<w3m-register-account-name-view></w3m-register-account-name-view>`;
            case "RegisterAccountNameSuccess":
              return (0,
              i.qy)`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
            case "SmartSessionCreated":
              return (0,
              i.qy)`<w3m-smart-session-created-view></w3m-smart-session-created-view>`;
            case "SmartSessionList":
              return (0,
              i.qy)`<w3m-smart-session-list-view></w3m-smart-session-list-view>`;
            case "SIWXSignMessage":
              return (0,
              i.qy)`<w3m-siwx-sign-message-view></w3m-siwx-sign-message-view>`;
            case "Pay":
              return (0, i.qy)`<w3m-pay-view></w3m-pay-view>`;
            case "PayLoading":
              return (0, i.qy)`<w3m-pay-loading-view></w3m-pay-loading-view>`;
            case "FundWallet":
              return (0, i.qy)`<w3m-fund-wallet-view></w3m-fund-wallet-view>`;
            case "PayWithExchange":
              return (0,
              i.qy)`<w3m-deposit-from-exchange-view></w3m-deposit-from-exchange-view>`;
            case "PayWithExchangeSelectAsset":
              return (0,
              i.qy)`<w3m-deposit-from-exchange-select-asset-view></w3m-deposit-from-exchange-select-asset-view>`;
          }
        }
      };
      (l.styles = [o]),
        c([(0, n.wk)()], l.prototype, "viewState", void 0),
        c([(0, n.wk)()], l.prototype, "history", void 0),
        (l = c([(0, a.EM)("w3m-router")], l));
    },
    22669: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      var i = r(73537),
        n = r(17389);
      let s = {
        set(e, t) {
          n.Q.isClient && localStorage.setItem(`${i.s1.STORAGE_KEY}${e}`, t);
        },
        get: (e) =>
          n.Q.isClient ? localStorage.getItem(`${i.s1.STORAGE_KEY}${e}`) : null,
        delete(e, t) {
          n.Q.isClient &&
            (t
              ? localStorage.removeItem(e)
              : localStorage.removeItem(`${i.s1.STORAGE_KEY}${e}`));
        },
      };
    },
    23308: (e, t, r) => {
      let i = r(52686);
      function n(e, t) {
        let r = e.a / 255,
          i = t + '="' + e.hex + '"';
        return r < 1
          ? i + " " + t + '-opacity="' + r.toFixed(2).slice(1) + '"'
          : i;
      }
      function s(e, t, r) {
        let i = e + t;
        return void 0 !== r && (i += " " + r), i;
      }
      t.render = function (e, t, r) {
        let a = i.getOptions(t),
          o = e.modules.size,
          c = e.modules.data,
          l = o + 2 * a.margin,
          d = a.color.light.a
            ? "<path " +
              n(a.color.light, "fill") +
              ' d="M0 0h' +
              l +
              "v" +
              l +
              'H0z"/>'
            : "",
          h =
            "<path " +
            n(a.color.dark, "stroke") +
            ' d="' +
            (function (e, t, r) {
              let i = "",
                n = 0,
                a = !1,
                o = 0;
              for (let c = 0; c < e.length; c++) {
                let l = Math.floor(c % t),
                  d = Math.floor(c / t);
                l || a || (a = !0),
                  e[c]
                    ? (o++,
                      (c > 0 && l > 0 && e[c - 1]) ||
                        ((i += a ? s("M", l + r, 0.5 + d + r) : s("m", n, 0)),
                        (n = 0),
                        (a = !1)),
                      (l + 1 < t && e[c + 1]) || ((i += s("h", o)), (o = 0)))
                    : n++;
              }
              return i;
            })(c, o, a.margin) +
            '"/>',
          u =
            '<svg xmlns="http://www.w3.org/2000/svg" ' +
            (a.width
              ? 'width="' + a.width + '" height="' + a.width + '" '
              : "") +
            ('viewBox="0 0 ' + l + " ") +
            l +
            '" shape-rendering="crispEdges">' +
            d +
            h +
            "</svg>\n";
        return "function" == typeof r && r(null, u), u;
      };
    },
    24250: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => n, R: () => i });
      let i = (e) => e,
        n = (e) => e;
    },
    24369: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => p });
      var i = r(1220),
        n = r(73537),
        s = r(71305),
        a = r(36964),
        o = r(44826),
        c = r(93481),
        l = r(70417),
        d = r(55480),
        h = r(65374);
      let u = (0, i.BX)({
          transactions: [],
          transactionsByYear: {},
          lastNetworkInView: void 0,
          loading: !1,
          empty: !1,
          next: void 0,
        }),
        p = (0, a.X)(
          {
            state: u,
            subscribe: (e) => (0, i.B1)(u, () => e(u)),
            setLastNetworkInView(e) {
              u.lastNetworkInView = e;
            },
            async fetchTransactions(e) {
              if (!e)
                throw Error(
                  "Transactions can't be fetched without an accountAddress"
                );
              u.loading = !0;
              try {
                let t = await o.T.fetchTransactions({
                    account: e,
                    cursor: u.next,
                    chainId: c.W.state.activeCaipNetwork?.caipNetworkId,
                  }),
                  r = p.filterSpamTransactions(t.data),
                  i = p.filterByConnectedChain(r),
                  n = [...u.transactions, ...i];
                (u.loading = !1),
                  (u.transactions = n),
                  (u.transactionsByYear = p.groupTransactionsByYearAndMonth(
                    u.transactionsByYear,
                    i
                  )),
                  (u.empty = 0 === n.length),
                  (u.next = t.next ? t.next : void 0);
              } catch (r) {
                let t = c.W.state.activeChain;
                l.E.sendEvent({
                  type: "track",
                  event: "ERROR_FETCH_TRANSACTIONS",
                  properties: {
                    address: e,
                    projectId: d.H.state.projectId,
                    cursor: u.next,
                    isSmartAccount:
                      (0, s.lj)(t) === n.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                }),
                  h.P.showError("Failed to fetch transactions"),
                  (u.loading = !1),
                  (u.empty = !0),
                  (u.next = void 0);
              }
            },
            groupTransactionsByYearAndMonth: (e = {}, t = []) => (
              t.forEach((t) => {
                let r = new Date(t.metadata.minedAt).getFullYear(),
                  i = new Date(t.metadata.minedAt).getMonth(),
                  n = e[r] ?? {},
                  s = (n[i] ?? []).filter((e) => e.id !== t.id);
                e[r] = {
                  ...n,
                  [i]: [...s, t].sort(
                    (e, t) =>
                      new Date(t.metadata.minedAt).getTime() -
                      new Date(e.metadata.minedAt).getTime()
                  ),
                };
              }),
              e
            ),
            filterSpamTransactions: (e) =>
              e.filter(
                (e) =>
                  !e.transfers.every((e) => e.nft_info?.flags.is_spam === !0)
              ),
            filterByConnectedChain(e) {
              let t = c.W.state.activeCaipNetwork?.caipNetworkId;
              return e.filter((e) => e.metadata.chain === t);
            },
            clearCursor() {
              u.next = void 0;
            },
            resetTransactions() {
              (u.transactions = []),
                (u.transactionsByYear = {}),
                (u.lastNetworkInView = void 0),
                (u.loading = !1),
                (u.empty = !1),
                (u.next = void 0);
            },
          },
          "API_ERROR"
        );
    },
    24772: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(2354),
        a = r(20296),
        o = r(71084),
        c = r(47327);
      let l = (0, a.AH)`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  /* -- Headings --------------------------------------------------- */
  .wui-font-h1-regular-mono {
    font-size: ${({ textSize: e }) => e.h1};
    line-height: ${({ typography: e }) => e["h1-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h1-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h1-regular {
    font-size: ${({ textSize: e }) => e.h1};
    line-height: ${({ typography: e }) => e["h1-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h1-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h1-medium {
    font-size: ${({ textSize: e }) => e.h1};
    line-height: ${({ typography: e }) => e["h1-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h1-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h2-regular-mono {
    font-size: ${({ textSize: e }) => e.h2};
    line-height: ${({ typography: e }) => e["h2-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h2-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h2-regular {
    font-size: ${({ textSize: e }) => e.h2};
    line-height: ${({ typography: e }) => e["h2-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h2-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h2-medium {
    font-size: ${({ textSize: e }) => e.h2};
    line-height: ${({ typography: e }) => e["h2-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h2-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h3-regular-mono {
    font-size: ${({ textSize: e }) => e.h3};
    line-height: ${({ typography: e }) => e["h3-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h3-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h3-regular {
    font-size: ${({ textSize: e }) => e.h3};
    line-height: ${({ typography: e }) => e["h3-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h3-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h3-medium {
    font-size: ${({ textSize: e }) => e.h3};
    line-height: ${({ typography: e }) => e["h3-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h3-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h4-regular-mono {
    font-size: ${({ textSize: e }) => e.h4};
    line-height: ${({ typography: e }) => e["h4-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h4-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h4-regular {
    font-size: ${({ textSize: e }) => e.h4};
    line-height: ${({ typography: e }) => e["h4-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h4-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h4-medium {
    font-size: ${({ textSize: e }) => e.h4};
    line-height: ${({ typography: e }) => e["h4-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h4-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h5-regular-mono {
    font-size: ${({ textSize: e }) => e.h5};
    line-height: ${({ typography: e }) => e["h5-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h5-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h5-regular {
    font-size: ${({ textSize: e }) => e.h5};
    line-height: ${({ typography: e }) => e["h5-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h5-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h5-medium {
    font-size: ${({ textSize: e }) => e.h5};
    line-height: ${({ typography: e }) => e["h5-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h5-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h6-regular-mono {
    font-size: ${({ textSize: e }) => e.h6};
    line-height: ${({ typography: e }) => e["h6-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["h6-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-h6-regular {
    font-size: ${({ textSize: e }) => e.h6};
    line-height: ${({ typography: e }) => e["h6-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h6-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-h6-medium {
    font-size: ${({ textSize: e }) => e.h6};
    line-height: ${({ typography: e }) => e["h6-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["h6-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-lg-regular-mono {
    font-size: ${({ textSize: e }) => e.large};
    line-height: ${({ typography: e }) => e["lg-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["lg-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-lg-regular {
    font-size: ${({ textSize: e }) => e.large};
    line-height: ${({ typography: e }) => e["lg-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["lg-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-lg-medium {
    font-size: ${({ textSize: e }) => e.large};
    line-height: ${({ typography: e }) => e["lg-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["lg-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-md-regular-mono {
    font-size: ${({ textSize: e }) => e.medium};
    line-height: ${({ typography: e }) => e["md-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["md-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-md-regular {
    font-size: ${({ textSize: e }) => e.medium};
    line-height: ${({ typography: e }) => e["md-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["md-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-md-medium {
    font-size: ${({ textSize: e }) => e.medium};
    line-height: ${({ typography: e }) => e["md-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["md-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-sm-regular-mono {
    font-size: ${({ textSize: e }) => e.small};
    line-height: ${({ typography: e }) => e["sm-regular-mono"].lineHeight};
    letter-spacing: ${({ typography: e }) =>
      e["sm-regular-mono"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.mono};
  }

  .wui-font-sm-regular {
    font-size: ${({ textSize: e }) => e.small};
    line-height: ${({ typography: e }) => e["sm-regular"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["sm-regular"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.regular};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }

  .wui-font-sm-medium {
    font-size: ${({ textSize: e }) => e.small};
    line-height: ${({ typography: e }) => e["sm-medium"].lineHeight};
    letter-spacing: ${({ typography: e }) => e["sm-medium"].letterSpacing};
    font-weight: ${({ fontWeight: e }) => e.medium};
    font-family: ${({ fontFamily: e }) => e.regular};
    font-feature-settings:
      'liga' off,
      'clig' off;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = {
          primary: a.f.tokens.theme.textPrimary,
          secondary: a.f.tokens.theme.textSecondary,
          tertiary: a.f.tokens.theme.textTertiary,
          invert: a.f.tokens.theme.textInvert,
          error: a.f.tokens.core.textError,
          warning: a.f.tokens.core.textWarning,
          "accent-primary": a.f.tokens.core.textAccentPrimary,
        },
        u = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.variant = "md-regular"),
              (this.color = "inherit"),
              (this.align = "left"),
              (this.lineClamp = void 0);
          }
          render() {
            let e = {
              [`wui-font-${this.variant}`]: !0,
              [`wui-line-clamp-${this.lineClamp}`]: !!this.lineClamp,
            };
            return (
              (this.style.cssText = `
      --local-align: ${this.align};
      --local-color: ${
        "inherit" === this.color ? "inherit" : h[this.color ?? "primary"]
      };
      `),
              (0, i.qy)`<slot class=${(0, s.H)(e)}></slot>`
            );
          }
        };
      (u.styles = [o.W5, l]),
        d([(0, n.MZ)()], u.prototype, "variant", void 0),
        d([(0, n.MZ)()], u.prototype, "color", void 0),
        d([(0, n.MZ)()], u.prototype, "align", void 0),
        d([(0, n.MZ)()], u.prototype, "lineClamp", void 0),
        (u = d([(0, c.E)("wui-text")], u));
    },
    24784: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => o });
      var i = r(20390),
        n = r(77608);
      let s = /^0x[a-fA-F0-9]{40}$/,
        a = new i.A(8192);
      function o(e, t) {
        let { strict: r = !0 } = t ?? {},
          i = `${e}.${r}`;
        if (a.has(i)) return a.get(i);
        let o =
          !!s.test(e) && (e.toLowerCase() === e || !r || (0, n.o)(e) === e);
        return a.set(i, o), o;
      }
    },
    24967: (e, t) => {
      (t.L = { bit: 1 }),
        (t.M = { bit: 0 }),
        (t.Q = { bit: 3 }),
        (t.H = { bit: 2 }),
        (t.isValid = function (e) {
          return e && void 0 !== e.bit && e.bit >= 0 && e.bit < 4;
        }),
        (t.from = function (e, r) {
          if (t.isValid(e)) return e;
          try {
            if ("string" != typeof e) throw Error("Param is not a string");
            switch (e.toLowerCase()) {
              case "l":
              case "low":
                return t.L;
              case "m":
              case "medium":
                return t.M;
              case "q":
              case "quartile":
                return t.Q;
              case "h":
              case "high":
                return t.H;
              default:
                throw Error("Unknown EC Level: " + e);
            }
          } catch (e) {
            return r;
          }
        });
    },
    25042: (e, t, r) => {
      "use strict";
      function i(e) {
        if ("string" != typeof e)
          throw Error(`Cannot safe json parse value of type ${typeof e}`);
        try {
          return JSON.parse(
            e.replace(
              /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
              '$1"$2n"$3'
            ),
            (e, t) =>
              "string" == typeof t && t.match(/^\d+n$/)
                ? BigInt(t.substring(0, t.length - 1))
                : t
          );
        } catch (t) {
          return e;
        }
      }
      function n(e) {
        return "string" == typeof e
          ? e
          : JSON.stringify(e, (e, t) =>
              "bigint" == typeof t ? t.toString() + "n" : t
            ) || "";
      }
      r.d(t, { h: () => n, j: () => i });
    },
    25648: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(81452), t), i.__exportStar(r(80361), t);
    },
    25654: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => E });
      var i = r(1220),
        n = r(98866),
        s = r(79530),
        a = r(12182),
        o = r(45553),
        c = r(425),
        l = r(73537),
        d = r(30982),
        h = r(71305),
        u = r(28977),
        p = r(12319),
        f = r(83941),
        g = r(36964),
        m = r(93481),
        y = r(97418),
        w = r(70417),
        b = r(67869),
        v = r(65374);
      let C = (0, i.BX)({ tokenBalances: [], loading: !1 }),
        E = (0, g.X)({
          state: C,
          subscribe: (e) => (0, i.B1)(C, () => e(C)),
          subscribeKey: (e, t) => (0, n.u$)(C, e, t),
          setToken(e) {
            e && (C.token = (0, i.KR)(e));
          },
          setTokenAmount(e) {
            C.sendTokenAmount = e;
          },
          setReceiverAddress(e) {
            C.receiverAddress = e;
          },
          setReceiverProfileImageUrl(e) {
            C.receiverProfileImageUrl = e;
          },
          setReceiverProfileName(e) {
            C.receiverProfileName = e;
          },
          setNetworkBalanceInUsd(e) {
            C.networkBalanceInUSD = e;
          },
          setLoading(e) {
            C.loading = e;
          },
          getSdkEventProperties: (e) => ({
            message: p.w.parseError(e),
            isSmartAccount:
              (0, h.lj)(m.W.state.activeChain) ===
              l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: C.token?.symbol || "",
            amount: C.sendTokenAmount ?? 0,
            network: m.W.state.activeCaipNetwork?.caipNetworkId || "",
          }),
          async sendToken() {
            try {
              switch (
                (E.setLoading(!0), m.W.state.activeCaipNetwork?.chainNamespace)
              ) {
                case "eip155":
                  await E.sendEvmToken();
                  return;
                case "solana":
                  await E.sendSolanaToken();
                  return;
                default:
                  throw Error("Unsupported chain");
              }
            } catch (e) {
              if (s.RQ.isUserRejectedRequestError(e)) throw new s.vx(e);
              throw e;
            } finally {
              E.setLoading(!1);
            }
          },
          async sendEvmToken() {
            let e = m.W.state.activeChain;
            if (!e)
              throw Error(
                "SendController:sendEvmToken - activeChainNamespace is required"
              );
            let t = (0, h.lj)(e);
            if (!E.state.sendTokenAmount || !E.state.receiverAddress)
              throw Error("An amount and receiver address are required");
            if (!E.state.token) throw Error("A token is required");
            if (E.state.token?.address) {
              w.E.sendEvent({
                type: "track",
                event: "SEND_INITIATED",
                properties: {
                  isSmartAccount: t === l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: E.state.token.address,
                  amount: E.state.sendTokenAmount,
                  network: m.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              });
              let { hash: e } = await E.sendERC20Token({
                receiverAddress: E.state.receiverAddress,
                tokenAddress: E.state.token.address,
                sendTokenAmount: E.state.sendTokenAmount,
                decimals: E.state.token.quantity.decimals,
              });
              e && (C.hash = e);
            } else {
              w.E.sendEvent({
                type: "track",
                event: "SEND_INITIATED",
                properties: {
                  isSmartAccount: t === l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: E.state.token.symbol || "",
                  amount: E.state.sendTokenAmount,
                  network: m.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              });
              let { hash: e } = await E.sendNativeToken({
                receiverAddress: E.state.receiverAddress,
                sendTokenAmount: E.state.sendTokenAmount,
                decimals: E.state.token.quantity.decimals,
              });
              e && (C.hash = e);
            }
          },
          async fetchTokenBalance(e) {
            C.loading = !0;
            let t = m.W.state.activeChain,
              r = m.W.state.activeCaipNetwork?.caipNetworkId,
              i = m.W.state.activeCaipNetwork?.chainNamespace,
              n =
                m.W.getAccountData(t)?.caipAddress ??
                m.W.state.activeCaipAddress,
              s = n ? p.w.getPlainAddress(n) : void 0;
            if (
              C.lastRetry &&
              !p.w.isAllowedRetry(C.lastRetry, 30 * u.oU.ONE_SEC_MS)
            )
              return (C.loading = !1), [];
            try {
              if (s && r && i) {
                let e = await d.Z.getMyTokensWithBalance();
                return (C.tokenBalances = e), (C.lastRetry = void 0), e;
              }
            } catch (t) {
              (C.lastRetry = Date.now()),
                e?.(t),
                v.P.showError("Token Balance Unavailable");
            } finally {
              C.loading = !1;
            }
            return [];
          },
          fetchNetworkBalance() {
            if (0 === C.tokenBalances.length) return;
            let e = f.s.mapBalancesToSwapTokens(C.tokenBalances);
            if (!e) return;
            let t = e.find((e) => e.address === (0, h.K1)());
            t &&
              (C.networkBalanceInUSD = t
                ? a.S.multiply(t.quantity.numeric, t.price).toString()
                : "0");
          },
          async sendNativeToken(e) {
            b.I.pushTransactionStack({});
            let t = e.receiverAddress,
              r = m.W.getAccountData()?.address,
              i = y.x.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              ),
              n = await y.x.sendTransaction({
                chainNamespace: o.o.CHAIN.EVM,
                to: t,
                address: r,
                data: "0x",
                value: i ?? BigInt(0),
              });
            return (
              w.E.sendEvent({
                type: "track",
                event: "SEND_SUCCESS",
                properties: {
                  isSmartAccount:
                    (0, h.lj)("eip155") === l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: E.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: m.W.state.activeCaipNetwork?.caipNetworkId || "",
                  hash: n || "",
                },
              }),
              y.x._getClient()?.updateBalance("eip155"),
              E.resetSend(),
              { hash: n }
            );
          },
          async sendERC20Token(e) {
            b.I.pushTransactionStack({
              onSuccess() {
                b.I.replace("Account");
              },
            });
            let t = y.x.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              ),
              r = m.W.getAccountData()?.address;
            if (r && e.sendTokenAmount && e.receiverAddress && e.tokenAddress) {
              let i = p.w.getPlainAddress(e.tokenAddress);
              if (!i)
                throw Error(
                  "SendController:sendERC20Token - tokenAddress is required"
                );
              let n = await y.x.writeContract({
                fromAddress: r,
                tokenAddress: i,
                args: [e.receiverAddress, t ?? BigInt(0)],
                method: "transfer",
                abi: c.v.getERC20Abi(i),
                chainNamespace: o.o.CHAIN.EVM,
              });
              return (
                w.E.sendEvent({
                  type: "track",
                  event: "SEND_SUCCESS",
                  properties: {
                    isSmartAccount:
                      (0, h.lj)("eip155") === l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: E.state.token?.symbol || "",
                    amount: e.sendTokenAmount,
                    network: m.W.state.activeCaipNetwork?.caipNetworkId || "",
                    hash: n || "",
                  },
                }),
                E.resetSend(),
                { hash: n }
              );
            }
            return { hash: void 0 };
          },
          async sendSolanaToken() {
            let e;
            if (!E.state.sendTokenAmount || !E.state.receiverAddress)
              throw Error("An amount and receiver address are required");
            b.I.pushTransactionStack({
              onSuccess() {
                b.I.replace("Account");
              },
            }),
              E.state.token &&
                E.state.token.address !== u.oU.SOLANA_NATIVE_TOKEN_ADDRESS &&
                (e = p.w.isCaipAddress(E.state.token.address)
                  ? p.w.getPlainAddress(E.state.token.address)
                  : E.state.token.address);
            let t = await y.x.sendTransaction({
              chainNamespace: "solana",
              tokenMint: e,
              to: E.state.receiverAddress,
              value: E.state.sendTokenAmount,
            });
            t && (C.hash = t),
              y.x._getClient()?.updateBalance("solana"),
              E.resetSend();
          },
          resetSend() {
            (C.token = void 0),
              (C.sendTokenAmount = void 0),
              (C.receiverAddress = void 0),
              (C.receiverProfileImageUrl = void 0),
              (C.receiverProfileName = void 0),
              (C.loading = !1),
              (C.tokenBalances = []);
          },
        });
    },
    25784: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(55480),
        s = r(70417),
        a = r(71305),
        o = r(93481),
        c = r(67869),
        l = r(36211);
      r(40575), r(77237), r(48352), r(41163);
      var d = r(73537);
      let h = (0, i.AH)``,
        u = class extends i.WF {
          render() {
            let { termsConditionsUrl: e, privacyPolicyUrl: t } = n.H.state;
            return e || t
              ? (0, i.qy)`
      <wui-flex
        .padding=${["4", "3", "3", "3"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="3"
      >
        <wui-text color="secondary" variant="md-regular" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `
              : null;
          }
          howDoesItWorkTemplate() {
            return (0, i.qy)` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-primary" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
          }
          onWhatIsBuy() {
            s.E.sendEvent({
              type: "track",
              event: "SELECT_WHAT_IS_A_BUY",
              properties: {
                isSmartAccount:
                  (0, a.lj)(o.W.state.activeChain) ===
                  d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
              },
            }),
              c.I.push("WhatIsABuy");
          }
        };
      (u.styles = [h]),
        (u = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, l.EM)("w3m-onramp-providers-footer")], u));
    },
    25939: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.fromMiliseconds = t.toMiliseconds = void 0);
      let i = r(25648);
      (t.toMiliseconds = function (e) {
        return e * i.ONE_THOUSAND;
      }),
        (t.fromMiliseconds = function (e) {
          return Math.floor(e / i.ONE_THOUSAND);
        });
    },
    26368: (e, t, r) => {
      "use strict";
      r.d(t, { lY: () => v });
      var i = r(20413),
        n = r(890);
      let s = BigInt(0),
        a = BigInt(1),
        o = BigInt(2),
        c = BigInt(7),
        l = BigInt(256),
        d = BigInt(113),
        h = [],
        u = [],
        p = [];
      for (let e = 0, t = a, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          h.push(2 * (5 * i + r)),
          u.push((((e + 1) * (e + 2)) / 2) % 64);
        let n = s;
        for (let e = 0; e < 7; e++)
          (t = ((t << a) ^ ((t >> c) * d)) % l) & o &&
            (n ^= a << ((a << BigInt(e)) - a));
        p.push(n);
      }
      let f = (0, i.lD)(p, !0),
        g = f[0],
        m = f[1],
        y = (e, t, r) => (r > 32 ? (0, i.WM)(e, t, r) : (0, i.P5)(e, t, r)),
        w = (e, t, r) => (r > 32 ? (0, i.im)(e, t, r) : (0, i.B4)(e, t, r));
      class b extends n.Vw {
        constructor(e, t, r, i = !1, s = 24) {
          if (
            (super(),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (this.enableXOF = !1),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = s),
            (0, n.Fe)(r),
            !(0 < e && e < 200))
          )
            throw Error("only keccak-f1600 function is supported");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, n.DH)(this.state));
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          (0, n.fd)(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    n = (t + 2) % 10,
                    s = r[n],
                    a = r[n + 1],
                    o = y(s, a, 1) ^ r[i],
                    c = w(s, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  n = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = u[r],
                    s = y(t, n, i),
                    a = w(t, n, i),
                    o = h[r];
                  (t = e[o]), (n = e[o + 1]), (e[o] = s), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= g[i]), (e[1] ^= m[i]);
              }
              (0, n.uH)(r);
            })(this.state32, this.rounds),
            (0, n.fd)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, n.CC)(this), (e = (0, n.ZJ)(e)), (0, n.DO)(e);
          let { blockLen: t, state: r } = this,
            i = e.length;
          for (let n = 0; n < i; ) {
            let s = Math.min(t - this.pos, i - n);
            for (let t = 0; t < s; t++) r[this.pos++] ^= e[n++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, n.CC)(this, !1), (0, n.DO)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
              (this.posOut += s),
              (i += s);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, n.Fe)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, n.Ht)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), (0, n.uH)(this.state);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: n,
            enableXOF: s,
          } = this;
          return (
            e || (e = new b(t, r, i, s, n)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = n),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = s),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let v = (() => (0, n.qj)(() => new b(136, 1, 32)))();
    },
    26662: (e, t) => {
      "use strict";
      function r(e) {
        let t;
        return (
          "undefined" != typeof window &&
            void 0 !== window[e] &&
            (t = window[e]),
          t
        );
      }
      function i(e) {
        let t = r(e);
        if (!t) throw Error(`${e} is not defined in Window`);
        return t;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.getLocalStorage =
          t.getLocalStorageOrThrow =
          t.getCrypto =
          t.getCryptoOrThrow =
          t.getLocation =
          t.getLocationOrThrow =
          t.getNavigator =
          t.getNavigatorOrThrow =
          t.getDocument =
          t.getDocumentOrThrow =
          t.getFromWindowOrThrow =
          t.getFromWindow =
            void 0),
        (t.getFromWindow = r),
        (t.getFromWindowOrThrow = i),
        (t.getDocumentOrThrow = function () {
          return i("document");
        }),
        (t.getDocument = function () {
          return r("document");
        }),
        (t.getNavigatorOrThrow = function () {
          return i("navigator");
        }),
        (t.getNavigator = function () {
          return r("navigator");
        }),
        (t.getLocationOrThrow = function () {
          return i("location");
        }),
        (t.getLocation = function () {
          return r("location");
        }),
        (t.getCryptoOrThrow = function () {
          return i("crypto");
        }),
        (t.getCrypto = function () {
          return r("crypto");
        }),
        (t.getLocalStorageOrThrow = function () {
          return i("localStorage");
        }),
        (t.getLocalStorage = function () {
          return r("localStorage");
        });
    },
    26670: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964);
      r(21129), r(24772);
      var a = r(71084),
        o = r(47327),
        c = r(20296);
      let l = (0, c.AH)`
  :host {
    width: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: ${({ spacing: e }) => e[3]};
    width: 100%;
    background-color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[4]};
    transition:
      background-color ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      scale ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]};
    will-change: background-color, scale;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-image {
    color: ${({ tokens: e }) => e.theme.textPrimary};
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    }
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.imageSrc = "google"),
            (this.loading = !1),
            (this.disabled = !1),
            (this.rightIcon = !0),
            (this.rounded = !1),
            (this.fullSize = !1);
        }
        render() {
          return (
            (this.dataset.rounded = this.rounded ? "true" : "false"),
            (0, i.qy)`
      <button
        ?disabled=${!!this.loading || !!this.disabled}
        data-loading=${this.loading}
        tabindex=${(0, s.J)(this.tabIdx)}
      >
        <wui-flex gap="2" alignItems="center">
          ${this.templateLeftIcon()}
          <wui-flex gap="1">
            <slot></slot>
          </wui-flex>
        </wui-flex>
        ${this.templateRightIcon()}
      </button>
    `
          );
        }
        templateLeftIcon() {
          return this.icon
            ? (0, i.qy)`<wui-image
        icon=${this.icon}
        iconColor=${(0, s.J)(this.iconColor)}
        ?boxed=${!0}
        ?rounded=${this.rounded}
      ></wui-image>`
            : (0, i.qy)`<wui-image
      ?boxed=${!0}
      ?rounded=${this.rounded}
      ?fullSize=${this.fullSize}
      src=${this.imageSrc}
    ></wui-image>`;
        }
        templateRightIcon() {
          return this.rightIcon
            ? this.loading
              ? (0,
                i.qy)`<wui-loading-spinner size="md" color="accent-primary"></wui-loading-spinner>`
              : (0,
                i.qy)`<wui-icon name="chevronRight" size="lg" color="default"></wui-icon>`
            : null;
        }
      };
      (h.styles = [a.W5, a.fD, l]),
        d([(0, n.MZ)()], h.prototype, "imageSrc", void 0),
        d([(0, n.MZ)()], h.prototype, "icon", void 0),
        d([(0, n.MZ)()], h.prototype, "iconColor", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "loading", void 0),
        d([(0, n.MZ)()], h.prototype, "tabIdx", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "disabled", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "rightIcon", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "rounded", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "fullSize", void 0),
        (h = d([(0, o.E)("wui-list-item")], h));
    },
    27313: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => n });
      var i = r(83138);
      let n = (0, i.JW)`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
    },
    27747: (e, t, r) => {
      "use strict";
      r.d(t, { B4: () => n, SK: () => s, hX: () => a });
      var i = r(13933);
      class n extends i.C {
        constructor({ offset: e }) {
          super(`Offset \`${e}\` cannot be negative.`, {
            name: "NegativeOffsetError",
          });
        }
      }
      class s extends i.C {
        constructor({ length: e, position: t }) {
          super(
            `Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,
            { name: "PositionOutOfBoundsError" }
          );
        }
      }
      class a extends i.C {
        constructor({ count: e, limit: t }) {
          super(
            `Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,
            { name: "RecursiveReadLimitExceededError" }
          );
        }
      }
    },
    28245: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => s });
      var i = r(62023),
        n = r(30598);
      function s(e, t = "wei") {
        return (0, n.J)(e, i.eL[t]);
      }
    },
    28977: (e, t, r) => {
      "use strict";
      r.d(t, { Db: () => o, oU: () => c, tM: () => a });
      var i = r(45553),
        n = r(95704);
      let s =
          (void 0 !== n && void 0 !== n.env
            ? n.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        a = [
          {
            label: "Meld.io",
            name: "meld",
            feeRange: "1-2%",
            url: "https://meldcrypto.com",
            supportedChains: ["eip155", "solana"],
          },
        ],
        o = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
        c = {
          FOUR_MINUTES_MS: 24e4,
          TEN_SEC_MS: 1e4,
          FIVE_SEC_MS: 5e3,
          THREE_SEC_MS: 3e3,
          ONE_SEC_MS: 1e3,
          SECURE_SITE: s,
          SECURE_SITE_DASHBOARD: `${s}/dashboard`,
          SECURE_SITE_FAVICON: `${s}/images/favicon.png`,
          SOLANA_NATIVE_TOKEN_ADDRESS:
            "So11111111111111111111111111111111111111111",
          RESTRICTED_TIMEZONES: [
            "ASIA/SHANGHAI",
            "ASIA/URUMQI",
            "ASIA/CHONGQING",
            "ASIA/HARBIN",
            "ASIA/KASHGAR",
            "ASIA/MACAU",
            "ASIA/HONG_KONG",
            "ASIA/MACAO",
            "ASIA/BEIJING",
            "ASIA/HARBIN",
          ],
          SWAP_SUGGESTED_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
          ],
          SWAP_POPULAR_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
            "METAL",
            "DAI",
            "CHAMP",
            "WOLF",
            "SALE",
            "BAL",
            "BUSD",
            "MUST",
            "BTCpx",
            "ROUTE",
            "HEX",
            "WELT",
            "amDAI",
            "VSQ",
            "VISION",
            "AURUM",
            "pSP",
            "SNX",
            "VC",
            "LINK",
            "CHP",
            "amUSDT",
            "SPHERE",
            "FOX",
            "GIDDY",
            "GFC",
            "OMEN",
            "OX_OLD",
            "DE",
            "WNT",
          ],
          BALANCE_SUPPORTED_CHAINS: [i.o.CHAIN.EVM, i.o.CHAIN.SOLANA],
          SEND_PARAMS_SUPPORTED_CHAINS: [i.o.CHAIN.EVM],
          SWAP_SUPPORTED_NETWORKS: [
            "eip155:1",
            "eip155:42161",
            "eip155:10",
            "eip155:324",
            "eip155:8453",
            "eip155:56",
            "eip155:137",
            "eip155:100",
            "eip155:43114",
            "eip155:250",
            "eip155:8217",
            "eip155:1313161554",
          ],
          NAMES_SUPPORTED_CHAIN_NAMESPACES: [i.o.CHAIN.EVM],
          ONRAMP_SUPPORTED_CHAIN_NAMESPACES: [i.o.CHAIN.EVM, i.o.CHAIN.SOLANA],
          PAY_WITH_EXCHANGE_SUPPORTED_CHAIN_NAMESPACES: [
            i.o.CHAIN.EVM,
            i.o.CHAIN.SOLANA,
          ],
          ACTIVITY_ENABLED_CHAIN_NAMESPACES: [i.o.CHAIN.EVM],
          NATIVE_TOKEN_ADDRESS: {
            eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            solana: "So11111111111111111111111111111111111111111",
            polkadot: "0x",
            bip122: "0x",
            cosmos: "0x",
            sui: "0x",
            stacks: "0x",
          },
          CONVERT_SLIPPAGE_TOLERANCE: 1,
          CONNECT_LABELS: {
            MOBILE: "Open and continue in the wallet app",
            WEB: "Open and continue in the wallet app",
          },
          SEND_SUPPORTED_NAMESPACES: [i.o.CHAIN.EVM, i.o.CHAIN.SOLANA],
          DEFAULT_REMOTE_FEATURES: {
            swaps: ["1inch"],
            onramp: ["meld"],
            email: !0,
            socials: [
              "google",
              "x",
              "discord",
              "farcaster",
              "github",
              "apple",
              "facebook",
            ],
            activity: !0,
            reownBranding: !0,
            multiWallet: !1,
            emailCapture: !1,
            payWithExchange: !1,
            payments: !1,
            reownAuthentication: !1,
          },
          DEFAULT_REMOTE_FEATURES_DISABLED: {
            email: !1,
            socials: !1,
            swaps: !1,
            onramp: !1,
            activity: !1,
            reownBranding: !1,
            emailCapture: !1,
            reownAuthentication: !1,
          },
          DEFAULT_FEATURES: {
            receive: !0,
            send: !0,
            emailShowWallets: !0,
            connectorTypeOrder: [
              "walletConnect",
              "recent",
              "injected",
              "featured",
              "custom",
              "external",
              "recommended",
            ],
            analytics: !0,
            allWallets: !0,
            legalCheckbox: !1,
            smartSessions: !1,
            collapseWallets: !1,
            walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
            connectMethodsOrder: void 0,
            pay: !1,
            reownAuthentication: !1,
          },
          DEFAULT_SOCIALS: [
            "google",
            "x",
            "farcaster",
            "discord",
            "apple",
            "github",
            "facebook",
          ],
          DEFAULT_ACCOUNT_TYPES: {
            bip122: "payment",
            eip155: "smartAccount",
            polkadot: "eoa",
            solana: "eoa",
          },
          ADAPTER_TYPES: {
            UNIVERSAL: "universal",
            SOLANA: "solana",
            WAGMI: "wagmi",
            ETHERS: "ethers",
            ETHERS5: "ethers5",
            BITCOIN: "bitcoin",
          },
          SIWX_DEFAULTS: { signOutOnDisconnect: !0 },
        };
    },
    29454: (e, t, r) => {
      "use strict";
      r.d(t, {
        EH: () => s,
        YE: () => o,
        jF: () => a,
        qD: () => c,
        rj: () => n,
      });
      var i = r(13933);
      class n extends i.C {
        constructor({ blockNumber: e, chain: t, contract: r }) {
          super(`Chain "${t.name}" does not support contract "${r.name}".`, {
            metaMessages: [
              "This could be due to any of the following:",
              ...(e && r.blockCreated && r.blockCreated > e
                ? [
                    `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`,
                  ]
                : [
                    `- The chain does not have the contract "${r.name}" configured.`,
                  ]),
            ],
            name: "ChainDoesNotSupportContract",
          });
        }
      }
      class s extends i.C {
        constructor({ chain: e, currentChainId: t }) {
          super(
            `The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`,
            {
              metaMessages: [
                `Current Chain ID:  ${t}`,
                `Expected Chain ID: ${e.id}  ${e.name}`,
              ],
              name: "ChainMismatchError",
            }
          );
        }
      }
      class a extends i.C {
        constructor() {
          super(
            "No chain was provided to the request.\nPlease provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.",
            { name: "ChainNotFoundError" }
          );
        }
      }
      class o extends i.C {
        constructor() {
          super("No chain was provided to the Client.", {
            name: "ClientChainNotConfiguredError",
          });
        }
      }
      class c extends i.C {
        constructor({ chainId: e }) {
          super(
            "number" == typeof e
              ? `Chain ID "${e}" is invalid.`
              : "Chain ID is invalid.",
            { name: "InvalidChainIdError" }
          );
        }
      }
    },
    29762: (e, t) => {
      t.isValid = function (e) {
        return !isNaN(e) && e >= 1 && e <= 40;
      };
    },
    29936: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => o });
      var i = r(1220),
        n = r(98866),
        s = r(36964);
      let a = (0, i.BX)({
          walletImages: {},
          networkImages: {},
          chainImages: {},
          connectorImages: {},
          tokenImages: {},
          currencyImages: {},
        }),
        o = (0, s.X)({
          state: a,
          subscribeNetworkImages: (e) =>
            (0, i.B1)(a.networkImages, () => e(a.networkImages)),
          subscribeKey: (e, t) => (0, n.u$)(a, e, t),
          subscribe: (e) => (0, i.B1)(a, () => e(a)),
          setWalletImage(e, t) {
            a.walletImages[e] = t;
          },
          setNetworkImage(e, t) {
            a.networkImages[e] = t;
          },
          setChainImage(e, t) {
            a.chainImages[e] = t;
          },
          setConnectorImage(e, t) {
            a.connectorImages = { ...a.connectorImages, [e]: t };
          },
          setTokenImage(e, t) {
            a.tokenImages[e] = t;
          },
          setCurrencyImage(e, t) {
            a.currencyImages[e] = t;
          },
        });
    },
    30112: (e, t, r) => {
      "use strict";
      r.d(t, { Up: () => f });
      var i = r(1220),
        n = r(45553),
        s = r(93481),
        a = r(10899),
        o = r(70417),
        c = r(67869),
        l = r(65374),
        d = r(12319),
        h = r(58653);
      async function u() {
        c.I.push("ConnectingFarcaster");
        let e = a.a.getAuthConnector();
        if (e) {
          let t = s.W.getAccountData();
          if (!t?.farcasterUrl)
            try {
              let { url: t } = await e.provider.getFarcasterUri();
              s.W.setAccountProp("farcasterUrl", t, s.W.state.activeChain);
            } catch (e) {
              c.I.goBack(), l.P.showError(e);
            }
        }
      }
      async function p(e) {
        c.I.push("ConnectingSocial");
        let t = a.a.getAuthConnector(),
          r = null;
        try {
          let a = setTimeout(() => {
            throw Error("Social login timed out. Please try again.");
          }, 45e3);
          if (t && e) {
            if (
              (d.w.isTelegram() ||
                (r = (function () {
                  try {
                    return d.w.returnOpenHref(
                      `${n.o.SECURE_SITE_SDK_ORIGIN}/loading`,
                      "popupWindow",
                      "width=600,height=800,scrollbars=yes"
                    );
                  } catch (e) {
                    throw Error("Could not open social popup");
                  }
                })()),
              r)
            )
              s.W.setAccountProp(
                "socialWindow",
                (0, i.KR)(r),
                s.W.state.activeChain
              );
            else if (!d.w.isTelegram())
              throw Error("Could not create social popup");
            let { uri: o } = await t.provider.getSocialRedirectUri({
              provider: e,
            });
            if (!o)
              throw (
                (r?.close(), Error("Could not fetch the social redirect uri"))
              );
            if ((r && (r.location.href = o), d.w.isTelegram())) {
              h.i.setTelegramSocialProvider(e);
              let t = d.w.formatTelegramSocialLoginUrl(o);
              d.w.openHref(t, "_top");
            }
            clearTimeout(a);
          }
        } catch (e) {
          r?.close(), l.P.showError(e?.message);
        }
      }
      async function f(e) {
        s.W.setAccountProp("socialProvider", e, s.W.state.activeChain),
          o.E.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_STARTED",
            properties: { provider: e },
          }),
          "farcaster" === e ? await u() : await p(e);
      }
    },
    30598: (e, t, r) => {
      "use strict";
      function i(e, t) {
        let r = e.toString(),
          i = r.startsWith("-");
        i && (r = r.slice(1));
        let [n, s] = [
          (r = r.padStart(t, "0")).slice(0, r.length - t),
          r.slice(r.length - t),
        ];
        return (
          (s = s.replace(/(0+)$/, "")),
          `${i ? "-" : ""}${n || "0"}${s ? `.${s}` : ""}`
        );
      }
      r.d(t, { J: () => i });
    },
    30718: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => s });
      var i = r(55563),
        n = r(34561);
      function s(e) {
        let { kzg: t } = e,
          r = e.to ?? ("string" == typeof e.blobs[0] ? "hex" : "bytes"),
          s =
            "string" == typeof e.blobs[0]
              ? e.blobs.map((e) => (0, i.aT)(e))
              : e.blobs,
          a = [];
        for (let e of s) a.push(Uint8Array.from(t.blobToKzgCommitment(e)));
        return "bytes" === r ? a : a.map((e) => (0, n.My)(e));
      }
    },
    30982: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { Z: () => y });
      var n = r(4486),
        s = r(30598),
        a = r(45553),
        o = r(65103),
        c = r(44826),
        l = r(93481),
        d = r(97418),
        h = r(10899);
      let u = {
        createBalance(e, t) {
          let r = {
            name: e.metadata.name || "",
            symbol: e.metadata.symbol || "",
            decimals: e.metadata.decimals || 0,
            value: e.metadata.value || 0,
            price: e.metadata.price || 0,
            iconUrl: e.metadata.iconUrl || "",
          };
          return {
            name: r.name,
            symbol: r.symbol,
            chainId: t,
            address:
              "native" === e.address
                ? void 0
                : this.convertAddressToCAIP10Address(e.address, t),
            value: r.value,
            price: r.price,
            quantity: {
              decimals: r.decimals.toString(),
              numeric: this.convertHexToBalance({
                hex: e.balance,
                decimals: r.decimals,
              }),
            },
            iconUrl: r.iconUrl,
          };
        },
        convertHexToBalance: ({ hex: e, decimals: t }) =>
          (0, s.J)(BigInt(e), t),
        convertAddressToCAIP10Address: (e, t) => `${t}:${e}`,
        createCAIP2ChainId: (e, t) => `${t}:${parseInt(e, 16)}`,
        getChainIdHexFromCAIP2ChainId(e) {
          let t = e.split(":");
          if (t.length < 2 || !t[1]) return "0x0";
          let r = parseInt(t[1], 10);
          return isNaN(r) ? "0x0" : `0x${r.toString(16)}`;
        },
        isWalletGetAssetsResponse(e) {
          return (
            "object" == typeof e &&
            null !== e &&
            Object.values(e).every(
              (e) => Array.isArray(e) && e.every((e) => this.isValidAsset(e))
            )
          );
        },
        isValidAsset: (e) =>
          "object" == typeof e &&
          null !== e &&
          "string" == typeof e.address &&
          "string" == typeof e.balance &&
          ("ERC20" === e.type || "NATIVE" === e.type) &&
          "object" == typeof e.metadata &&
          null !== e.metadata &&
          "string" == typeof e.metadata.name &&
          "string" == typeof e.metadata.symbol &&
          "number" == typeof e.metadata.decimals &&
          "number" == typeof e.metadata.price &&
          "string" == typeof e.metadata.iconUrl,
      };
      var p = r(58653),
        f = r(55480);
      async function g() {
        if (!i) {
          let {
            createPublicClient: e,
            http: t,
            defineChain: n,
          } = await Promise.all([
            r.e(1365),
            r.e(837),
            r.e(902),
            r.e(4209),
          ]).then(r.bind(r, 44209));
          i = { createPublicClient: e, http: t, defineChain: n };
        }
        return i;
      }
      let m = {
          getBlockchainApiRpcUrl(e, t) {
            let r = new URL("https://rpc.walletconnect.org/v1/");
            return (
              r.searchParams.set("chainId", e),
              r.searchParams.set("projectId", t),
              r.toString()
            );
          },
          async getViemChain(e) {
            let { defineChain: t } = await g(),
              { chainId: r } = o.C.parseCaipNetworkId(e.caipNetworkId);
            return t({ ...e, id: Number(r) });
          },
          async createViemPublicClient(e) {
            let { createPublicClient: t, http: r } = await g(),
              i = f.H.state.projectId,
              n = await m.getViemChain(e);
            if (!n)
              throw Error(`Chain ${e.caipNetworkId} not found in viem/chains`);
            return t({
              chain: n,
              transport: r(m.getBlockchainApiRpcUrl(e.caipNetworkId, i)),
            });
          },
        },
        y = {
          async getMyTokensWithBalance(e) {
            let t = l.W.getAccountData()?.address,
              r = l.W.state.activeCaipNetwork,
              i = h.a.getConnectorId("eip155") === a.o.CONNECTOR_ID.AUTH;
            if (!t || !r) return [];
            let n = `${r.caipNetworkId}:${t}`,
              s = p.i.getBalanceCacheForCaipAddress(n);
            if (s) return s.balances;
            if (r.chainNamespace === a.o.CHAIN.EVM && i) {
              let e = await this.getEIP155Balances(t, r);
              if (e) return this.filterLowQualityTokens(e);
            }
            let o = await c.T.getBalance(t, r.caipNetworkId, e);
            return this.filterLowQualityTokens(o.balances);
          },
          async getEIP155Balances(e, t) {
            try {
              let r = u.getChainIdHexFromCAIP2ChainId(t.caipNetworkId),
                i = await d.x.getCapabilities(e);
              if (!i?.[r]?.assetDiscovery?.supported) return null;
              let n = await d.x.walletGetAssets({
                account: e,
                chainFilter: [r],
              });
              if (!u.isWalletGetAssetsResponse(n)) return null;
              let s = (n[r] || []).map((e) =>
                u.createBalance(e, t.caipNetworkId)
              );
              return (
                p.i.updateBalanceCache({
                  caipAddress: `${t.caipNetworkId}:${e}`,
                  balance: { balances: s },
                  timestamp: Date.now(),
                }),
                s
              );
            } catch (e) {
              return null;
            }
          },
          filterLowQualityTokens: (e) =>
            e.filter((e) => "0" !== e.quantity.decimals),
          async fetchERC20Balance({
            caipAddress: e,
            assetAddress: t,
            caipNetwork: r,
          }) {
            let i = await m.createViemPublicClient(r),
              { address: a } = o.C.parseCaipAddress(e),
              [{ result: c }, { result: l }, { result: d }, { result: h }] =
                await i.multicall({
                  contracts: [
                    { address: t, functionName: "name", args: [], abi: n.xw },
                    { address: t, functionName: "symbol", args: [], abi: n.xw },
                    {
                      address: t,
                      functionName: "balanceOf",
                      args: [a],
                      abi: n.xw,
                    },
                    {
                      address: t,
                      functionName: "decimals",
                      args: [],
                      abi: n.xw,
                    },
                  ],
                });
            return {
              name: c,
              symbol: l,
              decimals: h,
              balance: d && h ? (0, s.J)(d, h) : "0",
            };
          },
        };
    },
    31937: (e, t, r) => {
      let i = r(89158),
        n = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          "$",
          "%",
          "*",
          "+",
          "-",
          ".",
          "/",
          ":",
        ];
      function s(e) {
        (this.mode = i.ALPHANUMERIC), (this.data = e);
      }
      (s.getBitsLength = function (e) {
        return 11 * Math.floor(e / 2) + (e % 2) * 6;
      }),
        (s.prototype.getLength = function () {
          return this.data.length;
        }),
        (s.prototype.getBitsLength = function () {
          return s.getBitsLength(this.data.length);
        }),
        (s.prototype.write = function (e) {
          let t;
          for (t = 0; t + 2 <= this.data.length; t += 2) {
            let r = 45 * n.indexOf(this.data[t]);
            (r += n.indexOf(this.data[t + 1])), e.put(r, 11);
          }
          this.data.length % 2 && e.put(n.indexOf(this.data[t]), 6);
        }),
        (e.exports = s);
    },
    32009: (e, t, r) => {
      "use strict";
      r.d(t, { G: () => o });
      var i = r(1220),
        n = r(98866);
      let s = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
          cosmos: void 0,
          sui: void 0,
          stacks: void 0,
        },
        a = (0, i.BX)({ providers: { ...s }, providerIds: { ...s } }),
        o = {
          state: a,
          subscribeKey: (e, t) => (0, n.u$)(a, e, t),
          subscribe: (e) =>
            (0, i.B1)(a, () => {
              e(a);
            }),
          subscribeProviders: (e) =>
            (0, i.B1)(a.providers, () => e(a.providers)),
          setProvider(e, t) {
            e && t && (a.providers[e] = (0, i.KR)(t));
          },
          getProvider(e) {
            if (e) return a.providers[e];
          },
          setProviderId(e, t) {
            t && (a.providerIds[e] = t);
          },
          getProviderId(e) {
            if (e) return a.providerIds[e];
          },
          reset() {
            (a.providers = { ...s }), (a.providerIds = { ...s });
          },
          resetChain(e) {
            (a.providers[e] = void 0), (a.providerIds[e] = void 0);
          },
        };
    },
    32464: (e, t, r) => {
      "use strict";
      async function i(...e) {
        let t = await fetch(...e);
        if (!t.ok) throw Error(`HTTP status code: ${t.status}`, { cause: t });
        return t;
      }
      r.d(t, { Z: () => n });
      class n {
        constructor({ baseUrl: e, clientId: t }) {
          (this.baseUrl = e), (this.clientId = t);
        }
        async get({ headers: e, signal: t, cache: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, { method: "GET", headers: e, signal: t, cache: r })
          ).json();
        }
        async getBlob({ headers: e, signal: t, ...r }) {
          let n = this.createUrl(r);
          return (await i(n, { method: "GET", headers: e, signal: t })).blob();
        }
        async post({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "POST",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async put({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "PUT",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async delete({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "DELETE",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        createUrl({ path: e, params: t }) {
          let r = new URL(e, this.baseUrl);
          return (
            t &&
              Object.entries(t).forEach(([e, t]) => {
                t && r.searchParams.append(e, t);
              }),
            this.clientId && r.searchParams.append("clientId", this.clientId),
            r
          );
        }
        sendBeacon({ body: e, ...t }) {
          let r = this.createUrl(t);
          return navigator.sendBeacon(
            r.toString(),
            e ? JSON.stringify(e) : void 0
          );
        }
      }
    },
    32973: (e, t, r) => {
      "use strict";
      r.d(t, { OA: () => i, WL: () => s, u$: () => n });
      let i = {
          ATTRIBUTE: 1,
          CHILD: 2,
          PROPERTY: 3,
          BOOLEAN_ATTRIBUTE: 4,
          EVENT: 5,
          ELEMENT: 6,
        },
        n =
          (e) =>
          (...t) => ({ _$litDirective$: e, values: t });
      class s {
        constructor(e) {}
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AT(e, t, r) {
          (this._$Ct = e), (this._$AM = t), (this._$Ci = r);
        }
        _$AS(e, t) {
          return this.update(e, t);
        }
        update(e, t) {
          return this.render(...t);
        }
      }
    },
    33791: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => i });
      let i = (0, r(91053).x)({
        id: 1,
        name: "Ethereum",
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        blockTime: 12e3,
        rpcUrls: { default: { http: ["https://eth.merkle.io"] } },
        blockExplorers: {
          default: {
            name: "Etherscan",
            url: "https://etherscan.io",
            apiUrl: "https://api.etherscan.io/api",
          },
        },
        contracts: {
          ensUniversalResolver: {
            address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
            blockCreated: 0x16041f6,
          },
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 0xdb04c1,
          },
        },
      });
    },
    34430: function (e) {
      e.exports = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          ),
        ordinal: function (e) {
          var t = ["th", "st", "nd", "rd"],
            r = e % 100;
          return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
        },
      };
    },
    34561: (e, t, r) => {
      "use strict";
      r.d(t, {
        $P: () => c,
        My: () => l,
        cK: () => d,
        i3: () => u,
        nj: () => o,
      });
      var i = r(35276),
        n = r(72427),
        s = r(11914);
      let a = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function o(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? d(e, t)
          : "string" == typeof e
          ? u(e, t)
          : "boolean" == typeof e
          ? c(e, t)
          : l(e, t);
      }
      function c(e, t = {}) {
        let r = `0x${Number(e)}`;
        return "number" == typeof t.size
          ? ((0, s.Sl)(r, { size: t.size }), (0, n.eV)(r, { size: t.size }))
          : r;
      }
      function l(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += a[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? ((0, s.Sl)(i, { size: t.size }),
            (0, n.eV)(i, { dir: "right", size: t.size }))
          : i;
      }
      function d(e, t = {}) {
        let r,
          { signed: s, size: a } = t,
          o = BigInt(e);
        a
          ? (r = s
              ? (1n << (8n * BigInt(a) - 1n)) - 1n
              : 2n ** (8n * BigInt(a)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let c = "bigint" == typeof r && s ? -r - 1n : 0;
        if ((r && o > r) || o < c) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new i.Ty({
            max: r ? `${r}${t}` : void 0,
            min: `${c}${t}`,
            signed: s,
            size: a,
            value: `${e}${t}`,
          });
        }
        let l = `0x${(s && o < 0
          ? (1n << BigInt(8 * a)) + BigInt(o)
          : o
        ).toString(16)}`;
        return a ? (0, n.eV)(l, { size: a }) : l;
      }
      let h = new TextEncoder();
      function u(e, t = {}) {
        return l(h.encode(e), t);
      }
    },
    34563: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691), r(45166), r(38534);
      var s = r(52769);
      function a(e, t, r) {
        return e !== t && (e - t < 0 ? t - e : e - t) <= r + 0.1;
      }
      let o = {
        generate({
          uri: e,
          size: t,
          logoSize: r,
          padding: n = 8,
          dotColor: o = "var(--apkt-colors-black)",
        }) {
          let c = [],
            l = (function (e, t) {
              let r = Array.prototype.slice.call(
                  s.create(e, { errorCorrectionLevel: "Q" }).modules.data,
                  0
                ),
                i = Math.sqrt(r.length);
              return r.reduce(
                (e, t, r) =>
                  (r % i == 0 ? e.push([t]) : e[e.length - 1].push(t)) && e,
                []
              );
            })(e, 0),
            d = (t - 2 * n) / l.length,
            h = [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 0, y: 1 },
            ];
          h.forEach(({ x: e, y: t }) => {
            let r = (l.length - 7) * d * e + n,
              s = (l.length - 7) * d * t + n;
            for (let e = 0; e < h.length; e += 1) {
              let t = d * (7 - 2 * e);
              c.push((0, i.JW)`
            <rect
              fill=${
                2 === e
                  ? "var(--apkt-colors-black)"
                  : "var(--apkt-colors-white)"
              }
              width=${0 === e ? t - 10 : t}
              rx= ${0 === e ? (t - 10) * 0.45 : 0.45 * t}
              ry= ${0 === e ? (t - 10) * 0.45 : 0.45 * t}
              stroke=${o}
              stroke-width=${10 * (0 === e)}
              height=${0 === e ? t - 10 : t}
              x= ${0 === e ? s + d * e + 5 : s + d * e}
              y= ${0 === e ? r + d * e + 5 : r + d * e}
            />
          `);
            }
          });
          let u = Math.floor((r + 25) / d),
            p = l.length / 2 - u / 2,
            f = l.length / 2 + u / 2 - 1,
            g = [];
          l.forEach((e, t) => {
            e.forEach((e, r) => {
              !l[t][r] ||
                (t < 7 && r < 7) ||
                (t > l.length - 8 && r < 7) ||
                (t < 7 && r > l.length - 8) ||
                (t > p && t < f && r > p && r < f) ||
                g.push([t * d + d / 2 + n, r * d + d / 2 + n]);
            });
          });
          let m = {};
          return (
            g.forEach(([e, t]) => {
              m[e] ? m[e]?.push(t) : (m[e] = [t]);
            }),
            Object.entries(m)
              .map(([e, t]) => {
                let r = t.filter((e) => t.every((t) => !a(e, t, d)));
                return [Number(e), r];
              })
              .forEach(([e, t]) => {
                t.forEach((t) => {
                  c.push(
                    (0, i.JW)`<circle cx=${e} cy=${t} fill=${o} r=${d / 2.5} />`
                  );
                });
              }),
            Object.entries(m)
              .filter(([e, t]) => t.length > 1)
              .map(([e, t]) => {
                let r = t.filter((e) => t.some((t) => a(e, t, d)));
                return [Number(e), r];
              })
              .map(([e, t]) => {
                t.sort((e, t) => (e < t ? -1 : 1));
                let r = [];
                for (let e of t) {
                  let t = r.find((t) => t.some((t) => a(e, t, d)));
                  t ? t.push(e) : r.push([e]);
                }
                return [e, r.map((e) => [e[0], e[e.length - 1]])];
              })
              .forEach(([e, t]) => {
                t.forEach(([t, r]) => {
                  c.push((0, i.JW)`
              <line
                x1=${e}
                x2=${e}
                y1=${t}
                y2=${r}
                stroke=${o}
                stroke-width=${d / 1.25}
                stroke-linecap="round"
              />
            `);
                });
              }),
            c
          );
        },
      };
      var c = r(71084),
        l = r(47327),
        d = r(20296);
      let h = (0, d.AH)`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: 100%;
    height: 100%;
    background-color: ${({ colors: e }) => e.white};
    border: 1px solid ${({ tokens: e }) => e.theme.borderPrimary};
  }

  :host {
    border-radius: ${({ borderRadius: e }) => e[4]};
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
    background-color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    box-shadow: inset 0 0 0 4px ${({ tokens: e }) => e.theme.backgroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[6]};
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }

  wui-icon > svg {
    width: inherit;
    height: inherit;
  }
`;
      var u = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let p = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.uri = ""),
            (this.size = 0),
            (this.theme = "dark"),
            (this.imageSrc = void 0),
            (this.alt = void 0),
            (this.arenaClear = void 0),
            (this.farcaster = void 0);
        }
        render() {
          return (
            (this.dataset.theme = this.theme),
            (this.dataset.clear = String(this.arenaClear)),
            (this.style.cssText = `--local-size: ${this.size}px`),
            (0, i.qy)`<wui-flex
      alignItems="center"
      justifyContent="center"
      class="wui-qr-code"
      direction="column"
      gap="4"
      width="100%"
      style="height: 100%"
    >
      ${this.templateVisual()} ${this.templateSvg()}
    </wui-flex>`
          );
        }
        templateSvg() {
          return (0, i.JW)`
      <svg height=${this.size} width=${this.size}>
        ${o.generate({
          uri: this.uri,
          size: this.size,
          logoSize: this.arenaClear ? 0 : this.size / 4,
        })}
      </svg>
    `;
        }
        templateVisual() {
          return this.imageSrc
            ? (0, i.qy)`<wui-image src=${this.imageSrc} alt=${
                this.alt ?? "logo"
              }></wui-image>`
            : this.farcaster
            ? (0, i.qy)`<wui-icon
        class="farcaster"
        size="inherit"
        color="inherit"
        name="farcaster"
      ></wui-icon>`
            : (0,
              i.qy)`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
        }
      };
      (p.styles = [c.W5, h]),
        u([(0, n.MZ)()], p.prototype, "uri", void 0),
        u([(0, n.MZ)({ type: Number })], p.prototype, "size", void 0),
        u([(0, n.MZ)()], p.prototype, "theme", void 0),
        u([(0, n.MZ)()], p.prototype, "imageSrc", void 0),
        u([(0, n.MZ)()], p.prototype, "alt", void 0),
        u([(0, n.MZ)({ type: Boolean })], p.prototype, "arenaClear", void 0),
        u([(0, n.MZ)({ type: Boolean })], p.prototype, "farcaster", void 0),
        (p = u([(0, l.E)("wui-qr-code")], p));
    },
    34777: (e, t, r) => {
      "use strict";
      r.d(t, {
        Dx: () => a,
        KO: () => h,
        Rt: () => n,
        cN: () => d,
        lx: () => o,
        mY: () => l,
      });
      let { I: i } = r(52321).ge,
        n = (e) => void 0 === e.strings,
        s = () => document.createComment(""),
        a = (e, t, r) => {
          let n = e._$AA.parentNode,
            a = void 0 === t ? e._$AB : t._$AA;
          if (void 0 === r)
            r = new i(
              n.insertBefore(s(), a),
              n.insertBefore(s(), a),
              e,
              e.options
            );
          else {
            let t = r._$AB.nextSibling,
              i = r._$AM,
              s = i !== e;
            if (s) {
              let t;
              r._$AQ?.(e),
                (r._$AM = e),
                void 0 !== r._$AP && (t = e._$AU) !== i._$AU && r._$AP(t);
            }
            if (t !== a || s) {
              let e = r._$AA;
              for (; e !== t; ) {
                let t = e.nextSibling;
                n.insertBefore(e, a), (e = t);
              }
            }
          }
          return r;
        },
        o = (e, t, r = e) => (e._$AI(t, r), e),
        c = {},
        l = (e, t = c) => (e._$AH = t),
        d = (e) => e._$AH,
        h = (e) => {
          e._$AR(), e._$AA.remove();
        };
    },
    35135: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(4959),
        a = r(36211);
      r(40575), r(77237), r(41163);
      let o = (0, a.AH)`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px ${({ spacing: e }) => e["3"]} 10px ${({ spacing: e }) =>
        e["3"]};
    border-radius: ${({ borderRadius: e }) => e["3"]};
    color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    position: absolute;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--apkt-modal-width) - ${({ spacing: e }) => e["5"]});
    transition: opacity ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity;
    opacity: 0;
    animation-duration: ${({ durations: e }) => e.xl};
    animation-timing-function: ${({ easings: e }) => e["ease-out-power-2"]};
    animation-name: fade-in;
    animation-fill-mode: forwards;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: ${({ tokens: e }) => e.theme.textPrimary};
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
`;
      var c = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let l = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.open = s.I.state.open),
            (this.message = s.I.state.message),
            (this.triggerRect = s.I.state.triggerRect),
            (this.variant = s.I.state.variant),
            this.unsubscribe.push(
              s.I.subscribe((e) => {
                (this.open = e.open),
                  (this.message = e.message),
                  (this.triggerRect = e.triggerRect),
                  (this.variant = e.variant);
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          this.dataset.variant = this.variant;
          let e = this.triggerRect.top,
            t = this.triggerRect.left;
          return (
            (this.style.cssText = `
    --w3m-tooltip-top: ${e}px;
    --w3m-tooltip-left: ${t}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${+!!this.open};
    `),
            (0, i.qy)`<wui-flex>
      <wui-icon data-placement="top" size="inherit" name="cursor"></wui-icon>
      <wui-text color="primary" variant="sm-regular">${this.message}</wui-text>
    </wui-flex>`
          );
        }
      };
      (l.styles = [o]),
        c([(0, n.wk)()], l.prototype, "open", void 0),
        c([(0, n.wk)()], l.prototype, "message", void 0),
        c([(0, n.wk)()], l.prototype, "triggerRect", void 0),
        c([(0, n.wk)()], l.prototype, "variant", void 0),
        (l = c([(0, a.EM)("w3m-tooltip")], l));
    },
    35276: (e, t, r) => {
      "use strict";
      r.d(t, { H2: () => a, Ty: () => n, u: () => o, xO: () => s });
      var i = r(13933);
      class n extends i.C {
        constructor({ max: e, min: t, signed: r, size: i, value: n }) {
          super(
            `Number "${n}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class s extends i.C {
        constructor(e) {
          super(
            `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
            { name: "InvalidBytesBooleanError" }
          );
        }
      }
      class a extends i.C {
        constructor(e) {
          super(
            `Hex value "${e}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,
            { name: "InvalidHexBooleanError" }
          );
        }
      }
      i.C;
      class o extends i.C {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
    },
    35425: (e) => {
      function t() {
        (this.buffer = []), (this.length = 0);
      }
      (t.prototype = {
        get: function (e) {
          let t = Math.floor(e / 8);
          return ((this.buffer[t] >>> (7 - (e % 8))) & 1) == 1;
        },
        put: function (e, t) {
          for (let r = 0; r < t; r++)
            this.putBit(((e >>> (t - r - 1)) & 1) == 1);
        },
        getLengthInBits: function () {
          return this.length;
        },
        putBit: function (e) {
          let t = Math.floor(this.length / 8);
          this.buffer.length <= t && this.buffer.push(0),
            e && (this.buffer[t] |= 128 >>> this.length % 8),
            this.length++;
        },
      }),
        (e.exports = t);
    },
    35630: (e, t, r) => {
      let i = r(46342).getSymbolSize;
      t.getPositions = function (e) {
        let t = i(e);
        return [
          [0, 0],
          [t - 7, 0],
          [0, t - 7],
        ];
      };
    },
    35766: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => d });
      var i = r(30718),
        n = r(17679),
        s = r(5082),
        a = r(82427),
        o = r(16871),
        c = r(55563),
        l = r(34561);
      function d(e) {
        let { data: t, kzg: r, to: d } = e,
          h =
            e.blobs ??
            (function (e) {
              let t = e.to ?? ("string" == typeof e.data ? "hex" : "bytes"),
                r = "string" == typeof e.data ? (0, c.aT)(e.data) : e.data,
                i = (0, o.E)(r);
              if (!i) throw new s.zF();
              if (i > 761855) throw new s.iq({ maxSize: 761855, size: i });
              let n = [],
                d = !0,
                h = 0;
              for (; d; ) {
                let e = (0, a.l)(new Uint8Array(131072)),
                  t = 0;
                for (; t < 4096; ) {
                  let i = r.slice(h, h + 31);
                  if ((e.pushByte(0), e.pushBytes(i), i.length < 31)) {
                    e.pushByte(128), (d = !1);
                    break;
                  }
                  t++, (h += 31);
                }
                n.push(e);
              }
              return "bytes" === t
                ? n.map((e) => e.bytes)
                : n.map((e) => (0, l.My)(e.bytes));
            })({ data: t, to: d }),
          u = e.commitments ?? (0, i.S)({ blobs: h, kzg: r, to: d }),
          p = e.proofs ?? (0, n.t)({ blobs: h, commitments: u, kzg: r, to: d }),
          f = [];
        for (let e = 0; e < h.length; e++)
          f.push({ blob: h[e], commitment: u[e], proof: p[e] });
        return f;
      }
    },
    36117: function (e) {
      e.exports = (function () {
        "use strict";
        var e = "millisecond",
          t = "second",
          r = "minute",
          i = "hour",
          n = "week",
          s = "month",
          a = "quarter",
          o = "year",
          c = "date",
          l = "Invalid Date",
          d =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          h =
            /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          u = function (e, t, r) {
            var i = String(e);
            return !i || i.length >= t
              ? e
              : "" + Array(t + 1 - i.length).join(r) + e;
          },
          p = "en",
          f = {};
        f[p] = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (e) {
            var t = ["th", "st", "nd", "rd"],
              r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
          },
        };
        var g = "$isDayjsObject",
          m = function (e) {
            return e instanceof v || !(!e || !e[g]);
          },
          y = function e(t, r, i) {
            var n;
            if (!t) return p;
            if ("string" == typeof t) {
              var s = t.toLowerCase();
              f[s] && (n = s), r && ((f[s] = r), (n = s));
              var a = t.split("-");
              if (!n && a.length > 1) return e(a[0]);
            } else {
              var o = t.name;
              (f[o] = t), (n = o);
            }
            return !i && n && (p = n), n || (!i && p);
          },
          w = function (e, t) {
            if (m(e)) return e.clone();
            var r = "object" == typeof t ? t : {};
            return (r.date = e), (r.args = arguments), new v(r);
          },
          b = {
            s: u,
            z: function (e) {
              var t = -e.utcOffset(),
                r = Math.abs(t);
              return (
                (t <= 0 ? "+" : "-") +
                u(Math.floor(r / 60), 2, "0") +
                ":" +
                u(r % 60, 2, "0")
              );
            },
            m: function e(t, r) {
              if (t.date() < r.date()) return -e(r, t);
              var i = 12 * (r.year() - t.year()) + (r.month() - t.month()),
                n = t.clone().add(i, s),
                a = r - n < 0,
                o = t.clone().add(i + (a ? -1 : 1), s);
              return +(-(i + (r - n) / (a ? n - o : o - n)) || 0);
            },
            a: function (e) {
              return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
            },
            p: function (l) {
              return (
                {
                  M: s,
                  y: o,
                  w: n,
                  d: "day",
                  D: c,
                  h: i,
                  m: r,
                  s: t,
                  ms: e,
                  Q: a,
                }[l] ||
                String(l || "")
                  .toLowerCase()
                  .replace(/s$/, "")
              );
            },
            u: function (e) {
              return void 0 === e;
            },
          };
        (b.l = y),
          (b.i = m),
          (b.w = function (e, t) {
            return w(e, {
              locale: t.$L,
              utc: t.$u,
              x: t.$x,
              $offset: t.$offset,
            });
          });
        var v = (function () {
            function u(e) {
              (this.$L = y(e.locale, null, !0)),
                this.parse(e),
                (this.$x = this.$x || e.x || {}),
                (this[g] = !0);
            }
            var p = u.prototype;
            return (
              (p.parse = function (e) {
                (this.$d = (function (e) {
                  var t = e.date,
                    r = e.utc;
                  if (null === t) return new Date(NaN);
                  if (b.u(t)) return new Date();
                  if (t instanceof Date) return new Date(t);
                  if ("string" == typeof t && !/Z$/i.test(t)) {
                    var i = t.match(d);
                    if (i) {
                      var n = i[2] - 1 || 0,
                        s = (i[7] || "0").substring(0, 3);
                      return r
                        ? new Date(
                            Date.UTC(
                              i[1],
                              n,
                              i[3] || 1,
                              i[4] || 0,
                              i[5] || 0,
                              i[6] || 0,
                              s
                            )
                          )
                        : new Date(
                            i[1],
                            n,
                            i[3] || 1,
                            i[4] || 0,
                            i[5] || 0,
                            i[6] || 0,
                            s
                          );
                    }
                  }
                  return new Date(t);
                })(e)),
                  this.init();
              }),
              (p.init = function () {
                var e = this.$d;
                (this.$y = e.getFullYear()),
                  (this.$M = e.getMonth()),
                  (this.$D = e.getDate()),
                  (this.$W = e.getDay()),
                  (this.$H = e.getHours()),
                  (this.$m = e.getMinutes()),
                  (this.$s = e.getSeconds()),
                  (this.$ms = e.getMilliseconds());
              }),
              (p.$utils = function () {
                return b;
              }),
              (p.isValid = function () {
                return this.$d.toString() !== l;
              }),
              (p.isSame = function (e, t) {
                var r = w(e);
                return this.startOf(t) <= r && r <= this.endOf(t);
              }),
              (p.isAfter = function (e, t) {
                return w(e) < this.startOf(t);
              }),
              (p.isBefore = function (e, t) {
                return this.endOf(t) < w(e);
              }),
              (p.$g = function (e, t, r) {
                return b.u(e) ? this[t] : this.set(r, e);
              }),
              (p.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (p.valueOf = function () {
                return this.$d.getTime();
              }),
              (p.startOf = function (e, a) {
                var l = this,
                  d = !!b.u(a) || a,
                  h = b.p(e),
                  u = function (e, t) {
                    var r = b.w(
                      l.$u ? Date.UTC(l.$y, t, e) : new Date(l.$y, t, e),
                      l
                    );
                    return d ? r : r.endOf("day");
                  },
                  p = function (e, t) {
                    return b.w(
                      l
                        .toDate()
                        [e].apply(
                          l.toDate("s"),
                          (d ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)
                        ),
                      l
                    );
                  },
                  f = this.$W,
                  g = this.$M,
                  m = this.$D,
                  y = "set" + (this.$u ? "UTC" : "");
                switch (h) {
                  case o:
                    return d ? u(1, 0) : u(31, 11);
                  case s:
                    return d ? u(1, g) : u(0, g + 1);
                  case n:
                    var w = this.$locale().weekStart || 0,
                      v = (f < w ? f + 7 : f) - w;
                    return u(d ? m - v : m + (6 - v), g);
                  case "day":
                  case c:
                    return p(y + "Hours", 0);
                  case i:
                    return p(y + "Minutes", 1);
                  case r:
                    return p(y + "Seconds", 2);
                  case t:
                    return p(y + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }),
              (p.endOf = function (e) {
                return this.startOf(e, !1);
              }),
              (p.$set = function (n, a) {
                var l,
                  d = b.p(n),
                  h = "set" + (this.$u ? "UTC" : ""),
                  u = (((l = {}).day = h + "Date"),
                  (l[c] = h + "Date"),
                  (l[s] = h + "Month"),
                  (l[o] = h + "FullYear"),
                  (l[i] = h + "Hours"),
                  (l[r] = h + "Minutes"),
                  (l[t] = h + "Seconds"),
                  (l[e] = h + "Milliseconds"),
                  l)[d],
                  p = "day" === d ? this.$D + (a - this.$W) : a;
                if (d === s || d === o) {
                  var f = this.clone().set(c, 1);
                  f.$d[u](p),
                    f.init(),
                    (this.$d = f.set(c, Math.min(this.$D, f.daysInMonth())).$d);
                } else u && this.$d[u](p);
                return this.init(), this;
              }),
              (p.set = function (e, t) {
                return this.clone().$set(e, t);
              }),
              (p.get = function (e) {
                return this[b.p(e)]();
              }),
              (p.add = function (e, a) {
                var c,
                  l = this;
                e = Number(e);
                var d = b.p(a),
                  h = function (t) {
                    var r = w(l);
                    return b.w(r.date(r.date() + Math.round(t * e)), l);
                  };
                if (d === s) return this.set(s, this.$M + e);
                if (d === o) return this.set(o, this.$y + e);
                if ("day" === d) return h(1);
                if (d === n) return h(7);
                var u =
                    (((c = {})[r] = 6e4), (c[i] = 36e5), (c[t] = 1e3), c)[d] ||
                    1,
                  p = this.$d.getTime() + e * u;
                return b.w(p, this);
              }),
              (p.subtract = function (e, t) {
                return this.add(-1 * e, t);
              }),
              (p.format = function (e) {
                var t = this,
                  r = this.$locale();
                if (!this.isValid()) return r.invalidDate || l;
                var i = e || "YYYY-MM-DDTHH:mm:ssZ",
                  n = b.z(this),
                  s = this.$H,
                  a = this.$m,
                  o = this.$M,
                  c = r.weekdays,
                  d = r.months,
                  u = r.meridiem,
                  p = function (e, r, n, s) {
                    return (e && (e[r] || e(t, i))) || n[r].slice(0, s);
                  },
                  f = function (e) {
                    return b.s(s % 12 || 12, e, "0");
                  },
                  g =
                    u ||
                    function (e, t, r) {
                      var i = e < 12 ? "AM" : "PM";
                      return r ? i.toLowerCase() : i;
                    };
                return i.replace(h, function (e, i) {
                  return (
                    i ||
                    (function (e) {
                      switch (e) {
                        case "YY":
                          return String(t.$y).slice(-2);
                        case "YYYY":
                          return b.s(t.$y, 4, "0");
                        case "M":
                          return o + 1;
                        case "MM":
                          return b.s(o + 1, 2, "0");
                        case "MMM":
                          return p(r.monthsShort, o, d, 3);
                        case "MMMM":
                          return p(d, o);
                        case "D":
                          return t.$D;
                        case "DD":
                          return b.s(t.$D, 2, "0");
                        case "d":
                          return String(t.$W);
                        case "dd":
                          return p(r.weekdaysMin, t.$W, c, 2);
                        case "ddd":
                          return p(r.weekdaysShort, t.$W, c, 3);
                        case "dddd":
                          return c[t.$W];
                        case "H":
                          return String(s);
                        case "HH":
                          return b.s(s, 2, "0");
                        case "h":
                          return f(1);
                        case "hh":
                          return f(2);
                        case "a":
                          return g(s, a, !0);
                        case "A":
                          return g(s, a, !1);
                        case "m":
                          return String(a);
                        case "mm":
                          return b.s(a, 2, "0");
                        case "s":
                          return String(t.$s);
                        case "ss":
                          return b.s(t.$s, 2, "0");
                        case "SSS":
                          return b.s(t.$ms, 3, "0");
                        case "Z":
                          return n;
                      }
                      return null;
                    })(e) ||
                    n.replace(":", "")
                  );
                });
              }),
              (p.utcOffset = function () {
                return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
              }),
              (p.diff = function (e, c, l) {
                var d,
                  h = this,
                  u = b.p(c),
                  p = w(e),
                  f = (p.utcOffset() - this.utcOffset()) * 6e4,
                  g = this - p,
                  m = function () {
                    return b.m(h, p);
                  };
                switch (u) {
                  case o:
                    d = m() / 12;
                    break;
                  case s:
                    d = m();
                    break;
                  case a:
                    d = m() / 3;
                    break;
                  case n:
                    d = (g - f) / 6048e5;
                    break;
                  case "day":
                    d = (g - f) / 864e5;
                    break;
                  case i:
                    d = g / 36e5;
                    break;
                  case r:
                    d = g / 6e4;
                    break;
                  case t:
                    d = g / 1e3;
                    break;
                  default:
                    d = g;
                }
                return l ? d : b.a(d);
              }),
              (p.daysInMonth = function () {
                return this.endOf(s).$D;
              }),
              (p.$locale = function () {
                return f[this.$L];
              }),
              (p.locale = function (e, t) {
                if (!e) return this.$L;
                var r = this.clone(),
                  i = y(e, t, !0);
                return i && (r.$L = i), r;
              }),
              (p.clone = function () {
                return b.w(this.$d, this);
              }),
              (p.toDate = function () {
                return new Date(this.valueOf());
              }),
              (p.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (p.toISOString = function () {
                return this.$d.toISOString();
              }),
              (p.toString = function () {
                return this.$d.toUTCString();
              }),
              u
            );
          })(),
          C = v.prototype;
        return (
          (w.prototype = C),
          [
            ["$ms", e],
            ["$s", t],
            ["$m", r],
            ["$H", i],
            ["$W", "day"],
            ["$M", s],
            ["$y", o],
            ["$D", c],
          ].forEach(function (e) {
            C[e[1]] = function (t) {
              return this.$g(t, e[0], e[1]);
            };
          }),
          (w.extend = function (e, t) {
            return e.$i || (e(t, v, w), (e.$i = !0)), w;
          }),
          (w.locale = y),
          (w.isDayjs = m),
          (w.unix = function (e) {
            return w(1e3 * e);
          }),
          (w.en = f[p]),
          (w.Ls = f),
          (w.p = {}),
          w
        );
      })();
    },
    36211: (e, t, r) => {
      "use strict";
      r.d(t, {
        z8: () => i,
        tt: () => l,
        Zv: () => s.Z,
        AH: () => h.AH,
        EM: () => d.E,
        RF: () => n.RF,
        JX: () => n.JX,
        ds: () => n.ds,
        f: () => h.f,
      });
      let i = {
        interpolate(e, t, r) {
          if (2 !== e.length || 2 !== t.length)
            throw Error(
              "inputRange and outputRange must be an array of length 2"
            );
          let i = e[0] || 0,
            n = e[1] || 0,
            s = t[0] || 0,
            a = t[1] || 0;
          return r < i ? s : r > n ? a : ((a - s) / (n - i)) * (r - i) + s;
        },
      };
      var n = r(71084),
        s = r(8821),
        a = r(12232);
      let o = ["receive", "deposit", "borrow", "claim"],
        c = ["withdraw", "repay", "burn"],
        l = {
          getTransactionGroupTitle(e, t) {
            let r = a.r.getYear(),
              i = a.r.getMonthNameByIndex(t);
            return e === r ? i : `${i} ${e}`;
          },
          getTransactionImages(e) {
            let [t] = e;
            return e?.length > 1
              ? e.map((e) => this.getTransactionImage(e))
              : [this.getTransactionImage(t)];
          },
          getTransactionImage: (e) => ({
            type: l.getTransactionTransferTokenType(e),
            url: l.getTransactionImageURL(e),
          }),
          getTransactionImageURL(e) {
            let t,
              r = !!e?.nft_info,
              i = !!e?.fungible_info;
            return (
              e && r
                ? (t = e?.nft_info?.content?.preview?.url)
                : e && i && (t = e?.fungible_info?.icon?.url),
              t
            );
          },
          getTransactionTransferTokenType: (e) =>
            e?.fungible_info ? "FUNGIBLE" : e?.nft_info ? "NFT" : void 0,
          getTransactionDescriptions(e, t) {
            let r = e?.metadata?.operationType,
              i = t || e?.transfers,
              n = i?.length > 0,
              a = i?.length > 1,
              l = n && i?.every((e) => !!e?.fungible_info),
              [d, h] = i,
              u = this.getTransferDescription(d),
              p = this.getTransferDescription(h);
            if (!n)
              return ("send" === r || "receive" === r) && l
                ? [
                    (u = s.Z.getTruncateString({
                      string: e?.metadata.sentFrom,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    })),
                    s.Z.getTruncateString({
                      string: e?.metadata.sentTo,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    }),
                  ]
                : [e.metadata.status];
            if (a) return i.map((e) => this.getTransferDescription(e));
            let f = "";
            return (
              o.includes(r) ? (f = "+") : c.includes(r) && (f = "-"),
              [(u = f.concat(u))]
            );
          },
          getTransferDescription(e) {
            let t = "";
            return (
              e &&
                (e?.nft_info
                  ? (t = e?.nft_info?.name || "-")
                  : e?.fungible_info &&
                    (t = this.getFungibleTransferDescription(e) || "-")),
              t
            );
          },
          getFungibleTransferDescription(e) {
            return e
              ? [
                  this.getQuantityFixedValue(e?.quantity.numeric),
                  e?.fungible_info?.symbol,
                ]
                  .join(" ")
                  .trim()
              : null;
          },
          mergeTransfers(e) {
            if (e?.length <= 1) return e;
            let t = this.filterGasFeeTransfers(e).reduce((e, t) => {
                let r = t?.fungible_info?.name,
                  i = e.find(
                    ({ fungible_info: e, direction: i }) =>
                      r && r === e?.name && i === t.direction
                  );
                if (i) {
                  let e =
                    Number(i.quantity.numeric) + Number(t.quantity.numeric);
                  (i.quantity.numeric = e.toString()),
                    (i.value = (i.value || 0) + (t.value || 0));
                } else e.push(t);
                return e;
              }, []),
              r = t;
            return (
              t.length > 2 &&
                (r = t
                  .sort((e, t) => (t.value || 0) - (e.value || 0))
                  .slice(0, 2)),
              (r = r.sort((e, t) =>
                "out" === e.direction && "in" === t.direction
                  ? -1
                  : +("in" === e.direction && "out" === t.direction)
              ))
            );
          },
          filterGasFeeTransfers(e) {
            let t = e.reduce((e, t) => {
                let r = t?.fungible_info?.name;
                return r && (e[r] || (e[r] = []), e[r].push(t)), e;
              }, {}),
              r = [];
            return (
              Object.values(t).forEach((e) => {
                if (1 === e.length) {
                  let t = e[0];
                  t && r.push(t);
                } else {
                  let t = e.filter((e) => "in" === e.direction),
                    i = e.filter((e) => "out" === e.direction);
                  if (1 === t.length && 1 === i.length) {
                    let n = t[0],
                      s = i[0],
                      a = !1;
                    if (n && s) {
                      let e = Number(n.quantity.numeric),
                        t = Number(s.quantity.numeric);
                      t < 0.1 * e
                        ? (r.push(n), (a = !0))
                        : e < 0.1 * t && (r.push(s), (a = !0));
                    }
                    a || r.push(...e);
                  } else {
                    let t = this.filterGasFeesFromTokenGroup(e);
                    r.push(...t);
                  }
                }
              }),
              e.forEach((e) => {
                e?.fungible_info?.name || r.push(e);
              }),
              r
            );
          },
          filterGasFeesFromTokenGroup(e) {
            if (e.length <= 1) return e;
            let t = e.map((e) => Number(e.quantity.numeric)),
              r = Math.max(...t);
            if (Math.min(...t) < 0.01 * r)
              return e.filter((e) => Number(e.quantity.numeric) >= 0.01 * r);
            let i = e.filter((e) => "in" === e.direction),
              n = e.filter((e) => "out" === e.direction);
            if (1 === i.length && 1 === n.length) {
              let e = i[0],
                t = n[0];
              if (e && t) {
                let r = Number(e.quantity.numeric),
                  i = Number(t.quantity.numeric);
                if (i < 0.1 * r) return [e];
                if (r < 0.1 * i) return [t];
              }
            }
            return e;
          },
          getQuantityFixedValue: (e) => (e ? parseFloat(e).toFixed(3) : null),
        };
      var d = r(47327);
      r(81345);
      var h = r(20296);
    },
    36964: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => u, X: () => f });
      var i = r(1220),
        n = r(98866),
        s = r(12319),
        a = r(32464),
        o = r(55480);
      let c = Object.freeze({ enabled: !0, events: [] }),
        l = new a.Z({ baseUrl: s.w.getAnalyticsUrl(), clientId: null }),
        d = (0, i.BX)({ ...c }),
        h = {
          state: d,
          subscribeKey: (e, t) => (0, n.u$)(d, e, t),
          async sendError(e, t) {
            if (!d.enabled) return;
            let r = Date.now();
            if (
              d.events.filter(
                (e) =>
                  r - new Date(e.properties.timestamp || "").getTime() < 6e4
              ).length >= 5
            )
              return;
            let i = {
              type: "error",
              event: t,
              properties: {
                errorType: e.name,
                errorMessage: e.message,
                stackTrace: e.stack,
                timestamp: new Date().toISOString(),
              },
            };
            d.events.push(i);
            try {
              if ("undefined" == typeof window) return;
              let { projectId: r, sdkType: i, sdkVersion: n } = o.H.state;
              await l.post({
                path: "/e",
                params: { projectId: r, st: i, sv: n || "html-wagmi-4.2.2" },
                body: {
                  eventId: s.w.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: new Date().toISOString(),
                  props: {
                    type: "error",
                    event: t,
                    errorType: e.name,
                    errorMessage: e.message,
                    stackTrace: e.stack,
                  },
                },
              });
            } catch {}
          },
          enable() {
            d.enabled = !0;
          },
          disable() {
            d.enabled = !1;
          },
          clearEvents() {
            d.events = [];
          },
        };
      class u extends Error {
        constructor(e, t, r) {
          super(e),
            (this.originalName = "AppKitError"),
            (this.name = "AppKitError"),
            (this.category = t),
            (this.originalError = r),
            r && r instanceof Error && (this.originalName = r.name),
            Object.setPrototypeOf(this, u.prototype);
          let i = !1;
          if (r instanceof Error && "string" == typeof r.stack && r.stack) {
            let e = r.stack,
              t = e.indexOf("\n");
            if (t > -1) {
              let r = e.substring(t + 1);
              (this.stack = `${this.name}: ${this.message}
${r}`),
                (i = !0);
            }
          }
          !i &&
            (Error.captureStackTrace
              ? Error.captureStackTrace(this, u)
              : this.stack || (this.stack = `${this.name}: ${this.message}`));
        }
      }
      function p(e, t) {
        let r = "";
        try {
          r =
            e instanceof Error
              ? e.message
              : "string" == typeof e
              ? e
              : "object" == typeof e && null !== e
              ? 0 === Object.keys(e).length
                ? "Unknown error"
                : e?.message || JSON.stringify(e)
              : String(e);
        } catch (e) {
          (r = "Unknown error"),
            console.error("Error parsing error message", e);
        }
        let i = e instanceof u ? e : new u(r, t, e);
        throw (h.sendError(i, i.category), i);
      }
      function f(e, t = "INTERNAL_SDK_ERROR") {
        let r = {};
        return (
          Object.keys(e).forEach((i) => {
            let n = e[i];
            if ("function" == typeof n) {
              let e = n;
              (e =
                "AsyncFunction" === n.constructor.name
                  ? async (...e) => {
                      try {
                        return await n(...e);
                      } catch (e) {
                        return p(e, t);
                      }
                    }
                  : (...e) => {
                      try {
                        return n(...e);
                      } catch (e) {
                        return p(e, t);
                      }
                    }),
                (r[i] = e);
            } else r[i] = n;
          }),
          r
        );
      }
    },
    37370: (e, t, r) => {
      var i =
          ("undefined" != typeof globalThis && globalThis) ||
          ("undefined" != typeof self && self) ||
          (void 0 !== r.g && r.g),
        n = (function () {
          function e() {
            (this.fetch = !1), (this.DOMException = i.DOMException);
          }
          return (e.prototype = i), new e();
        })();
      !(function (e) {
        !(function (t) {
          var i =
              (void 0 !== e && e) ||
              ("undefined" != typeof self && self) ||
              (void 0 !== r.g && r.g) ||
              {},
            n = {
              searchParams: "URLSearchParams" in i,
              iterable: "Symbol" in i && "iterator" in Symbol,
              blob:
                "FileReader" in i &&
                "Blob" in i &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (e) {
                    return !1;
                  }
                })(),
              formData: "FormData" in i,
              arrayBuffer: "ArrayBuffer" in i,
            };
          if (n.arrayBuffer)
            var s = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]",
              ],
              a =
                ArrayBuffer.isView ||
                function (e) {
                  return e && s.indexOf(Object.prototype.toString.call(e)) > -1;
                };
          function o(e) {
            if (
              ("string" != typeof e && (e = String(e)),
              /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
            )
              throw TypeError(
                'Invalid character in header field name: "' + e + '"'
              );
            return e.toLowerCase();
          }
          function c(e) {
            return "string" != typeof e && (e = String(e)), e;
          }
          function l(e) {
            var t = {
              next: function () {
                var t = e.shift();
                return { done: void 0 === t, value: t };
              },
            };
            return (
              n.iterable &&
                (t[Symbol.iterator] = function () {
                  return t;
                }),
              t
            );
          }
          function d(e) {
            (this.map = {}),
              e instanceof d
                ? e.forEach(function (e, t) {
                    this.append(t, e);
                  }, this)
                : Array.isArray(e)
                ? e.forEach(function (e) {
                    if (2 != e.length)
                      throw TypeError(
                        "Headers constructor: expected name/value pair to be length 2, found" +
                          e.length
                      );
                    this.append(e[0], e[1]);
                  }, this)
                : e &&
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    this.append(t, e[t]);
                  }, this);
          }
          function h(e) {
            if (!e._noBody) {
              if (e.bodyUsed) return Promise.reject(TypeError("Already read"));
              e.bodyUsed = !0;
            }
          }
          function u(e) {
            return new Promise(function (t, r) {
              (e.onload = function () {
                t(e.result);
              }),
                (e.onerror = function () {
                  r(e.error);
                });
            });
          }
          function p(e) {
            var t = new FileReader(),
              r = u(t);
            return t.readAsArrayBuffer(e), r;
          }
          function f(e) {
            if (e.slice) return e.slice(0);
            var t = new Uint8Array(e.byteLength);
            return t.set(new Uint8Array(e)), t.buffer;
          }
          function g() {
            return (
              (this.bodyUsed = !1),
              (this._initBody = function (e) {
                if (((this.bodyUsed = this.bodyUsed), (this._bodyInit = e), e))
                  if ("string" == typeof e) this._bodyText = e;
                  else if (n.blob && Blob.prototype.isPrototypeOf(e))
                    this._bodyBlob = e;
                  else if (n.formData && FormData.prototype.isPrototypeOf(e))
                    this._bodyFormData = e;
                  else if (
                    n.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(e)
                  )
                    this._bodyText = e.toString();
                  else {
                    var t;
                    n.arrayBuffer &&
                    n.blob &&
                    (t = e) &&
                    DataView.prototype.isPrototypeOf(t)
                      ? ((this._bodyArrayBuffer = f(e.buffer)),
                        (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                      : n.arrayBuffer &&
                        (ArrayBuffer.prototype.isPrototypeOf(e) || a(e))
                      ? (this._bodyArrayBuffer = f(e))
                      : (this._bodyText = e =
                          Object.prototype.toString.call(e));
                  }
                else (this._noBody = !0), (this._bodyText = "");
                !this.headers.get("content-type") &&
                  ("string" == typeof e
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : n.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
              }),
              n.blob &&
                (this.blob = function () {
                  var e = h(this);
                  if (e) return e;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (!this._bodyFormData)
                    return Promise.resolve(new Blob([this._bodyText]));
                  throw Error("could not read FormData body as blob");
                }),
              (this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                  var e = h(this);
                  return (
                    e ||
                    (ArrayBuffer.isView(this._bodyArrayBuffer)
                      ? Promise.resolve(
                          this._bodyArrayBuffer.buffer.slice(
                            this._bodyArrayBuffer.byteOffset,
                            this._bodyArrayBuffer.byteOffset +
                              this._bodyArrayBuffer.byteLength
                          )
                        )
                      : Promise.resolve(this._bodyArrayBuffer))
                  );
                }
                if (n.blob) return this.blob().then(p);
                throw Error("could not read as ArrayBuffer");
              }),
              (this.text = function () {
                var e,
                  t,
                  r,
                  i,
                  n,
                  s = h(this);
                if (s) return s;
                if (this._bodyBlob)
                  return (
                    (e = this._bodyBlob),
                    (r = u((t = new FileReader()))),
                    (n = (i = /charset=([A-Za-z0-9_-]+)/.exec(e.type))
                      ? i[1]
                      : "utf-8"),
                    t.readAsText(e, n),
                    r
                  );
                if (this._bodyArrayBuffer)
                  return Promise.resolve(
                    (function (e) {
                      for (
                        var t = new Uint8Array(e), r = Array(t.length), i = 0;
                        i < t.length;
                        i++
                      )
                        r[i] = String.fromCharCode(t[i]);
                      return r.join("");
                    })(this._bodyArrayBuffer)
                  );
                if (!this._bodyFormData) return Promise.resolve(this._bodyText);
                throw Error("could not read FormData body as text");
              }),
              n.formData &&
                (this.formData = function () {
                  return this.text().then(w);
                }),
              (this.json = function () {
                return this.text().then(JSON.parse);
              }),
              this
            );
          }
          (d.prototype.append = function (e, t) {
            (e = o(e)), (t = c(t));
            var r = this.map[e];
            this.map[e] = r ? r + ", " + t : t;
          }),
            (d.prototype.delete = function (e) {
              delete this.map[o(e)];
            }),
            (d.prototype.get = function (e) {
              return (e = o(e)), this.has(e) ? this.map[e] : null;
            }),
            (d.prototype.has = function (e) {
              return this.map.hasOwnProperty(o(e));
            }),
            (d.prototype.set = function (e, t) {
              this.map[o(e)] = c(t);
            }),
            (d.prototype.forEach = function (e, t) {
              for (var r in this.map)
                this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
            }),
            (d.prototype.keys = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push(r);
                }),
                l(e)
              );
            }),
            (d.prototype.values = function () {
              var e = [];
              return (
                this.forEach(function (t) {
                  e.push(t);
                }),
                l(e)
              );
            }),
            (d.prototype.entries = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push([r, t]);
                }),
                l(e)
              );
            }),
            n.iterable && (d.prototype[Symbol.iterator] = d.prototype.entries);
          var m = [
            "CONNECT",
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT",
            "TRACE",
          ];
          function y(e, t) {
            if (!(this instanceof y))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            var r,
              n,
              s = (t = t || {}).body;
            if (e instanceof y) {
              if (e.bodyUsed) throw TypeError("Already read");
              (this.url = e.url),
                (this.credentials = e.credentials),
                t.headers || (this.headers = new d(e.headers)),
                (this.method = e.method),
                (this.mode = e.mode),
                (this.signal = e.signal),
                s ||
                  null == e._bodyInit ||
                  ((s = e._bodyInit), (e.bodyUsed = !0));
            } else this.url = String(e);
            if (
              ((this.credentials =
                t.credentials || this.credentials || "same-origin"),
              (t.headers || !this.headers) && (this.headers = new d(t.headers)),
              (this.method =
                ((n = (r = t.method || this.method || "GET").toUpperCase()),
                m.indexOf(n) > -1 ? n : r)),
              (this.mode = t.mode || this.mode || null),
              (this.signal =
                t.signal ||
                this.signal ||
                (function () {
                  if ("AbortController" in i)
                    return new AbortController().signal;
                })()),
              (this.referrer = null),
              ("GET" === this.method || "HEAD" === this.method) && s)
            )
              throw TypeError("Body not allowed for GET or HEAD requests");
            if (
              (this._initBody(s),
              ("GET" === this.method || "HEAD" === this.method) &&
                ("no-store" === t.cache || "no-cache" === t.cache))
            ) {
              var a = /([?&])_=[^&]*/;
              a.test(this.url)
                ? (this.url = this.url.replace(
                    a,
                    "$1_=" + new Date().getTime()
                  ))
                : (this.url +=
                    (/\?/.test(this.url) ? "&" : "?") +
                    "_=" +
                    new Date().getTime());
            }
          }
          function w(e) {
            var t = new FormData();
            return (
              e
                .trim()
                .split("&")
                .forEach(function (e) {
                  if (e) {
                    var r = e.split("="),
                      i = r.shift().replace(/\+/g, " "),
                      n = r.join("=").replace(/\+/g, " ");
                    t.append(decodeURIComponent(i), decodeURIComponent(n));
                  }
                }),
              t
            );
          }
          function b(e, t) {
            if (!(this instanceof b))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            if (
              (t || (t = {}),
              (this.type = "default"),
              (this.status = void 0 === t.status ? 200 : t.status),
              this.status < 200 || this.status > 599)
            )
              throw RangeError(
                "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
              );
            (this.ok = this.status >= 200 && this.status < 300),
              (this.statusText =
                void 0 === t.statusText ? "" : "" + t.statusText),
              (this.headers = new d(t.headers)),
              (this.url = t.url || ""),
              this._initBody(e);
          }
          (y.prototype.clone = function () {
            return new y(this, { body: this._bodyInit });
          }),
            g.call(y.prototype),
            g.call(b.prototype),
            (b.prototype.clone = function () {
              return new b(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new d(this.headers),
                url: this.url,
              });
            }),
            (b.error = function () {
              var e = new b(null, { status: 200, statusText: "" });
              return (e.ok = !1), (e.status = 0), (e.type = "error"), e;
            });
          var v = [301, 302, 303, 307, 308];
          (b.redirect = function (e, t) {
            if (-1 === v.indexOf(t)) throw RangeError("Invalid status code");
            return new b(null, { status: t, headers: { location: e } });
          }),
            (t.DOMException = i.DOMException);
          try {
            new t.DOMException();
          } catch (e) {
            (t.DOMException = function (e, t) {
              (this.message = e), (this.name = t);
              var r = Error(e);
              this.stack = r.stack;
            }),
              (t.DOMException.prototype = Object.create(Error.prototype)),
              (t.DOMException.prototype.constructor = t.DOMException);
          }
          function C(e, r) {
            return new Promise(function (s, a) {
              var l = new y(e, r);
              if (l.signal && l.signal.aborted)
                return a(new t.DOMException("Aborted", "AbortError"));
              var h = new XMLHttpRequest();
              function u() {
                h.abort();
              }
              if (
                ((h.onload = function () {
                  var e,
                    t,
                    r = {
                      statusText: h.statusText,
                      headers:
                        ((e = h.getAllResponseHeaders() || ""),
                        (t = new d()),
                        e
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split("\r")
                          .map(function (e) {
                            return 0 === e.indexOf("\n")
                              ? e.substr(1, e.length)
                              : e;
                          })
                          .forEach(function (e) {
                            var r = e.split(":"),
                              i = r.shift().trim();
                            if (i) {
                              var n = r.join(":").trim();
                              try {
                                t.append(i, n);
                              } catch (e) {
                                console.warn("Response " + e.message);
                              }
                            }
                          }),
                        t),
                    };
                  0 === l.url.indexOf("file://") &&
                  (h.status < 200 || h.status > 599)
                    ? (r.status = 200)
                    : (r.status = h.status),
                    (r.url =
                      "responseURL" in h
                        ? h.responseURL
                        : r.headers.get("X-Request-URL"));
                  var i = "response" in h ? h.response : h.responseText;
                  setTimeout(function () {
                    s(new b(i, r));
                  }, 0);
                }),
                (h.onerror = function () {
                  setTimeout(function () {
                    a(TypeError("Network request failed"));
                  }, 0);
                }),
                (h.ontimeout = function () {
                  setTimeout(function () {
                    a(TypeError("Network request timed out"));
                  }, 0);
                }),
                (h.onabort = function () {
                  setTimeout(function () {
                    a(new t.DOMException("Aborted", "AbortError"));
                  }, 0);
                }),
                h.open(
                  l.method,
                  (function (e) {
                    try {
                      return "" === e && i.location.href ? i.location.href : e;
                    } catch (t) {
                      return e;
                    }
                  })(l.url),
                  !0
                ),
                "include" === l.credentials
                  ? (h.withCredentials = !0)
                  : "omit" === l.credentials && (h.withCredentials = !1),
                "responseType" in h &&
                  (n.blob
                    ? (h.responseType = "blob")
                    : n.arrayBuffer && (h.responseType = "arraybuffer")),
                r &&
                  "object" == typeof r.headers &&
                  !(
                    r.headers instanceof d ||
                    (i.Headers && r.headers instanceof i.Headers)
                  ))
              ) {
                var p = [];
                Object.getOwnPropertyNames(r.headers).forEach(function (e) {
                  p.push(o(e)), h.setRequestHeader(e, c(r.headers[e]));
                }),
                  l.headers.forEach(function (e, t) {
                    -1 === p.indexOf(t) && h.setRequestHeader(t, e);
                  });
              } else
                l.headers.forEach(function (e, t) {
                  h.setRequestHeader(t, e);
                });
              l.signal &&
                (l.signal.addEventListener("abort", u),
                (h.onreadystatechange = function () {
                  4 === h.readyState &&
                    l.signal.removeEventListener("abort", u);
                })),
                h.send(void 0 === l._bodyInit ? null : l._bodyInit);
            });
          }
          (C.polyfill = !0),
            i.fetch ||
              ((i.fetch = C),
              (i.Headers = d),
              (i.Request = y),
              (i.Response = b)),
            (t.Headers = d),
            (t.Request = y),
            (t.Response = b),
            (t.fetch = C),
            Object.defineProperty(t, "__esModule", { value: !0 });
        })({});
      })(n),
        (n.fetch.ponyfill = !0),
        delete n.fetch.polyfill;
      var s = i.fetch ? i : n;
      ((t = s.fetch).default = s.fetch),
        (t.fetch = s.fetch),
        (t.Headers = s.Headers),
        (t.Request = s.Request),
        (t.Response = s.Response),
        (e.exports = t);
    },
    37407: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => n });
      var i = r(78140);
      function n(
        e,
        { delay: t = 100, retryCount: r = 2, shouldRetry: s = () => !0 } = {}
      ) {
        return new Promise((n, a) => {
          let o = async ({ count: c = 0 } = {}) => {
            let l = async ({ error: e }) => {
              let r = "function" == typeof t ? t({ count: c, error: e }) : t;
              r && (await (0, i.u)(r)), o({ count: c + 1 });
            };
            try {
              let t = await e();
              n(t);
            } catch (e) {
              if (c < r && (await s({ count: c, error: e })))
                return l({ error: e });
              a(e);
            }
          };
          o();
        });
      }
    },
    37465: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691), r(21129), r(24772);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  :host {
    width: var(--local-width);
  }

  button {
    width: var(--local-width);
    white-space: nowrap;
    column-gap: ${({ spacing: e }) => e[2]};
    transition:
      scale ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-1"]},
      background-color ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      border-radius ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-1"]};
    will-change: scale, background-color, border-radius;
    cursor: pointer;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='sm'] {
    border-radius: ${({ borderRadius: e }) => e[2]};
    padding: 0 ${({ spacing: e }) => e[2]};
    height: 28px;
  }

  button[data-size='md'] {
    border-radius: ${({ borderRadius: e }) => e[3]};
    padding: 0 ${({ spacing: e }) => e[4]};
    height: 38px;
  }

  button[data-size='lg'] {
    border-radius: ${({ borderRadius: e }) => e[4]};
    padding: 0 ${({ spacing: e }) => e[5]};
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='accent-primary'] {
    background-color: ${({ tokens: e }) => e.core.backgroundAccentPrimary};
    color: ${({ tokens: e }) => e.theme.textInvert};
  }

  button[data-variant='accent-secondary'] {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
    color: ${({ tokens: e }) => e.core.textAccentPrimary};
  }

  button[data-variant='neutral-primary'] {
    background-color: ${({ tokens: e }) => e.theme.backgroundInvert};
    color: ${({ tokens: e }) => e.theme.textInvert};
  }

  button[data-variant='neutral-secondary'] {
    background-color: transparent;
    border: 1px solid ${({ tokens: e }) => e.theme.borderSecondary};
    color: ${({ tokens: e }) => e.theme.textPrimary};
  }

  button[data-variant='neutral-tertiary'] {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    color: ${({ tokens: e }) => e.theme.textPrimary};
  }

  button[data-variant='error-primary'] {
    background-color: ${({ tokens: e }) => e.core.textError};
    color: ${({ tokens: e }) => e.theme.textInvert};
  }

  button[data-variant='error-secondary'] {
    background-color: ${({ tokens: e }) => e.core.backgroundError};
    color: ${({ tokens: e }) => e.core.textError};
  }

  button[data-variant='shade'] {
    background: var(--wui-color-gray-glass-002);
    color: var(--wui-color-fg-200);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-size='sm']:focus-visible:enabled {
    border-radius: 28px;
  }

  button[data-size='md']:focus-visible:enabled {
    border-radius: 38px;
  }

  button[data-size='lg']:focus-visible:enabled {
    border-radius: 48px;
  }
  button[data-variant='shade']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) {
    button[data-size='sm']:hover:enabled {
      border-radius: 28px;
    }

    button[data-size='md']:hover:enabled {
      border-radius: 38px;
    }

    button[data-size='lg']:hover:enabled {
      border-radius: 48px;
    }

    button[data-variant='shade']:hover:enabled {
      background: var(--wui-color-gray-glass-002);
    }

    button[data-variant='shade']:active:enabled {
      background: var(--wui-color-gray-glass-005);
    }
  }

  button[data-size='sm']:active:enabled {
    border-radius: 28px;
  }

  button[data-size='md']:active:enabled {
    border-radius: 38px;
  }

  button[data-size='lg']:active:enabled {
    border-radius: 48px;
  }

  /* -- Disabled states --------------------------------------------------- */
  button:disabled {
    opacity: 0.3;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = {
          lg: "lg-regular-mono",
          md: "md-regular-mono",
          sm: "sm-regular-mono",
        },
        h = { lg: "md", md: "md", sm: "sm" },
        u = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.size = "lg"),
              (this.disabled = !1),
              (this.fullWidth = !1),
              (this.loading = !1),
              (this.variant = "accent-primary");
          }
          render() {
            this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
     `;
            let e = this.textVariant ?? d[this.size];
            return (0, i.qy)`
      <button data-variant=${this.variant} data-size=${this.size} ?disabled=${
              this.disabled
            }>
        ${this.loadingTemplate()}
        <slot name="iconLeft"></slot>
        <wui-text variant=${e} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
          }
          loadingTemplate() {
            if (this.loading) {
              let e = h[this.size],
                t =
                  "neutral-primary" === this.variant ||
                  "accent-primary" === this.variant
                    ? "invert"
                    : "primary";
              return (0,
              i.qy)`<wui-loading-spinner color=${t} size=${e}></wui-loading-spinner>`;
            }
            return null;
          }
        };
      (u.styles = [s.W5, s.fD, c]),
        l([(0, n.MZ)()], u.prototype, "size", void 0),
        l([(0, n.MZ)({ type: Boolean })], u.prototype, "disabled", void 0),
        l([(0, n.MZ)({ type: Boolean })], u.prototype, "fullWidth", void 0),
        l([(0, n.MZ)({ type: Boolean })], u.prototype, "loading", void 0),
        l([(0, n.MZ)()], u.prototype, "variant", void 0),
        l([(0, n.MZ)()], u.prototype, "textVariant", void 0),
        (u = l([(0, a.E)("wui-button")], u));
    },
    38053: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.Watch = void 0);
      class r {
        constructor() {
          this.timestamps = new Map();
        }
        start(e) {
          if (this.timestamps.has(e))
            throw Error(`Watch already started for label: ${e}`);
          this.timestamps.set(e, { started: Date.now() });
        }
        stop(e) {
          let t = this.get(e);
          if (void 0 !== t.elapsed)
            throw Error(`Watch already stopped for label: ${e}`);
          let r = Date.now() - t.started;
          this.timestamps.set(e, { started: t.started, elapsed: r });
        }
        get(e) {
          let t = this.timestamps.get(e);
          if (void 0 === t) throw Error(`No timestamp found for label: ${e}`);
          return t;
        }
        elapsed(e) {
          let t = this.get(e);
          return t.elapsed || Date.now() - t.started;
        }
      }
      (t.Watch = r), (t.default = r);
    },
    38534: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(71084),
        a = r(8821),
        o = r(47327);
      let c = (0, i.AH)`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
    box-sizing: border-box;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        render() {
          return (
            (this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--apkt-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--apkt-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--apkt-spacing-${this.gap})`};
      padding-top: ${this.padding && a.Z.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && a.Z.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && a.Z.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && a.Z.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && a.Z.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && a.Z.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && a.Z.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && a.Z.getSpacingStyles(this.margin, 3)};
      width: ${this.width};
    `),
            (0, i.qy)`<slot></slot>`
          );
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)()], d.prototype, "flexDirection", void 0),
        l([(0, n.MZ)()], d.prototype, "flexWrap", void 0),
        l([(0, n.MZ)()], d.prototype, "flexBasis", void 0),
        l([(0, n.MZ)()], d.prototype, "flexGrow", void 0),
        l([(0, n.MZ)()], d.prototype, "flexShrink", void 0),
        l([(0, n.MZ)()], d.prototype, "alignItems", void 0),
        l([(0, n.MZ)()], d.prototype, "justifyContent", void 0),
        l([(0, n.MZ)()], d.prototype, "columnGap", void 0),
        l([(0, n.MZ)()], d.prototype, "rowGap", void 0),
        l([(0, n.MZ)()], d.prototype, "gap", void 0),
        l([(0, n.MZ)()], d.prototype, "padding", void 0),
        l([(0, n.MZ)()], d.prototype, "margin", void 0),
        l([(0, n.MZ)()], d.prototype, "width", void 0),
        (d = l([(0, o.E)("wui-flex")], d));
    },
    39752: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(24772);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: ${({ tokens: e }) => e.theme.borderPrimary};
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 8px;
    background-color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: background-color;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments), (this.text = "");
        }
        render() {
          return (0, i.qy)`${this.template()}`;
        }
        template() {
          return this.text
            ? (0,
              i.qy)`<wui-text variant="md-regular" color="secondary">${this.text}</wui-text>`
            : null;
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)()], d.prototype, "text", void 0),
        (d = l([(0, a.E)("wui-separator")], d));
    },
    40284: (e, t, r) => {
      "use strict";
      r(5089);
    },
    40290: (e, t, r) => {
      "use strict";
      function i(e) {
        return "string" == typeof e[0]
          ? n(e)
          : (function (e) {
              let t = 0;
              for (let r of e) t += r.length;
              let r = new Uint8Array(t),
                i = 0;
              for (let t of e) r.set(t, i), (i += t.length);
              return r;
            })(e);
      }
      function n(e) {
        return `0x${e.reduce((e, t) => e + t.replace("0x", ""), "")}`;
      }
      r.d(t, { aP: () => n, xW: () => i });
    },
    40396: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(47327),
        a = r(20296);
      let o = (0, a.AH)`
  :host {
    display: block;
    background: linear-gradient(
      90deg,
      ${({ tokens: e }) => e.theme.foregroundSecondary} 0%,
      ${({ tokens: e }) => e.theme.foregroundTertiary} 50%,
      ${({ tokens: e }) => e.theme.foregroundSecondary} 100%
    );
    background-size: 200% 100%;
    animation: shimmer 1s ease-in-out infinite;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host([data-rounded='true']) {
    border-radius: ${({ borderRadius: e }) => e[16]};
  }

  @keyframes shimmer {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }
`;
      var c = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let l = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.width = ""),
            (this.height = ""),
            (this.variant = "default"),
            (this.rounded = !1);
        }
        render() {
          return (
            (this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
    `),
            (this.dataset.rounded = this.rounded ? "true" : "false"),
            (0, i.qy)`<slot></slot>`
          );
        }
      };
      (l.styles = [o]),
        c([(0, n.MZ)()], l.prototype, "width", void 0),
        c([(0, n.MZ)()], l.prototype, "height", void 0),
        c([(0, n.MZ)()], l.prototype, "variant", void 0),
        c([(0, n.MZ)({ type: Boolean })], l.prototype, "rounded", void 0),
        (l = c([(0, s.E)("wui-shimmer")], l));
    },
    40575: (e, t, r) => {
      "use strict";
      r(38534);
    },
    41028: (e, t, r) => {
      "use strict";
      r(37465);
    },
    41163: (e, t, r) => {
      "use strict";
      r(24772);
    },
    41699: (e, t, r) => {
      "use strict";
      r(40396);
    },
    41953: (e, t, r) => {
      let i = r(46342),
        n = i.getBCHDigit(1335);
      t.getEncodedBits = function (e, t) {
        let r = (e.bit << 3) | t,
          s = r << 10;
        for (; i.getBCHDigit(s) - n >= 0; ) s ^= 1335 << (i.getBCHDigit(s) - n);
        return ((r << 10) | s) ^ 21522;
      };
    },
    42312: (e, t, r) => {
      "use strict";
      r.d(t, { Aj: () => n.A, gf: () => i.g });
      var i = r(48981);
      r(91867);
      var n = r(18635);
    },
    42438: (e, t, r) => {
      "use strict";
      function i(e, { dir: t = "left" } = {}) {
        let r = "string" == typeof e ? e.replace("0x", "") : e,
          n = 0;
        for (let e = 0; e < r.length - 1; e++)
          if ("0" === r["left" === t ? e : r.length - e - 1].toString()) n++;
          else break;
        return ((r = "left" === t ? r.slice(n) : r.slice(0, r.length - n)),
        "string" == typeof e)
          ? (1 === r.length && "right" === t && (r = `${r}0`),
            `0x${r.length % 2 == 1 ? `0${r}` : r}`)
          : r;
      }
      r.d(t, { B: () => i });
    },
    42503: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => s });
      var i = r(62023),
        n = r(30598);
      function s(e, t = "wei") {
        return (0, n.J)(e, i.sz[t]);
      }
    },
    44006: (e, t, r) => {
      let i = r(62497),
        n = r(89158);
      function s(e) {
        (this.mode = n.BYTE),
          "string" == typeof e && (e = i(e)),
          (this.data = new Uint8Array(e));
      }
      (s.getBitsLength = function (e) {
        return 8 * e;
      }),
        (s.prototype.getLength = function () {
          return this.data.length;
        }),
        (s.prototype.getBitsLength = function () {
          return s.getBitsLength(this.data.length);
        }),
        (s.prototype.write = function (e) {
          for (let t = 0, r = this.data.length; t < r; t++)
            e.put(this.data[t], 8);
        }),
        (e.exports = s);
    },
    44016: (e, t, r) => {
      "use strict";
      r.d(t, { Ao: () => i });
      let i = 2n ** 256n - 1n;
    },
    44036: (e, t, r) => {
      "use strict";
      r(50505);
    },
    44161: (e, t, r) => {
      "use strict";
      r.d(t, {
        $f: () => u,
        V1: () => d,
        cz: () => l,
        lZ: () => h,
        nj: () => g,
        ro: () => c,
        sP: () => p,
      });
      var i = r(65103),
        n = r(55480);
      let s = {
        eip155: {
          native: { assetNamespace: "slip44", assetReference: "60" },
          defaultTokenNamespace: "erc20",
        },
        solana: {
          native: { assetNamespace: "slip44", assetReference: "501" },
          defaultTokenNamespace: "token",
        },
      };
      class a extends Error {}
      async function o(e, t) {
        let r = (function () {
            let { sdkType: e, sdkVersion: t, projectId: r } = n.H.getSnapshot(),
              i = new URL("https://rpc.walletconnect.org/v1/json-rpc");
            return (
              i.searchParams.set("projectId", r),
              i.searchParams.set("st", e),
              i.searchParams.set("sv", t),
              i.searchParams.set("source", "fund-wallet"),
              i.toString()
            );
          })(),
          { projectId: i } = n.H.getSnapshot(),
          s = {
            jsonrpc: "2.0",
            id: 1,
            method: e,
            params: { ...(t || {}), projectId: i },
          },
          o = await fetch(r, {
            method: "POST",
            body: JSON.stringify(s),
            headers: { "Content-Type": "application/json" },
          }),
          c = await o.json();
        if (c.error) throw new a(c.error.message);
        return c;
      }
      async function c(e) {
        return (await o("reown_getExchanges", e)).result;
      }
      async function l(e) {
        return (await o("reown_getExchangePayUrl", e)).result;
      }
      async function d(e) {
        return (await o("reown_getExchangeBuyStatus", e)).result;
      }
      function h(e, t) {
        let { chainNamespace: r, chainId: n } = i.C.parseCaipNetworkId(e),
          a = s[r];
        if (!a)
          throw Error(
            `Unsupported chain namespace for CAIP-19 formatting: ${r}`
          );
        let o = a.native.assetNamespace,
          c = a.native.assetReference;
        "native" !== t && ((o = a.defaultTokenNamespace), (c = t));
        let l = `${r}:${n}`;
        return `${l}/${o}:${c}`;
      }
      let u = {
          network: "eip155:8453",
          asset: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
          metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
        },
        p = {
          network: "eip155:84532",
          asset: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
          metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
        },
        f = {
          ethereumETH: {
            network: "eip155:1",
            asset: "native",
            metadata: { name: "Ethereum", symbol: "ETH", decimals: 18 },
          },
          baseETH: {
            network: "eip155:8453",
            asset: "native",
            metadata: { name: "Ethereum", symbol: "ETH", decimals: 18 },
          },
          baseUSDC: u,
          baseSepoliaETH: {
            network: "eip155:84532",
            asset: "native",
            metadata: { name: "Ethereum", symbol: "ETH", decimals: 18 },
          },
          ethereumUSDC: {
            network: "eip155:1",
            asset: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
            metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
          },
          arbitrumUSDC: {
            network: "eip155:42161",
            asset: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
            metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
          },
          polygonUSDC: {
            network: "eip155:137",
            asset: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
            metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
          },
          solanaUSDC: {
            network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
            asset: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            metadata: { name: "USD Coin", symbol: "USDC", decimals: 6 },
          },
          ethereumUSDT: {
            network: "eip155:1",
            asset: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
            metadata: { name: "Tether USD", symbol: "USDT", decimals: 6 },
          },
          optimismUSDT: {
            network: "eip155:10",
            asset: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
            metadata: { name: "Tether USD", symbol: "USDT", decimals: 6 },
          },
          arbitrumUSDT: {
            network: "eip155:42161",
            asset: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
            metadata: { name: "Tether USD", symbol: "USDT", decimals: 6 },
          },
          polygonUSDT: {
            network: "eip155:137",
            asset: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
            metadata: { name: "Tether USD", symbol: "USDT", decimals: 6 },
          },
          solanaUSDT: {
            network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
            asset: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
            metadata: { name: "Tether USD", symbol: "USDT", decimals: 6 },
          },
          solanaSOL: {
            network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
            asset: "native",
            metadata: { name: "Solana", symbol: "SOL", decimals: 9 },
          },
        };
      function g(e) {
        return Object.values(f).filter((t) => t.network === e);
      }
    },
    44352: (e, t, r) => {
      "use strict";
      r.d(t, { A1: () => l, di: () => a, iN: () => d });
      var i = r(66969),
        n = r(60587),
        s = r(16871);
      function a(e, t, r, { strict: i } = {}) {
        return (0, n.q)(e, { strict: !1 })
          ? d(e, t, r, { strict: i })
          : l(e, t, r, { strict: i });
      }
      function o(e, t) {
        if ("number" == typeof t && t > 0 && t > (0, s.E)(e) - 1)
          throw new i.ii({ offset: t, position: "start", size: (0, s.E)(e) });
      }
      function c(e, t, r) {
        if (
          "number" == typeof t &&
          "number" == typeof r &&
          (0, s.E)(e) !== r - t
        )
          throw new i.ii({ offset: r, position: "end", size: (0, s.E)(e) });
      }
      function l(e, t, r, { strict: i } = {}) {
        o(e, t);
        let n = e.slice(t, r);
        return i && c(n, t, r), n;
      }
      function d(e, t, r, { strict: i } = {}) {
        o(e, t);
        let n = `0x${e
          .replace("0x", "")
          .slice((t ?? 0) * 2, (r ?? e.length) * 2)}`;
        return i && c(n, t, r), n;
      }
    },
    44826: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => f });
      var i = r(1220),
        n = r(28977),
        s = r(12319),
        a = r(32464),
        o = r(58653),
        c = r(93481),
        l = r(55480),
        d = r(65374);
      let h = {
          purchaseCurrencies: [
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "USD Coin",
              symbol: "USDC",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "Ether",
              symbol: "ETH",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
          ],
          paymentCurrencies: [
            {
              id: "USD",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
            {
              id: "EUR",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
          ],
        },
        u = s.w.getBlockchainApiUrl(),
        p = (0, i.BX)({
          clientId: null,
          api: new a.Z({ baseUrl: u, clientId: null }),
          supportedChains: { http: [], ws: [] },
        }),
        f = {
          state: p,
          async get(e) {
            let { st: t, sv: r } = f.getSdkProperties(),
              i = l.H.state.projectId,
              n = { ...(e.params || {}), st: t, sv: r, projectId: i };
            return p.api.get({ ...e, params: n });
          },
          getSdkProperties() {
            let { sdkType: e, sdkVersion: t } = l.H.state;
            return { st: e || "unknown", sv: t || "unknown" };
          },
          async isNetworkSupported(e) {
            if (!e) return !1;
            try {
              p.supportedChains.http.length || (await f.getSupportedNetworks());
            } catch (e) {
              return !1;
            }
            return p.supportedChains.http.includes(e);
          },
          async getSupportedNetworks() {
            try {
              let e = await f.get({ path: "v1/supported-chains" });
              return (p.supportedChains = e), e;
            } catch {
              return p.supportedChains;
            }
          },
          async fetchIdentity({ address: e }) {
            let t = o.i.getIdentityFromCacheForAddress(e);
            if (t) return t;
            let r = await f.get({
              path: `/v1/identity/${e}`,
              params: {
                sender: c.W.state.activeCaipAddress
                  ? s.w.getPlainAddress(c.W.state.activeCaipAddress)
                  : void 0,
              },
            });
            return (
              o.i.updateIdentityCache({
                address: e,
                identity: r,
                timestamp: Date.now(),
              }),
              r
            );
          },
          async fetchTransactions({
            account: e,
            cursor: t,
            signal: r,
            cache: i,
            chainId: n,
          }) {
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { data: [], next: void 0 };
            let s = o.i.getTransactionsCacheForAddress({
              address: e,
              chainId: n,
            });
            if (s) return s;
            let a = await f.get({
              path: `/v1/account/${e}/history`,
              params: { cursor: t, chainId: n },
              signal: r,
              cache: i,
            });
            return (
              o.i.updateTransactionsCache({
                address: e,
                chainId: n,
                timestamp: Date.now(),
                transactions: a,
              }),
              a
            );
          },
          fetchSwapQuote: async ({
            amount: e,
            userAddress: t,
            from: r,
            to: i,
            gasPrice: n,
          }) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({
                  path: "/v1/convert/quotes",
                  headers: { "Content-Type": "application/json" },
                  params: {
                    amount: e,
                    userAddress: t,
                    from: r,
                    to: i,
                    gasPrice: n,
                  },
                })
              : { quotes: [] },
          fetchSwapTokens: async ({ chainId: e }) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({ path: "/v1/convert/tokens", params: { chainId: e } })
              : { tokens: [] },
          async fetchTokenPrice({ addresses: e }) {
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { fungibles: [] };
            let t = o.i.getTokenPriceCacheForAddresses(e);
            if (t) return t;
            let r = await p.api.post({
              path: "/v1/fungible/price",
              body: {
                currency: "usd",
                addresses: e,
                projectId: l.H.state.projectId,
              },
              headers: { "Content-Type": "application/json" },
            });
            return (
              o.i.updateTokenPriceCache({
                addresses: e,
                timestamp: Date.now(),
                tokenPrice: r,
              }),
              r
            );
          },
          fetchSwapAllowance: async ({ tokenAddress: e, userAddress: t }) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({
                  path: "/v1/convert/allowance",
                  params: { tokenAddress: e, userAddress: t },
                  headers: { "Content-Type": "application/json" },
                })
              : { allowance: "0" },
          async fetchGasPrice({ chainId: e }) {
            let { st: t, sv: r } = f.getSdkProperties();
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Gas Price");
            return f.get({
              path: "/v1/convert/gas-price",
              headers: { "Content-Type": "application/json" },
              params: { chainId: e, st: t, sv: r },
            });
          },
          async generateSwapCalldata({
            amount: e,
            from: t,
            to: r,
            userAddress: i,
            disableEstimate: s,
          }) {
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return p.api.post({
              path: "/v1/convert/build-transaction",
              headers: { "Content-Type": "application/json" },
              body: {
                amount: e,
                eip155: { slippage: n.oU.CONVERT_SLIPPAGE_TOLERANCE },
                projectId: l.H.state.projectId,
                from: t,
                to: r,
                userAddress: i,
                disableEstimate: s,
              },
            });
          },
          async generateApproveCalldata({ from: e, to: t, userAddress: r }) {
            let { st: i, sv: n } = f.getSdkProperties();
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return f.get({
              path: "/v1/convert/build-approve",
              headers: { "Content-Type": "application/json" },
              params: { userAddress: r, from: e, to: t, st: i, sv: n },
            });
          },
          async getBalance(e, t, r) {
            let { st: i, sv: n } = f.getSdkProperties();
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return (
                d.P.showError("Token Balance Unavailable"), { balances: [] }
              );
            let s = `${t}:${e}`,
              a = o.i.getBalanceCacheForCaipAddress(s);
            if (a) return a;
            let l = await f.get({
              path: `/v1/account/${e}/balance`,
              params: {
                currency: "usd",
                chainId: t,
                forceUpdate: r,
                st: i,
                sv: n,
              },
            });
            return (
              o.i.updateBalanceCache({
                caipAddress: s,
                balance: l,
                timestamp: Date.now(),
              }),
              l
            );
          },
          lookupEnsName: async (e) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({
                  path: `/v1/profile/account/${e}`,
                  params: { apiVersion: "2" },
                })
              : { addresses: {}, attributes: [] },
          async reverseLookupEnsName({ address: e }) {
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return [];
            let t = c.W.getAccountData()?.address;
            return f.get({
              path: `/v1/profile/reverse/${e}`,
              params: { sender: t, apiVersion: "2" },
            });
          },
          getEnsNameSuggestions: async (e) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({
                  path: `/v1/profile/suggestions/${e}`,
                  params: { zone: "reown.id" },
                })
              : { suggestions: [] },
          registerEnsName: async ({
            coinType: e,
            address: t,
            message: r,
            signature: i,
          }) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? p.api.post({
                  path: "/v1/profile/account",
                  body: { coin_type: e, address: t, message: r, signature: i },
                  headers: { "Content-Type": "application/json" },
                })
              : { success: !1 },
          generateOnRampURL: async ({
            destinationWallets: e,
            partnerUserId: t,
            defaultNetwork: r,
            purchaseAmount: i,
            paymentAmount: n,
          }) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? (
                  await p.api.post({
                    path: "/v1/generators/onrampurl",
                    params: { projectId: l.H.state.projectId },
                    body: {
                      destinationWallets: e,
                      defaultNetwork: r,
                      partnerUserId: t,
                      defaultExperience: "buy",
                      presetCryptoAmount: i,
                      presetFiatAmount: n,
                    },
                  })
                ).url
              : "",
          async getOnrampOptions() {
            if (
              !(await f.isNetworkSupported(
                c.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { paymentCurrencies: [], purchaseCurrencies: [] };
            try {
              return await f.get({ path: "/v1/onramp/options" });
            } catch (e) {
              return h;
            }
          },
          async getOnrampQuote({
            purchaseCurrency: e,
            paymentCurrency: t,
            amount: r,
            network: i,
          }) {
            try {
              if (
                !(await f.isNetworkSupported(
                  c.W.state.activeCaipNetwork?.caipNetworkId
                ))
              )
                return null;
              return await p.api.post({
                path: "/v1/onramp/quote",
                params: { projectId: l.H.state.projectId },
                body: {
                  purchaseCurrency: e,
                  paymentCurrency: t,
                  amount: r,
                  network: i,
                },
              });
            } catch (e) {
              return {
                networkFee: { amount: r, currency: t.id },
                paymentSubtotal: { amount: r, currency: t.id },
                paymentTotal: { amount: r, currency: t.id },
                purchaseAmount: { amount: r, currency: t.id },
                quoteId: "mocked-quote-id",
              };
            }
          },
          getSmartSessions: async (e) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.get({ path: `/v1/sessions/${e}` })
              : [],
          revokeSmartSession: async (e, t, r) =>
            (await f.isNetworkSupported(
              c.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? p.api.post({
                  path: `/v1/sessions/${e}/revoke`,
                  params: { projectId: l.H.state.projectId },
                  body: { pci: t, signature: r },
                })
              : { success: !1 },
          setClientId(e) {
            (p.clientId = e), (p.api = new a.Z({ baseUrl: u, clientId: e }));
          },
        };
    },
    44839: function (e) {
      e.exports = function (e, t, r) {
        e = e || {};
        var i = t.prototype,
          n = {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years",
          };
        function s(e, t, r, n) {
          return i.fromToBase(e, t, r, n);
        }
        (r.en.relativeTime = n),
          (i.fromToBase = function (t, i, s, a, o) {
            for (
              var c,
                l,
                d,
                h = s.$locale().relativeTime || n,
                u = e.thresholds || [
                  { l: "s", r: 44, d: "second" },
                  { l: "m", r: 89 },
                  { l: "mm", r: 44, d: "minute" },
                  { l: "h", r: 89 },
                  { l: "hh", r: 21, d: "hour" },
                  { l: "d", r: 35 },
                  { l: "dd", r: 25, d: "day" },
                  { l: "M", r: 45 },
                  { l: "MM", r: 10, d: "month" },
                  { l: "y", r: 17 },
                  { l: "yy", d: "year" },
                ],
                p = u.length,
                f = 0;
              f < p;
              f += 1
            ) {
              var g = u[f];
              g.d && (c = a ? r(t).diff(s, g.d, !0) : s.diff(t, g.d, !0));
              var m = (e.rounding || Math.round)(Math.abs(c));
              if (((d = c > 0), m <= g.r || !g.r)) {
                m <= 1 && f > 0 && (g = u[f - 1]);
                var y = h[g.l];
                o && (m = o("" + m)),
                  (l =
                    "string" == typeof y
                      ? y.replace("%d", m)
                      : y(m, i, g.l, d));
                break;
              }
            }
            if (i) return l;
            var w = d ? h.future : h.past;
            return "function" == typeof w ? w(l) : w.replace("%s", l);
          }),
          (i.to = function (e, t) {
            return s(e, t, this, !0);
          }),
          (i.from = function (e, t) {
            return s(e, t, this);
          });
        var a = function (e) {
          return e.$u ? r.utc() : r();
        };
        (i.toNow = function (e) {
          return this.to(a(this), e);
        }),
          (i.fromNow = function (e) {
            return this.from(a(this), e);
          });
      };
    },
    45069: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => l });
      var i = r(1220),
        n = r(52617),
        s = r(36964),
        a = r(10899);
      let o = (0, i.BX)({
          themeMode: "dark",
          themeVariables: {},
          w3mThemeVariables: void 0,
        }),
        c = {
          state: o,
          subscribe: (e) => (0, i.B1)(o, () => e(o)),
          setThemeMode(e) {
            o.themeMode = e;
            try {
              let t = a.a.getAuthConnector();
              if (t) {
                let r = c.getSnapshot().themeVariables;
                t.provider.syncTheme({
                  themeMode: e,
                  themeVariables: r,
                  w3mThemeVariables: (0, n.o)(r, e),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          setThemeVariables(e) {
            o.themeVariables = { ...o.themeVariables, ...e };
            try {
              let e = a.a.getAuthConnector();
              if (e) {
                let t = c.getSnapshot().themeVariables;
                e.provider.syncTheme({
                  themeVariables: t,
                  w3mThemeVariables: (0, n.o)(o.themeVariables, o.themeMode),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          getSnapshot: () => (0, i.P9)(o),
        },
        l = (0, s.X)(c);
    },
    45166: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964),
        a = r(71084),
        o = r(47327),
        c = r(20296);
      let l = (0, c.AH)`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
    user-select: none;
    user-drag: none;
    -webkit-user-drag: none;
    -khtml-user-drag: none;
    -moz-user-drag: none;
    -o-user-drag: none;
  }

  :host([data-boxed='true']) {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host([data-boxed='true']) img {
    width: 20px;
    height: 20px;
    border-radius: ${({ borderRadius: e }) => e[16]};
  }

  :host([data-full='true']) img {
    width: 100%;
    height: 100%;
  }

  :host([data-boxed='true']) wui-icon {
    width: 20px;
    height: 20px;
  }

  :host([data-icon='error']) {
    background-color: ${({ tokens: e }) => e.core.backgroundError};
  }

  :host([data-rounded='true']) {
    border-radius: ${({ borderRadius: e }) => e[16]};
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.src = "./path/to/image.jpg"),
            (this.alt = "Image"),
            (this.size = void 0),
            (this.boxed = !1),
            (this.rounded = !1),
            (this.fullSize = !1);
        }
        render() {
          let e = {
            inherit: "inherit",
            xxs: "2",
            xs: "3",
            sm: "4",
            md: "4",
            mdl: "5",
            lg: "5",
            xl: "6",
            xxl: "7",
            "3xl": "8",
            "4xl": "9",
            "5xl": "10",
          };
          return ((this.style.cssText = `
      --local-width: ${
        this.size ? `var(--apkt-spacing-${e[this.size]});` : "100%"
      };
      --local-height: ${
        this.size ? `var(--apkt-spacing-${e[this.size]});` : "100%"
      };
      `),
          (this.dataset.boxed = this.boxed ? "true" : "false"),
          (this.dataset.rounded = this.rounded ? "true" : "false"),
          (this.dataset.full = this.fullSize ? "true" : "false"),
          (this.dataset.icon = this.iconColor || "inherit"),
          this.icon)
            ? (0, i.qy)`<wui-icon
        color=${this.iconColor || "inherit"}
        name=${this.icon}
        size="lg"
      ></wui-icon> `
            : this.logo
            ? (0,
              i.qy)`<wui-icon size="lg" color="inherit" name=${this.logo}></wui-icon> `
            : (0, i.qy)`<img src=${(0, s.J)(this.src)} alt=${this.alt} @error=${
                this.handleImageError
              } />`;
        }
        handleImageError() {
          this.dispatchEvent(
            new CustomEvent("onLoadError", { bubbles: !0, composed: !0 })
          );
        }
      };
      (h.styles = [a.W5, l]),
        d([(0, n.MZ)()], h.prototype, "src", void 0),
        d([(0, n.MZ)()], h.prototype, "logo", void 0),
        d([(0, n.MZ)()], h.prototype, "icon", void 0),
        d([(0, n.MZ)()], h.prototype, "iconColor", void 0),
        d([(0, n.MZ)()], h.prototype, "alt", void 0),
        d([(0, n.MZ)()], h.prototype, "size", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "boxed", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "rounded", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "fullSize", void 0),
        (h = d([(0, o.E)("wui-image")], h));
    },
    45553: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var i = r(95704);
      let n = {
        WC_NAME_SUFFIX: ".reown.id",
        WC_NAME_SUFFIX_LEGACY: ".wcn.id",
        BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
        PULSE_API_URL: "https://pulse.walletconnect.org",
        W3M_API_URL: "https://api.web3modal.org",
        CONNECTOR_ID: {
          WALLET_CONNECT: "walletConnect",
          INJECTED: "injected",
          WALLET_STANDARD: "announced",
          COINBASE: "coinbaseWallet",
          COINBASE_SDK: "coinbaseWalletSDK",
          SAFE: "safe",
          LEDGER: "ledger",
          OKX: "okx",
          EIP6963: "eip6963",
          AUTH: "ID_AUTH",
        },
        CONNECTOR_NAMES: { AUTH: "Auth" },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: {
          EVM: "eip155",
          SOLANA: "solana",
          POLKADOT: "polkadot",
          BITCOIN: "bip122",
        },
        CHAIN_NAME_MAP: {
          eip155: "EVM Networks",
          solana: "Solana",
          polkadot: "Polkadot",
          bip122: "Bitcoin",
          cosmos: "Cosmos",
          sui: "Sui",
          stacks: "Stacks",
        },
        ADAPTER_TYPES: {
          BITCOIN: "bitcoin",
          SOLANA: "solana",
          WAGMI: "wagmi",
          ETHERS: "ethers",
          ETHERS5: "ethers5",
        },
        USDT_CONTRACT_ADDRESSES: [
          "0xdac17f958d2ee523a2206206994597c13d831ec7",
          "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
          "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
          "0x919C1c267BC06a7039e03fcc2eF738525769109c",
          "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
          "0x55d398326f99059fF775485246999027B3197955",
          "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        ],
        SOLANA_SPL_TOKEN_ADDRESSES: {
          SOL: "So11111111111111111111111111111111111111112",
        },
        HTTP_STATUS_CODES: {
          SERVER_ERROR: 500,
          TOO_MANY_REQUESTS: 429,
          SERVICE_UNAVAILABLE: 503,
          FORBIDDEN: 403,
        },
        UNSUPPORTED_NETWORK_NAME: "Unknown Network",
        SECURE_SITE_SDK_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        REMOTE_FEATURES_ALERTS: {
          MULTI_WALLET_NOT_ENABLED: {
            DEFAULT: {
              displayMessage: "Multi-Wallet Not Enabled",
              debugMessage:
                "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com.",
            },
            CONNECTIONS_HOOK: {
              displayMessage: "Multi-Wallet Not Enabled",
              debugMessage:
                "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com to use the useAppKitConnections hook.",
            },
            CONNECTION_HOOK: {
              displayMessage: "Multi-Wallet Not Enabled",
              debugMessage:
                "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com to use the useAppKitConnection hook.",
            },
          },
        },
        IS_DEVELOPMENT: void 0 !== i && !1,
      };
    },
    46333: (e, t, r) => {
      "use strict";
      r.d(t, { d: () => o });
      var i = r(34561);
      let n = r(60869).sc;
      var s = r(60587),
        a = r(55563);
      function o(e) {
        let { commitments: t, version: r } = e,
          o = e.to ?? ("string" == typeof t[0] ? "hex" : "bytes"),
          c = [];
        for (let e of t)
          c.push(
            (function (e) {
              let { commitment: t, version: r = 1 } = e,
                o = e.to ?? ("string" == typeof t ? "hex" : "bytes"),
                c = (function (e, t) {
                  let r = n((0, s.q)(e, { strict: !1 }) ? (0, a.ZJ)(e) : e);
                  return "bytes" === (t || "hex") ? r : (0, i.nj)(r);
                })(t, "bytes");
              return c.set([r], 0), "bytes" === o ? c : (0, i.My)(c);
            })({ commitment: e, to: o, version: r })
          );
        return c;
      }
    },
    46342: (e, t) => {
      let r,
        i = [
          0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581,
          655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706,
          1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196,
          3362, 3532, 3706,
        ];
      (t.getSymbolSize = function (e) {
        if (!e) throw Error('"version" cannot be null or undefined');
        if (e < 1 || e > 40)
          throw Error('"version" should be in range from 1 to 40');
        return 4 * e + 17;
      }),
        (t.getSymbolTotalCodewords = function (e) {
          return i[e];
        }),
        (t.getBCHDigit = function (e) {
          let t = 0;
          for (; 0 !== e; ) t++, (e >>>= 1);
          return t;
        }),
        (t.setToSJISFunction = function (e) {
          if ("function" != typeof e)
            throw Error('"toSJISFunc" is not a valid function.');
          r = e;
        }),
        (t.isKanjiModeEnabled = function () {
          return void 0 !== r;
        }),
        (t.toSJIS = function (e) {
          return r(e);
        });
    },
    46747: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => p, K: () => m });
      var i = r(52321),
        n = r(34777),
        s = r(32973);
      let a = (e, t) => {
          let r = e._$AN;
          if (void 0 === r) return !1;
          for (let e of r) e._$AO?.(t, !1), a(e, t);
          return !0;
        },
        o = (e) => {
          let t, r;
          do {
            if (void 0 === (t = e._$AM)) break;
            (r = t._$AN).delete(e), (e = t);
          } while (0 === r?.size);
        },
        c = (e) => {
          for (let t; (t = e._$AM); e = t) {
            let r = t._$AN;
            if (void 0 === r) t._$AN = r = new Set();
            else if (r.has(e)) break;
            r.add(e), h(t);
          }
        };
      function l(e) {
        void 0 !== this._$AN
          ? (o(this), (this._$AM = e), c(this))
          : (this._$AM = e);
      }
      function d(e, t = !1, r = 0) {
        let i = this._$AH,
          n = this._$AN;
        if (void 0 !== n && 0 !== n.size)
          if (t)
            if (Array.isArray(i))
              for (let e = r; e < i.length; e++) a(i[e], !1), o(i[e]);
            else null != i && (a(i, !1), o(i));
          else a(this, e);
      }
      let h = (e) => {
        e.type == s.OA.CHILD && ((e._$AP ??= d), (e._$AQ ??= l));
      };
      class u extends s.WL {
        constructor() {
          super(...arguments), (this._$AN = void 0);
        }
        _$AT(e, t, r) {
          super._$AT(e, t, r), c(this), (this.isConnected = e._$AU);
        }
        _$AO(e, t = !0) {
          e !== this.isConnected &&
            ((this.isConnected = e),
            e ? this.reconnected?.() : this.disconnected?.()),
            t && (a(this, e), o(this));
        }
        setValue(e) {
          if ((0, n.Rt)(this._$Ct)) this._$Ct._$AI(e, this);
          else {
            let t = [...this._$Ct._$AH];
            (t[this._$Ci] = e), this._$Ct._$AI(t, this, 0);
          }
        }
        disconnected() {}
        reconnected() {}
      }
      let p = () => new f();
      class f {}
      let g = new WeakMap(),
        m = (0, s.u$)(
          class extends u {
            render(e) {
              return i.s6;
            }
            update(e, [t]) {
              let r = t !== this.G;
              return (
                r && void 0 !== this.G && this.rt(void 0),
                (r || this.lt !== this.ct) &&
                  ((this.G = t),
                  (this.ht = e.options?.host),
                  this.rt((this.ct = e.element))),
                i.s6
              );
            }
            rt(e) {
              if (
                (this.isConnected || (e = void 0), "function" == typeof this.G)
              ) {
                let t = this.ht ?? globalThis,
                  r = g.get(t);
                void 0 === r && ((r = new WeakMap()), g.set(t, r)),
                  void 0 !== r.get(this.G) && this.G.call(this.ht, void 0),
                  r.set(this.G, e),
                  void 0 !== e && this.G.call(this.ht, e);
              } else this.G.value = e;
            }
            get lt() {
              return "function" == typeof this.G
                ? g.get(this.ht ?? globalThis)?.get(this.G)
                : this.G?.value;
            }
            disconnected() {
              this.lt === this.ct && this.rt(void 0);
            }
            reconnected() {
              this.rt(this.ct);
            }
          }
        );
    },
    47327: (e, t, r) => {
      "use strict";
      function i(e) {
        return function (t) {
          return "function" == typeof t
            ? (customElements.get(e) || customElements.define(e, t), t)
            : (function (e, t) {
                let { kind: r, elements: i } = t;
                return {
                  kind: r,
                  elements: i,
                  finisher(t) {
                    customElements.get(e) || customElements.define(e, t);
                  },
                };
              })(e, t);
        };
      }
      r.d(t, { E: () => i });
    },
    47824: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
    border-radius: ${({ borderRadius: e }) => e["20"]};
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments), (this.logo = "google");
        }
        render() {
          return (0,
          i.qy)`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)()], d.prototype, "logo", void 0),
        (d = l([(0, a.E)("wui-logo")], d));
    },
    48241: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => b }), r(59335);
      var i = r(45553),
        n = r(79530),
        s = r(93481),
        a = r(10899),
        o = r(71305),
        c = r(12319),
        l = r(75578),
        d = r(79355);
      let h = {
        hexStringToNumber: (e) =>
          parseInt(e.startsWith("0x") ? e.slice(2) : e, 16),
        numberToHexString: (e) => `0x${e.toString(16)}`,
        async getUserInfo(e) {
          let [t, r] = await Promise.all([h.getAddresses(e), h.getChainId(e)]);
          return { chainId: r, addresses: t };
        },
        getChainId: async (e) =>
          Number(await e.request({ method: "eth_chainId" })),
        async getAddress(e) {
          let [t] = await e.request({ method: "eth_accounts" });
          return t;
        },
        getAddresses: async (e) => await e.request({ method: "eth_accounts" }),
        async addEthereumChain(e, t) {
          let r = t.rpcUrls.chainDefault?.http || [];
          await e.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: h.numberToHexString(t.id),
                rpcUrls: [...r],
                chainName: t.name,
                nativeCurrency: {
                  name: t.nativeCurrency.name,
                  decimals: t.nativeCurrency.decimals,
                  symbol: t.nativeCurrency.symbol,
                },
                blockExplorerUrls: [t.blockExplorers?.default.url],
                iconUrls: [l.L.NetworkImageIds[t.id]],
              },
            ],
          });
        },
      };
      var u = r(42312);
      let p = { ACCOUNT_INDEXES: { PAYMENT: 0, ORDINAL: 1 } };
      var f = r(15913);
      class g {
        constructor(e) {
          this.namespace = e.namespace;
        }
        async syncConnections(e) {
          switch (this.namespace) {
            case i.o.CHAIN.EVM:
              await this.syncEVMConnections(e);
              break;
            case i.o.CHAIN.SOLANA:
              await this.syncSolanaConnections(e);
              break;
            case i.o.CHAIN.BITCOIN:
              await this.syncBitcoinConnections(e);
              break;
            default:
              throw Error(`Unsupported chain namespace: ${this.namespace}`);
          }
        }
        async syncEVMConnections({
          connectors: e,
          caipNetworks: t,
          universalProvider: r,
          onConnection: n,
          onListenProvider: s,
        }) {
          await Promise.all(
            e
              .filter((e) => {
                let { hasDisconnected: t, hasConnected: r } =
                  d.y.getConnectorStorageInfo(e.id, this.namespace);
                return !t && r;
              })
              .map(async (e) => {
                if (e.id === i.o.CONNECTOR_ID.WALLET_CONNECT) {
                  let i = f.k.getWalletConnectAccounts(r, this.namespace),
                    s = t.find(
                      (e) =>
                        e.chainNamespace === this.namespace &&
                        e.id.toString() === i[0]?.chainId?.toString()
                    );
                  i.length > 0 &&
                    n({
                      connectorId: e.id,
                      accounts: i.map((e) => ({ address: e.address })),
                      caipNetwork: s,
                    });
                } else {
                  let { accounts: r, chainId: a } =
                    await u.gf.fetchProviderData(e);
                  if (r.length > 0 && a) {
                    let o = t.find(
                      (e) =>
                        e.chainNamespace === this.namespace &&
                        e.id.toString() === a.toString()
                    );
                    n({
                      connectorId: e.id,
                      accounts: r.map((e) => ({ address: e })),
                      caipNetwork: o,
                    }),
                      e.provider &&
                        e.id !== i.o.CONNECTOR_ID.AUTH &&
                        e.id !== i.o.CONNECTOR_ID.WALLET_CONNECT &&
                        s(e.id, e.provider);
                  }
                }
              })
          );
        }
        async syncSolanaConnections({
          connectors: e,
          caipNetwork: t,
          universalProvider: r,
          onConnection: n,
          onListenProvider: s,
        }) {
          await Promise.all(
            e
              .filter((e) => {
                let { hasDisconnected: t, hasConnected: r } =
                  d.y.getConnectorStorageInfo(e.id, this.namespace);
                return !t && r;
              })
              .map(async (e) => {
                if (e.id === i.o.CONNECTOR_ID.WALLET_CONNECT) {
                  let i = f.k.getWalletConnectAccounts(r, this.namespace);
                  i.length > 0 &&
                    n({
                      connectorId: e.id,
                      accounts: i.map((e) => ({ address: e.address })),
                      caipNetwork: t,
                    });
                } else {
                  let r = await e.connect({ chainId: t?.id });
                  r &&
                    (n({
                      connectorId: e.id,
                      accounts: [{ address: r }],
                      caipNetwork: t,
                    }),
                    s(e.id, e.provider));
                }
              })
          );
        }
        async syncBitcoinConnections({
          connectors: e,
          caipNetwork: t,
          universalProvider: r,
          onConnection: n,
          onListenProvider: s,
        }) {
          await Promise.all(
            e
              .filter((e) => {
                let { hasDisconnected: t, hasConnected: r } =
                  d.y.getConnectorStorageInfo(e.id, this.namespace);
                return !t && r;
              })
              .map(async (e) => {
                if (e.id === i.o.CONNECTOR_ID.WALLET_CONNECT) {
                  let i = f.k.getWalletConnectAccounts(r, this.namespace);
                  i.length > 0 &&
                    n({
                      connectorId: e.id,
                      accounts: i.map((e) => ({ address: e.address })),
                      caipNetwork: t,
                    });
                  return;
                }
                let a = await e.connect(),
                  o = await e.getAccountAddresses(),
                  l = o?.map((e) =>
                    c.w.createAccount(
                      i.o.CHAIN.BITCOIN,
                      e.address,
                      e.purpose || "payment",
                      e.publicKey,
                      e.path
                    )
                  );
                if (
                  (l &&
                    l.length > 1 &&
                    (l = [
                      {
                        namespace: i.o.CHAIN.BITCOIN,
                        publicKey:
                          l[p.ACCOUNT_INDEXES.PAYMENT]?.publicKey ?? "",
                        path: l[p.ACCOUNT_INDEXES.PAYMENT]?.path ?? "",
                        address: l[p.ACCOUNT_INDEXES.PAYMENT]?.address ?? "",
                        type: "payment",
                      },
                      {
                        namespace: i.o.CHAIN.BITCOIN,
                        publicKey:
                          l[p.ACCOUNT_INDEXES.ORDINAL]?.publicKey ?? "",
                        path: l[p.ACCOUNT_INDEXES.ORDINAL]?.path ?? "",
                        address: l[p.ACCOUNT_INDEXES.ORDINAL]?.address ?? "",
                        type: "ordinal",
                      },
                    ]),
                  !(e.chains.find((e) => e.id === t?.id) || e.chains[0]))
                )
                  throw Error(
                    "The connector does not support any of the requested chains"
                  );
                a &&
                  (s(e.id, e.provider),
                  n({
                    connectorId: e.id,
                    accounts: l.map((e) => ({
                      address: e.address,
                      type: e.type,
                      publicKey: e.publicKey,
                      path: e.path,
                    })),
                    caipNetwork: t,
                  }));
              })
          );
        }
        getConnection({
          address: e,
          connectorId: t,
          connections: r,
          connectors: i,
        }) {
          if (t) {
            let n = r.find((e) => d.y.isLowerCaseMatch(e.connectorId, t));
            if (!n) return null;
            let s = i.find((e) => d.y.isLowerCaseMatch(e.id, n.connectorId)),
              a = e
                ? n.accounts.find((t) => d.y.isLowerCaseMatch(t.address, e))
                : n.accounts[0];
            return { ...n, account: a, connector: s };
          }
          let n = r.find(
            (e) =>
              e.accounts.length > 0 &&
              i.some((t) => d.y.isLowerCaseMatch(t.id, e.connectorId))
          );
          if (n) {
            let [e] = n.accounts,
              t = i.find((e) => d.y.isLowerCaseMatch(e.id, n.connectorId));
            return { ...n, account: e, connector: t };
          }
          return null;
        }
      }
      var m = r(10763),
        y = r(19816);
      let w = [i.o.CONNECTOR_ID.AUTH, i.o.CONNECTOR_ID.WALLET_CONNECT];
      class b {
        constructor(e) {
          (this.availableConnectors = []),
            (this.availableConnections = []),
            (this.providerHandlers = {}),
            (this.eventListeners = new Map()),
            (this.getCaipNetworks = (e) => s.W.getCaipNetworks(e)),
            (this.getConnectorId = (e) => a.a.getConnectorId(e)),
            e && this.construct(e),
            e?.namespace &&
              (this.connectionManager = new g({ namespace: e.namespace }));
        }
        construct(e) {
          (this.projectId = e.projectId),
            (this.namespace = e.namespace),
            (this.adapterType = e.adapterType);
        }
        get connectors() {
          return this.availableConnectors;
        }
        get connections() {
          return this.availableConnections;
        }
        get networks() {
          return this.getCaipNetworks(this.namespace);
        }
        onAuthConnected({ accounts: e, chainId: t }) {
          let r = this.getCaipNetworks()
            .filter((e) => e.chainNamespace === this.namespace)
            .find((e) => e.id.toString() === t?.toString());
          e &&
            r &&
            this.addConnection({
              connectorId: i.o.CONNECTOR_ID.AUTH,
              accounts: e,
              caipNetwork: r,
            });
        }
        setAuthProvider(e) {
          e.onConnect(this.onAuthConnected.bind(this)),
            e.onSocialConnected(this.onAuthConnected.bind(this)),
            this.addConnector({
              id: i.o.CONNECTOR_ID.AUTH,
              type: "AUTH",
              name: i.o.CONNECTOR_NAMES.AUTH,
              provider: e,
              imageId: l.L.ConnectorImageIds[i.o.CONNECTOR_ID.AUTH],
              chain: this.namespace,
              chains: [],
            });
        }
        addConnector(...e) {
          let t = new Set();
          (this.availableConnectors = [
            ...e,
            ...this.availableConnectors,
          ].filter((e) => !t.has(e.id) && (t.add(e.id), !0))),
            this.emit("connectors", this.availableConnectors);
        }
        addConnection(...e) {
          let t = new Set();
          (this.availableConnections = [
            ...e,
            ...this.availableConnections,
          ].filter(
            (e) =>
              !t.has(e.connectorId.toLowerCase()) &&
              (t.add(e.connectorId.toLowerCase()), !0)
          )),
            this.emit("connections", this.availableConnections);
        }
        deleteConnection(e) {
          (this.availableConnections = this.availableConnections.filter(
            (t) => !d.y.isLowerCaseMatch(t.connectorId, e)
          )),
            this.emit("connections", this.availableConnections);
        }
        clearConnections(e = !1) {
          (this.availableConnections = []),
            e && this.emit("connections", this.availableConnections);
        }
        setStatus(e, t) {
          s.W.setAccountProp("status", e, t);
        }
        on(e, t) {
          this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
            this.eventListeners.get(e)?.add(t);
        }
        off(e, t) {
          let r = this.eventListeners.get(e);
          r && r.delete(t);
        }
        removeAllEventListeners() {
          this.eventListeners.forEach((e) => {
            e.clear();
          });
        }
        emit(e, t) {
          let r = this.eventListeners.get(e);
          r && r.forEach((e) => e(t));
        }
        async connectWalletConnect(e) {
          try {
            let e = this.getWalletConnectConnector();
            return { clientId: (await e.connectWalletConnect()).clientId };
          } catch (e) {
            if (y.kl.isUserRejectedRequestError(e)) throw new n.vx(e);
            throw e;
          }
        }
        async switchNetwork(e) {
          let { caipNetwork: t, providerType: r } = e;
          if (!e.provider) return;
          let i = "provider" in e.provider ? e.provider.provider : e.provider;
          if ("WALLET_CONNECT" === r)
            return void i.setDefaultChain(t.caipNetworkId);
          if (i && "AUTH" === r) {
            let e = (0, o.lj)(t.chainNamespace);
            await i.switchNetwork({ chainId: t.caipNetworkId });
            let r = await i.getUser({
              chainId: t.caipNetworkId,
              preferredAccountType: e,
            });
            this.emit("switchNetwork", r);
          }
        }
        getWalletConnectConnector() {
          let e = this.connectors.find((e) => e instanceof m.F);
          if (!e) throw Error("WalletConnectConnector not found");
          return e;
        }
        onConnect(e, t) {
          if (e.length > 0) {
            let { address: r, chainId: i } = c.w.getAccount(e[0]),
              n = this.getCaipNetworks()
                .filter((e) => e.chainNamespace === this.namespace)
                .find((e) => e.id.toString() === i?.toString()),
              s = this.connectors.find((e) => e.id === t);
            r &&
              (this.emit("accountChanged", {
                address: r,
                chainId: i,
                connector: s,
              }),
              this.addConnection({
                connectorId: t,
                accounts: e.map((e) => {
                  let { address: t } = c.w.getAccount(e);
                  return { address: t };
                }),
                caipNetwork: n,
              }));
          }
        }
        onAccountsChanged(e, t, r = !0) {
          if (e.length > 0) {
            let { address: r } = c.w.getAccount(e[0]),
              n = this.connectionManager?.getConnection({
                connectorId: t,
                connections: this.connections,
                connectors: this.connectors,
              });
            r &&
              d.y.isLowerCaseMatch(this.getConnectorId(i.o.CHAIN.EVM), t) &&
              this.emit("accountChanged", {
                address: r,
                chainId: n?.caipNetwork?.id,
                connector: n?.connector,
              }),
              this.addConnection({
                connectorId: t,
                accounts: e.map((e) => {
                  let { address: t } = c.w.getAccount(e);
                  return { address: t };
                }),
                caipNetwork: n?.caipNetwork,
              });
          } else r && this.onDisconnect(t);
        }
        onDisconnect(e) {
          this.removeProviderListeners(e),
            this.deleteConnection(e),
            d.y.isLowerCaseMatch(this.getConnectorId(i.o.CHAIN.EVM), e) &&
              this.emitFirstAvailableConnection(),
            0 === this.connections.length && this.emit("disconnect");
        }
        onChainChanged(e, t) {
          let r =
              "string" == typeof e && e.startsWith("0x")
                ? h.hexStringToNumber(e).toString()
                : e.toString(),
            n = this.connectionManager?.getConnection({
              connectorId: t,
              connections: this.connections,
              connectors: this.connectors,
            }),
            s = this.getCaipNetworks()
              .filter((e) => e.chainNamespace === this.namespace)
              .find((e) => e.id.toString() === r);
          n &&
            this.addConnection({
              connectorId: t,
              accounts: n.accounts,
              caipNetwork: s,
            }),
            d.y.isLowerCaseMatch(this.getConnectorId(i.o.CHAIN.EVM), t) &&
              this.emit("switchNetwork", { chainId: r });
        }
        listenProviderEvents(e, t) {
          if (w.includes(e)) return;
          let r = (t) => this.onAccountsChanged(t, e),
            i = (t) => this.onChainChanged(t, e),
            n = () => this.onDisconnect(e);
          this.providerHandlers[e] ||
            (t.on("disconnect", n),
            t.on("accountsChanged", r),
            t.on("chainChanged", i),
            (this.providerHandlers[e] = {
              provider: t,
              disconnect: n,
              accountsChanged: r,
              chainChanged: i,
            }));
        }
        removeProviderListeners(e) {
          if (this.providerHandlers[e]) {
            let {
              provider: t,
              disconnect: r,
              accountsChanged: i,
              chainChanged: n,
            } = this.providerHandlers[e];
            t.removeListener("disconnect", r),
              t.removeListener("accountsChanged", i),
              t.removeListener("chainChanged", n),
              (this.providerHandlers[e] = null);
          }
        }
        emitFirstAvailableConnection() {
          let e = this.connectionManager?.getConnection({
            connections: this.connections,
            connectors: this.connectors,
          });
          if (e) {
            let [t] = e.accounts;
            this.emit("accountChanged", {
              address: t?.address,
              chainId: e.caipNetwork?.id,
              connector: e.connector,
            });
          }
        }
      }
    },
    48352: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691), r(24772);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  button {
    border: none;
    background: transparent;
    height: 20px;
    padding: ${({ spacing: e }) => e[2]};
    column-gap: ${({ spacing: e }) => e[1]};
    border-radius: ${({ borderRadius: e }) => e[1]};
    padding: 0 ${({ spacing: e }) => e[1]};
    border-radius: ${({ spacing: e }) => e[1]};
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='accent'] {
    color: ${({ tokens: e }) => e.core.textAccentPrimary};
  }

  button[data-variant='secondary'] {
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  /* -- Focus states --------------------------------------------------- */
  button:focus-visible:enabled {
    box-shadow: 0px 0px 0px 4px rgba(9, 136, 240, 0.2);
  }

  button[data-variant='accent']:focus-visible:enabled {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  button[data-variant='secondary']:focus-visible:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  button[data-variant='accent']:hover:enabled {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  button[data-variant='secondary']:hover:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  button[data-variant='accent']:focus-visible {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  button[data-variant='secondary']:focus-visible {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    box-shadow: 0px 0px 0px 4px rgba(9, 136, 240, 0.2);
  }

  button[disabled] {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = { sm: "sm-medium", md: "md-medium" },
        h = { accent: "accent-primary", secondary: "secondary" },
        u = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.size = "md"),
              (this.disabled = !1),
              (this.variant = "accent"),
              (this.icon = void 0);
          }
          render() {
            return (0, i.qy)`
      <button ?disabled=${this.disabled} data-variant=${this.variant}>
        <slot name="iconLeft"></slot>
        <wui-text
          color=${h[this.variant]}
          variant=${d[this.size]}
        >
          <slot></slot>
        </wui-text>
        ${this.iconTemplate()}
      </button>
    `;
          }
          iconTemplate() {
            return this.icon
              ? (0, i.qy)`<wui-icon name=${this.icon} size="sm"></wui-icon>`
              : null;
          }
        };
      (u.styles = [s.W5, s.fD, c]),
        l([(0, n.MZ)()], u.prototype, "size", void 0),
        l([(0, n.MZ)({ type: Boolean })], u.prototype, "disabled", void 0),
        l([(0, n.MZ)()], u.prototype, "variant", void 0),
        l([(0, n.MZ)()], u.prototype, "icon", void 0),
        (u = l([(0, a.E)("wui-link")], u));
    },
    48543: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.delay = void 0),
        (t.delay = function (e) {
          return new Promise((t) => {
            setTimeout(() => {
              t(!0);
            }, e);
          });
        });
    },
    48876: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964);
      r(99691), r(24772);
      var a = r(71084),
        o = r(47327);
      r(5089);
      let c = (0, i.AH)`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments), (this.disabled = !1);
        }
        render() {
          return (0, i.qy)`
      <wui-input-text
        type="email"
        placeholder="Email"
        icon="mail"
        size="lg"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
        tabIdx=${(0, s.J)(this.tabIdx)}
      ></wui-input-text>
      ${this.templateError()}
    `;
        }
        templateError() {
          return this.errorMessage
            ? (0,
              i.qy)`<wui-text variant="sm-regular" color="error">${this.errorMessage}</wui-text>`
            : null;
        }
      };
      (d.styles = [a.W5, c]),
        l([(0, n.MZ)()], d.prototype, "errorMessage", void 0),
        l([(0, n.MZ)({ type: Boolean })], d.prototype, "disabled", void 0),
        l([(0, n.MZ)()], d.prototype, "value", void 0),
        l([(0, n.MZ)()], d.prototype, "tabIdx", void 0),
        (d = l([(0, o.E)("wui-email-input")], d));
    },
    48981: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => p });
      var i = r(45553),
        n = r(55480),
        s = r(58653),
        a = r(72880),
        o = r(12319),
        c = r(97418),
        l = r(93481),
        d = r(10899),
        h = r(79355),
        u = r(18635);
      let p = {
        getConnectorsByType(e, t, r) {
          let { customWallets: i } = n.H.state,
            a = s.i.getRecentWallets(),
            o = u.A.filterOutDuplicateWallets(t),
            c = u.A.filterOutDuplicateWallets(r),
            l = e.filter((e) => "MULTI_CHAIN" === e.type),
            d = e.filter((e) => "ANNOUNCED" === e.type),
            h = e.filter((e) => "INJECTED" === e.type);
          return {
            custom: i,
            recent: a,
            external: e.filter((e) => "EXTERNAL" === e.type),
            multiChain: l,
            announced: d,
            injected: h,
            recommended: o,
            featured: c,
          };
        },
        showConnector(e) {
          let t = e.info?.rdns,
            r =
              !!t &&
              a.N.state.excludedWallets.some((e) => !!e.rdns && e.rdns === t),
            i =
              !!e.name &&
              a.N.state.excludedWallets.some((t) =>
                h.y.isLowerCaseMatch(t.name, e.name)
              );
          if (
            "INJECTED" === e.type &&
            (("Browser Wallet" === e.name &&
              (!o.w.isMobile() ||
                (o.w.isMobile() && !t && !c.x.checkInstalled()))) ||
              r ||
              i)
          )
            return !1;
          return (
            ("ANNOUNCED" !== e.type && "EXTERNAL" !== e.type) || (!r && !i)
          );
        },
        getIsConnectedWithWC: () =>
          Array.from(l.W.state.chains.values()).some(
            (e) =>
              d.a.getConnectorId(e.namespace) ===
              i.o.CONNECTOR_ID.WALLET_CONNECT
          ),
        getConnectorTypeOrder({
          recommended: e,
          featured: t,
          custom: r,
          recent: i,
          announced: s,
          injected: a,
          multiChain: o,
          external: c,
          overriddenConnectors: l = n.H.state.features?.connectorTypeOrder ??
            [],
        }) {
          let d = [
              { type: "walletConnect", isEnabled: !0 },
              { type: "recent", isEnabled: i.length > 0 },
              { type: "injected", isEnabled: [...a, ...s, ...o].length > 0 },
              { type: "featured", isEnabled: t.length > 0 },
              { type: "custom", isEnabled: r && r.length > 0 },
              { type: "external", isEnabled: c.length > 0 },
              { type: "recommended", isEnabled: e.length > 0 },
            ].filter((e) => e.isEnabled),
            h = new Set(d.map((e) => e.type)),
            u = l
              .filter((e) => h.has(e))
              .map((e) => ({ type: e, isEnabled: !0 })),
            p = d.filter(({ type: e }) => !u.some(({ type: t }) => t === e));
          return Array.from(new Set([...u, ...p].map(({ type: e }) => e)));
        },
        sortConnectorsByExplorerWallet: (e) =>
          [...e].sort((e, t) =>
            e.explorerWallet && t.explorerWallet
              ? (e.explorerWallet.order ?? 0) - (t.explorerWallet.order ?? 0)
              : e.explorerWallet
              ? -1
              : +!!t.explorerWallet
          ),
        getAuthName: ({ email: e, socialUsername: t, socialProvider: r }) =>
          t
            ? r && "discord" === r && t.endsWith("0")
              ? t.slice(0, -1)
              : t
            : e.length > 30
            ? `${e.slice(0, -3)}...`
            : e,
        async fetchProviderData(e) {
          try {
            if (
              ("Browser Wallet" === e.name && !o.w.isMobile()) ||
              e.id === i.o.CONNECTOR_ID.AUTH
            )
              return { accounts: [], chainId: void 0 };
            let [t, r] = await Promise.all([
              e.provider?.request({ method: "eth_accounts" }),
              e.provider
                ?.request({ method: "eth_chainId" })
                .then((e) => Number(e)),
            ]);
            return { accounts: t, chainId: r };
          } catch (t) {
            return (
              console.warn(`Failed to fetch provider data for ${e.name}`, t),
              { accounts: [], chainId: void 0 }
            );
          }
        },
      };
    },
    50505: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      r(99691), r(24772);
      var s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: ${({ spacing: e }) => e[1]};
    text-transform: uppercase;
  }

  :host([data-variant='accent']) {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
    color: ${({ tokens: e }) => e.core.textAccentPrimary};
  }

  :host([data-variant='info']) {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  :host([data-variant='success']) {
    background-color: ${({ tokens: e }) => e.core.backgroundSuccess};
    color: ${({ tokens: e }) => e.core.textSuccess};
  }

  :host([data-variant='warning']) {
    background-color: ${({ tokens: e }) => e.core.backgroundWarning};
    color: ${({ tokens: e }) => e.core.textWarning};
  }

  :host([data-variant='error']) {
    background-color: ${({ tokens: e }) => e.core.backgroundError};
    color: ${({ tokens: e }) => e.core.textError};
  }

  :host([data-variant='certified']) {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  :host([data-size='md']) {
    height: 30px;
    padding: 0 ${({ spacing: e }) => e[2]};
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host([data-size='sm']) {
    height: 20px;
    padding: 0 ${({ spacing: e }) => e[1]};
    border-radius: ${({ borderRadius: e }) => e[1]};
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.variant = "accent"),
            (this.size = "md"),
            (this.icon = void 0);
        }
        render() {
          (this.dataset.variant = this.variant),
            (this.dataset.size = this.size);
          let e = "md" === this.size ? "md-medium" : "sm-medium",
            t = "md" === this.size ? "md" : "sm";
          return (0, i.qy)`
      ${
        this.icon
          ? (0, i.qy)`<wui-icon size=${t} name=${this.icon}></wui-icon>`
          : null
      }
      <wui-text data-variant=${this.variant} variant=${e} color="inherit">
        <slot></slot>
      </wui-text>
    `;
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)()], d.prototype, "variant", void 0),
        l([(0, n.MZ)()], d.prototype, "size", void 0),
        l([(0, n.MZ)()], d.prototype, "icon", void 0),
        (d = l([(0, a.E)("wui-tag")], d));
    },
    50707: (e, t, r) => {
      "use strict";
      function i(e, t) {
        return ({ exclude: r, format: i }) => ({
          exclude: r,
          format: (e) => {
            let n = t(e);
            if (r) for (let e of r) delete n[e];
            return { ...n, ...i(e) };
          },
          type: e,
        });
      }
      r.d(t, { q: () => i });
    },
    50879: (e, t, r) => {
      "use strict";
      r.d(t, {
        $s: () => h,
        Kc: () => p,
        Kz: () => u,
        Vg: () => l,
        WA: () => f,
        aO: () => a,
        fZ: () => d,
        n3: () => o,
        zW: () => c,
      });
      var i = r(28245),
        n = r(42503),
        s = r(13933);
      function a(e) {
        let t = Object.entries(e)
            .map(([e, t]) => (void 0 === t || !1 === t ? null : [e, t]))
            .filter(Boolean),
          r = t.reduce((e, [t]) => Math.max(e, t.length), 0);
        return t.map(([e, t]) => `  ${`${e}:`.padEnd(r + 1)}  ${t}`).join("\n");
      }
      class o extends s.C {
        constructor() {
          super(
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.\nUse `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.",
            { name: "FeeConflictError" }
          );
        }
      }
      class c extends s.C {
        constructor({ v: e }) {
          super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
            name: "InvalidLegacyVError",
          });
        }
      }
      class l extends s.C {
        constructor({ transaction: e }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              a(e),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
              "- an EIP-7702 Transaction with `authorizationList`, or",
              "- a Legacy Transaction with `gasPrice`",
            ],
            name: "InvalidSerializableTransactionError",
          });
        }
      }
      s.C, s.C;
      class d extends s.C {
        constructor({ storageKey: e }) {
          super(
            `Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor(
              (e.length - 2) / 2
            )} bytes.`,
            { name: "InvalidStorageKeySizeError" }
          );
        }
      }
      class h extends s.C {
        constructor(
          e,
          {
            account: t,
            docsPath: r,
            chain: s,
            data: o,
            gas: c,
            gasPrice: l,
            maxFeePerGas: d,
            maxPriorityFeePerGas: h,
            nonce: u,
            to: p,
            value: f,
          }
        ) {
          super(e.shortMessage, {
            cause: e,
            docsPath: r,
            metaMessages: [
              ...(e.metaMessages ? [...e.metaMessages, " "] : []),
              "Request Arguments:",
              a({
                chain: s && `${s?.name} (id: ${s?.id})`,
                from: t?.address,
                to: p,
                value:
                  void 0 !== f &&
                  `${(0, i.c)(f)} ${s?.nativeCurrency?.symbol || "ETH"}`,
                data: o,
                gas: c,
                gasPrice: void 0 !== l && `${(0, n.Q)(l)} gwei`,
                maxFeePerGas: void 0 !== d && `${(0, n.Q)(d)} gwei`,
                maxPriorityFeePerGas: void 0 !== h && `${(0, n.Q)(h)} gwei`,
                nonce: u,
              }),
            ].filter(Boolean),
            name: "TransactionExecutionError",
          }),
            Object.defineProperty(this, "cause", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.cause = e);
        }
      }
      class u extends s.C {
        constructor({
          blockHash: e,
          blockNumber: t,
          blockTag: r,
          hash: i,
          index: n,
        }) {
          let s = "Transaction";
          r &&
            void 0 !== n &&
            (s = `Transaction at block time "${r}" at index "${n}"`),
            e &&
              void 0 !== n &&
              (s = `Transaction at block hash "${e}" at index "${n}"`),
            t &&
              void 0 !== n &&
              (s = `Transaction at block number "${t}" at index "${n}"`),
            i && (s = `Transaction with hash "${i}"`),
            super(`${s} could not be found.`, {
              name: "TransactionNotFoundError",
            });
        }
      }
      class p extends s.C {
        constructor({ hash: e }) {
          super(
            `Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,
            { name: "TransactionReceiptNotFoundError" }
          );
        }
      }
      class f extends s.C {
        constructor({ hash: e }) {
          super(
            `Timed out while waiting for transaction with hash "${e}" to be confirmed.`,
            { name: "WaitForTransactionReceiptTimeoutError" }
          );
        }
      }
    },
    50915: (e, t, r) => {
      let i = r(10429);
      (t.mul = function (e, t) {
        let r = new Uint8Array(e.length + t.length - 1);
        for (let n = 0; n < e.length; n++)
          for (let s = 0; s < t.length; s++) r[n + s] ^= i.mul(e[n], t[s]);
        return r;
      }),
        (t.mod = function (e, t) {
          let r = new Uint8Array(e);
          for (; r.length - t.length >= 0; ) {
            let e = r[0];
            for (let n = 0; n < t.length; n++) r[n] ^= i.mul(t[n], e);
            let n = 0;
            for (; n < r.length && 0 === r[n]; ) n++;
            r = r.slice(n);
          }
          return r;
        }),
        (t.generateECPolynomial = function (e) {
          let r = new Uint8Array([1]);
          for (let n = 0; n < e; n++)
            r = t.mul(r, new Uint8Array([1, i.exp(n)]));
          return r;
        });
    },
    51568: (e, t, r) => {
      "use strict";
      r(4693);
    },
    51746: (e, t) => {
      "use strict";
      (t.byteLength = function (e) {
        var t = c(e),
          r = t[0],
          i = t[1];
        return ((r + i) * 3) / 4 - i;
      }),
        (t.toByteArray = function (e) {
          var t,
            r,
            s = c(e),
            a = s[0],
            o = s[1],
            l = new n(((a + o) * 3) / 4 - o),
            d = 0,
            h = o > 0 ? a - 4 : a;
          for (r = 0; r < h; r += 4)
            (t =
              (i[e.charCodeAt(r)] << 18) |
              (i[e.charCodeAt(r + 1)] << 12) |
              (i[e.charCodeAt(r + 2)] << 6) |
              i[e.charCodeAt(r + 3)]),
              (l[d++] = (t >> 16) & 255),
              (l[d++] = (t >> 8) & 255),
              (l[d++] = 255 & t);
          return (
            2 === o &&
              ((t = (i[e.charCodeAt(r)] << 2) | (i[e.charCodeAt(r + 1)] >> 4)),
              (l[d++] = 255 & t)),
            1 === o &&
              ((t =
                (i[e.charCodeAt(r)] << 10) |
                (i[e.charCodeAt(r + 1)] << 4) |
                (i[e.charCodeAt(r + 2)] >> 2)),
              (l[d++] = (t >> 8) & 255),
              (l[d++] = 255 & t)),
            l
          );
        }),
        (t.fromByteArray = function (e) {
          for (
            var t, i = e.length, n = i % 3, s = [], a = 0, o = i - n;
            a < o;
            a += 16383
          )
            s.push(
              (function (e, t, i) {
                for (var n, s = [], a = t; a < i; a += 3)
                  (n =
                    ((e[a] << 16) & 0xff0000) +
                    ((e[a + 1] << 8) & 65280) +
                    (255 & e[a + 2])),
                    s.push(
                      r[(n >> 18) & 63] +
                        r[(n >> 12) & 63] +
                        r[(n >> 6) & 63] +
                        r[63 & n]
                    );
                return s.join("");
              })(e, a, a + 16383 > o ? o : a + 16383)
            );
          return (
            1 === n
              ? s.push(r[(t = e[i - 1]) >> 2] + r[(t << 4) & 63] + "==")
              : 2 === n &&
                s.push(
                  r[(t = (e[i - 2] << 8) + e[i - 1]) >> 10] +
                    r[(t >> 4) & 63] +
                    r[(t << 2) & 63] +
                    "="
                ),
            s.join("")
          );
        });
      for (
        var r = [],
          i = [],
          n = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          s =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = 0,
          o = s.length;
        a < o;
        ++a
      )
        (r[a] = s[a]), (i[s.charCodeAt(a)] = a);
      function c(e) {
        var t = e.length;
        if (t % 4 > 0)
          throw Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        -1 === r && (r = t);
        var i = r === t ? 0 : 4 - (r % 4);
        return [r, i];
      }
      (i[45] = 62), (i[95] = 63);
    },
    52321: (e, t, r) => {
      "use strict";
      r.d(t, {
        JW: () => _,
        XX: () => q,
        c0: () => S,
        ej: () => I,
        ge: () => F,
        qy: () => A,
        s6: () => k,
      });
      let i = globalThis,
        n = i.trustedTypes,
        s = n ? n.createPolicy("lit-html", { createHTML: (e) => e }) : void 0,
        a = "$lit$",
        o = `lit$${Math.random().toFixed(9).slice(2)}$`,
        c = "?" + o,
        l = `<${c}>`,
        d = document,
        h = () => d.createComment(""),
        u = (e) =>
          null === e || ("object" != typeof e && "function" != typeof e),
        p = Array.isArray,
        f = (e) => p(e) || "function" == typeof e?.[Symbol.iterator],
        g = "[ 	\n\f\r]",
        m = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
        y = /-->/g,
        w = />/g,
        b = RegExp(
          `>|${g}(?:([^\\s"'>=/]+)(${g}*=${g}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
          "g"
        ),
        v = /'/g,
        C = /"/g,
        E = /^(?:script|style|textarea|title)$/i,
        x =
          (e) =>
          (t, ...r) => ({ _$litType$: e, strings: t, values: r }),
        A = x(1),
        _ = x(2),
        I = x(3),
        S = Symbol.for("lit-noChange"),
        k = Symbol.for("lit-nothing"),
        N = new WeakMap(),
        T = d.createTreeWalker(d, 129);
      function O(e, t) {
        if (!p(e) || !e.hasOwnProperty("raw"))
          throw Error("invalid template strings array");
        return void 0 !== s ? s.createHTML(t) : t;
      }
      let P = (e, t) => {
        let r = e.length - 1,
          i = [],
          n,
          s = 2 === t ? "<svg>" : 3 === t ? "<math>" : "",
          c = m;
        for (let t = 0; t < r; t++) {
          let r = e[t],
            d,
            h,
            u = -1,
            p = 0;
          for (
            ;
            p < r.length && ((c.lastIndex = p), null !== (h = c.exec(r)));

          )
            (p = c.lastIndex),
              c === m
                ? "!--" === h[1]
                  ? (c = y)
                  : void 0 !== h[1]
                  ? (c = w)
                  : void 0 !== h[2]
                  ? (E.test(h[2]) && (n = RegExp("</" + h[2], "g")), (c = b))
                  : void 0 !== h[3] && (c = b)
                : c === b
                ? ">" === h[0]
                  ? ((c = n ?? m), (u = -1))
                  : void 0 === h[1]
                  ? (u = -2)
                  : ((u = c.lastIndex - h[2].length),
                    (d = h[1]),
                    (c = void 0 === h[3] ? b : '"' === h[3] ? C : v))
                : c === C || c === v
                ? (c = b)
                : c === y || c === w
                ? (c = m)
                : ((c = b), (n = void 0));
          let f = c === b && e[t + 1].startsWith("/>") ? " " : "";
          s +=
            c === m
              ? r + l
              : u >= 0
              ? (i.push(d), r.slice(0, u) + a + r.slice(u) + o + f)
              : r + o + (-2 === u ? t : f);
        }
        return [
          O(
            e,
            s +
              (e[r] || "<?>") +
              (2 === t ? "</svg>" : 3 === t ? "</math>" : "")
          ),
          i,
        ];
      };
      class R {
        constructor({ strings: e, _$litType$: t }, r) {
          let i;
          this.parts = [];
          let s = 0,
            l = 0,
            d = e.length - 1,
            u = this.parts,
            [p, f] = P(e, t);
          if (
            ((this.el = R.createElement(p, r)),
            (T.currentNode = this.el.content),
            2 === t || 3 === t)
          ) {
            let e = this.el.content.firstChild;
            e.replaceWith(...e.childNodes);
          }
          for (; null !== (i = T.nextNode()) && u.length < d; ) {
            if (1 === i.nodeType) {
              if (i.hasAttributes())
                for (let e of i.getAttributeNames())
                  if (e.endsWith(a)) {
                    let t = f[l++],
                      r = i.getAttribute(e).split(o),
                      n = /([.?@])?(.*)/.exec(t);
                    u.push({
                      type: 1,
                      index: s,
                      name: n[2],
                      strings: r,
                      ctor:
                        "." === n[1]
                          ? L
                          : "?" === n[1]
                          ? B
                          : "@" === n[1]
                          ? W
                          : M,
                    }),
                      i.removeAttribute(e);
                  } else
                    e.startsWith(o) &&
                      (u.push({ type: 6, index: s }), i.removeAttribute(e));
              if (E.test(i.tagName)) {
                let e = i.textContent.split(o),
                  t = e.length - 1;
                if (t > 0) {
                  i.textContent = n ? n.emptyScript : "";
                  for (let r = 0; r < t; r++)
                    i.append(e[r], h()),
                      T.nextNode(),
                      u.push({ type: 2, index: ++s });
                  i.append(e[t], h());
                }
              }
            } else if (8 === i.nodeType)
              if (i.data === c) u.push({ type: 2, index: s });
              else {
                let e = -1;
                for (; -1 !== (e = i.data.indexOf(o, e + 1)); )
                  u.push({ type: 7, index: s }), (e += o.length - 1);
              }
            s++;
          }
        }
        static createElement(e, t) {
          let r = d.createElement("template");
          return (r.innerHTML = e), r;
        }
      }
      function $(e, t, r = e, i) {
        if (t === S) return t;
        let n = void 0 !== i ? r._$Co?.[i] : r._$Cl,
          s = u(t) ? void 0 : t._$litDirective$;
        return (
          n?.constructor !== s &&
            (n?._$AO?.(!1),
            void 0 === s ? (n = void 0) : (n = new s(e))._$AT(e, r, i),
            void 0 !== i ? ((r._$Co ??= [])[i] = n) : (r._$Cl = n)),
          void 0 !== n && (t = $(e, n._$AS(e, t.values), n, i)),
          t
        );
      }
      class D {
        constructor(e, t) {
          (this._$AV = []),
            (this._$AN = void 0),
            (this._$AD = e),
            (this._$AM = t);
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(e) {
          let {
              el: { content: t },
              parts: r,
            } = this._$AD,
            i = (e?.creationScope ?? d).importNode(t, !0);
          T.currentNode = i;
          let n = T.nextNode(),
            s = 0,
            a = 0,
            o = r[0];
          for (; void 0 !== o; ) {
            if (s === o.index) {
              let t;
              2 === o.type
                ? (t = new U(n, n.nextSibling, this, e))
                : 1 === o.type
                ? (t = new o.ctor(n, o.name, o.strings, this, e))
                : 6 === o.type && (t = new j(n, this, e)),
                this._$AV.push(t),
                (o = r[++a]);
            }
            s !== o?.index && ((n = T.nextNode()), s++);
          }
          return (T.currentNode = d), i;
        }
        p(e) {
          let t = 0;
          for (let r of this._$AV)
            void 0 !== r &&
              (void 0 !== r.strings
                ? (r._$AI(e, r, t), (t += r.strings.length - 2))
                : r._$AI(e[t])),
              t++;
        }
      }
      class U {
        get _$AU() {
          return this._$AM?._$AU ?? this._$Cv;
        }
        constructor(e, t, r, i) {
          (this.type = 2),
            (this._$AH = k),
            (this._$AN = void 0),
            (this._$AA = e),
            (this._$AB = t),
            (this._$AM = r),
            (this.options = i),
            (this._$Cv = i?.isConnected ?? !0);
        }
        get parentNode() {
          let e = this._$AA.parentNode,
            t = this._$AM;
          return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(e, t = this) {
          u((e = $(this, e, t)))
            ? e === k || null == e || "" === e
              ? (this._$AH !== k && this._$AR(), (this._$AH = k))
              : e !== this._$AH && e !== S && this._(e)
            : void 0 !== e._$litType$
            ? this.$(e)
            : void 0 !== e.nodeType
            ? this.T(e)
            : f(e)
            ? this.k(e)
            : this._(e);
        }
        O(e) {
          return this._$AA.parentNode.insertBefore(e, this._$AB);
        }
        T(e) {
          this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
        }
        _(e) {
          this._$AH !== k && u(this._$AH)
            ? (this._$AA.nextSibling.data = e)
            : this.T(d.createTextNode(e)),
            (this._$AH = e);
        }
        $(e) {
          let { values: t, _$litType$: r } = e,
            i =
              "number" == typeof r
                ? this._$AC(e)
                : (void 0 === r.el &&
                    (r.el = R.createElement(O(r.h, r.h[0]), this.options)),
                  r);
          if (this._$AH?._$AD === i) this._$AH.p(t);
          else {
            let e = new D(i, this),
              r = e.u(this.options);
            e.p(t), this.T(r), (this._$AH = e);
          }
        }
        _$AC(e) {
          let t = N.get(e.strings);
          return void 0 === t && N.set(e.strings, (t = new R(e))), t;
        }
        k(e) {
          p(this._$AH) || ((this._$AH = []), this._$AR());
          let t = this._$AH,
            r,
            i = 0;
          for (let n of e)
            i === t.length
              ? t.push(
                  (r = new U(this.O(h()), this.O(h()), this, this.options))
                )
              : (r = t[i]),
              r._$AI(n),
              i++;
          i < t.length &&
            (this._$AR(r && r._$AB.nextSibling, i), (t.length = i));
        }
        _$AR(e = this._$AA.nextSibling, t) {
          for (this._$AP?.(!1, !0, t); e !== this._$AB; ) {
            let t = e.nextSibling;
            e.remove(), (e = t);
          }
        }
        setConnected(e) {
          void 0 === this._$AM && ((this._$Cv = e), this._$AP?.(e));
        }
      }
      class M {
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        constructor(e, t, r, i, n) {
          (this.type = 1),
            (this._$AH = k),
            (this._$AN = void 0),
            (this.element = e),
            (this.name = t),
            (this._$AM = i),
            (this.options = n),
            r.length > 2 || "" !== r[0] || "" !== r[1]
              ? ((this._$AH = Array(r.length - 1).fill(new String())),
                (this.strings = r))
              : (this._$AH = k);
        }
        _$AI(e, t = this, r, i) {
          let n = this.strings,
            s = !1;
          if (void 0 === n)
            (s = !u((e = $(this, e, t, 0))) || (e !== this._$AH && e !== S)) &&
              (this._$AH = e);
          else {
            let i,
              a,
              o = e;
            for (e = n[0], i = 0; i < n.length - 1; i++)
              (a = $(this, o[r + i], t, i)) === S && (a = this._$AH[i]),
                (s ||= !u(a) || a !== this._$AH[i]),
                a === k ? (e = k) : e !== k && (e += (a ?? "") + n[i + 1]),
                (this._$AH[i] = a);
          }
          s && !i && this.j(e);
        }
        j(e) {
          e === k
            ? this.element.removeAttribute(this.name)
            : this.element.setAttribute(this.name, e ?? "");
        }
      }
      class L extends M {
        constructor() {
          super(...arguments), (this.type = 3);
        }
        j(e) {
          this.element[this.name] = e === k ? void 0 : e;
        }
      }
      class B extends M {
        constructor() {
          super(...arguments), (this.type = 4);
        }
        j(e) {
          this.element.toggleAttribute(this.name, !!e && e !== k);
        }
      }
      class W extends M {
        constructor(e, t, r, i, n) {
          super(e, t, r, i, n), (this.type = 5);
        }
        _$AI(e, t = this) {
          if ((e = $(this, e, t, 0) ?? k) === S) return;
          let r = this._$AH,
            i =
              (e === k && r !== k) ||
              e.capture !== r.capture ||
              e.once !== r.once ||
              e.passive !== r.passive,
            n = e !== k && (r === k || i);
          i && this.element.removeEventListener(this.name, this, r),
            n && this.element.addEventListener(this.name, this, e),
            (this._$AH = e);
        }
        handleEvent(e) {
          "function" == typeof this._$AH
            ? this._$AH.call(this.options?.host ?? this.element, e)
            : this._$AH.handleEvent(e);
        }
      }
      class j {
        constructor(e, t, r) {
          (this.element = e),
            (this.type = 6),
            (this._$AN = void 0),
            (this._$AM = t),
            (this.options = r);
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(e) {
          $(this, e);
        }
      }
      let F = {
          M: a,
          P: o,
          A: c,
          C: 1,
          L: P,
          R: D,
          D: f,
          V: $,
          I: U,
          H: M,
          N: B,
          U: W,
          B: L,
          F: j,
        },
        H = i.litHtmlPolyfillSupport;
      H?.(R, U), (i.litHtmlVersions ??= []).push("3.3.1");
      let q = (e, t, r) => {
        let i = r?.renderBefore ?? t,
          n = i._$litPart$;
        if (void 0 === n) {
          let e = r?.renderBefore ?? null;
          i._$litPart$ = n = new U(t.insertBefore(h(), e), e, void 0, r ?? {});
        }
        return n._$AI(e), n;
      };
    },
    52502: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => c });
      var i = r(1220),
        n = r(98866),
        s = r(36964),
        a = r(55480);
      let o = (0, i.BX)({ message: "", variant: "info", open: !1 }),
        c = (0, s.X)({
          state: o,
          subscribeKey: (e, t) => (0, n.u$)(o, e, t),
          open(e, t) {
            let { debug: r } = a.H.state,
              { code: i, displayMessage: n, debugMessage: s } = e;
            n && r && ((o.message = n), (o.variant = t), (o.open = !0)),
              s &&
                console.error(
                  "function" == typeof s ? s() : s,
                  i ? { code: i } : void 0
                );
          },
          warn(e, t, r) {
            (o.open = !0),
              (o.message = e),
              (o.variant = "warning"),
              t && console.warn(t, r);
          },
          close() {
            (o.open = !1), (o.message = ""), (o.variant = "info");
          },
        });
    },
    52617: (e, t, r) => {
      "use strict";
      function i(e, t) {
        return "light" === t
          ? {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
              "--w3m-background": "#fff",
            }
          : {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
              "--w3m-background": "#202020",
            };
      }
      r.d(t, { o: () => i });
    },
    52623: (e, t, r) => {
      "use strict";
      function i(e, { args: t, eventName: r } = {}) {
        return {
          ...e,
          blockHash: e.blockHash ? e.blockHash : null,
          blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
          logIndex: e.logIndex ? Number(e.logIndex) : null,
          transactionHash: e.transactionHash ? e.transactionHash : null,
          transactionIndex: e.transactionIndex
            ? Number(e.transactionIndex)
            : null,
          ...(r ? { args: t, eventName: r } : {}),
        };
      }
      r.d(t, { e: () => i });
    },
    52686: (e, t) => {
      function r(e) {
        if (("number" == typeof e && (e = e.toString()), "string" != typeof e))
          throw Error("Color should be defined as hex string");
        let t = e.slice().replace("#", "").split("");
        if (t.length < 3 || 5 === t.length || t.length > 8)
          throw Error("Invalid hex color: " + e);
        (3 === t.length || 4 === t.length) &&
          (t = Array.prototype.concat.apply(
            [],
            t.map(function (e) {
              return [e, e];
            })
          )),
          6 === t.length && t.push("F", "F");
        let r = parseInt(t.join(""), 16);
        return {
          r: (r >> 24) & 255,
          g: (r >> 16) & 255,
          b: (r >> 8) & 255,
          a: 255 & r,
          hex: "#" + t.slice(0, 6).join(""),
        };
      }
      (t.getOptions = function (e) {
        e || (e = {}), e.color || (e.color = {});
        let t =
            void 0 === e.margin || null === e.margin || e.margin < 0
              ? 4
              : e.margin,
          i = e.width && e.width >= 21 ? e.width : void 0,
          n = e.scale || 4;
        return {
          width: i,
          scale: i ? 4 : n,
          margin: t,
          color: {
            dark: r(e.color.dark || "#000000ff"),
            light: r(e.color.light || "#ffffffff"),
          },
          type: e.type,
          rendererOpts: e.rendererOpts || {},
        };
      }),
        (t.getScale = function (e, t) {
          return t.width && t.width >= e + 2 * t.margin
            ? t.width / (e + 2 * t.margin)
            : t.scale;
        }),
        (t.getImageWidth = function (e, r) {
          let i = t.getScale(e, r);
          return Math.floor((e + 2 * r.margin) * i);
        }),
        (t.qrToImageData = function (e, r, i) {
          let n = r.modules.size,
            s = r.modules.data,
            a = t.getScale(n, i),
            o = Math.floor((n + 2 * i.margin) * a),
            c = i.margin * a,
            l = [i.color.light, i.color.dark];
          for (let t = 0; t < o; t++)
            for (let r = 0; r < o; r++) {
              let d = (t * o + r) * 4,
                h = i.color.light;
              t >= c &&
                r >= c &&
                t < o - c &&
                r < o - c &&
                (h =
                  l[
                    +!!s[Math.floor((t - c) / a) * n + Math.floor((r - c) / a)]
                  ]),
                (e[d++] = h.r),
                (e[d++] = h.g),
                (e[d++] = h.b),
                (e[d] = h.a);
            }
        });
    },
    52769: (e, t, r) => {
      let i = r(91791),
        n = r(93711),
        s = r(85289),
        a = r(23308);
      function o(e, t, r, s, a) {
        let o = [].slice.call(arguments, 1),
          c = o.length,
          l = "function" == typeof o[c - 1];
        if (!l && !i()) throw Error("Callback required as last argument");
        if (l) {
          if (c < 2) throw Error("Too few arguments provided");
          2 === c
            ? ((a = r), (r = t), (t = s = void 0))
            : 3 === c &&
              (t.getContext && void 0 === a
                ? ((a = s), (s = void 0))
                : ((a = s), (s = r), (r = t), (t = void 0)));
        } else {
          if (c < 1) throw Error("Too few arguments provided");
          return (
            1 === c
              ? ((r = t), (t = s = void 0))
              : 2 !== c || t.getContext || ((s = r), (r = t), (t = void 0)),
            new Promise(function (i, a) {
              try {
                let a = n.create(r, s);
                i(e(a, t, s));
              } catch (e) {
                a(e);
              }
            })
          );
        }
        try {
          let i = n.create(r, s);
          a(null, e(i, t, s));
        } catch (e) {
          a(e);
        }
      }
      (t.create = n.create),
        (t.toCanvas = o.bind(null, s.render)),
        (t.toDataURL = o.bind(null, s.renderToDataURL)),
        (t.toString = o.bind(null, function (e, t, r) {
          return a.render(e, r);
        }));
    },
    53473: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => h });
      var i = r(13933),
        n = r(4058),
        s = r(73168),
        a = r(34561);
      let o = new (r(20390).A)(8192);
      var c = r(37407),
        l = r(59350),
        d = r(95789);
      function h(
        {
          key: e,
          methods: t,
          name: r,
          request: h,
          retryCount: u = 3,
          retryDelay: p = 150,
          timeout: f,
          type: g,
        },
        m
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: r,
            request: h,
            retryCount: u,
            retryDelay: p,
            timeout: f,
            type: g,
          },
          request: (function (e, t = {}) {
            return async (r, d = {}) => {
              let {
                  dedupe: h = !1,
                  methods: u,
                  retryDelay: p = 150,
                  retryCount: f = 3,
                  uid: g,
                } = { ...t, ...d },
                { method: m } = r;
              if (
                u?.exclude?.includes(m) ||
                (u?.include && !u.include.includes(m))
              )
                throw new s.ab(Error("method not supported"), { method: m });
              let y = h ? (0, a.i3)(`${g}.${(0, l.A)(r)}`) : void 0;
              return (function (e, { enabled: t = !0, id: r }) {
                if (!t || !r) return e();
                if (o.get(r)) return o.get(r);
                let i = e().finally(() => o.delete(r));
                return o.set(r, i), i;
              })(
                () =>
                  (0, c.b)(
                    async () => {
                      try {
                        return await e(r);
                      } catch (e) {
                        switch (e.code) {
                          case s.XU.code:
                            throw new s.XU(e);
                          case s.CL.code:
                            throw new s.CL(e);
                          case s.Gi.code:
                            throw new s.Gi(e, { method: r.method });
                          case s.D5.code:
                            throw new s.D5(e);
                          case s.bq.code:
                            throw new s.bq(e);
                          case s.Di.code:
                            throw new s.Di(e);
                          case s.hA.code:
                            throw new s.hA(e);
                          case s.qZ.code:
                            throw new s.qZ(e);
                          case s.YW.code:
                            throw new s.YW(e);
                          case s.ab.code:
                            throw new s.ab(e, { method: r.method });
                          case s.s0.code:
                            throw new s.s0(e);
                          case s.xQ.code:
                            throw new s.xQ(e);
                          case s.vx.code:
                            throw new s.vx(e);
                          case s.sV.code:
                            throw new s.sV(e);
                          case s.Sf.code:
                            throw new s.Sf(e);
                          case s.RV.code:
                            throw new s.RV(e);
                          case s.xq.code:
                            throw new s.xq(e);
                          case s.ch.code:
                            throw new s.ch(e);
                          case s.L5.code:
                            throw new s.L5(e);
                          case s.WT.code:
                            throw new s.WT(e);
                          case s.hl.code:
                            throw new s.hl(e);
                          case s.cg.code:
                            throw new s.cg(e);
                          case s.uL.code:
                            throw new s.uL(e);
                          case s.G1.code:
                            throw new s.G1(e);
                          case s.jz.code:
                            throw new s.jz(e);
                          case 5e3:
                            throw new s.vx(e);
                          default:
                            if (e instanceof i.C) throw e;
                            throw new s.MI(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof n.Ci) {
                          let e = t?.headers?.get("Retry-After");
                          if (e?.match(/\d/))
                            return 1e3 * Number.parseInt(e, 10);
                        }
                        return ~~(1 << e) * p;
                      },
                      retryCount: f,
                      shouldRetry: ({ error: e }) => {
                        var t;
                        return "code" in (t = e) && "number" == typeof t.code
                          ? -1 === t.code ||
                              t.code === s.s0.code ||
                              t.code === s.bq.code
                          : !(t instanceof n.Ci) ||
                              !t.status ||
                              403 === t.status ||
                              408 === t.status ||
                              413 === t.status ||
                              429 === t.status ||
                              500 === t.status ||
                              502 === t.status ||
                              503 === t.status ||
                              504 === t.status ||
                              !1;
                      },
                    }
                  ),
                { enabled: h, id: y }
              );
            };
          })(h, { methods: t, retryCount: u, retryDelay: p, uid: (0, d.L)() }),
          value: m,
        };
      }
    },
    53896: (e, t) => {
      let r = "[0-9]+",
        i =
          "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+",
        n =
          "(?:(?![A-Z0-9 $%*+\\-./:]|" +
          (i = i.replace(/u/g, "\\u")) +
          ")(?:.|[\r\n]))+";
      (t.KANJI = RegExp(i, "g")),
        (t.BYTE_KANJI = RegExp("[^A-Z0-9 $%*+\\-./:]+", "g")),
        (t.BYTE = RegExp(n, "g")),
        (t.NUMERIC = RegExp(r, "g")),
        (t.ALPHANUMERIC = RegExp("[A-Z $%*+\\-./:]+", "g"));
      let s = RegExp("^" + i + "$"),
        a = RegExp("^" + r + "$"),
        o = RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      (t.testKanji = function (e) {
        return s.test(e);
      }),
        (t.testNumeric = function (e) {
          return a.test(e);
        }),
        (t.testAlphanumeric = function (e) {
          return o.test(e);
        });
    },
    54415: (e, t, r) => {
      let i = r(89158);
      function n(e) {
        (this.mode = i.NUMERIC), (this.data = e.toString());
      }
      (n.getBitsLength = function (e) {
        return 10 * Math.floor(e / 3) + (e % 3 ? (e % 3) * 3 + 1 : 0);
      }),
        (n.prototype.getLength = function () {
          return this.data.length;
        }),
        (n.prototype.getBitsLength = function () {
          return n.getBitsLength(this.data.length);
        }),
        (n.prototype.write = function (e) {
          let t, r;
          for (t = 0; t + 3 <= this.data.length; t += 3)
            (r = parseInt(this.data.substr(t, 3), 10)), e.put(r, 10);
          let i = this.data.length - t;
          i > 0 &&
            ((r = parseInt(this.data.substr(t), 10)), e.put(r, 3 * i + 1));
        }),
        (e.exports = n);
    },
    55283: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => m });
      var i = r(82050),
        n = r(88737),
        s = r(73168),
        a = r(78140),
        o = r(53473);
      function c(e, t = {}) {
        let {
          key: r = "fallback",
          name: i = "Fallback",
          rank: n = !1,
          shouldThrow: s = l,
          retryCount: d,
          retryDelay: h,
        } = t;
        return ({ chain: t, pollingInterval: c = 4e3, timeout: l, ...u }) => {
          let p = e,
            f = () => {},
            g = (0, o.o)(
              {
                key: r,
                name: i,
                async request({ method: e, params: r }) {
                  let i,
                    n = async (a = 0) => {
                      let o = p[a]({
                        ...u,
                        chain: t,
                        retryCount: 0,
                        timeout: l,
                      });
                      try {
                        let t = await o.request({ method: e, params: r });
                        return (
                          f({
                            method: e,
                            params: r,
                            response: t,
                            transport: o,
                            status: "success",
                          }),
                          t
                        );
                      } catch (c) {
                        if (
                          (f({
                            error: c,
                            method: e,
                            params: r,
                            transport: o,
                            status: "error",
                          }),
                          s(c) ||
                            a === p.length - 1 ||
                            !(i ??= p.slice(a + 1).some((r) => {
                              let { include: i, exclude: n } =
                                r({ chain: t }).config.methods || {};
                              return i ? i.includes(e) : !n || !n.includes(e);
                            })))
                        )
                          throw c;
                        return n(a + 1);
                      }
                    };
                  return n();
                },
                retryCount: d,
                retryDelay: h,
                type: "fallback",
              },
              {
                onResponse: (e) => (f = e),
                transports: p.map((e) => e({ chain: t, retryCount: 0 })),
              }
            );
          if (n) {
            let e = "object" == typeof n ? n : {};
            !(function ({
              chain: e,
              interval: t = 4e3,
              onTransports: r,
              ping: i,
              sampleCount: n = 10,
              timeout: s = 1e3,
              transports: o,
              weights: c = {},
            }) {
              let { stability: l = 0.7, latency: d = 0.3 } = c,
                h = [],
                u = async () => {
                  let c = await Promise.all(
                    o.map(async (t) => {
                      let r,
                        n,
                        a = t({ chain: e, retryCount: 0, timeout: s }),
                        o = Date.now();
                      try {
                        await (i
                          ? i({ transport: a })
                          : a.request({ method: "net_listening" })),
                          (n = 1);
                      } catch {
                        n = 0;
                      } finally {
                        r = Date.now();
                      }
                      return { latency: r - o, success: n };
                    })
                  );
                  h.push(c), h.length > n && h.shift();
                  let p = Math.max(
                    ...h.map((e) => Math.max(...e.map(({ latency: e }) => e)))
                  );
                  r(
                    o
                      .map((e, t) => {
                        let r = h.map((e) => e[t].latency),
                          i = r.reduce((e, t) => e + t, 0) / r.length,
                          n = h.map((e) => e[t].success),
                          s = n.reduce((e, t) => e + t, 0) / n.length;
                        return 0 === s ? [0, t] : [d * (1 - i / p) + l * s, t];
                      })
                      .sort((e, t) => t[0] - e[0])
                      .map(([, e]) => o[e])
                  ),
                    await (0, a.u)(t),
                    u();
                };
              u();
            })({
              chain: t,
              interval: e.interval ?? c,
              onTransports: (e) => (p = e),
              ping: e.ping,
              sampleCount: e.sampleCount,
              timeout: e.timeout,
              transports: p,
              weights: e.weights,
            });
          }
          return g;
        };
      }
      function l(e) {
        return !!(
          "code" in e &&
          "number" == typeof e.code &&
          (e.code === s.YW.code ||
            e.code === s.vx.code ||
            n.A7.nodeMessage.test(e.message) ||
            5e3 === e.code)
        );
      }
      var d = r(45553),
        h = r(58653),
        u = r(93481),
        p = r(75578);
      function f(e, t) {
        let r = new URL("https://rpc.walletconnect.org/v1/");
        return (
          r.searchParams.set("chainId", e),
          r.searchParams.set("projectId", t),
          r.toString()
        );
      }
      let g = [
          "near:mainnet",
          "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          "eip155:1101",
          "eip155:56",
          "eip155:42161",
          "eip155:7777777",
          "eip155:59144",
          "eip155:324",
          "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          "eip155:5000",
          "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
          "eip155:80084",
          "eip155:5003",
          "eip155:100",
          "eip155:8453",
          "eip155:42220",
          "eip155:1313161555",
          "eip155:17000",
          "eip155:1",
          "eip155:300",
          "eip155:1313161554",
          "eip155:1329",
          "eip155:84532",
          "eip155:421614",
          "eip155:11155111",
          "eip155:8217",
          "eip155:43114",
          "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
          "eip155:999999999",
          "eip155:11155420",
          "eip155:80002",
          "eip155:97",
          "eip155:43113",
          "eip155:137",
          "eip155:10",
          "eip155:1301",
          "eip155:80094",
          "eip155:80069",
          "eip155:560048",
          "eip155:31",
          "eip155:2818",
          "eip155:57054",
          "eip155:911867",
          "eip155:534351",
          "eip155:1112",
          "eip155:534352",
          "eip155:1111",
          "eip155:146",
          "eip155:130",
          "eip155:1284",
          "eip155:30",
          "eip155:2810",
          "bip122:000000000019d6689c085ae165831e93",
          "bip122:000000000933ea01ad0ee984209779ba",
        ],
        m = {
          extendRpcUrlWithProjectId(e, t) {
            let r = !1;
            try {
              r = "rpc.walletconnect.org" === new URL(e).host;
            } catch (e) {
              r = !1;
            }
            if (r) {
              let r = new URL(e);
              return (
                r.searchParams.has("projectId") ||
                  r.searchParams.set("projectId", t),
                r.toString()
              );
            }
            return e;
          },
          isCaipNetwork: (e) => "chainNamespace" in e && "caipNetworkId" in e,
          getChainNamespace(e) {
            return this.isCaipNetwork(e) ? e.chainNamespace : d.o.CHAIN.EVM;
          },
          getCaipNetworkId(e) {
            return this.isCaipNetwork(e)
              ? e.caipNetworkId
              : `${d.o.CHAIN.EVM}:${e.id}`;
          },
          getDefaultRpcUrl(e, t, r) {
            let i = e.rpcUrls?.default?.http?.[0];
            return g.includes(t) ? f(t, r) : i || "";
          },
          extendCaipNetwork(
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) {
            let n = this.getChainNamespace(e),
              s = this.getCaipNetworkId(e),
              a = e.rpcUrls?.default?.http?.[0],
              o = this.getDefaultRpcUrl(e, s, r),
              c = e?.rpcUrls?.chainDefault?.http?.[0] || a,
              l = i?.[s]?.map((e) => e.url) || [],
              d = [...l, ...(o ? [o] : [])],
              h = [...l];
            return (
              c && !h.includes(c) && h.push(c),
              {
                ...e,
                chainNamespace: n,
                caipNetworkId: s,
                assets: {
                  imageId: p.L.NetworkImageIds[e.id],
                  imageUrl: t?.[e.id],
                },
                rpcUrls: {
                  ...e.rpcUrls,
                  default: { http: d },
                  chainDefault: { http: h },
                },
              }
            );
          },
          extendCaipNetworks: (
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) =>
            e.map((e) =>
              m.extendCaipNetwork(e, {
                customNetworkImageUrls: t,
                customRpcUrls: i,
                projectId: r,
              })
            ),
          getViemTransport(e, t, r) {
            let n = [];
            return (
              r?.forEach((e) => {
                n.push((0, i.L)(e.url, e.config));
              }),
              g.includes(e.caipNetworkId) &&
                n.push(
                  (0, i.L)(f(e.caipNetworkId, t), {
                    fetchOptions: { headers: { "Content-Type": "text/plain" } },
                  })
                ),
              e?.rpcUrls?.default?.http?.forEach((e) => {
                n.push((0, i.L)(e));
              }),
              c(n)
            );
          },
          extendWagmiTransports(e, t, r) {
            if (g.includes(e.caipNetworkId)) {
              let n = this.getDefaultRpcUrl(e, e.caipNetworkId, t);
              return c([r, (0, i.L)(n)]);
            }
            return r;
          },
          getUnsupportedNetwork: (e) => ({
            id: e.split(":")[1],
            caipNetworkId: e,
            name: d.o.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: e.split(":")[0],
            nativeCurrency: { name: "", decimals: 0, symbol: "" },
            rpcUrls: { default: { http: [] } },
          }),
          getCaipNetworkFromStorage(e) {
            let t = h.i.getActiveCaipNetworkId(),
              r = u.W.getAllRequestedCaipNetworks(),
              i = Array.from(u.W.state.chains?.keys() || []),
              n = t?.split(":")[0],
              s = !!n && i.includes(n),
              a = r?.find((e) => e.caipNetworkId === t);
            return s && !a && t
              ? this.getUnsupportedNetwork(t)
              : a || e || r?.[0];
          },
        };
    },
    55459: (e, t) => {
      (t.read = function (e, t, r, i, n) {
        var s,
          a,
          o = 8 * n - i - 1,
          c = (1 << o) - 1,
          l = c >> 1,
          d = -7,
          h = r ? n - 1 : 0,
          u = r ? -1 : 1,
          p = e[t + h];
        for (
          h += u, s = p & ((1 << -d) - 1), p >>= -d, d += o;
          d > 0;
          s = 256 * s + e[t + h], h += u, d -= 8
        );
        for (
          a = s & ((1 << -d) - 1), s >>= -d, d += i;
          d > 0;
          a = 256 * a + e[t + h], h += u, d -= 8
        );
        if (0 === s) s = 1 - l;
        else {
          if (s === c) return a ? NaN : (1 / 0) * (p ? -1 : 1);
          (a += Math.pow(2, i)), (s -= l);
        }
        return (p ? -1 : 1) * a * Math.pow(2, s - i);
      }),
        (t.write = function (e, t, r, i, n, s) {
          var a,
            o,
            c,
            l = 8 * s - n - 1,
            d = (1 << l) - 1,
            h = d >> 1,
            u = 5960464477539062e-23 * (23 === n),
            p = i ? 0 : s - 1,
            f = i ? 1 : -1,
            g = +(t < 0 || (0 === t && 1 / t < 0));
          for (
            isNaN((t = Math.abs(t))) || t === 1 / 0
              ? ((o = +!!isNaN(t)), (a = d))
              : ((a = Math.floor(Math.log(t) / Math.LN2)),
                t * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                a + h >= 1 ? (t += u / c) : (t += u * Math.pow(2, 1 - h)),
                t * c >= 2 && (a++, (c /= 2)),
                a + h >= d
                  ? ((o = 0), (a = d))
                  : a + h >= 1
                  ? ((o = (t * c - 1) * Math.pow(2, n)), (a += h))
                  : ((o = t * Math.pow(2, h - 1) * Math.pow(2, n)), (a = 0)));
            n >= 8;
            e[r + p] = 255 & o, p += f, o /= 256, n -= 8
          );
          for (
            a = (a << n) | o, l += n;
            l > 0;
            e[r + p] = 255 & a, p += f, a /= 256, l -= 8
          );
          e[r + p - f] |= 128 * g;
        });
    },
    55480: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => l });
      var i = r(1220),
        n = r(98866),
        s = r(28977),
        a = r(12319);
      let o = {
          getFeatureValue(e, t) {
            let r = t?.[e];
            return void 0 === r ? s.oU.DEFAULT_FEATURES[e] : r;
          },
          filterSocialsByPlatform(e) {
            if (!e || !e.length) return e;
            if (a.w.isTelegram()) {
              if (a.w.isIos()) return e.filter((e) => "google" !== e);
              if (a.w.isMac()) return e.filter((e) => "x" !== e);
              if (a.w.isAndroid())
                return e.filter((e) => !["facebook", "x"].includes(e));
            }
            return e;
          },
        },
        c = (0, i.BX)({
          features: s.oU.DEFAULT_FEATURES,
          projectId: "",
          sdkType: "appkit",
          sdkVersion: "html-wagmi-undefined",
          defaultAccountTypes: s.oU.DEFAULT_ACCOUNT_TYPES,
          enableNetworkSwitch: !0,
          experimental_preferUniversalLinks: !1,
          remoteFeatures: {},
          enableMobileFullScreen: !1,
        }),
        l = {
          state: c,
          subscribeKey: (e, t) => (0, n.u$)(c, e, t),
          setOptions(e) {
            Object.assign(c, e);
          },
          setRemoteFeatures(e) {
            if (!e) return;
            let t = { ...c.remoteFeatures, ...e };
            (c.remoteFeatures = t),
              c.remoteFeatures?.socials &&
                (c.remoteFeatures.socials = o.filterSocialsByPlatform(
                  c.remoteFeatures.socials
                )),
              c.features?.pay &&
                ((c.remoteFeatures.email = !1),
                (c.remoteFeatures.socials = !1));
          },
          setFeatures(e) {
            if (!e) return;
            c.features || (c.features = s.oU.DEFAULT_FEATURES);
            let t = { ...c.features, ...e };
            (c.features = t),
              c.features?.pay &&
                c.remoteFeatures &&
                ((c.remoteFeatures.email = !1),
                (c.remoteFeatures.socials = !1));
          },
          setProjectId(e) {
            c.projectId = e;
          },
          setCustomRpcUrls(e) {
            c.customRpcUrls = e;
          },
          setAllWallets(e) {
            c.allWallets = e;
          },
          setIncludeWalletIds(e) {
            c.includeWalletIds = e;
          },
          setExcludeWalletIds(e) {
            c.excludeWalletIds = e;
          },
          setFeaturedWalletIds(e) {
            c.featuredWalletIds = e;
          },
          setTokens(e) {
            c.tokens = e;
          },
          setTermsConditionsUrl(e) {
            c.termsConditionsUrl = e;
          },
          setPrivacyPolicyUrl(e) {
            c.privacyPolicyUrl = e;
          },
          setCustomWallets(e) {
            c.customWallets = e;
          },
          setIsSiweEnabled(e) {
            c.isSiweEnabled = e;
          },
          setIsUniversalProvider(e) {
            c.isUniversalProvider = e;
          },
          setSdkVersion(e) {
            c.sdkVersion = e;
          },
          setMetadata(e) {
            c.metadata = e;
          },
          setDisableAppend(e) {
            c.disableAppend = e;
          },
          setEIP6963Enabled(e) {
            c.enableEIP6963 = e;
          },
          setDebug(e) {
            c.debug = e;
          },
          setEnableWalletGuide(e) {
            c.enableWalletGuide = e;
          },
          setEnableAuthLogger(e) {
            c.enableAuthLogger = e;
          },
          setEnableWallets(e) {
            c.enableWallets = e;
          },
          setPreferUniversalLinks(e) {
            c.experimental_preferUniversalLinks = e;
          },
          setSIWX(e) {
            if (e)
              for (let [t, r] of Object.entries(s.oU.SIWX_DEFAULTS)) e[t] ??= r;
            c.siwx = e;
          },
          setConnectMethodsOrder(e) {
            c.features = { ...c.features, connectMethodsOrder: e };
          },
          setWalletFeaturesOrder(e) {
            c.features = { ...c.features, walletFeaturesOrder: e };
          },
          setSocialsOrder(e) {
            c.remoteFeatures = { ...c.remoteFeatures, socials: e };
          },
          setCollapseWallets(e) {
            c.features = { ...c.features, collapseWallets: e };
          },
          setEnableEmbedded(e) {
            c.enableEmbedded = e;
          },
          setAllowUnsupportedChain(e) {
            c.allowUnsupportedChain = e;
          },
          setManualWCControl(e) {
            c.manualWCControl = e;
          },
          setEnableNetworkSwitch(e) {
            c.enableNetworkSwitch = e;
          },
          setEnableMobileFullScreen(e) {
            c.enableMobileFullScreen = a.w.isMobile() && e;
          },
          setEnableReconnect(e) {
            c.enableReconnect = e;
          },
          setDefaultAccountTypes(e = {}) {
            Object.entries(e).forEach(([e, t]) => {
              t && (c.defaultAccountTypes[e] = t);
            });
          },
          setUniversalProviderConfigOverride(e) {
            c.universalProviderConfigOverride = e;
          },
          getUniversalProviderConfigOverride: () =>
            c.universalProviderConfigOverride,
          getSnapshot: () => (0, i.P9)(c),
        };
    },
    55563: (e, t, r) => {
      "use strict";
      r.d(t, { Af: () => p, ZJ: () => l, aT: () => u });
      var i = r(13933),
        n = r(60587),
        s = r(72427),
        a = r(11914),
        o = r(34561);
      let c = new TextEncoder();
      function l(e, t = {}) {
        var r, i;
        return "number" == typeof e || "bigint" == typeof e
          ? ((r = e), (i = t), u((0, o.cK)(r, i)))
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = new Uint8Array(1);
              return ((r[0] = Number(e)), "number" == typeof t.size)
                ? ((0, a.Sl)(r, { size: t.size }),
                  (0, s.eV)(r, { size: t.size }))
                : r;
            })(e, t)
          : (0, n.q)(e)
          ? u(e, t)
          : p(e, t);
      }
      let d = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function h(e) {
        return e >= d.zero && e <= d.nine
          ? e - d.zero
          : e >= d.A && e <= d.F
          ? e - (d.A - 10)
          : e >= d.a && e <= d.f
          ? e - (d.a - 10)
          : void 0;
      }
      function u(e, t = {}) {
        let r = e;
        t.size &&
          ((0, a.Sl)(r, { size: t.size }),
          (r = (0, s.eV)(r, { dir: "right", size: t.size })));
        let n = r.slice(2);
        n.length % 2 && (n = `0${n}`);
        let o = n.length / 2,
          c = new Uint8Array(o);
        for (let e = 0, t = 0; e < o; e++) {
          let r = h(n.charCodeAt(t++)),
            s = h(n.charCodeAt(t++));
          if (void 0 === r || void 0 === s)
            throw new i.C(
              `Invalid byte sequence ("${n[t - 2]}${n[t - 1]}" in "${n}").`
            );
          c[e] = 16 * r + s;
        }
        return c;
      }
      function p(e, t = {}) {
        let r = c.encode(e);
        return "number" == typeof t.size
          ? ((0, a.Sl)(r, { size: t.size }),
            (0, s.eV)(r, { dir: "right", size: t.size }))
          : r;
      }
    },
    55762: (e) => {
      "use strict";
      e.exports = function () {
        throw Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    },
    55877: (e, t, r) => {
      "use strict";
      var i = r(83138);
      r(99691), r(24772), r(38534);
      var n = r(71084),
        s = r(47327),
        a = r(20296);
      let o = (0, a.AH)`
  .reown-logo {
    height: 24px;
  }

  a {
    text-decoration: none;
    cursor: pointer;
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  a:hover {
    opacity: 0.9;
  }
`,
        c = class extends i.WF {
          render() {
            return (0, i.qy)`
      <a
        data-testid="ux-branding-reown"
        href=${"https://reown.com"}
        rel="noreferrer"
        target="_blank"
        style="text-decoration: none;"
      >
        <wui-flex
          justifyContent="center"
          alignItems="center"
          gap="1"
          .padding=${["01", "0", "3", "0"]}
        >
          <wui-text variant="sm-regular" color="inherit"> UX by </wui-text>
          <wui-icon name="reown" size="inherit" class="reown-logo"></wui-icon>
        </wui-flex>
      </a>
    `;
          }
        };
      (c.styles = [n.W5, n.fD, o]),
        (c = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, s.E)("wui-ux-by-reown")], c));
    },
    56341: (e, t, r) => {
      "use strict";
      r.d(t, {
        B4: () => p,
        CQ: () => v,
        CW: () => b,
        Ei: () => h,
        F8: () => C,
        P5: () => u,
        TH: () => E,
        Vl: () => y,
        Vr: () => w,
        WM: () => f,
        WQ: () => m,
        im: () => g,
        jm: () => o,
        lD: () => s,
        qh: () => d,
        rE: () => c,
        ry: () => l,
        xn: () => a,
      });
      let i = BigInt(0x100000000 - 1),
        n = BigInt(32);
      function s(e, t = !1) {
        let r = e.length,
          a = new Uint32Array(r),
          o = new Uint32Array(r);
        for (let s = 0; s < r; s++) {
          let { h: r, l: c } = (function (e, t = !1) {
            return t
              ? { h: Number(e & i), l: Number((e >> n) & i) }
              : { h: 0 | Number((e >> n) & i), l: 0 | Number(e & i) };
          })(e[s], t);
          [a[s], o[s]] = [r, c];
        }
        return [a, o];
      }
      let a = (e, t, r) => e >>> r,
        o = (e, t, r) => (e << (32 - r)) | (t >>> r),
        c = (e, t, r) => (e >>> r) | (t << (32 - r)),
        l = (e, t, r) => (e << (32 - r)) | (t >>> r),
        d = (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
        h = (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
        u = (e, t, r) => (e << r) | (t >>> (32 - r)),
        p = (e, t, r) => (t << r) | (e >>> (32 - r)),
        f = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        g = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
      function m(e, t, r, i) {
        let n = (t >>> 0) + (i >>> 0);
        return { h: (e + r + ((n / 0x100000000) | 0)) | 0, l: 0 | n };
      }
      let y = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
        w = (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
        b = (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
        v = (e, t, r, i, n) => (t + r + i + n + ((e / 0x100000000) | 0)) | 0,
        C = (e, t, r, i, n) =>
          (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
        E = (e, t, r, i, n, s) =>
          (t + r + i + n + s + ((e / 0x100000000) | 0)) | 0;
    },
    56674: (e, t, r) => {
      "use strict";
      function i(
        e,
        { errorInstance: t = Error("timed out"), timeout: r, signal: i }
      ) {
        return new Promise((n, s) => {
          (async () => {
            let a;
            try {
              let o = new AbortController();
              r > 0 &&
                (a = setTimeout(() => {
                  i ? o.abort() : s(t);
                }, r)),
                n(await e({ signal: o?.signal || null }));
            } catch (e) {
              e?.name === "AbortError" && s(t), s(e);
            } finally {
              clearTimeout(a);
            }
          })();
        });
      }
      r.d(t, { w: () => i });
    },
    56975: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      let s = (0, i.JW)`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
      var a = r(27313);
      let o = (0, i.JW)`
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`;
      r(99691), r(45166);
      var c = r(71084),
        l = r(47327),
        d = r(20296);
      let h = (0, d.AH)`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  :host([data-round='true']) {
    background: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: 100%;
    outline: 1px solid ${({ tokens: e }) => e.core.glass010};
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  svg > path {
    stroke: var(--local-stroke);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
      var u = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let p = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.size = "md"),
            (this.name = "uknown"),
            (this.networkImagesBySize = { sm: o, md: a.a, lg: s }),
            (this.selected = !1),
            (this.round = !1);
        }
        render() {
          return (
            this.round
              ? ((this.dataset.round = "true"),
                (this.style.cssText = `
      --local-width: var(--apkt-spacing-10);
      --local-height: var(--apkt-spacing-10);
      --local-icon-size: var(--apkt-spacing-4);
    `))
              : (this.style.cssText = `

      --local-path: var(--apkt-path-network-${this.size});
      --local-width:  var(--apkt-width-network-${this.size});
      --local-height:  var(--apkt-height-network-${this.size});
      --local-icon-size:  var(--apkt-spacing-${
        { sm: "4", md: "6", lg: "10" }[this.size]
      });
    `),
            (0, i.qy)`${this.templateVisual()} ${this.svgTemplate()} `
          );
        }
        svgTemplate() {
          return this.round ? null : this.networkImagesBySize[this.size];
        }
        templateVisual() {
          return this.imageSrc
            ? (0,
              i.qy)`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`
            : (0,
              i.qy)`<wui-icon size="inherit" color="default" name="networkPlaceholder"></wui-icon>`;
        }
      };
      (p.styles = [c.W5, h]),
        u([(0, n.MZ)()], p.prototype, "size", void 0),
        u([(0, n.MZ)()], p.prototype, "name", void 0),
        u(
          [(0, n.MZ)({ type: Object })],
          p.prototype,
          "networkImagesBySize",
          void 0
        ),
        u([(0, n.MZ)()], p.prototype, "imageSrc", void 0),
        u([(0, n.MZ)({ type: Boolean })], p.prototype, "selected", void 0),
        u([(0, n.MZ)({ type: Boolean })], p.prototype, "round", void 0),
        (p = u([(0, l.E)("wui-network-image")], p));
    },
    58653: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => s });
      var i = r(93965),
        n = r(45553);
      let s = {
        cacheExpiry: {
          portfolio: 3e4,
          nativeBalance: 3e4,
          ens: 3e5,
          identity: 3e5,
          transactionsHistory: 15e3,
          tokenPrice: 15e3,
          latestAppKitVersion: 6048e5,
        },
        isCacheExpired: (e, t) => Date.now() - e > t,
        getActiveNetworkProps() {
          let e = s.getActiveNamespace(),
            t = s.getActiveCaipNetworkId(),
            r = t ? t.split(":")[1] : void 0;
          return {
            namespace: e,
            caipNetworkId: t,
            chainId: r ? (isNaN(Number(r)) ? r : Number(r)) : void 0,
          };
        },
        setWalletConnectDeepLink({ name: e, href: t }) {
          try {
            i.Ud.setItem(
              i.Ws.DEEPLINK_CHOICE,
              JSON.stringify({ href: t, name: e })
            );
          } catch {
            console.info("Unable to set WalletConnect deep link");
          }
        },
        getWalletConnectDeepLink() {
          try {
            let e = i.Ud.getItem(i.Ws.DEEPLINK_CHOICE);
            if (e) return JSON.parse(e);
          } catch {
            console.info("Unable to get WalletConnect deep link");
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            i.Ud.removeItem(i.Ws.DEEPLINK_CHOICE);
          } catch {
            console.info("Unable to delete WalletConnect deep link");
          }
        },
        setActiveNamespace(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_NAMESPACE, e);
          } catch {
            console.info("Unable to set active namespace");
          }
        },
        setActiveCaipNetworkId(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_CAIP_NETWORK_ID, e),
              s.setActiveNamespace(e.split(":")[0]);
          } catch {
            console.info("Unable to set active caip network id");
          }
        },
        getActiveCaipNetworkId() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to get active caip network id");
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            i.Ud.removeItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to delete active caip network id");
          }
        },
        deleteConnectedConnectorId(e) {
          try {
            let t = (0, i.T8)(e);
            i.Ud.removeItem(t);
          } catch {
            console.info("Unable to delete connected connector id");
          }
        },
        setAppKitRecent(e) {
          try {
            let t = s.getRecentWallets();
            t.find((t) => t.id === e.id) ||
              (t.unshift(e),
              t.length > 2 && t.pop(),
              i.Ud.setItem(i.Ws.RECENT_WALLETS, JSON.stringify(t)),
              i.Ud.setItem(i.Ws.RECENT_WALLET, JSON.stringify(e)));
          } catch {
            console.info("Unable to set AppKit recent");
          }
        },
        getRecentWallets() {
          try {
            let e = i.Ud.getItem(i.Ws.RECENT_WALLETS);
            return e ? JSON.parse(e) : [];
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return [];
        },
        getRecentWallet() {
          try {
            let e = i.Ud.getItem(i.Ws.RECENT_WALLET);
            return e ? JSON.parse(e) : null;
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return null;
        },
        deleteRecentWallet() {
          try {
            i.Ud.removeItem(i.Ws.RECENT_WALLET);
          } catch {
            console.info("Unable to delete AppKit recent");
          }
        },
        setConnectedConnectorId(e, t) {
          try {
            let r = (0, i.T8)(e);
            i.Ud.setItem(r, t);
          } catch {
            console.info("Unable to set Connected Connector Id");
          }
        },
        getActiveNamespace() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_NAMESPACE);
          } catch {
            console.info("Unable to get active namespace");
          }
        },
        getConnectedConnectorId(e) {
          if (e)
            try {
              let t = (0, i.T8)(e);
              return i.Ud.getItem(t);
            } catch (t) {
              console.info(
                "Unable to get connected connector id in namespace",
                e
              );
            }
        },
        setConnectedSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTED_SOCIAL, e);
          } catch {
            console.info("Unable to set connected social provider");
          }
        },
        getConnectedSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to get connected social provider");
          }
        },
        deleteConnectedSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to delete connected social provider");
          }
        },
        getConnectedSocialUsername() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info("Unable to get connected social username");
          }
        },
        getStoredActiveCaipNetworkId() {
          let e = i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          return e?.split(":")?.[1];
        },
        setConnectionStatus(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTION_STATUS, e);
          } catch {
            console.info("Unable to set connection status");
          }
        },
        getConnectionStatus() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            let e = i.Ud.getItem(i.Ws.CONNECTED_NAMESPACES);
            if (!e?.length) return [];
            return e.split(",");
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(e) {
          try {
            let t = Array.from(new Set(e));
            i.Ud.setItem(i.Ws.CONNECTED_NAMESPACES, t.join(","));
          } catch {
            console.info("Unable to set namespaces in storage");
          }
        },
        addConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces();
            t.includes(e) || (t.push(e), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to add connected namespace");
          }
        },
        removeConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces(),
              r = t.indexOf(e);
            r > -1 && (t.splice(r, 1), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to remove connected namespace");
          }
        },
        getTelegramSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info("Unable to get telegram social provider"), null;
          }
        },
        setTelegramSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER, e);
          } catch {
            console.info("Unable to set telegram social provider");
          }
        },
        removeTelegramSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info("Unable to remove telegram social provider");
          }
        },
        getBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.PORTFOLIO_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.PORTFOLIO_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio)
            )
              return t.balance;
            s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.PORTFOLIO_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getNativeBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.NATIVE_BALANCE_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromNativeBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.NATIVE_BALANCE_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getNativeBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getNativeBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)
            )
              return t;
            console.info("Discarding cache for address", e),
              s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateNativeBalanceCache(e) {
          try {
            let t = s.getNativeBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.NATIVE_BALANCE_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getEnsCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.ENS_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get ens name cache");
          }
          return e;
        },
        getEnsFromCacheForAddress(e) {
          try {
            let t = s.getEnsCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
              return t.ens;
            s.removeEnsFromCache(e);
          } catch {
            console.info("Unable to get ens name from cache", e);
          }
        },
        updateEnsCache(e) {
          try {
            let t = s.getEnsCache();
            (t[e.address] = e), i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update ens name cache", e);
          }
        },
        removeEnsFromCache(e) {
          try {
            let t = s.getEnsCache();
            i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info("Unable to remove ens name from cache", e);
          }
        },
        getIdentityCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.IDENTITY_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get identity cache");
          }
          return e;
        },
        getIdentityFromCacheForAddress(e) {
          try {
            let t = s.getIdentityCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity)
            )
              return t.identity;
            s.removeIdentityFromCache(e);
          } catch {
            console.info("Unable to get identity from cache", e);
          }
        },
        updateIdentityCache(e) {
          try {
            let t = s.getIdentityCache();
            (t[e.address] = { identity: e.identity, timestamp: e.timestamp }),
              i.Ud.setItem(i.Ws.IDENTITY_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update identity cache", e);
          }
        },
        removeIdentityFromCache(e) {
          try {
            let t = s.getIdentityCache();
            i.Ud.setItem(
              i.Ws.IDENTITY_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove identity from cache", e);
          }
        },
        clearAddressCache() {
          try {
            i.Ud.removeItem(i.Ws.PORTFOLIO_CACHE),
              i.Ud.removeItem(i.Ws.NATIVE_BALANCE_CACHE),
              i.Ud.removeItem(i.Ws.ENS_CACHE),
              i.Ud.removeItem(i.Ws.IDENTITY_CACHE),
              i.Ud.removeItem(i.Ws.HISTORY_TRANSACTIONS_CACHE);
          } catch {
            console.info("Unable to clear address cache");
          }
        },
        setPreferredAccountTypes(e) {
          try {
            i.Ud.setItem(i.Ws.PREFERRED_ACCOUNT_TYPES, JSON.stringify(e));
          } catch {
            console.info("Unable to set preferred account types", e);
          }
        },
        getPreferredAccountTypes() {
          try {
            let e = i.Ud.getItem(i.Ws.PREFERRED_ACCOUNT_TYPES);
            if (!e) return {};
            return JSON.parse(e);
          } catch {
            console.info("Unable to get preferred account types");
          }
          return {};
        },
        setConnections(e, t) {
          try {
            let r = s.getConnections(),
              a = r[t] ?? [],
              o = new Map();
            for (let e of a) o.set(e.connectorId, { ...e });
            for (let t of e) {
              let e = o.get(t.connectorId),
                r = t.connectorId === n.o.CONNECTOR_ID.AUTH;
              if (e && !r) {
                let r = new Set(e.accounts.map((e) => e.address.toLowerCase())),
                  i = t.accounts.filter((e) => !r.has(e.address.toLowerCase()));
                e.accounts.push(...i);
              } else o.set(t.connectorId, { ...t });
            }
            let c = { ...r, [t]: Array.from(o.values()) };
            i.Ud.setItem(i.Ws.CONNECTIONS, JSON.stringify(c));
          } catch (e) {
            console.error("Unable to sync connections to storage", e);
          }
        },
        getConnections() {
          try {
            let e = i.Ud.getItem(i.Ws.CONNECTIONS);
            if (!e) return {};
            return JSON.parse(e);
          } catch (e) {
            return (
              console.error("Unable to get connections from storage", e), {}
            );
          }
        },
        deleteAddressFromConnection({
          connectorId: e,
          address: t,
          namespace: r,
        }) {
          try {
            let n = s.getConnections(),
              a = n[r] ?? [],
              o = new Map(a.map((e) => [e.connectorId, e])),
              c = o.get(e);
            if (c) {
              let r = c.accounts.filter(
                (e) => e.address.toLowerCase() !== t.toLowerCase()
              );
              0 === r.length
                ? o.delete(e)
                : o.set(e, {
                    ...c,
                    accounts: c.accounts.filter(
                      (e) => e.address.toLowerCase() !== t.toLowerCase()
                    ),
                  });
            }
            i.Ud.setItem(
              i.Ws.CONNECTIONS,
              JSON.stringify({ ...n, [r]: Array.from(o.values()) })
            );
          } catch {
            console.error(
              `Unable to remove address "${t}" from connector "${e}" in namespace "${r}"`
            );
          }
        },
        getDisconnectedConnectorIds() {
          try {
            let e = i.Ud.getItem(i.Ws.DISCONNECTED_CONNECTOR_IDS);
            if (!e) return {};
            return JSON.parse(e);
          } catch {
            console.info("Unable to get disconnected connector ids");
          }
          return {};
        },
        addDisconnectedConnectorId(e, t) {
          try {
            let r = s.getDisconnectedConnectorIds(),
              n = r[t] ?? [];
            n.push(e),
              i.Ud.setItem(
                i.Ws.DISCONNECTED_CONNECTOR_IDS,
                JSON.stringify({ ...r, [t]: Array.from(new Set(n)) })
              );
          } catch {
            console.error(
              `Unable to set disconnected connector id "${e}" for namespace "${t}"`
            );
          }
        },
        removeDisconnectedConnectorId(e, t) {
          try {
            let r = s.getDisconnectedConnectorIds(),
              n = r[t] ?? [];
            (n = n.filter((t) => t.toLowerCase() !== e.toLowerCase())),
              i.Ud.setItem(
                i.Ws.DISCONNECTED_CONNECTOR_IDS,
                JSON.stringify({ ...r, [t]: Array.from(new Set(n)) })
              );
          } catch {
            console.error(
              `Unable to remove disconnected connector id "${e}" for namespace "${t}"`
            );
          }
        },
        isConnectorDisconnected(e, t) {
          try {
            return (s.getDisconnectedConnectorIds()[t] ?? []).some(
              (t) => t.toLowerCase() === e.toLowerCase()
            );
          } catch {
            console.info(
              `Unable to get disconnected connector id "${e}" for namespace "${t}"`
            );
          }
          return !1;
        },
        getTransactionsCache() {
          try {
            let e = i.Ud.getItem(i.Ws.HISTORY_TRANSACTIONS_CACHE);
            return e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get transactions cache");
          }
          return {};
        },
        getTransactionsCacheForAddress({ address: e, chainId: t = "" }) {
          try {
            let r = s.getTransactionsCache(),
              i = r[e]?.[t];
            if (
              i &&
              !this.isCacheExpired(
                i.timestamp,
                this.cacheExpiry.transactionsHistory
              )
            )
              return i.transactions;
            s.removeTransactionsCache({ address: e, chainId: t });
          } catch {
            console.info("Unable to get transactions cache");
          }
        },
        updateTransactionsCache({
          address: e,
          chainId: t = "",
          timestamp: r,
          transactions: n,
        }) {
          try {
            let a = s.getTransactionsCache();
            (a[e] = { ...a[e], [t]: { timestamp: r, transactions: n } }),
              i.Ud.setItem(i.Ws.HISTORY_TRANSACTIONS_CACHE, JSON.stringify(a));
          } catch {
            console.info("Unable to update transactions cache", {
              address: e,
              chainId: t,
              timestamp: r,
              transactions: n,
            });
          }
        },
        removeTransactionsCache({ address: e, chainId: t }) {
          try {
            let r = s.getTransactionsCache(),
              { [t]: n, ...a } = r?.[e] || {};
            i.Ud.setItem(
              i.Ws.HISTORY_TRANSACTIONS_CACHE,
              JSON.stringify({ ...r, [e]: a })
            );
          } catch {
            console.info("Unable to remove transactions cache", {
              address: e,
              chainId: t,
            });
          }
        },
        getTokenPriceCache() {
          try {
            let e = i.Ud.getItem(i.Ws.TOKEN_PRICE_CACHE);
            return e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get token price cache");
          }
          return {};
        },
        getTokenPriceCacheForAddresses(e) {
          try {
            let t = s.getTokenPriceCache()[e.join(",")];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.tokenPrice)
            )
              return t.tokenPrice;
            s.removeTokenPriceCache(e);
          } catch {
            console.info("Unable to get token price cache for addresses", e);
          }
        },
        updateTokenPriceCache(e) {
          try {
            let t = s.getTokenPriceCache();
            (t[e.addresses.join(",")] = {
              timestamp: e.timestamp,
              tokenPrice: e.tokenPrice,
            }),
              i.Ud.setItem(i.Ws.TOKEN_PRICE_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update token price cache", e);
          }
        },
        removeTokenPriceCache(e) {
          try {
            let t = s.getTokenPriceCache();
            i.Ud.setItem(
              i.Ws.TOKEN_PRICE_CACHE,
              JSON.stringify({ ...t, [e.join(",")]: void 0 })
            );
          } catch {
            console.info("Unable to remove token price cache", e);
          }
        },
        getLatestAppKitVersion() {
          try {
            let e = this.getLatestAppKitVersionCache(),
              t = e?.version;
            if (
              t &&
              !this.isCacheExpired(
                e.timestamp,
                this.cacheExpiry.latestAppKitVersion
              )
            )
              return t;
          } catch {
            console.info("Unable to get latest AppKit version");
          }
        },
        getLatestAppKitVersionCache() {
          try {
            let e = i.Ud.getItem(i.Ws.LATEST_APPKIT_VERSION);
            return e ? JSON.parse(e) : {};
          } catch {
            console.info("Unable to get latest AppKit version cache");
          }
          return {};
        },
        updateLatestAppKitVersion(e) {
          try {
            let t = s.getLatestAppKitVersionCache();
            (t.timestamp = e.timestamp),
              (t.version = e.version),
              i.Ud.setItem(i.Ws.LATEST_APPKIT_VERSION, JSON.stringify(t));
          } catch {
            console.info(
              "Unable to update latest AppKit version on local storage",
              e
            );
          }
        },
      };
    },
    59233: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => en });
      var i = r(45553),
        n = r(52617),
        s = r(67243),
        a = r(71305),
        o = r(10899),
        c = r(70417),
        l = r(67869),
        d = r(97418),
        h = r(6578),
        u = r(72880),
        p = r(28977),
        f = r(55480),
        g = r(93481),
        m = r(45069),
        y = r(58653),
        w = r(12319),
        b = r(52502),
        v = r(32009),
        C = r(79355),
        E = r(8567),
        x = r(89600),
        A = r(17389),
        _ = r(73537),
        I = r(72289),
        S = r(59335),
        k = r(65103),
        N = r(76190),
        T = r(44826),
        O = r(62609),
        P = r(14744),
        R = r(4768),
        $ = r(63621),
        D = r(81701),
        U = r(25654),
        M = r(65374),
        L = r(42312),
        B = r(36211);
      let W = {
        extractVersion(e) {
          if (!e || "string" != typeof e) return null;
          let t = e.match(
            /(?:[~^>=<]+\s*)?(?<version>\d+(?:\.\d+){0,2})(?:-[a-zA-Z]+\.\d+)?/u
          );
          return t?.groups?.version || null;
        },
        checkSDKVersion(e) {
          let t = this.extractVersion(e),
            r = i.o.IS_DEVELOPMENT;
          if (!t || !r) return;
          let n = y.i.getLatestAppKitVersion();
          if (this.isValidVersion(n) && this.isOlder(t, n))
            return void console.warn(E.o.getSDKVersionWarningMessage(t, n));
          try {
            fetch("https://registry.npmjs.org/@reown/appkit/latest")
              .then((e) => e.json())
              .then((e) => {
                let r = e.version;
                this.isOlder(t, r) &&
                  (y.i.updateLatestAppKitVersion({
                    timestamp: Date.now(),
                    version: r,
                  }),
                  console.warn(E.o.getSDKVersionWarningMessage(t, r)));
              });
          } catch (e) {}
        },
        isValidVersion: (e) =>
          "string" == typeof e && /^\d+\.\d+\.\d+$/u.test(e),
        isOlder(e, t) {
          let r = this.extractVersion(e),
            i = this.extractVersion(t);
          if (!r || !i) return !1;
          function n(e) {
            let t = e.split(".").map(Number);
            for (; t.length < 3; ) t.push(0);
            return t;
          }
          let s = n(r),
            a = n(i);
          for (let e = 0; e < Math.max(s.length, a.length); e += 1) {
            let t = s[e] || 0,
              r = a[e] || 0;
            if (t < r) return !0;
            if (t > r) break;
          }
          return !1;
        },
      };
      var j = r(44161);
      let F = {
        TOKEN_ADDRESSES_BY_SYMBOL: {
          USDC: { 8453: j.$f.asset, 84532: j.sP.asset },
        },
        getTokenSymbolByAddress(e) {
          if (!e) return;
          let [t] =
            Object.entries(F.TOKEN_ADDRESSES_BY_SYMBOL).find(([t, r]) =>
              Object.values(r).includes(e)
            ) ?? [];
          return t;
        },
      };
      var H = r(55283),
        q = r(71018);
      let z = {
        createLogger(e, t = "error") {
          let r = (0, q.iP)({ level: t }),
            { logger: i } = (0, q.D5)({ opts: r });
          return (
            (i.error = (...t) => {
              for (let r of t) if (r instanceof Error) return void e(r, ...t);
              e(void 0, ...t);
            }),
            i
          );
        },
      };
      var V = r(8444),
        Z = r(34561),
        K = r(48241),
        G = r(10763),
        J = r(72557);
      class Y extends K.X {
        async setUniversalProvider(e) {
          if (!this.namespace)
            throw Error(
              "UniversalAdapter:setUniversalProvider - namespace is required"
            );
          return (
            this.addConnector(
              new G.F({
                provider: e,
                caipNetworks: this.getCaipNetworks(),
                namespace: this.namespace,
              })
            ),
            Promise.resolve()
          );
        }
        async connect(e) {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: Number(e.chainId),
            provider: this.provider,
            address: "",
          });
        }
        async disconnect() {
          try {
            let e = this.getWalletConnectConnector();
            await e.disconnect(), this.emit("disconnect");
          } catch (e) {
            console.warn("UniversalAdapter:disconnect - error", e);
          }
          return { connections: [] };
        }
        syncConnections() {
          return Promise.resolve();
        }
        async getAccounts({ namespace: e }) {
          let t = this.provider;
          return Promise.resolve({
            accounts: (
              t?.session?.namespaces?.[e]?.accounts
                ?.map((e) => {
                  let [, , t] = e.split(":");
                  return t;
                })
                .filter((e, t, r) => r.indexOf(e) === t) || []
            ).map((t) =>
              w.w.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
            ),
          });
        }
        async syncConnectors() {
          return Promise.resolve();
        }
        async getBalance(e) {
          if (
            !(
              e.caipNetwork &&
              p.oU.BALANCE_SUPPORTED_CHAINS.includes(
                e.caipNetwork?.chainNamespace
              )
            ) ||
            e.caipNetwork?.testnet
          )
            return {
              balance: "0.00",
              symbol: e.caipNetwork?.nativeCurrency.symbol || "",
            };
          let t = g.W.getAccountData();
          if (
            t?.balanceLoading &&
            e.chainId === g.W.state.activeCaipNetwork?.id
          )
            return {
              balance: t?.balance || "0.00",
              symbol: t?.balanceSymbol || "",
            };
          let r = (await g.W.fetchTokenBalance()).find(
            (t) =>
              t.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
              t.symbol === e.caipNetwork?.nativeCurrency.symbol
          );
          return {
            balance: r?.quantity.numeric || "0.00",
            symbol: r?.symbol || e.caipNetwork?.nativeCurrency.symbol || "",
          };
        }
        async signMessage(e) {
          let { provider: t, message: r, address: n } = e;
          if (!t)
            throw Error("UniversalAdapter:signMessage - provider is undefined");
          return {
            signature:
              g.W.state.activeCaipNetwork?.chainNamespace === i.o.CHAIN.SOLANA
                ? (
                    await t.request(
                      {
                        method: "solana_signMessage",
                        params: {
                          message: V.A.encode(new TextEncoder().encode(r)),
                          pubkey: n,
                        },
                      },
                      g.W.state.activeCaipNetwork?.caipNetworkId
                    )
                  ).signature
                : await t.request(
                    { method: "personal_sign", params: [r, n] },
                    g.W.state.activeCaipNetwork?.caipNetworkId
                  ),
          };
        }
        async estimateGas() {
          return Promise.resolve({ gas: BigInt(0) });
        }
        async sendTransaction() {
          return Promise.resolve({ hash: "" });
        }
        walletGetAssets(e) {
          return Promise.resolve({});
        }
        async writeContract() {
          return Promise.resolve({ hash: "" });
        }
        emitFirstAvailableConnection() {}
        parseUnits() {
          return 0n;
        }
        formatUnits() {
          return "0";
        }
        async getCapabilities() {
          return Promise.resolve({});
        }
        async grantPermissions() {
          return Promise.resolve({});
        }
        async revokePermissions() {
          return Promise.resolve("0x");
        }
        async syncConnection() {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: 1,
            provider: this.provider,
            address: "",
          });
        }
        async switchNetwork(e) {
          let { caipNetwork: t } = e,
            r = this.getWalletConnectConnector();
          if (t.chainNamespace === i.o.CHAIN.EVM)
            try {
              await r.provider?.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: (0, Z.nj)(t.id) }],
              });
            } catch (e) {
              if (
                e.code === J.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                e.code === J.E.ERROR_INVALID_CHAIN_ID ||
                e.code === J.E.ERROR_CODE_DEFAULT ||
                e?.data?.originalError?.code ===
                  J.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
              )
                try {
                  await r.provider?.request({
                    method: "wallet_addEthereumChain",
                    params: [
                      {
                        chainId: (0, Z.nj)(t.id),
                        rpcUrls: [t?.rpcUrls.chainDefault?.http],
                        chainName: t.name,
                        nativeCurrency: t.nativeCurrency,
                        blockExplorerUrls: [t.blockExplorers?.default.url],
                      },
                    ],
                  });
                } catch (e) {
                  throw Error("Chain is not supported");
                }
            }
          r.provider.setDefaultChain(t.caipNetworkId);
        }
        getWalletConnectProvider() {
          let e = this.connectors.find((e) => "WALLET_CONNECT" === e.type);
          return e?.provider;
        }
      }
      let X = [
          "email",
          "socials",
          "swaps",
          "onramp",
          "activity",
          "reownBranding",
          "multiWallet",
          "emailCapture",
          "payWithExchange",
          "payments",
          "reownAuthentication",
        ],
        Q = {
          email: {
            apiFeatureName: "social_login",
            localFeatureName: "email",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.includes("email");
            },
            processFallback: (e) =>
              void 0 === e ? p.oU.DEFAULT_REMOTE_FEATURES.email : !!e,
          },
          socials: {
            apiFeatureName: "social_login",
            localFeatureName: "socials",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return (
                !!e.isEnabled && t.length > 0 && t.filter((e) => "email" !== e)
              );
            },
            processFallback: (e) =>
              void 0 === e
                ? p.oU.DEFAULT_REMOTE_FEATURES.socials
                : "boolean" == typeof e
                ? !!e && p.oU.DEFAULT_REMOTE_FEATURES.socials
                : e,
          },
          swaps: {
            apiFeatureName: "swap",
            localFeatureName: "swaps",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.length > 0 && t;
            },
            processFallback: (e) =>
              void 0 === e
                ? p.oU.DEFAULT_REMOTE_FEATURES.swaps
                : "boolean" == typeof e
                ? !!e && p.oU.DEFAULT_REMOTE_FEATURES.swaps
                : e,
          },
          onramp: {
            apiFeatureName: "onramp",
            localFeatureName: "onramp",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => {
              if (!e?.config) return !1;
              let t = e.config;
              return !!e.isEnabled && t.length > 0 && t;
            },
            processFallback: (e) =>
              void 0 === e
                ? p.oU.DEFAULT_REMOTE_FEATURES.onramp
                : "boolean" == typeof e
                ? !!e && p.oU.DEFAULT_REMOTE_FEATURES.onramp
                : e,
          },
          activity: {
            apiFeatureName: "activity",
            localFeatureName: "history",
            returnType: !1,
            isLegacy: !0,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: (e) =>
              void 0 === e ? p.oU.DEFAULT_REMOTE_FEATURES.activity : !!e,
          },
          reownBranding: {
            apiFeatureName: "reown_branding",
            localFeatureName: "reownBranding",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: (e) =>
              void 0 === e ? p.oU.DEFAULT_REMOTE_FEATURES.reownBranding : !!e,
          },
          emailCapture: {
            apiFeatureName: "email_capture",
            localFeatureName: "emailCapture",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => e.isEnabled && (e.config ?? []),
            processFallback: (e) => !1,
          },
          multiWallet: {
            apiFeatureName: "multi_wallet",
            localFeatureName: "multiWallet",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: () => p.oU.DEFAULT_REMOTE_FEATURES.multiWallet,
          },
          payWithExchange: {
            apiFeatureName: "fund_from_exchange",
            localFeatureName: "payWithExchange",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: () => p.oU.DEFAULT_REMOTE_FEATURES.payWithExchange,
          },
          payments: {
            apiFeatureName: "payments",
            localFeatureName: "payments",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: () => p.oU.DEFAULT_REMOTE_FEATURES.payments,
          },
          reownAuthentication: {
            apiFeatureName: "reown_authentication",
            localFeatureName: "reownAuthentication",
            returnType: !1,
            isLegacy: !1,
            isAvailableOnBasic: !1,
            processApi: (e) => !!e.isEnabled,
            processFallback: (e) =>
              void 0 === e
                ? p.oU.DEFAULT_REMOTE_FEATURES.reownAuthentication
                : !!e,
          },
        },
        ee = {
          localSettingsOverridden: new Set(),
          getApiConfig: (e, t) => t?.find((t) => t.id === e),
          addWarning(e, t) {
            if (void 0 !== e) {
              let e = Q[t],
                r = e.isLegacy
                  ? `"features.${e.localFeatureName}" (now "${t}")`
                  : `"features.${t}"`;
              this.localSettingsOverridden.add(r);
            }
          },
          processFeature(e, t, r, i, n) {
            let s = Q[e],
              a = t[s.localFeatureName];
            if (n && !s.isAvailableOnBasic) return !1;
            if (i) {
              let t = this.getApiConfig(s.apiFeatureName, r);
              return t?.config === null
                ? this.processFallbackFeature(e, a)
                : !!t?.config &&
                    (void 0 !== a && this.addWarning(a, e),
                    this.processApiFeature(e, t));
            }
            return this.processFallbackFeature(e, a);
          },
          processApiFeature: (e, t) => Q[e].processApi(t),
          processFallbackFeature: (e, t) => Q[e].processFallback(t),
          async fetchRemoteFeatures(e) {
            let t = e.basic ?? !1,
              r = e.features || {};
            this.localSettingsOverridden.clear();
            let i = null,
              n = !1;
            try {
              n = null != (i = await u.N.fetchProjectConfig());
            } catch (e) {
              console.warn(
                "[Reown Config] Failed to fetch remote project configuration. Using local/default values.",
                e
              );
            }
            let s =
              n && !t
                ? p.oU.DEFAULT_REMOTE_FEATURES
                : p.oU.DEFAULT_REMOTE_FEATURES_DISABLED;
            try {
              for (let e of X) {
                let a = this.processFeature(e, r, i, n, t);
                Object.assign(s, { [e]: a });
              }
            } catch (e) {
              return (
                console.warn(
                  "[Reown Config] Failed to process the configuration from Cloud. Using default values.",
                  e
                ),
                p.oU.DEFAULT_REMOTE_FEATURES
              );
            }
            if (n && this.localSettingsOverridden.size > 0) {
              let e = `Your local configuration for ${Array.from(
                this.localSettingsOverridden
              ).join(
                ", "
              )} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
              b.h.open(
                {
                  debugMessage:
                    x.R.ALERT_WARNINGS.LOCAL_CONFIGURATION_IGNORED.debugMessage(
                      e
                    ),
                },
                "warning"
              );
            }
            return s;
          },
        };
      var et = r(19816);
      class er {
        constructor(e) {
          (this.chainNamespaces = []),
            (this.features = {}),
            (this.remoteFeatures = {}),
            (this.reportedAlertErrors = {}),
            (this.getCaipNetwork = (e, t) => {
              if (e) {
                let r = g.W.getCaipNetworks(e)?.find((e) => e.id === t);
                if (r) return r;
                let i = g.W.getNetworkData(e)?.caipNetwork;
                if (i) return i;
                let n = g.W.getRequestedCaipNetworks(e);
                return n.filter((t) => t.chainNamespace === e)?.[0];
              }
              return g.W.state.activeCaipNetwork || this.defaultCaipNetwork;
            }),
            (this.getCaipNetworkId = () => {
              let e = this.getCaipNetwork();
              if (e) return e.id;
            }),
            (this.getCaipNetworks = (e) => g.W.getCaipNetworks(e)),
            (this.getActiveChainNamespace = () => g.W.state.activeChain),
            (this.setRequestedCaipNetworks = (e, t) => {
              g.W.setRequestedCaipNetworks(e, t);
            }),
            (this.getApprovedCaipNetworkIds = () =>
              g.W.getAllApprovedCaipNetworkIds()),
            (this.getCaipAddress = (e) =>
              g.W.state.activeChain !== e && e
                ? g.W.state.chains.get(e)?.accountState?.caipAddress
                : g.W.state.activeCaipAddress),
            (this.setClientId = (e) => {
              T.T.setClientId(e);
            }),
            (this.getProvider = (e) => v.G.getProvider(e)),
            (this.getProviderType = (e) => v.G.getProviderId(e)),
            (this.getPreferredAccountType = (e) => (0, a.lj)(e)),
            (this.setCaipAddress = (e, t, r = !1) => {
              g.W.setAccountProp("caipAddress", e, t, r),
                g.W.setAccountProp("address", w.w.getPlainAddress(e), t, r);
            }),
            (this.setBalance = (e, t, r) => {
              g.W.setAccountProp("balance", e, r),
                g.W.setAccountProp("balanceSymbol", t, r);
            }),
            (this.setProfileName = (e, t) => {
              g.W.setAccountProp("profileName", e, t);
            }),
            (this.setProfileImage = (e, t) => {
              g.W.setAccountProp("profileImage", e, t);
            }),
            (this.setUser = (e, t) => {
              g.W.setAccountProp("user", e, t);
            }),
            (this.resetAccount = (e) => {
              g.W.resetAccount(e);
            }),
            (this.setCaipNetwork = (e) => {
              g.W.setActiveCaipNetwork(e);
            }),
            (this.setCaipNetworkOfNamespace = (e, t) => {
              g.W.setChainNetworkData(t, { caipNetwork: e });
            }),
            (this.setStatus = (e, t) => {
              g.W.setAccountProp("status", e, t),
                o.a.isConnected()
                  ? y.i.setConnectionStatus("connected")
                  : y.i.setConnectionStatus("disconnected");
            }),
            (this.getAddressByChainNamespace = (e) =>
              g.W.getAccountData(e)?.address),
            (this.setConnectors = (e) => {
              let t = [...o.a.state.allConnectors, ...e];
              o.a.setConnectors(t);
            }),
            (this.setConnections = (e, t) => {
              y.i.setConnections(e, t), d.x.setConnections(e, t);
            }),
            (this.fetchIdentity = (e) => T.T.fetchIdentity(e)),
            (this.getReownName = (e) => O.f.getNamesForAddress(e)),
            (this.getConnectors = () => o.a.getConnectors()),
            (this.getConnectorImage = (e) => P.$.getConnectorImage(e)),
            (this.getConnections = (e) =>
              this.remoteFeatures.multiWallet
                ? R.b.getConnectionsData(e).connections
                : (b.h.open(
                    i.o.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
                    "info"
                  ),
                  [])),
            (this.getRecentConnections = (e) =>
              this.remoteFeatures.multiWallet
                ? R.b.getConnectionsData(e).recentConnections
                : (b.h.open(
                    i.o.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
                    "info"
                  ),
                  [])),
            (this.switchConnection = async (e) => {
              if (!this.remoteFeatures.multiWallet)
                return void b.h.open(
                  i.o.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
                  "info"
                );
              await d.x.switchConnection(e);
            }),
            (this.deleteConnection = (e) => {
              if (!this.remoteFeatures.multiWallet)
                return void b.h.open(
                  i.o.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
                  "info"
                );
              y.i.deleteAddressFromConnection(e), d.x.syncStorageConnections();
            }),
            (this.setConnectedWalletInfo = (e, t) => {
              let r = v.G.getProviderId(t),
                i = e ? { ...e, type: r } : void 0;
              g.W.setAccountProp("connectedWalletInfo", i, t);
            }),
            (this.getIsConnectedState = () => !!g.W.state.activeCaipAddress),
            (this.addAddressLabel = (e, t, r) => {
              let i = g.W.getAccountData(r)?.addressLabels || {};
              g.W.setAccountProp("addressLabels", { ...i, [e]: t }, r);
            }),
            (this.removeAddressLabel = (e, t) => {
              let r = g.W.getAccountData(t)?.addressLabels || {};
              g.W.setAccountProp("addressLabels", { ...r, [e]: void 0 }, t);
            }),
            (this.getAddress = (e) => {
              let t = e || g.W.state.activeChain;
              return g.W.getAccountData(t)?.address;
            }),
            (this.setApprovedCaipNetworksData = (e) =>
              g.W.setApprovedCaipNetworksData(e)),
            (this.resetNetwork = (e) => {
              g.W.resetNetwork(e);
            }),
            (this.addConnector = (e) => {
              o.a.addConnector(e);
            }),
            (this.resetWcConnection = () => {
              d.x.resetWcConnection();
            }),
            (this.setAddressExplorerUrl = (e, t) => {
              g.W.setAccountProp("addressExplorerUrl", e, t);
            }),
            (this.setSmartAccountDeployed = (e, t) => {
              g.W.setAccountProp("smartAccountDeployed", e, t);
            }),
            (this.setPreferredAccountType = (e, t) => {
              g.W.setAccountProp("preferredAccountType", e, t);
            }),
            (this.setEIP6963Enabled = (e) => {
              f.H.setEIP6963Enabled(e);
            }),
            (this.handleUnsafeRPCRequest = () => {
              this.isOpen()
                ? this.isTransactionStackEmpty() ||
                  this.redirect("ApproveTransaction")
                : this.open({ view: "ApproveTransaction" });
            }),
            (this.options = e),
            (this.version = e.sdkVersion),
            (this.caipNetworks = this.extendCaipNetworks(e)),
            (this.chainNamespaces = this.getChainNamespacesSet(
              e.adapters,
              this.caipNetworks
            )),
            (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
            (this.chainAdapters = this.createAdapters(e.adapters)),
            (this.readyPromise = this.initialize(e)),
            W.checkSDKVersion(e.sdkVersion);
        }
        getChainNamespacesSet(e, t) {
          let r = e?.map((e) => e.namespace).filter((e) => !!e);
          return r?.length
            ? [...new Set(r)]
            : [...new Set(t?.map((e) => e.chainNamespace))];
        }
        async initialize(e) {
          if (
            (this.initializeProjectSettings(e),
            this.initControllers(e),
            await this.initChainAdapters(),
            this.sendInitializeEvent(e),
            f.H.state.enableReconnect
              ? (await this.syncExistingConnection(),
                await this.syncAdapterConnections())
              : await this.unSyncExistingConnection(),
            (this.remoteFeatures = await ee.fetchRemoteFeatures(e)),
            f.H.setRemoteFeatures(this.remoteFeatures),
            this.remoteFeatures.onramp &&
              $.aG.setOnrampProviders(this.remoteFeatures.onramp),
            (f.H.state.remoteFeatures?.email ||
              (Array.isArray(f.H.state.remoteFeatures?.socials) &&
                f.H.state.remoteFeatures?.socials.length > 0)) &&
              (await this.checkAllowedOrigins()),
            f.H.state.features?.reownAuthentication ||
              f.H.state.remoteFeatures?.reownAuthentication)
          ) {
            let { ReownAuthentication: e } = await r
                .e(5803)
                .then(r.bind(r, 95803)),
              t = f.H.state.siwx;
            t instanceof e ||
              (t &&
                console.warn(
                  "ReownAuthentication option is enabled, SIWX configuration will be overridden."
                ),
              f.H.setSIWX(new e()));
          }
        }
        async openSend(e) {
          let t = e.namespace || g.W.state.activeChain,
            r = this.getCaipAddress(t),
            i = this.getCaipNetwork(t)?.id;
          if (!r) throw Error("openSend: caipAddress not found");
          if (i?.toString() !== e.chainId.toString()) {
            let r = g.W.getCaipNetworkById(e.chainId, t);
            if (!r)
              throw Error(
                `openSend: caipNetwork with chainId ${e.chainId} not found`
              );
            await this.switchNetwork(r, { throwOnFailure: !0 });
          }
          try {
            let t = F.getTokenSymbolByAddress(e.assetAddress);
            t && (await u.N.fetchTokenImages([t]));
          } catch {}
          return (
            await D.W.open({ view: "WalletSend", data: { send: e } }),
            new Promise((e, t) => {
              let r = U.R.subscribeKey("hash", (t) => {
                  t && (n(), e({ hash: t }));
                }),
                i = D.W.subscribe((e) => {
                  e.open || (n(), t(Error("Modal closed")));
                }),
                n = this.createCleanupHandler([r, i]);
            })
          );
        }
        toModalOptions() {
          return {
            isSwap: function (e) {
              return e?.view === "Swap";
            },
            isSend: function (e) {
              return e?.view === "WalletSend";
            },
          };
        }
        async checkAllowedOrigins() {
          try {
            let e = await u.N.fetchAllowedOrigins();
            if (!w.w.isClient()) return;
            let t = window.location.origin;
            et.kl.isOriginAllowed(t, e, et.E1.DEFAULT_ALLOWED_ANCESTORS) ||
              b.h.open(x.R.ALERT_ERRORS.ORIGIN_NOT_ALLOWED, "error");
          } catch (e) {
            if (!(e instanceof Error)) return;
            switch (e.message) {
              case "RATE_LIMITED":
                b.h.open(
                  x.R.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION,
                  "error"
                );
                break;
              case "SERVER_ERROR": {
                let t = e.cause instanceof Error ? e.cause : e;
                b.h.open(
                  {
                    displayMessage:
                      x.R.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION
                        .displayMessage,
                    debugMessage:
                      x.R.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.debugMessage(
                        t.message
                      ),
                  },
                  "error"
                );
              }
            }
          }
        }
        createCleanupHandler(e) {
          return () => {
            e.forEach((e) => {
              try {
                e();
              } catch {}
            });
          };
        }
        sendInitializeEvent(e) {
          let { ...t } = e;
          delete t.adapters,
            delete t.universalProvider,
            c.E.sendEvent({
              type: "track",
              event: "INITIALIZE",
              properties: {
                ...t,
                networks: e.networks.map((e) => e.id),
                siweConfig: { options: e.siweConfig?.options || {} },
              },
            });
        }
        initControllers(e) {
          this.initializeOptionsController(e),
            this.initializeChainController(e),
            this.initializeThemeController(e),
            this.initializeConnectionController(e),
            this.initializeConnectorController();
        }
        initializeThemeController(e) {
          e.themeMode && m.W.setThemeMode(e.themeMode),
            e.themeVariables && m.W.setThemeVariables(e.themeVariables);
        }
        initializeChainController(e) {
          if (!this.connectionControllerClient || !this.networkControllerClient)
            throw Error(
              "ConnectionControllerClient and NetworkControllerClient must be set"
            );
          g.W.initialize(e.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient,
          });
          let t = this.getDefaultNetwork();
          t && g.W.setActiveCaipNetwork(t);
        }
        initializeConnectionController(e) {
          d.x.initialize(e.adapters ?? []), d.x.setWcBasic(e.basic ?? !1);
        }
        initializeConnectorController() {
          o.a.initialize(this.chainNamespaces);
        }
        initializeProjectSettings(e) {
          f.H.setProjectId(e.projectId), f.H.setSdkVersion(e.sdkVersion);
        }
        initializeOptionsController(e) {
          f.H.setDebug(!1 !== e.debug),
            f.H.setEnableWalletGuide(!1 !== e.enableWalletGuide),
            f.H.setEnableWallets(!1 !== e.enableWallets),
            f.H.setEIP6963Enabled(!1 !== e.enableEIP6963),
            f.H.setEnableNetworkSwitch(!1 !== e.enableNetworkSwitch),
            f.H.setEnableReconnect(!1 !== e.enableReconnect),
            f.H.setEnableMobileFullScreen(!0 === e.enableMobileFullScreen),
            f.H.setEnableAuthLogger(!1 !== e.enableAuthLogger),
            f.H.setCustomRpcUrls(e.customRpcUrls),
            f.H.setEnableEmbedded(e.enableEmbedded),
            f.H.setAllWallets(e.allWallets),
            f.H.setIncludeWalletIds(e.includeWalletIds),
            f.H.setExcludeWalletIds(e.excludeWalletIds),
            f.H.setFeaturedWalletIds(e.featuredWalletIds),
            f.H.setTokens(e.tokens),
            f.H.setTermsConditionsUrl(e.termsConditionsUrl),
            f.H.setPrivacyPolicyUrl(e.privacyPolicyUrl),
            f.H.setCustomWallets(e.customWallets),
            f.H.setFeatures(e.features),
            f.H.setAllowUnsupportedChain(e.allowUnsupportedChain),
            f.H.setUniversalProviderConfigOverride(
              e.universalProviderConfigOverride
            ),
            f.H.setPreferUniversalLinks(e.experimental_preferUniversalLinks),
            f.H.setDefaultAccountTypes(e.defaultAccountTypes);
          let t = this.getDefaultMetaData();
          if (
            (!e.metadata && t && (e.metadata = t),
            f.H.setMetadata(e.metadata),
            f.H.setDisableAppend(e.disableAppend),
            f.H.setEnableEmbedded(e.enableEmbedded),
            f.H.setSIWX(e.siwx),
            (this.features = f.H.state.features ?? {}),
            !e.projectId)
          )
            return void b.h.open(
              x.R.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,
              "error"
            );
          if (
            e.adapters?.find((e) => e.namespace === i.o.CHAIN.EVM) &&
            e.siweConfig
          ) {
            if (e.siwx)
              throw Error("Cannot set both `siweConfig` and `siwx` options");
            f.H.setSIWX(e.siweConfig.mapToSIWX());
          }
        }
        getDefaultMetaData() {
          return w.w.isClient()
            ? {
                name:
                  document.getElementsByTagName("title")?.[0]?.textContent ||
                  "",
                description:
                  document.querySelector('meta[property="og:description"]')
                    ?.content || "",
                url: window.location.origin,
                icons: [
                  document.querySelector('link[rel~="icon"]')?.href || "",
                ],
              }
            : null;
        }
        setUnsupportedNetwork(e) {
          let t = this.getActiveChainNamespace();
          if (t) {
            let r = H.R.getUnsupportedNetwork(`${t}:${e}`);
            g.W.setActiveCaipNetwork(r);
          }
        }
        getDefaultNetwork() {
          return H.R.getCaipNetworkFromStorage(this.defaultCaipNetwork);
        }
        extendCaipNetwork(e, t) {
          return H.R.extendCaipNetwork(e, {
            customNetworkImageUrls: t.chainImages,
            projectId: t.projectId,
          });
        }
        extendCaipNetworks(e) {
          return H.R.extendCaipNetworks(e.networks, {
            customNetworkImageUrls: e.chainImages,
            customRpcUrls: e.customRpcUrls,
            projectId: e.projectId,
          });
        }
        extendDefaultCaipNetwork(e) {
          let t = e.networks.find((t) => t.id === e.defaultNetwork?.id);
          return t
            ? H.R.extendCaipNetwork(t, {
                customNetworkImageUrls: e.chainImages,
                customRpcUrls: e.customRpcUrls,
                projectId: e.projectId,
              })
            : void 0;
        }
        async disconnectConnector(e, t) {
          try {
            this.setLoading(!0, e);
            let r = { connections: [] },
              i = this.getAdapter(e);
            return (
              (g.W.state.chains.get(e)?.accountState?.caipAddress ||
                !f.H.state.enableReconnect) &&
                i?.disconnect &&
                (r = await i.disconnect({ id: t })),
              this.setLoading(!1, e),
              r
            );
          } catch (t) {
            throw (
              (this.setLoading(!1, e),
              Error(`Failed to disconnect chains: ${t.message}`))
            );
          }
        }
        createClients() {
          (this.connectionControllerClient = {
            connectWalletConnect: async () => {
              let e = g.W.state.activeChain,
                t = this.getAdapter(e),
                r = this.getCaipNetwork(e)?.id,
                i = d.x.getConnections(e),
                n = this.remoteFeatures.multiWallet,
                a = i.length > 0;
              if (!t) throw Error("Adapter not found");
              let o = await t.connectWalletConnect(r);
              (a && n) || this.close(),
                this.setClientId(o?.clientId || null),
                y.i.setConnectedNamespaces([...g.W.state.chains.keys()]),
                await this.syncWalletConnectAccount(),
                await s.U.initializeIfEnabled();
            },
            connectExternal: async (e) => {
              let t = await this.onConnectExternal(e);
              return (
                await this.connectInactiveNamespaces(e, t),
                t ? { address: t.address } : void 0
              );
            },
            reconnectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
            }) => {
              let n = g.W.state.activeChain,
                s = this.getAdapter(n);
              if (!n) throw Error("reconnectExternal: namespace not found");
              if (!s) throw Error("reconnectExternal: adapter not found");
              s?.reconnect &&
                (await s?.reconnect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: this.getCaipNetwork()?.id,
                }),
                y.i.addConnectedNamespace(n),
                this.syncConnectedWalletInfo(n));
            },
            disconnectConnector: async (e) => {
              await this.disconnectConnector(e.namespace, e.id);
            },
            disconnect: async (e) => {
              let { id: t, chainNamespace: r, initialDisconnect: n } = e || {},
                a = r || g.W.state.activeChain,
                l = o.a.getConnectorId(a),
                h = t === i.o.CONNECTOR_ID.AUTH || l === i.o.CONNECTOR_ID.AUTH,
                u =
                  t === i.o.CONNECTOR_ID.WALLET_CONNECT ||
                  l === i.o.CONNECTOR_ID.WALLET_CONNECT;
              try {
                let e = Array.from(g.W.state.chains.keys()),
                  i = r ? [r] : e;
                (u || h) && (i = e);
                let a = i.map(async (e) => {
                    let r = o.a.getConnectorId(e),
                      i = await this.disconnectConnector(e, t || r);
                    i &&
                      (h && y.i.deleteConnectedSocialProvider(),
                      i.connections.forEach((t) => {
                        y.i.addDisconnectedConnectorId(t.connectorId, e);
                      })),
                      n &&
                        this.onDisconnectNamespace({
                          chainNamespace: e,
                          closeModal: !1,
                        });
                  }),
                  l = await Promise.allSettled(a);
                U.R.resetSend(),
                  d.x.resetWcConnection(),
                  s.U.getSIWX()?.signOutOnDisconnect &&
                    (await s.U.clearSessions()),
                  o.a.setFilterByNamespace(void 0),
                  d.x.syncStorageConnections();
                let p = l.filter((e) => "rejected" === e.status);
                if (p.length > 0)
                  throw Error(p.map((e) => e.reason.message).join(", "));
                c.E.sendEvent({
                  type: "track",
                  event: "DISCONNECT_SUCCESS",
                  properties: { namespace: r || "all" },
                });
              } catch (e) {
                throw Error(`Failed to disconnect chains: ${e.message}`);
              }
            },
            checkInstalled: (e) =>
              e
                ? e.some((e) => !!window.ethereum?.[String(e)])
                : !!window.ethereum,
            signMessage: async (e) => {
              let t = g.W.state.activeChain,
                r = this.getAdapter(g.W.state.activeChain);
              if (!t) throw Error("signMessage: namespace not found");
              if (!r) throw Error("signMessage: adapter not found");
              let i = this.getAddress(t);
              if (!i) throw Error("signMessage: address not found");
              let n = await r?.signMessage({
                message: e,
                address: i,
                provider: v.G.getProvider(t),
              });
              return n?.signature || "";
            },
            sendTransaction: async (e) => {
              let t = e.chainNamespace;
              if (!t) throw Error("sendTransaction: namespace not found");
              if (p.oU.SEND_SUPPORTED_NAMESPACES.includes(t)) {
                let r = this.getAdapter(t);
                if (!r) throw Error("sendTransaction: adapter not found");
                let i = v.G.getProvider(t),
                  n = await r?.sendTransaction({
                    ...e,
                    caipNetwork: this.getCaipNetwork(),
                    provider: i,
                  });
                return n?.hash || "";
              }
              return "";
            },
            estimateGas: async (e) => {
              let t = e.chainNamespace;
              if (t === i.o.CHAIN.EVM) {
                let r = this.getAdapter(t);
                if (!r)
                  throw Error(
                    "estimateGas: adapter is required but got undefined"
                  );
                let i = v.G.getProvider(t),
                  n = this.getCaipNetwork();
                if (!n)
                  throw Error(
                    "estimateGas: caipNetwork is required but got undefined"
                  );
                let s = await r?.estimateGas({
                  ...e,
                  provider: i,
                  caipNetwork: n,
                });
                return s?.gas || 0n;
              }
              return 0n;
            },
            getEnsAvatar: async () => {
              let e = g.W.state.activeChain;
              if (!e)
                throw Error(
                  "getEnsAvatar: namespace is required but got undefined"
                );
              let t = this.getAddress(e);
              if (!t) throw Error("getEnsAvatar: address not found");
              await this.syncIdentity({
                address: t,
                chainId: Number(this.getCaipNetwork()?.id),
                chainNamespace: e,
              });
              let r = g.W.getAccountData();
              return r?.profileImage || !1;
            },
            getEnsAddress: async (e) => await et.kl.resolveReownName(e),
            writeContract: async (e) => {
              let t = g.W.state.activeChain,
                r = this.getAdapter(t);
              if (!t)
                throw Error(
                  "writeContract: namespace is required but got undefined"
                );
              if (!r)
                throw Error(
                  "writeContract: adapter is required but got undefined"
                );
              let i = this.getCaipNetwork(),
                n = this.getCaipAddress(),
                s = v.G.getProvider(t);
              if (!i || !n)
                throw Error(
                  "writeContract: caipNetwork or caipAddress is required but got undefined"
                );
              let a = await r?.writeContract({
                ...e,
                caipNetwork: i,
                provider: s,
                caipAddress: n,
              });
              return a?.hash;
            },
            parseUnits: (e, t) => {
              let r = this.getAdapter(g.W.state.activeChain);
              if (!r)
                throw Error(
                  "parseUnits: adapter is required but got undefined"
                );
              return r?.parseUnits({ value: e, decimals: t }) ?? 0n;
            },
            formatUnits: (e, t) => {
              let r = this.getAdapter(g.W.state.activeChain);
              if (!r)
                throw Error(
                  "formatUnits: adapter is required but got undefined"
                );
              return r?.formatUnits({ value: e, decimals: t }) ?? "0";
            },
            getCapabilities: async (e) => {
              let t = this.getAdapter(g.W.state.activeChain);
              if (!t)
                throw Error(
                  "getCapabilities: adapter is required but got undefined"
                );
              return await t?.getCapabilities(e);
            },
            grantPermissions: async (e) => {
              let t = this.getAdapter(g.W.state.activeChain);
              if (!t)
                throw Error(
                  "grantPermissions: adapter is required but got undefined"
                );
              return await t?.grantPermissions(e);
            },
            revokePermissions: async (e) => {
              let t = this.getAdapter(g.W.state.activeChain);
              if (!t)
                throw Error(
                  "revokePermissions: adapter is required but got undefined"
                );
              return t?.revokePermissions ? await t.revokePermissions(e) : "0x";
            },
            walletGetAssets: async (e) => {
              let t = this.getAdapter(g.W.state.activeChain);
              if (!t)
                throw Error(
                  "walletGetAssets: adapter is required but got undefined"
                );
              return (await t?.walletGetAssets(e)) ?? {};
            },
            updateBalance: (e) => {
              let t = this.getAddress(e),
                r = this.getCaipNetwork(e);
              r && t && this.updateNativeBalance(t, r?.id, e);
            },
          }),
            (this.networkControllerClient = {
              switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
              getApprovedCaipNetworksData: async () =>
                this.getApprovedCaipNetworksData(),
            }),
            d.x.setClient(this.connectionControllerClient);
        }
        async onConnectExternal(e) {
          let t = g.W.state.activeChain,
            r = e.chain || t,
            n = this.getAdapter(r),
            s = !0;
          if (
            (e.type === E.o.CONNECTOR_TYPE_AUTH &&
              i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(
                (e) => o.a.getConnectorId(e) === i.o.CONNECTOR_ID.AUTH
              ) &&
              e.chain !== t &&
              (s = !1),
            e.chain && e.chain !== t && !e.caipNetwork)
          ) {
            let t = this.getCaipNetworks().find(
              (t) => t.chainNamespace === e.chain
            );
            t && s && this.setCaipNetwork(t);
          }
          if (!r) throw Error("connectExternal: namespace not found");
          if (!n) throw Error("connectExternal: adapter not found");
          let a = this.getCaipNetwork(r),
            c = e.caipNetwork || a,
            l = await n.connect({
              id: e.id,
              address: e.address,
              info: e.info,
              type: e.type,
              provider: e.provider,
              socialUri: e.socialUri,
              chainId: e.caipNetwork?.id || a?.id,
              rpcUrl:
                e.caipNetwork?.rpcUrls?.default?.http?.[0] ||
                a?.rpcUrls?.default?.http?.[0],
            });
          if (l)
            return (
              y.i.addConnectedNamespace(r),
              this.syncProvider({ ...l, chainNamespace: r }),
              this.setStatus("connected", r),
              this.syncConnectedWalletInfo(r),
              y.i.removeDisconnectedConnectorId(e.id, r),
              { address: l.address, connectedCaipNetwork: c }
            );
        }
        async connectInactiveNamespaces(e, t) {
          let r = e.type === E.o.CONNECTOR_TYPE_AUTH,
            i = C.y.getOtherAuthNamespaces(
              t?.connectedCaipNetwork?.chainNamespace
            ),
            n = g.W.state.activeCaipNetwork,
            s = this.getAdapter(n?.chainNamespace),
            a = v.G.getProvider(n?.chainNamespace);
          r &&
            (await Promise.all(
              i.map(async (t) => {
                try {
                  let r = v.G.getProvider(t),
                    i = this.getCaipNetwork(t),
                    n = this.getAdapter(t);
                  (await n?.connect({
                    ...e,
                    provider: r,
                    socialUri: void 0,
                    chainId: i?.id,
                    rpcUrl: i?.rpcUrls?.default?.http?.[0],
                  })) &&
                    (y.i.addConnectedNamespace(t),
                    y.i.removeDisconnectedConnectorId(e.id, t),
                    this.setStatus("connected", t),
                    this.syncConnectedWalletInfo(t));
                } catch (e) {
                  b.h.warn(
                    x.R.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED
                      .displayMessage,
                    x.R.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.debugMessage(
                      t,
                      e instanceof Error ? e.message : void 0
                    ),
                    x.R.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.code
                  );
                }
              })
            ),
            n &&
              (await s?.switchNetwork({
                caipNetwork: n,
                provider: a,
                providerType: e.type,
              })));
        }
        getApprovedCaipNetworksData() {
          if (
            v.G.getProviderId(g.W.state.activeChain) ===
            E.o.CONNECTOR_TYPE_WALLET_CONNECT
          ) {
            let e = this.universalProvider?.session?.namespaces;
            return {
              supportsAllNetworks:
                this.universalProvider?.session?.peer?.metadata.name ===
                "MetaMask Wallet",
              approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
            };
          }
          return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
        }
        async switchCaipNetwork(e) {
          let t = e.chainNamespace;
          if (this.getAddressByChainNamespace(e.chainNamespace)) {
            let r = v.G.getProvider(t),
              i = v.G.getProviderId(t);
            if (e.chainNamespace === g.W.state.activeChain) {
              let n = this.getAdapter(t);
              await n?.switchNetwork({
                caipNetwork: e,
                provider: r,
                providerType: i,
              });
            } else if (
              (this.setCaipNetwork(e), i === E.o.CONNECTOR_TYPE_WALLET_CONNECT)
            )
              this.syncWalletConnectAccount();
            else {
              let r = this.getAddressByChainNamespace(t);
              r &&
                this.syncAccount({
                  address: r,
                  chainId: e.id,
                  chainNamespace: t,
                });
            }
          } else this.setCaipNetwork(e);
        }
        getChainsFromNamespaces(e = {}) {
          return Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let { chainId: t, chainNamespace: r } =
                    k.C.parseCaipAddress(e);
                  return `${r}:${t}`;
                }),
              ])
            )
          );
        }
        createAdapters(e) {
          return (
            this.createClients(),
            this.chainNamespaces.reduce((t, r) => {
              let i = e?.find((e) => e.namespace === r);
              return (
                i
                  ? (i.construct({
                      namespace: r,
                      projectId: this.options?.projectId,
                      networks: this.caipNetworks?.filter(
                        ({ chainNamespace: e }) => e === r
                      ),
                    }),
                    (t[r] = i))
                  : (t[r] = new Y({
                      namespace: r,
                      networks: this.getCaipNetworks(),
                    })),
                t
              );
            }, {})
          );
        }
        async initChainAdapter(e) {
          this.onConnectors(e),
            this.listenAdapter(e),
            await this.chainAdapters?.[e].syncConnectors(this.options, this),
            await this.createUniversalProviderForAdapter(e);
        }
        async initChainAdapters() {
          await Promise.all(
            this.chainNamespaces.map(async (e) => {
              await this.initChainAdapter(e);
            })
          );
        }
        onConnectors(e) {
          let t = this.getAdapter(e);
          t?.on("connectors", this.setConnectors.bind(this));
        }
        listenAdapter(e) {
          let t = this.getAdapter(e);
          if (!t) return;
          let r = y.i.getConnectionStatus();
          !1 === f.H.state.enableReconnect
            ? this.setStatus("disconnected", e)
            : "connected" === r
            ? this.setStatus("connecting", e)
            : ("disconnected" === r && y.i.clearAddressCache(),
              this.setStatus(r, e)),
            t.on("switchNetwork", ({ address: t, chainId: r }) => {
              let i = this.getCaipNetworks().find(
                  (e) =>
                    e.id.toString() === r.toString() ||
                    e.caipNetworkId.toString() === r.toString()
                ),
                n = g.W.state.activeChain === e,
                s = g.W.state.chains.get(e)?.accountState?.address;
              if (i) {
                let r = n && t ? t : s;
                r &&
                  this.syncAccount({
                    address: r,
                    chainId: i.id,
                    chainNamespace: e,
                  });
              } else this.setUnsupportedNetwork(r);
            }),
            t.on("disconnect", () => {
              let t = this.remoteFeatures.multiWallet,
                r = Array.from(d.x.state.connections.values()).flat();
              this.onDisconnectNamespace({
                chainNamespace: e,
                closeModal: !t || 0 === r.length,
              });
            }),
            t.on("connections", (t) => {
              this.setConnections(t, e);
            }),
            t.on("pendingTransactions", () => {
              let t = this.getAddress(e),
                r = g.W.state.activeCaipNetwork;
              t && r?.id && this.updateNativeBalance(t, r.id, r.chainNamespace);
            }),
            t.on(
              "accountChanged",
              ({ address: t, chainId: r, connector: i }) => {
                this.handlePreviousConnectorConnection(i);
                let n = g.W.state.activeChain === e;
                i?.provider &&
                  (this.syncProvider({
                    id: i.id,
                    type: i.type,
                    provider: i?.provider,
                    chainNamespace: e,
                  }),
                  this.syncConnectedWalletInfo(e));
                let s = g.W.getNetworkData(e)?.caipNetwork?.id,
                  a = r || s;
                n && a
                  ? this.syncAccount({
                      address: t,
                      chainId: a,
                      chainNamespace: e,
                    })
                  : !n && a
                  ? (this.syncAccountInfo(t, a, e),
                    this.syncBalance({
                      address: t,
                      chainId: a,
                      chainNamespace: e,
                    }))
                  : this.syncAccountInfo(t, r, e),
                  y.i.addConnectedNamespace(e);
              }
            );
        }
        async handlePreviousConnectorConnection(e) {
          let t = e?.chain,
            r = e?.id,
            i = o.a.getConnectorId(t),
            n = f.H.state.remoteFeatures?.multiWallet,
            s = i !== r,
            a = t && r && i && s && !n;
          try {
            a && (await d.x.disconnect({ id: i, namespace: t }));
          } catch (e) {
            console.warn("Error disconnecting previous connector", e);
          }
        }
        async createUniversalProviderForAdapter(e) {
          await this.getUniversalProvider(),
            this.universalProvider &&
              (await this.chainAdapters?.[e]?.setUniversalProvider?.(
                this.universalProvider
              ));
        }
        async syncExistingConnection() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
          );
        }
        async unSyncExistingConnection() {
          try {
            await Promise.allSettled(
              this.chainNamespaces.map((e) =>
                d.x.disconnect({ namespace: e, initialDisconnect: !0 })
              )
            );
          } catch (e) {
            console.error("Error disconnecting existing connections:", e);
          }
        }
        async reconnectWalletConnect() {
          await this.syncWalletConnectAccount();
          let e = this.getAddress();
          this.getCaipAddress() || y.i.deleteRecentWallet();
          let t = y.i.getRecentWallet();
          c.E.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            address: e,
            properties: {
              method: w.w.isMobile() ? "mobile" : "qrcode",
              name: t?.name || "Unknown",
              reconnect: !0,
              view: l.I.state.view,
              walletRank: t?.order,
            },
          });
        }
        async syncNamespaceConnection(e) {
          try {
            e === i.o.CHAIN.EVM &&
              w.w.isSafeApp() &&
              o.a.setConnectorId(i.o.CONNECTOR_ID.SAFE, e);
            let t = o.a.getConnectorId(e);
            switch ((this.setStatus("connecting", e), t)) {
              case i.o.CONNECTOR_ID.WALLET_CONNECT:
                await this.reconnectWalletConnect();
                break;
              case i.o.CONNECTOR_ID.AUTH:
                break;
              default:
                await this.syncAdapterConnection(e);
            }
          } catch (t) {
            console.warn("AppKit couldn't sync existing connection", t),
              this.setStatus("disconnected", e);
          }
        }
        onDisconnectNamespace(e) {
          let { chainNamespace: t, closeModal: r } = e || {};
          g.W.resetAccount(t),
            g.W.resetNetwork(t),
            y.i.removeConnectedNamespace(t);
          let i = Array.from(g.W.state.chains.keys());
          (t ? [t] : i).forEach((e) =>
            y.i.addDisconnectedConnectorId(o.a.getConnectorId(e) || "", e)
          ),
            o.a.removeConnectorId(t),
            v.G.resetChain(t),
            this.setUser(null, t),
            this.setStatus("disconnected", t),
            this.setConnectedWalletInfo(null, t),
            !1 !== r && D.W.close();
        }
        async syncAdapterConnections() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => {
              let t = this.getAdapter(e),
                r = this.getCaipAddress(e),
                i = this.getCaipNetwork(e);
              return t?.syncConnections({
                connectToFirstConnector: !r,
                caipNetwork: i,
              });
            })
          );
        }
        async syncAdapterConnection(e) {
          let t = this.getAdapter(e),
            r = this.getCaipNetwork(e),
            i = o.a.getConnectorId(e),
            n = o.a.getConnectors(e).find((e) => e.id === i);
          try {
            if (!t || !n)
              throw Error(`Adapter or connector not found for namespace ${e}`);
            if (!r?.id) throw Error("CaipNetwork not found");
            let i = await t?.syncConnection({
              namespace: e,
              id: n.id,
              chainId: r.id,
              rpcUrl: r?.rpcUrls?.default?.http?.[0],
            });
            i
              ? (this.syncProvider({ ...i, chainNamespace: e }),
                await this.syncAccount({ ...i, chainNamespace: e }),
                this.setStatus("connected", e),
                c.E.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  address: i.address,
                  properties: {
                    method: "browser",
                    name: n.info?.name || n.name || "Unknown",
                    reconnect: !0,
                    view: l.I.state.view,
                    walletRank: void 0,
                  },
                }))
              : this.setStatus("disconnected", e);
          } catch (t) {
            this.onDisconnectNamespace({ chainNamespace: e, closeModal: !1 });
          }
        }
        async syncWalletConnectAccount() {
          let e = Object.keys(
              this.universalProvider?.session?.namespaces || {}
            ),
            t = this.chainNamespaces.map(async (t) => {
              let r = this.getAdapter(t);
              if (!r) return;
              let n =
                  this.universalProvider?.session?.namespaces?.[t]?.accounts ||
                  [],
                s = g.W.state.activeCaipNetwork?.id,
                a =
                  n.find((e) => {
                    let { chainId: t } = k.C.parseCaipAddress(e);
                    return t === s?.toString();
                  }) || n[0];
              if (a) {
                let e = k.C.validateCaipAddress(a),
                  { chainId: n, address: s } = k.C.parseCaipAddress(e);
                if (
                  (v.G.setProviderId(t, E.o.CONNECTOR_TYPE_WALLET_CONNECT),
                  this.caipNetworks &&
                    g.W.state.activeCaipNetwork &&
                    r.namespace !== i.o.CHAIN.EVM)
                ) {
                  let e = r.getWalletConnectProvider({
                    caipNetworks: this.getCaipNetworks(),
                    provider: this.universalProvider,
                    activeCaipNetwork: g.W.state.activeCaipNetwork,
                  });
                  v.G.setProvider(t, e);
                } else v.G.setProvider(t, this.universalProvider);
                o.a.setConnectorId(i.o.CONNECTOR_ID.WALLET_CONNECT, t),
                  y.i.addConnectedNamespace(t),
                  await this.syncAccount({
                    address: s,
                    chainId: n,
                    chainNamespace: t,
                  });
              } else e.includes(t) && this.setStatus("disconnected", t);
              this.syncConnectedWalletInfo(t),
                await g.W.setApprovedCaipNetworksData(t);
            });
          await Promise.all(t);
        }
        syncProvider({ type: e, provider: t, id: r, chainNamespace: i }) {
          v.G.setProviderId(i, e),
            v.G.setProvider(i, t),
            o.a.setConnectorId(r, i);
        }
        async syncAccount(e) {
          let t = e.chainNamespace === g.W.state.activeChain,
            r = g.W.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
            { address: n, chainId: s, chainNamespace: a } = e,
            { chainId: o } = y.i.getActiveNetworkProps(),
            c = s || o,
            l =
              g.W.state.activeCaipNetwork?.name ===
              i.o.UNSUPPORTED_NETWORK_NAME,
            d = g.W.getNetworkProp("supportsAllNetworks", a);
          if ((this.setStatus("connected", a), (!l || d) && c)) {
            let e = this.getCaipNetworks().find(
                (e) => e.id.toString() === c.toString()
              ),
              o = this.getCaipNetworks().find((e) => e.chainNamespace === a);
            if (!d && !e && !o) {
              let t = this.getApprovedCaipNetworkIds() || [],
                r = t.find(
                  (e) => k.C.parseCaipNetworkId(e)?.chainId === c.toString()
                ),
                i = t.find(
                  (e) => k.C.parseCaipNetworkId(e)?.chainNamespace === a
                );
              (e = this.getCaipNetworks().find((e) => e.caipNetworkId === r)),
                (o = this.getCaipNetworks().find(
                  (e) =>
                    e.caipNetworkId === i ||
                    ("deprecatedCaipNetworkId" in e &&
                      e.deprecatedCaipNetworkId === i)
                ));
            }
            let l = e || o;
            l?.chainNamespace === g.W.state.activeChain
              ? f.H.state.enableNetworkSwitch &&
                !f.H.state.allowUnsupportedChain &&
                g.W.state.activeCaipNetwork?.name ===
                  i.o.UNSUPPORTED_NETWORK_NAME
                ? g.W.showUnsupportedChainUI()
                : this.setCaipNetwork(l)
              : !t && r && this.setCaipNetworkOfNamespace(r, a),
              this.syncConnectedWalletInfo(a);
            let h = this.getAddress(a);
            C.y.isLowerCaseMatch(n, h) || this.syncAccountInfo(n, l?.id, a),
              t
                ? await this.syncBalance({
                    address: n,
                    chainId: l?.id,
                    chainNamespace: a,
                  })
                : await this.syncBalance({
                    address: n,
                    chainId: r?.id,
                    chainNamespace: a,
                  }),
              this.syncIdentity({ address: n, chainId: s, chainNamespace: a });
          }
        }
        async syncAccountInfo(e, t, r) {
          let i = this.getCaipAddress(r),
            n = t || i?.split(":")[1];
          if (!n) return;
          let s = `${r}:${n}:${e}`;
          this.setCaipAddress(s, r, !0),
            await this.syncIdentity({
              address: e,
              chainId: n,
              chainNamespace: r,
            });
        }
        async syncReownName(e, t) {
          try {
            let r = await this.getReownName(e);
            if (r[0]) {
              let e = r[0];
              this.setProfileName(e.name, t);
            } else this.setProfileName(null, t);
          } catch {
            this.setProfileName(null, t);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = o.a.getConnectorId(e),
            r = v.G.getProviderId(e);
          if (
            r === E.o.CONNECTOR_TYPE_ANNOUNCED ||
            r === E.o.CONNECTOR_TYPE_INJECTED
          ) {
            if (t) {
              let r = this.getConnectors().find((e) => {
                let r = e.id === t,
                  i = e.info?.rdns === t,
                  n = e.connectors?.some(
                    (e) => e.id === t || e.info?.rdns === t
                  );
                return r || i || !!n;
              });
              if (r) {
                let { info: t, name: i, imageUrl: n } = r,
                  s = n || this.getConnectorImage(r);
                this.setConnectedWalletInfo({ name: i, icon: s, ...t }, e);
              }
            }
          } else if (r === E.o.CONNECTOR_TYPE_WALLET_CONNECT) {
            let t = v.G.getProvider(e);
            t?.session &&
              this.setConnectedWalletInfo(
                {
                  ...t.session.peer.metadata,
                  name: t.session.peer.metadata.name,
                  icon: t.session.peer.metadata.icons?.[0],
                },
                e
              );
          } else if (
            t &&
            (t === i.o.CONNECTOR_ID.COINBASE_SDK ||
              t === i.o.CONNECTOR_ID.COINBASE)
          ) {
            let r = this.getConnectors().find((e) => e.id === t),
              i = r?.name || "Coinbase Wallet",
              n = r?.imageUrl || this.getConnectorImage(r),
              s = r?.info;
            this.setConnectedWalletInfo({ ...s, name: i, icon: n }, e);
          }
        }
        async syncBalance(e) {
          N.L.getNetworksByNamespace(
            this.getCaipNetworks(),
            e.chainNamespace
          ).find((t) => t.id.toString() === e.chainId?.toString()) &&
            e.chainId &&
            (await this.updateNativeBalance(
              e.address,
              e.chainId,
              e.chainNamespace
            ));
        }
        async ready() {
          await this.readyPromise;
        }
        async updateNativeBalance(e, t, r) {
          let i = this.getAdapter(r),
            n = g.W.getCaipNetworkByNamespace(r, t);
          if (i) {
            let s = await i.getBalance({
              address: e,
              chainId: t,
              caipNetwork: n,
              tokens: this.options.tokens,
            });
            return this.setBalance(s.balance, s.symbol, r), s;
          }
        }
        async initializeUniversalAdapter() {
          let e = z.createLogger((e, ...t) => {
              e && this.handleAlertError(e), console.error(...t);
            }),
            t = {
              projectId: this.options?.projectId,
              metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : "",
                description: this.options?.metadata
                  ? this.options?.metadata.description
                  : "",
                url: this.options?.metadata ? this.options?.metadata.url : "",
                icons: this.options?.metadata
                  ? this.options?.metadata.icons
                  : [""],
              },
              logger: e,
            };
          f.H.setManualWCControl(!!this.options?.manualWCControl),
            (this.universalProvider =
              this.options.universalProvider ?? (await S.A.init(t))),
            !1 === f.H.state.enableReconnect &&
              this.universalProvider.session &&
              (await this.universalProvider.disconnect()),
            this.listenWalletConnect();
        }
        listenWalletConnect() {
          this.universalProvider &&
            this.chainNamespaces.forEach((e) => {
              et.kl.listenWcProvider({
                universalProvider: this.universalProvider,
                namespace: e,
                onDisplayUri: (e) => {
                  d.x.setUri(e);
                },
                onConnect: (e) => {
                  let { address: t } = w.w.getAccount(e[0]);
                  d.x.finalizeWcConnection(t);
                },
                onDisconnect: () => {
                  g.W.state.noAdapters && this.resetAccount(e),
                    d.x.resetWcConnection();
                },
                onChainChanged: (t) => {
                  let r = g.W.state.activeChain,
                    n =
                      r &&
                      o.a.state.activeConnectorIds[r] ===
                        i.o.CONNECTOR_ID.WALLET_CONNECT;
                  if (r === e && (g.W.state.noAdapters || n)) {
                    let e = this.getCaipNetworks().find(
                        (e) =>
                          e.id.toString() === t.toString() ||
                          e.caipNetworkId.toString() === t.toString()
                      ),
                      r = this.getCaipNetwork();
                    if (!e) return void this.setUnsupportedNetwork(t);
                    r?.id.toString() !== e?.id.toString() &&
                      r?.chainNamespace === e?.chainNamespace &&
                      this.setCaipNetwork(e);
                  }
                },
                onAccountsChanged: (t) => {
                  let r = g.W.state.activeChain,
                    n =
                      r &&
                      o.a.state.activeConnectorIds[r] ===
                        i.o.CONNECTOR_ID.WALLET_CONNECT;
                  if (r === e && (g.W.state.noAdapters || n)) {
                    let e = t?.[0];
                    e &&
                      this.syncAccount({
                        address: e.address,
                        chainId: e.chainId,
                        chainNamespace: e.chainNamespace,
                      });
                  }
                },
              });
            });
        }
        createUniversalProvider() {
          return (
            !this.universalProviderInitPromise &&
              w.w.isClient() &&
              this.options?.projectId &&
              (this.universalProviderInitPromise =
                this.initializeUniversalAdapter()),
            this.universalProviderInitPromise
          );
        }
        async getUniversalProvider() {
          if (!this.universalProvider)
            try {
              await this.createUniversalProvider();
            } catch (e) {
              c.E.sendEvent({
                type: "error",
                event: "INTERNAL_SDK_ERROR",
                properties: {
                  errorType: "UniversalProviderInitError",
                  errorMessage: e instanceof Error ? e.message : "Unknown",
                  uncaught: !1,
                },
              }),
                console.error(
                  "AppKit:getUniversalProvider - Cannot create provider",
                  e
                );
            }
          return this.universalProvider;
        }
        handleAlertError(e) {
          let [t, r] =
              Object.entries(x.R.UniversalProviderErrors).find(
                ([, { message: t }]) => e.message.includes(t)
              ) ?? [],
            { message: i, alertErrorKey: n } = r ?? {};
          if (t && i && !this.reportedAlertErrors[t]) {
            let e = x.R.ALERT_ERRORS[n];
            e && (b.h.open(e, "error"), (this.reportedAlertErrors[t] = !0));
          }
        }
        getAdapter(e) {
          if (e) return this.chainAdapters?.[e];
        }
        createAdapter(e) {
          if (!e) return;
          let t = e.namespace;
          t &&
            (this.createClients(),
            (e.namespace = t),
            e.construct({
              namespace: t,
              projectId: this.options?.projectId,
              networks: this.caipNetworks?.filter(
                ({ chainNamespace: e }) => e === t
              ),
            }),
            this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
            this.chainAdapters && (this.chainAdapters[t] = e));
        }
        async open(e) {
          await this.injectModalUi(), e?.uri && d.x.setUri(e.uri);
          let { isSwap: t, isSend: r } = this.toModalOptions();
          return t(e)
            ? D.W.open({ ...e, data: { swap: e.arguments } })
            : r(e) && e.arguments
            ? this.openSend(e.arguments)
            : D.W.open(e);
        }
        async close() {
          await this.injectModalUi(), D.W.close();
        }
        setLoading(e, t) {
          D.W.setLoading(e, t);
        }
        async disconnect(e) {
          await d.x.disconnect({ namespace: e });
        }
        getSIWX() {
          return f.H.state.siwx;
        }
        getError() {
          return "";
        }
        getChainId() {
          return g.W.state.activeCaipNetwork?.id;
        }
        async switchNetwork(e, { throwOnFailure: t = !1 } = {}) {
          let r = this.getCaipNetworks().find((t) => t.id === e.id);
          if (!r)
            return void b.h.open(
              x.R.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND,
              "error"
            );
          await g.W.switchActiveNetwork(r, { throwOnFailure: t });
        }
        getWalletProvider() {
          return g.W.state.activeChain
            ? v.G.state.providers[g.W.state.activeChain]
            : null;
        }
        getWalletProviderType() {
          return v.G.getProviderId(g.W.state.activeChain);
        }
        subscribeProviders(e) {
          return v.G.subscribeProviders(e);
        }
        getThemeMode() {
          return m.W.state.themeMode;
        }
        getThemeVariables() {
          return m.W.state.themeVariables;
        }
        setThemeMode(e) {
          m.W.setThemeMode(e), (0, B.JX)(m.W.state.themeMode);
        }
        setTermsConditionsUrl(e) {
          f.H.setTermsConditionsUrl(e);
        }
        setPrivacyPolicyUrl(e) {
          f.H.setPrivacyPolicyUrl(e);
        }
        setThemeVariables(e) {
          m.W.setThemeVariables(e), (0, B.ds)(m.W.state.themeVariables);
        }
        subscribeTheme(e) {
          return m.W.subscribe(e);
        }
        subscribeConnections(e) {
          return this.remoteFeatures.multiWallet
            ? d.x.subscribe(e)
            : (b.h.open(
                i.o.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,
                "info"
              ),
              () => void 0);
        }
        getWalletInfo(e) {
          if (e)
            return g.W.state.chains.get(e)?.accountState?.connectedWalletInfo;
          let t = g.W.getAccountData();
          return t?.connectedWalletInfo;
        }
        getAccount(e) {
          let t = e || g.W.state.activeChain,
            r = o.a.getAuthConnector(t),
            n = g.W.getAccountData(t),
            s = y.i.getConnectedConnectorId(g.W.state.activeChain),
            c = d.x.getConnections(t);
          if (!t) throw Error("AppKit:getAccount - namespace is required");
          let l = c.flatMap((e) =>
            e.accounts.map(({ address: e, type: r, publicKey: i }) =>
              w.w.createAccount(t, e, r || "eoa", i)
            )
          );
          if (n)
            return {
              allAccounts: l,
              caipAddress: n.caipAddress,
              address: w.w.getPlainAddress(n.caipAddress),
              isConnected: !!n.caipAddress,
              status: n.status,
              embeddedWalletInfo:
                r && s === i.o.CONNECTOR_ID.AUTH
                  ? {
                      user: n.user
                        ? {
                            ...n.user,
                            username: y.i.getConnectedSocialUsername(),
                          }
                        : void 0,
                      authProvider: n.socialProvider || "email",
                      accountType: (0, a.lj)(t),
                      isSmartAccountDeployed: !!n.smartAccountDeployed,
                    }
                  : void 0,
            };
        }
        subscribeAccount(e, t) {
          let r = () => {
            let r = this.getAccount(t);
            r && e(r);
          };
          t ? g.W.subscribeChainProp("accountState", r, t) : g.W.subscribe(r),
            o.a.subscribe(r);
        }
        subscribeNetwork(e) {
          return g.W.subscribe(({ activeCaipNetwork: t }) => {
            e({
              caipNetwork: t,
              chainId: t?.id,
              caipNetworkId: t?.caipNetworkId,
            });
          });
        }
        subscribeWalletInfo(e, t) {
          return t
            ? g.W.subscribeChainProp(
                "accountState",
                (t) => e(t?.connectedWalletInfo),
                t
              )
            : g.W.subscribeChainProp("accountState", (t) =>
                e(t?.connectedWalletInfo)
              );
        }
        subscribeShouldUpdateToAddress(e) {
          g.W.subscribeChainProp("accountState", (t) =>
            e(t?.shouldUpdateToAddress)
          );
        }
        subscribeCaipNetworkChange(e) {
          g.W.subscribeKey("activeCaipNetwork", e);
        }
        getState() {
          return h.z.state;
        }
        getRemoteFeatures() {
          return f.H.state.remoteFeatures;
        }
        subscribeState(e) {
          return h.z.subscribe(e);
        }
        subscribeRemoteFeatures(e) {
          return f.H.subscribeKey("remoteFeatures", e);
        }
        showErrorMessage(e) {
          M.P.showError(e);
        }
        showSuccessMessage(e) {
          M.P.showSuccess(e);
        }
        getEvent() {
          return { ...c.E.state };
        }
        subscribeEvents(e) {
          return c.E.subscribe(e);
        }
        replace(e) {
          l.I.replace(e);
        }
        redirect(e) {
          l.I.push(e);
        }
        popTransactionStack(e) {
          l.I.popTransactionStack(e);
        }
        isOpen() {
          return D.W.state.open;
        }
        isTransactionStackEmpty() {
          return 0 === l.I.state.transactionStack.length;
        }
        static getInstance() {
          return this.instance;
        }
        updateFeatures(e) {
          f.H.setFeatures(e);
        }
        updateRemoteFeatures(e) {
          f.H.setRemoteFeatures(e);
        }
        updateOptions(e) {
          let t = { ...(f.H.state || {}), ...e };
          f.H.setOptions(t);
        }
        setConnectMethodsOrder(e) {
          f.H.setConnectMethodsOrder(e);
        }
        setWalletFeaturesOrder(e) {
          f.H.setWalletFeaturesOrder(e);
        }
        setCollapseWallets(e) {
          f.H.setCollapseWallets(e);
        }
        setSocialsOrder(e) {
          f.H.setSocialsOrder(e);
        }
        getConnectMethodsOrder() {
          return L.Aj.getConnectOrderMethod(
            f.H.state.features,
            o.a.getConnectors()
          );
        }
        addNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          let r = this.extendCaipNetwork(t, this.options);
          this.getCaipNetworks().find((e) => e.id === r.id) ||
            g.W.addNetwork(r);
        }
        removeNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          this.getCaipNetworks().find((e) => e.id === t) &&
            g.W.removeNetwork(e, t);
        }
      }
      let ei = !1;
      class en extends er {
        async onAuthProviderConnected(e) {
          let t = C.y.userChainIdToChainNamespace(e?.chainId);
          if (
            (e.message &&
              e.signature &&
              e.siwxMessage &&
              (await s.U.addEmbeddedWalletSession(
                {
                  chainId: e.siwxMessage.chainId,
                  accountAddress: e.address,
                  notBefore: e.siwxMessage.notBefore,
                  statement: e.siwxMessage.statement,
                  resources: e.siwxMessage.resources,
                  requestId: e.siwxMessage.requestId,
                  issuedAt: e.siwxMessage.issuedAt,
                  domain: e.siwxMessage.domain,
                  uri: e.siwxMessage.uri,
                  version: e.siwxMessage.version,
                  nonce: e.siwxMessage.nonce,
                },
                e.message,
                e.signature
              )),
            !t)
          )
            throw Error(
              "AppKit:onAuthProviderConnected - namespace is required"
            );
          let r =
              t === i.o.CHAIN.EVM
                ? `eip155:${e.chainId}:${e.address}`
                : `${e.chainId}:${e.address}`,
            n = f.H.state.defaultAccountTypes[t],
            o = (0, a.lj)(t),
            c = e.preferredAccountType || o || n;
          this.setCaipAddress(r, t);
          let { signature: l, siwxMessage: d, message: h, ...u } = e,
            p = g.W.getAccountData(t);
          this.setUser({ ...(p?.user || {}), ...u }, t),
            this.setSmartAccountDeployed(!!e.smartAccountDeployed, t),
            this.setPreferredAccountType(c, t),
            this.setLoading(!1, t);
        }
        setupAuthConnectorListeners(e) {
          e.onRpcRequest((t) => {
            A.Q.checkIfRequestExists(t)
              ? A.Q.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
              : (this.open(),
                console.error(_.Vl.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
                  method: t.method,
                }),
                setTimeout(() => {
                  this.showErrorMessage(_.Vl.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                }, 300),
                e.rejectRpcRequests());
          }),
            e.onRpcError(() => {
              this.isOpen() &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack("error"));
            }),
            e.onRpcSuccess((e, t) => {
              let r = A.Q.checkIfRequestIsSafe(t),
                i = this.getAddress(),
                n = g.W.state.activeCaipNetwork;
              r ||
                (i &&
                  n?.id &&
                  this.updateNativeBalance(i, n.id, n.chainNamespace),
                this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack("success"));
            }),
            e.onNotConnected(() => {
              let e = g.W.state.activeChain;
              if (!e)
                throw Error("AppKit:onNotConnected - namespace is required");
              o.a.getConnectorId(e) === i.o.CONNECTOR_ID.AUTH &&
                (this.setCaipAddress(null, e), this.setLoading(!1, e));
            }),
            e.onConnect(this.onAuthProviderConnected.bind(this)),
            e.onSocialConnected(this.onAuthProviderConnected.bind(this)),
            e.onSetPreferredAccount(({ address: e, type: t }) => {
              let r = g.W.state.activeChain;
              if (!r)
                throw Error(
                  "AppKit:onSetPreferredAccount - namespace is required"
                );
              e && this.setPreferredAccountType(t, r);
            });
        }
        async syncAuthConnectorTheme(e) {
          if (!e) return;
          let t = m.W.getSnapshot(),
            r = f.H.getSnapshot();
          await Promise.all([
            e.syncDappData({
              metadata: r.metadata,
              sdkVersion: r.sdkVersion,
              projectId: r.projectId,
              sdkType: r.sdkType,
            }),
            e.syncTheme({
              themeMode: t.themeMode,
              themeVariables: t.themeVariables,
              w3mThemeVariables: (0, n.o)(t.themeVariables, t.themeMode),
            }),
          ]);
        }
        async syncAuthConnector(e, t) {
          let r = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t),
            n = t === g.W.state.activeChain;
          if (!r) return;
          this.setLoading(!0, t);
          let s = e.getLoginEmailUsed();
          this.setLoading(s, t), s && this.setStatus("connecting", t);
          let a = e.getEmail(),
            d = e.getUsername(),
            h = g.W.getAccountData(t)?.user || {};
          this.setUser({ ...h, username: d, email: a }, t),
            this.setupAuthConnectorListeners(e);
          let { isConnected: u } = await e.isConnected();
          if ((await this.syncAuthConnectorTheme(e), t && r && n)) {
            let r = await e.getSmartAccountEnabledNetworks();
            if (
              (g.W.setSmartAccountEnabledNetworks(
                r?.smartAccountEnabledNetworks || [],
                t
              ),
              u && this.connectionControllerClient?.connectExternal)
            ) {
              await this.connectionControllerClient?.connectExternal({
                id: i.o.CONNECTOR_ID.AUTH,
                info: { name: i.o.CONNECTOR_ID.AUTH },
                type: E.o.CONNECTOR_TYPE_AUTH,
                provider: e,
                chainId: g.W.getNetworkData(t)?.caipNetwork?.id,
                chain: t,
              }),
                this.setStatus("connected", t);
              let r = y.i.getConnectedSocialProvider();
              r
                ? c.E.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_SUCCESS",
                    address: this.getAddress(),
                    properties: { provider: r, reconnect: !0 },
                  })
                : c.E.sendEvent({
                    type: "track",
                    event: "CONNECT_SUCCESS",
                    address: this.getAddress(),
                    properties: {
                      method: "email",
                      name:
                        this.universalProvider?.session?.peer?.metadata?.name ||
                        "Unknown",
                      reconnect: !0,
                      view: l.I.state.view,
                      walletRank: void 0,
                    },
                  });
            } else
              o.a.getConnectorId(t) === i.o.CONNECTOR_ID.AUTH &&
                (this.setStatus("disconnected", t),
                y.i.removeConnectedNamespace(t));
          }
          this.setLoading(!1, t);
        }
        async checkExistingTelegramSocialConnection(e) {
          try {
            if (!w.w.isTelegram()) return;
            let t = y.i.getTelegramSocialProvider();
            if (!t || !w.w.isClient()) return;
            let r = new URL(window.location.href).searchParams.get(
              "result_uri"
            );
            if (!r) return;
            t && g.W.setAccountProp("socialProvider", t, e),
              await this.authProvider?.init();
            let i = o.a.getAuthConnector();
            t &&
              i &&
              (this.setLoading(!0, e),
              await d.x.connectExternal(
                { id: i.id, type: i.type, socialUri: r },
                i.chain
              ),
              y.i.setConnectedSocialProvider(t),
              y.i.removeTelegramSocialProvider(),
              c.E.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_SUCCESS",
                properties: { provider: t },
              }));
          } catch (t) {
            this.setLoading(!1, e),
              console.error("checkExistingSTelegramocialConnection error", t);
          }
          try {
            let e = new URL(window.location.href);
            e.searchParams.delete("result_uri"),
              window.history.replaceState({}, document.title, e.toString());
          } catch (e) {
            console.error("tma social login failed", e);
          }
        }
        createAuthProvider(e) {
          if (!i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
          let t = this.remoteFeatures?.email,
            r =
              Array.isArray(this.remoteFeatures?.socials) &&
              this.remoteFeatures.socials.length > 0,
            n = C.y.getActiveNamespaceConnectedToAuth() || e;
          !this.authProvider &&
            this.options?.projectId &&
            (t || r) &&
            ((this.authProvider = I.v.getInstance({
              projectId: this.options.projectId,
              enableLogger: this.options.enableAuthLogger,
              chainId: this.getCaipNetwork(n)?.caipNetworkId,
              abortController: x.R.EmbeddedWalletAbortController,
              onTimeout: (e) => {
                "iframe_load_failed" === e
                  ? b.h.open(x.R.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
                  : "iframe_request_timeout" === e
                  ? b.h.open(x.R.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
                  : "unverified_domain" === e &&
                    b.h.open(x.R.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
              },
              getActiveCaipNetwork: (e) => (0, a.kg)(e),
              getCaipNetworks: (e) => g.W.getCaipNetworks(e),
            })),
            h.z.subscribeOpen((e) => {
              !e &&
                this.isTransactionStackEmpty() &&
                this.authProvider?.rejectRpcRequests();
            }));
          let s = e === g.W.state.activeChain && f.H.state.enableReconnect;
          !1 === f.H.state.enableReconnect
            ? this.syncAuthConnectorTheme(this.authProvider)
            : this.authProvider &&
              s &&
              (this.syncAuthConnector(this.authProvider, e),
              this.checkExistingTelegramSocialConnection(e));
        }
        createAuthProviderForAdapter(e) {
          this.createAuthProvider(e),
            this.authProvider &&
              this.chainAdapters?.[e]?.setAuthProvider?.(this.authProvider);
        }
        initControllers(e) {
          super.initControllers(e),
            this.options.excludeWalletIds &&
              u.N.initializeExcludedWallets({
                ids: this.options.excludeWalletIds,
              });
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = g.W.state.activeChain,
            r = e.chainNamespace,
            n = this.getAddressByChainNamespace(r);
          if (r === t && g.W.getAccountData(r)?.caipAddress) {
            let t = this.getAdapter(r),
              i = v.G.getProvider(r),
              n = v.G.getProviderId(r);
            await t?.switchNetwork({
              caipNetwork: e,
              provider: i,
              providerType: n,
            }),
              this.setCaipNetwork(e);
          } else {
            let s = v.G.getProviderId(t) === E.o.CONNECTOR_TYPE_AUTH,
              a = v.G.getProviderId(r),
              o = a === E.o.CONNECTOR_TYPE_AUTH,
              c = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r);
            if (!r)
              throw Error(
                "AppKit:switchCaipNetwork - networkNamespace is required"
              );
            if (((s && void 0 === a) || o) && c)
              try {
                if (((g.W.state.activeChain = e.chainNamespace), n)) {
                  let t = this.getAdapter(r);
                  await t?.switchNetwork({
                    caipNetwork: e,
                    provider: this.authProvider,
                    providerType: a,
                  });
                } else
                  await this.connectionControllerClient?.connectExternal?.({
                    id: i.o.CONNECTOR_ID.AUTH,
                    provider: this.authProvider,
                    chain: r,
                    chainId: e.id,
                    type: E.o.CONNECTOR_TYPE_AUTH,
                    caipNetwork: e,
                  });
                this.setCaipNetwork(e);
              } catch (i) {
                let t = this.getAdapter(r);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: a,
                });
              }
            else if (a === E.o.CONNECTOR_TYPE_WALLET_CONNECT) {
              if (!g.W.state.noAdapters) {
                let t = this.getAdapter(r),
                  i = v.G.getProvider(r),
                  n = v.G.getProviderId(r);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: i,
                  providerType: n,
                });
              }
              this.setCaipNetwork(e), this.syncWalletConnectAccount();
            } else
              this.setCaipNetwork(e),
                n &&
                  this.syncAccount({
                    address: n,
                    chainId: e.id,
                    chainNamespace: r,
                  });
          }
        }
        async initialize(e) {
          await super.initialize(e),
            this.chainNamespaces?.forEach((e) => {
              this.createAuthProviderForAdapter(e);
            }),
            await this.injectModalUi(),
            h.z.set({ initialized: !0 });
        }
        async syncIdentity({ address: e, chainId: t, chainNamespace: r }) {
          let n = `${r}:${t}`,
            s = this.caipNetworks?.find((e) => e.caipNetworkId === n);
          if (s?.testnet) {
            this.setProfileName(null, r), this.setProfileImage(null, r);
            return;
          }
          let a = o.a.getConnectorId(r) === i.o.CONNECTOR_ID.AUTH;
          try {
            let { name: t, avatar: i } = await this.fetchIdentity({
              address: e,
            });
            !t && a
              ? await this.syncReownName(e, r)
              : (this.setProfileName(t, r), this.setProfileImage(i, r));
          } catch {
            1 !== t && this.setProfileImage(null, r);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = v.G.getProviderId(e);
          if (t === E.o.CONNECTOR_TYPE_AUTH) {
            let r = this.authProvider;
            if (r) {
              let i = y.i.getConnectedSocialProvider() ?? "email",
                n = r.getEmail() ?? r.getUsername();
              this.setConnectedWalletInfo(
                { name: t, identifier: n, social: i },
                e
              );
            }
          } else super.syncConnectedWalletInfo(e);
        }
        async injectModalUi() {
          if (w.w.isClient() && !ei)
            try {
              let e = { ...p.oU.DEFAULT_FEATURES, ...this.options.features },
                t = this.remoteFeatures;
              if (
                (await this.loadModalComponents(e, t),
                w.w.isClient() && !document.querySelector("w3m-modal"))
              ) {
                let e = document.createElement("w3m-modal");
                f.H.state.disableAppend ||
                  f.H.state.enableEmbedded ||
                  document.body.insertAdjacentElement("beforeend", e);
              }
              ei = !0;
            } catch (e) {
              console.error("Error injecting modal UI:", e);
            }
        }
        async loadModalComponents(e, t) {
          if (!w.w.isClient()) return;
          let i = [];
          (t.email || (t.socials && t.socials.length > 0)) &&
            i.push(r.e(8558).then(r.bind(r, 68558))),
            t.email && i.push(r.e(5744).then(r.bind(r, 45744))),
            t.socials && i.push(r.e(2170).then(r.bind(r, 92170))),
            t.swaps &&
              t.swaps.length > 0 &&
              i.push(
                Promise.all([r.e(4836), r.e(1745)]).then(r.bind(r, 51745))
              ),
            e.send &&
              i.push(
                Promise.all([r.e(4836), r.e(8309)]).then(r.bind(r, 28309))
              ),
            e.receive && i.push(r.e(9872).then(r.bind(r, 19872))),
            t.onramp &&
              t.onramp.length > 0 &&
              i.push(r.e(7838).then(r.bind(r, 17838))),
            t.payWithExchange && i.push(r.e(4329).then(r.bind(r, 74329))),
            t.activity && i.push(r.e(840).then(r.bind(r, 20840))),
            (e.pay || t.payments) && i.push(r.e(5920).then(r.bind(r, 15920))),
            t.emailCapture && i.push(r.e(6226).then(r.bind(r, 16226))),
            await Promise.all([
              ...i,
              Promise.resolve().then(r.bind(r, 83621)),
              Promise.all([r.e(4836), r.e(1557)]).then(r.bind(r, 51557)),
            ]);
        }
      }
    },
    59335: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => gF });
      var i,
        n = {};
      r.r(n), r.d(n, { identity: () => no });
      var s = {};
      r.r(s), r.d(s, { base2: () => nc });
      var a = {};
      r.r(a), r.d(a, { base8: () => nl });
      var o = {};
      r.r(o), r.d(o, { base10: () => nd });
      var c = {};
      r.r(c), r.d(c, { base16: () => nh, base16upper: () => nu });
      var l = {};
      r.r(l),
        r.d(l, {
          base32: () => np,
          base32hex: () => ny,
          base32hexpad: () => nb,
          base32hexpadupper: () => nv,
          base32hexupper: () => nw,
          base32pad: () => ng,
          base32padupper: () => nm,
          base32upper: () => nf,
          base32z: () => nC,
        });
      var d = {};
      r.r(d), r.d(d, { base36: () => nE, base36upper: () => nx });
      var h = {};
      r.r(h), r.d(h, { base58btc: () => nA, base58flickr: () => n_ });
      var u = {};
      r.r(u),
        r.d(u, {
          base64: () => nI,
          base64pad: () => nS,
          base64url: () => nk,
          base64urlpad: () => nN,
        });
      var p = {};
      r.r(p), r.d(p, { base256emoji: () => nR });
      var f = {};
      r.r(f), r.d(f, { sha256: () => nz, sha512: () => nV });
      var g = {};
      r.r(g), r.d(g, { identity: () => nZ });
      var m = {};
      r.r(m),
        r.d(m, {
          code: () => nG,
          decode: () => nY,
          encode: () => nJ,
          name: () => nK,
        });
      var y = {};
      r.r(y),
        r.d(y, {
          code: () => n1,
          decode: () => n3,
          encode: () => n2,
          name: () => n0,
        });
      var w = r(16459),
        b = r.n(w),
        v = r(5566);
      class C {}
      class E extends C {
        constructor(e) {
          super();
        }
      }
      let x = v.FIVE_SECONDS,
        A = { pulse: "heartbeat_pulse" };
      class _ extends E {
        constructor(e) {
          super(e),
            (this.events = new w.EventEmitter()),
            (this.interval = x),
            (this.interval = e?.interval || x);
        }
        static async init(e) {
          let t = new _(e);
          return await t.init(), t;
        }
        async init() {
          await this.initialize();
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async initialize() {
          this.intervalRef = setInterval(
            () => this.pulse(),
            (0, v.toMiliseconds)(this.interval)
          );
        }
        pulse() {
          this.events.emit(A.pulse);
        }
      }
      let I =
          /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
        S =
          /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
        k = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function N(e, t) {
        var r;
        return "__proto__" === e ||
          ("constructor" === e && t && "object" == typeof t && "prototype" in t)
          ? void ((r = e),
            console.warn(
              `[destr] Dropping "${r}" key to prevent prototype pollution.`
            ))
          : t;
      }
      function T(e, t = {}) {
        if ("string" != typeof e) return e;
        if ('"' === e[0] && '"' === e[e.length - 1] && -1 === e.indexOf("\\"))
          return e.slice(1, -1);
        let r = e.trim();
        if (r.length <= 9)
          switch (r.toLowerCase()) {
            case "true":
              return !0;
            case "false":
              return !1;
            case "undefined":
              return;
            case "null":
              return null;
            case "nan":
              return NaN;
            case "infinity":
              return 1 / 0;
            case "-infinity":
              return -1 / 0;
          }
        if (!k.test(e)) {
          if (t.strict) throw SyntaxError("[destr] Invalid JSON");
          return e;
        }
        try {
          if (I.test(e) || S.test(e)) {
            if (t.strict) throw Error("[destr] Possible prototype pollution");
            return JSON.parse(e, N);
          }
          return JSON.parse(e);
        } catch (r) {
          if (t.strict) throw r;
          return e;
        }
      }
      var O = r(81029).Buffer;
      function P(e, ...t) {
        try {
          var r;
          return (r = e(...t)) && "function" == typeof r.then
            ? r
            : Promise.resolve(r);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      function R(e) {
        if (
          (function (e) {
            let t = typeof e;
            return null === e || ("object" !== t && "function" !== t);
          })(e)
        )
          return String(e);
        if (
          (function (e) {
            let t = Object.getPrototypeOf(e);
            return !t || t.isPrototypeOf(Object);
          })(e) ||
          Array.isArray(e)
        )
          return JSON.stringify(e);
        if ("function" == typeof e.toJSON) return R(e.toJSON());
        throw Error("[unstorage] Cannot stringify value!");
      }
      let $ = "base64:";
      function D(e) {
        return (
          (e &&
            e
              .split("?")[0]
              ?.replace(/[/\\]/g, ":")
              .replace(/:+/g, ":")
              .replace(/^:|:$/g, "")) ||
          ""
        );
      }
      function U(e) {
        return (e = D(e)) ? e + ":" : "";
      }
      function M(e, t, r) {
        return e.watch ? e.watch((e, i) => t(e, r + i)) : () => {};
      }
      async function L(e) {
        "function" == typeof e.dispose && (await P(e.dispose));
      }
      var B = r(88254),
        W = r(25042);
      class j {
        constructor() {
          this.indexedDb = (function (e = {}) {
            let t = {
                mounts: {
                  "":
                    e.driver ||
                    (() => {
                      let e = new Map();
                      return {
                        name: "memory",
                        getInstance: () => e,
                        hasItem: (t) => e.has(t),
                        getItem: (t) => e.get(t) ?? null,
                        getItemRaw: (t) => e.get(t) ?? null,
                        setItem(t, r) {
                          e.set(t, r);
                        },
                        setItemRaw(t, r) {
                          e.set(t, r);
                        },
                        removeItem(t) {
                          e.delete(t);
                        },
                        getKeys: () => [...e.keys()],
                        clear() {
                          e.clear();
                        },
                        dispose() {
                          e.clear();
                        },
                      };
                    })(),
                },
                mountpoints: [""],
                watching: !1,
                watchListeners: [],
                unwatch: {},
              },
              r = (e) => {
                for (let r of t.mountpoints)
                  if (e.startsWith(r))
                    return {
                      base: r,
                      relativeKey: e.slice(r.length),
                      driver: t.mounts[r],
                    };
                return { base: "", relativeKey: e, driver: t.mounts[""] };
              },
              i = (e, r) =>
                t.mountpoints
                  .filter((t) => t.startsWith(e) || (r && e.startsWith(t)))
                  .map((r) => ({
                    relativeBase:
                      e.length > r.length ? e.slice(r.length) : void 0,
                    mountpoint: r,
                    driver: t.mounts[r],
                  })),
              n = (e, r) => {
                if (t.watching)
                  for (let i of ((r = D(r)), t.watchListeners)) i(e, r);
              },
              s = async () => {
                if (!t.watching)
                  for (let e in ((t.watching = !0), t.mounts))
                    t.unwatch[e] = await M(t.mounts[e], n, e);
              },
              a = async () => {
                if (t.watching) {
                  for (let e in t.unwatch) await t.unwatch[e]();
                  (t.unwatch = {}), (t.watching = !1);
                }
              },
              o = (e, t, i) => {
                let n = new Map(),
                  s = (e) => {
                    let t = n.get(e.base);
                    return (
                      t ||
                        ((t = { driver: e.driver, base: e.base, items: [] }),
                        n.set(e.base, t)),
                      t
                    );
                  };
                for (let i of e) {
                  let e = "string" == typeof i,
                    n = D(e ? i : i.key),
                    a = e ? void 0 : i.value,
                    o = e || !i.options ? t : { ...t, ...i.options },
                    c = r(n);
                  s(c).items.push({
                    key: n,
                    value: a,
                    relativeKey: c.relativeKey,
                    options: o,
                  });
                }
                return Promise.all([...n.values()].map((e) => i(e))).then((e) =>
                  e.flat()
                );
              },
              c = {
                hasItem(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = D(e)));
                  return P(n.hasItem, i, t);
                },
                getItem(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = D(e)));
                  return P(n.getItem, i, t).then((e) => T(e));
                },
                getItems: (e, t = {}) =>
                  o(e, t, (e) =>
                    e.driver.getItems
                      ? P(
                          e.driver.getItems,
                          e.items.map((e) => ({
                            key: e.relativeKey,
                            options: e.options,
                          })),
                          t
                        ).then((t) =>
                          t.map((t) => ({
                            key: (function (...e) {
                              return D(e.join(":"));
                            })(e.base, t.key),
                            value: T(t.value),
                          }))
                        )
                      : Promise.all(
                          e.items.map((t) =>
                            P(e.driver.getItem, t.relativeKey, t.options).then(
                              (e) => ({ key: t.key, value: T(e) })
                            )
                          )
                        )
                  ),
                getItemRaw(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = D(e)));
                  return n.getItemRaw
                    ? P(n.getItemRaw, i, t)
                    : P(n.getItem, i, t).then((e) => {
                        var t;
                        return "string" == typeof e && e.startsWith($)
                          ? ((t = e.slice($.length)),
                            globalThis.Buffer
                              ? O.from(t, "base64")
                              : Uint8Array.from(globalThis.atob(t), (e) =>
                                  e.codePointAt(0)
                                ))
                          : e;
                      });
                },
                async setItem(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e);
                  let { relativeKey: s, driver: a } = r((e = D(e)));
                  a.setItem &&
                    (await P(a.setItem, s, R(t), i), a.watch || n("update", e));
                },
                async setItems(e, t) {
                  await o(e, t, async (e) => {
                    if (e.driver.setItems)
                      return P(
                        e.driver.setItems,
                        e.items.map((e) => ({
                          key: e.relativeKey,
                          value: R(e.value),
                          options: e.options,
                        })),
                        t
                      );
                    e.driver.setItem &&
                      (await Promise.all(
                        e.items.map((t) =>
                          P(
                            e.driver.setItem,
                            t.relativeKey,
                            R(t.value),
                            t.options
                          )
                        )
                      ));
                  });
                },
                async setItemRaw(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e, i);
                  let { relativeKey: s, driver: a } = r((e = D(e)));
                  if (a.setItemRaw) await P(a.setItemRaw, s, t, i);
                  else {
                    var o;
                    if (!a.setItem) return;
                    await P(
                      a.setItem,
                      s,
                      "string" == typeof t
                        ? t
                        : $ +
                            ((o = t),
                            globalThis.Buffer
                              ? O.from(o).toString("base64")
                              : globalThis.btoa(String.fromCodePoint(...o))),
                      i
                    );
                  }
                  a.watch || n("update", e);
                },
                async removeItem(e, t = {}) {
                  "boolean" == typeof t && (t = { removeMeta: t });
                  let { relativeKey: i, driver: s } = r((e = D(e)));
                  s.removeItem &&
                    (await P(s.removeItem, i, t),
                    (t.removeMeta || t.removeMata) &&
                      (await P(s.removeItem, i + "$", t)),
                    s.watch || n("remove", e));
                },
                async getMeta(e, t = {}) {
                  "boolean" == typeof t && (t = { nativeOnly: t });
                  let { relativeKey: i, driver: n } = r((e = D(e))),
                    s = Object.create(null);
                  if (
                    (n.getMeta && Object.assign(s, await P(n.getMeta, i, t)),
                    !t.nativeOnly)
                  ) {
                    let e = await P(n.getItem, i + "$", t).then((e) => T(e));
                    e &&
                      "object" == typeof e &&
                      ("string" == typeof e.atime &&
                        (e.atime = new Date(e.atime)),
                      "string" == typeof e.mtime &&
                        (e.mtime = new Date(e.mtime)),
                      Object.assign(s, e));
                  }
                  return s;
                },
                setMeta(e, t, r = {}) {
                  return this.setItem(e + "$", t, r);
                },
                removeMeta(e, t = {}) {
                  return this.removeItem(e + "$", t);
                },
                async getKeys(e, t = {}) {
                  let r = i((e = U(e)), !0),
                    n = [],
                    s = [],
                    a = !0;
                  for (let e of r) {
                    for (let r of (e.driver.flags?.maxDepth || (a = !1),
                    await P(e.driver.getKeys, e.relativeBase, t))) {
                      let t = e.mountpoint + D(r);
                      n.some((e) => t.startsWith(e)) || s.push(t);
                    }
                    n = [
                      e.mountpoint,
                      ...n.filter((t) => !t.startsWith(e.mountpoint)),
                    ];
                  }
                  let o = void 0 !== t.maxDepth && !a;
                  return s.filter((r) => {
                    var i;
                    return (
                      (!o ||
                        (function (e, t) {
                          if (void 0 === t) return !0;
                          let r = 0,
                            i = e.indexOf(":");
                          for (; i > -1; ) r++, (i = e.indexOf(":", i + 1));
                          return r <= t;
                        })(r, t.maxDepth)) &&
                      ((i = e)
                        ? r.startsWith(i) && "$" !== r[r.length - 1]
                        : "$" !== r[r.length - 1])
                    );
                  });
                },
                async clear(e, t = {}) {
                  (e = U(e)),
                    await Promise.all(
                      i(e, !1).map(async (e) =>
                        e.driver.clear
                          ? P(e.driver.clear, e.relativeBase, t)
                          : e.driver.removeItem
                          ? Promise.all(
                              (
                                await e.driver.getKeys(e.relativeBase || "", t)
                              ).map((r) => e.driver.removeItem(r, t))
                            )
                          : void 0
                      )
                    );
                },
                async dispose() {
                  await Promise.all(Object.values(t.mounts).map((e) => L(e)));
                },
                watch: async (e) => (
                  await s(),
                  t.watchListeners.push(e),
                  async () => {
                    (t.watchListeners = t.watchListeners.filter(
                      (t) => t !== e
                    )),
                      0 === t.watchListeners.length && (await a());
                  }
                ),
                async unwatch() {
                  (t.watchListeners = []), await a();
                },
                mount(e, r) {
                  if ((e = U(e)) && t.mounts[e])
                    throw Error(`already mounted at ${e}`);
                  return (
                    e &&
                      (t.mountpoints.push(e),
                      t.mountpoints.sort((e, t) => t.length - e.length)),
                    (t.mounts[e] = r),
                    t.watching &&
                      Promise.resolve(M(r, n, e))
                        .then((r) => {
                          t.unwatch[e] = r;
                        })
                        .catch(console.error),
                    c
                  );
                },
                async unmount(e, r = !0) {
                  (e = U(e)) &&
                    t.mounts[e] &&
                    (t.watching &&
                      e in t.unwatch &&
                      (t.unwatch[e]?.(), delete t.unwatch[e]),
                    r && (await L(t.mounts[e])),
                    (t.mountpoints = t.mountpoints.filter((t) => t !== e)),
                    delete t.mounts[e]);
                },
                getMount(e = "") {
                  let t = r((e = D(e) + ":"));
                  return { driver: t.driver, base: t.base };
                },
                getMounts: (e = "", t = {}) =>
                  i((e = D(e)), t.parents).map((e) => ({
                    driver: e.driver,
                    base: e.mountpoint,
                  })),
                keys: (e, t = {}) => c.getKeys(e, t),
                get: (e, t = {}) => c.getItem(e, t),
                set: (e, t, r = {}) => c.setItem(e, t, r),
                has: (e, t = {}) => c.hasItem(e, t),
                del: (e, t = {}) => c.removeItem(e, t),
                remove: (e, t = {}) => c.removeItem(e, t),
              };
            return c;
          })({
            driver: ((e = {}) => {
              let t,
                r = e.base && e.base.length > 0 ? `${e.base}:` : "";
              return (
                e.dbName &&
                  e.storeName &&
                  (t = (0, B.y$)(e.dbName, e.storeName)),
                {
                  name: "idb-keyval",
                  options: e,
                  hasItem: async (e) =>
                    !(typeof (await (0, B.Jt)(r + e, t)) > "u"),
                  getItem: async (e) => (await (0, B.Jt)(r + e, t)) ?? null,
                  setItem: (e, i) => (0, B.hZ)(r + e, i, t),
                  removeItem: (e) => (0, B.yH)(r + e, t),
                  getKeys: () => (0, B.HP)(t),
                  clear: () => (0, B.IU)(t),
                }
              );
            })({
              dbName: "WALLET_CONNECT_V2_INDEXED_DB",
              storeName: "keyvaluestorage",
            }),
          });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (
            await this.indexedDb.getItems(await this.indexedDb.getKeys())
          ).map((e) => [e.key, e.value]);
        }
        async getItem(e) {
          let t = await this.indexedDb.getItem(e);
          if (null !== t) return t;
        }
        async setItem(e, t) {
          await this.indexedDb.setItem(e, (0, W.h)(t));
        }
        async removeItem(e) {
          await this.indexedDb.removeItem(e);
        }
      }
      var F =
          "u" > typeof globalThis
            ? globalThis
            : "u" > typeof window
            ? window
            : "u" > typeof r.g
            ? r.g
            : "u" > typeof self
            ? self
            : {},
        H = { exports: {} };
      function q(e) {
        var t;
        return [e[0], (0, W.j)(null != (t = e[1]) ? t : "")];
      }
      !(function () {
        function e() {}
        (e.prototype.getItem = function (e) {
          return this.hasOwnProperty(e) ? String(this[e]) : null;
        }),
          (e.prototype.setItem = function (e, t) {
            this[e] = String(t);
          }),
          (e.prototype.removeItem = function (e) {
            delete this[e];
          }),
          (e.prototype.clear = function () {
            let e = this;
            Object.keys(e).forEach(function (t) {
              (e[t] = void 0), delete e[t];
            });
          }),
          (e.prototype.key = function (e) {
            return (e = e || 0), Object.keys(this)[e];
          }),
          e.prototype.__defineGetter__("length", function () {
            return Object.keys(this).length;
          }),
          "u" > typeof F && F.localStorage
            ? (H.exports = F.localStorage)
            : "u" > typeof window && window.localStorage
            ? (H.exports = window.localStorage)
            : (H.exports = new e());
      })();
      class z {
        constructor() {
          this.localStorage = H.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(q);
        }
        async getItem(e) {
          let t = this.localStorage.getItem(e);
          if (null !== t) return (0, W.j)(t);
        }
        async setItem(e, t) {
          this.localStorage.setItem(e, (0, W.h)(t));
        }
        async removeItem(e) {
          this.localStorage.removeItem(e);
        }
      }
      let V = async (e, t, r) => {
          let i = "wc_storage_version",
            n = await t.getItem(i);
          if (n && n >= 1) return void r(t);
          let s = await e.getKeys();
          if (!s.length) return void r(t);
          let a = [];
          for (; s.length; ) {
            let r = s.shift();
            if (!r) continue;
            let i = r.toLowerCase();
            if (
              i.includes("wc@") ||
              i.includes("walletconnect") ||
              i.includes("wc_") ||
              i.includes("wallet_connect")
            ) {
              let i = await e.getItem(r);
              await t.setItem(r, i), a.push(r);
            }
          }
          await t.setItem(i, 1), r(t), Z(e, a);
        },
        Z = async (e, t) => {
          t.length &&
            t.forEach(async (t) => {
              await e.removeItem(t);
            });
        };
      class K {
        constructor() {
          (this.initialized = !1),
            (this.setInitialized = (e) => {
              (this.storage = e), (this.initialized = !0);
            });
          let e = new z();
          this.storage = e;
          try {
            let t = new j();
            V(e, t, this.setInitialized);
          } catch {
            this.initialized = !0;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(e) {
          return await this.initialize(), this.storage.getItem(e);
        }
        async setItem(e, t) {
          return await this.initialize(), this.storage.setItem(e, t);
        }
        async removeItem(e) {
          return await this.initialize(), this.storage.removeItem(e);
        }
        async initialize() {
          this.initialized ||
            (await new Promise((e) => {
              let t = setInterval(() => {
                this.initialized && (clearInterval(t), e());
              }, 20);
            }));
        }
      }
      var G = r(71018),
        J = Object.defineProperty,
        Y = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? J(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class X extends C {
        constructor(e) {
          super(),
            (this.opts = e),
            Y(this, "protocol", "wc"),
            Y(this, "version", 2);
        }
      }
      var Q = Object.defineProperty;
      class ee extends C {
        constructor(e, t) {
          super(),
            (this.core = e),
            (this.logger = t),
            ((e, t, r) =>
              ((e, t, r) =>
                t in e
                  ? Q(e, t, {
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                      value: r,
                    })
                  : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r))(
              this,
              "records",
              new Map()
            );
        }
      }
      class et {
        constructor(e, t) {
          (this.logger = e), (this.core = t);
        }
      }
      class er extends C {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ei extends C {
        constructor(e) {
          super();
        }
      }
      class en {
        constructor(e, t, r, i) {
          (this.core = e), (this.logger = t), (this.name = r);
        }
      }
      class es extends C {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ea extends C {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t);
        }
      }
      class eo {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.store = r);
        }
      }
      class ec {
        constructor(e, t) {
          (this.projectId = e), (this.logger = t);
        }
      }
      class el {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.telemetryEnabled = r);
        }
      }
      var ed = Object.defineProperty,
        eh = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? ed(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      b();
      class eu {
        constructor(e) {
          (this.opts = e), eh(this, "protocol", "wc"), eh(this, "version", 2);
        }
      }
      w.EventEmitter;
      class ep {
        constructor(e) {
          this.client = e;
        }
      }
      function ef(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function eg(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      let em =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0,
        ey = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      function ew(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          ef(e),
          e
        );
      }
      class eb {
        clone() {
          return this._cloneInto();
        }
      }
      function ev(e = 32) {
        if (em && "function" == typeof em.getRandomValues)
          return em.getRandomValues(new Uint8Array(e));
        if (em && "function" == typeof em.randomBytes) return em.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      class eC extends eb {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = ey(this.buffer));
        }
        update(e) {
          eg(this);
          let { view: t, buffer: r, blockLen: i } = this,
            n = (e = ew(e)).length;
          for (let s = 0; s < n; ) {
            let a = Math.min(i - this.pos, n - s);
            if (a === i) {
              let t = ey(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + a), this.pos),
              (this.pos += a),
              (s += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          eg(this),
            (function (e, t) {
              ef(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: n } = this,
            { pos: s } = this;
          (t[s++] = 128),
            this.buffer.subarray(s).fill(0),
            this.padOffset > i - s && (this.process(r, 0), (s = 0));
          for (let e = s; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(0xffffffff),
              a = Number((r >> n) & s),
              o = Number(r & s),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), n),
            this.process(r, 0);
          let a = ey(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = o / 4,
            l = this.get();
          if (c > l.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, l[e], n);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = n),
            (e.destroyed = s),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let eE = BigInt(0x100000000 - 1),
        ex = BigInt(32),
        eA = {
          split: function (e, t = !1) {
            let r = new Uint32Array(e.length),
              i = new Uint32Array(e.length);
            for (let n = 0; n < e.length; n++) {
              let { h: s, l: a } = (function (e, t = !1) {
                return t
                  ? { h: Number(e & eE), l: Number((e >> ex) & eE) }
                  : { h: 0 | Number((e >> ex) & eE), l: 0 | Number(e & eE) };
              })(e[n], t);
              [r[n], i[n]] = [s, a];
            }
            return [r, i];
          },
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          add: function (e, t, r, i) {
            let n = (t >>> 0) + (i >>> 0);
            return { h: (e + r + ((n / 0x100000000) | 0)) | 0, l: 0 | n };
          },
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
          add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
          add4H: (e, t, r, i, n) =>
            (t + r + i + n + ((e / 0x100000000) | 0)) | 0,
          add5H: (e, t, r, i, n, s) =>
            (t + r + i + n + s + ((e / 0x100000000) | 0)) | 0,
          add5L: (e, t, r, i, n) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
        },
        [e_, eI] = eA.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        eS = new Uint32Array(80),
        ek = new Uint32Array(80);
      class eN extends eC {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 0x6a09e667),
            (this.Al = -0xc4336f8),
            (this.Bh = -0x4498517b),
            (this.Bl = -0x7b3558c5),
            (this.Ch = 0x3c6ef372),
            (this.Cl = -0x16b07d5),
            (this.Dh = -0x5ab00ac6),
            (this.Dl = 0x5f1d36f1),
            (this.Eh = 0x510e527f),
            (this.El = -0x52197d2f),
            (this.Fh = -0x64fa9774),
            (this.Fl = 0x2b3e6c1f),
            (this.Gh = 0x1f83d9ab),
            (this.Gl = -0x4be4295),
            (this.Hh = 0x5be0cd19),
            (this.Hl = 0x137e2179);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: n,
            Cl: s,
            Dh: a,
            Dl: o,
            Eh: c,
            El: l,
            Fh: d,
            Fl: h,
            Gh: u,
            Gl: p,
            Hh: f,
            Hl: g,
          } = this;
          return [e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g];
        }
        set(e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | n),
            (this.Cl = 0 | s),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | c),
            (this.El = 0 | l),
            (this.Fh = 0 | d),
            (this.Fl = 0 | h),
            (this.Gh = 0 | u),
            (this.Gl = 0 | p),
            (this.Hh = 0 | f),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (eS[r] = e.getUint32(t)), (ek[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | eS[e - 15],
              r = 0 | ek[e - 15],
              i = eA.rotrSH(t, r, 1) ^ eA.rotrSH(t, r, 8) ^ eA.shrSH(t, r, 7),
              n = eA.rotrSL(t, r, 1) ^ eA.rotrSL(t, r, 8) ^ eA.shrSL(t, r, 7),
              s = 0 | eS[e - 2],
              a = 0 | ek[e - 2],
              o = eA.rotrSH(s, a, 19) ^ eA.rotrBH(s, a, 61) ^ eA.shrSH(s, a, 6),
              c = eA.rotrSL(s, a, 19) ^ eA.rotrBL(s, a, 61) ^ eA.shrSL(s, a, 6),
              l = eA.add4L(n, c, ek[e - 7], ek[e - 16]),
              d = eA.add4H(l, i, o, eS[e - 7], eS[e - 16]);
            (eS[e] = 0 | d), (ek[e] = 0 | l);
          }
          let {
            Ah: r,
            Al: i,
            Bh: n,
            Bl: s,
            Ch: a,
            Cl: o,
            Dh: c,
            Dl: l,
            Eh: d,
            El: h,
            Fh: u,
            Fl: p,
            Gh: f,
            Gl: g,
            Hh: m,
            Hl: y,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t =
                eA.rotrSH(d, h, 14) ^ eA.rotrSH(d, h, 18) ^ eA.rotrBH(d, h, 41),
              w =
                eA.rotrSL(d, h, 14) ^ eA.rotrSL(d, h, 18) ^ eA.rotrBL(d, h, 41),
              b = (d & u) ^ (~d & f),
              v = (h & p) ^ (~h & g),
              C = eA.add5L(y, w, v, eI[e], ek[e]),
              E = eA.add5H(C, m, t, b, e_[e], eS[e]),
              x = 0 | C,
              A =
                eA.rotrSH(r, i, 28) ^ eA.rotrBH(r, i, 34) ^ eA.rotrBH(r, i, 39),
              _ =
                eA.rotrSL(r, i, 28) ^ eA.rotrBL(r, i, 34) ^ eA.rotrBL(r, i, 39),
              I = (r & n) ^ (r & a) ^ (n & a),
              S = (i & s) ^ (i & o) ^ (s & o);
            (m = 0 | f),
              (y = 0 | g),
              (f = 0 | u),
              (g = 0 | p),
              (u = 0 | d),
              (p = 0 | h),
              ({ h: d, l: h } = eA.add(0 | c, 0 | l, 0 | E, 0 | x)),
              (c = 0 | a),
              (l = 0 | o),
              (a = 0 | n),
              (o = 0 | s),
              (n = 0 | r),
              (s = 0 | i);
            let k = eA.add3L(x, _, S);
            (r = eA.add3H(k, E, A, I)), (i = 0 | k);
          }
          ({ h: r, l: i } = eA.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: n, l: s } = eA.add(0 | this.Bh, 0 | this.Bl, 0 | n, 0 | s)),
            ({ h: a, l: o } = eA.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: c, l: l } = eA.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
            ({ h: d, l: h } = eA.add(0 | this.Eh, 0 | this.El, 0 | d, 0 | h)),
            ({ h: u, l: p } = eA.add(0 | this.Fh, 0 | this.Fl, 0 | u, 0 | p)),
            ({ h: f, l: g } = eA.add(0 | this.Gh, 0 | this.Gl, 0 | f, 0 | g)),
            ({ h: m, l: y } = eA.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
            this.set(r, i, n, s, a, o, c, l, d, h, u, p, f, g, m, y);
        }
        roundClean() {
          eS.fill(0), ek.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let eT = (function (e) {
          let t = (t) => e().update(ew(t)).digest(),
            r = e();
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = () => e()),
            t
          );
        })(() => new eN()),
        eO = BigInt(0),
        eP = BigInt(1),
        eR = BigInt(2);
      function e$(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function eD(e) {
        if (!e$(e)) throw Error("Uint8Array expected");
      }
      function eU(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      let eM = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function eL(e) {
        eD(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += eM[e[r]];
        return t;
      }
      function eB(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? eO : BigInt("0x" + e);
      }
      let eW = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function ej(e) {
        return e >= eW._0 && e <= eW._9
          ? e - eW._0
          : e >= eW.A && e <= eW.F
          ? e - (eW.A - 10)
          : e >= eW.a && e <= eW.f
          ? e - (eW.a - 10)
          : void 0;
      }
      function eF(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, n = 0; t < r; t++, n += 2) {
          let r = ej(e.charCodeAt(n)),
            s = ej(e.charCodeAt(n + 1));
          if (void 0 === r || void 0 === s)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[n] + e[n + 1]) +
                '" at index ' +
                n
            );
          i[t] = 16 * r + s;
        }
        return i;
      }
      function eH(e) {
        return eD(e), eB(eL(Uint8Array.from(e).reverse()));
      }
      function eq(e, t) {
        return eF(e.toString(16).padStart(2 * t, "0"));
      }
      function ez(e, t) {
        return eq(e, t).reverse();
      }
      function eV(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = eF(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (e$(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let n = i.length;
        if ("number" == typeof r && n !== r)
          throw Error(e + " of length " + r + " expected, got " + n);
        return i;
      }
      function eZ(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          eD(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let n = e[t];
          r.set(n, i), (i += n.length);
        }
        return r;
      }
      let eK = (e) => "bigint" == typeof e && eO <= e;
      function eG(e, t, r, i) {
        if (!(eK(t) && eK(r) && eK(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let eJ = {
        bigint: (e) => "bigint" == typeof e,
        function: (e) => "function" == typeof e,
        boolean: (e) => "boolean" == typeof e,
        string: (e) => "string" == typeof e,
        stringOrUint8Array: (e) => "string" == typeof e || e$(e),
        isSafeInteger: (e) => Number.isSafeInteger(e),
        array: (e) => Array.isArray(e),
        field: (e, t) => t.Fp.isValid(e),
        hash: (e) =>
          "function" == typeof e && Number.isSafeInteger(e.outputLen),
      };
      function eY(e, t, r = {}) {
        let i = (t, r, i) => {
          let n = eJ[r];
          if ("function" != typeof n) throw Error("invalid validator function");
          let s = e[t];
          if (!(i && void 0 === s) && !n(s, e))
            throw Error(
              "param " + String(t) + " is invalid. Expected " + r + ", got " + s
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      function eX(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let n = t.get(r);
          if (void 0 !== n) return n;
          let s = e(r, ...i);
          return t.set(r, s), s;
        };
      }
      let eQ = BigInt(0),
        e0 = BigInt(1),
        e1 = BigInt(2),
        e2 = BigInt(3),
        e3 = BigInt(4),
        e5 = BigInt(5),
        e4 = BigInt(8);
      function e6(e, t) {
        let r = e % t;
        return r >= eQ ? r : t + r;
      }
      function e8(e, t, r) {
        let i = e;
        for (; t-- > eQ; ) (i *= i), (i %= r);
        return i;
      }
      function e9(e, t) {
        if (e === eQ) throw Error("invert: expected non-zero number");
        if (t <= eQ) throw Error("invert: expected positive modulus, got " + t);
        let r = e6(e, t),
          i = t,
          n = eQ,
          s = e0;
        for (; r !== eQ; ) {
          let e = i / r,
            t = i % r,
            a = n - s * e;
          (i = r), (r = t), (n = s), (s = a);
        }
        if (i !== e0) throw Error("invert: does not exist");
        return e6(n, t);
      }
      let e7 = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function te(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length,
          i = Math.ceil(r / 8);
        return { nBitLength: r, nByteLength: i };
      }
      function tt(e, t, r = !1, i = {}) {
        let n;
        if (e <= eQ) throw Error("invalid field: expected ORDER > 0, got " + e);
        let { nBitLength: s, nByteLength: a } = te(e, t);
        if (a > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let o = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: s,
          BYTES: a,
          MASK: (eR << BigInt(s - 1)) - eP,
          ZERO: eQ,
          ONE: e0,
          create: (t) => e6(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return eQ <= t && t < e;
          },
          is0: (e) => e === eQ,
          isOdd: (e) => (e & e0) === e0,
          neg: (t) => e6(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => e6(t * t, e),
          add: (t, r) => e6(t + r, e),
          sub: (t, r) => e6(t - r, e),
          mul: (t, r) => e6(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < eQ)
                throw Error("invalid exponent, negatives unsupported");
              if (r === eQ) return e.ONE;
              if (r === e0) return t;
              let i = e.ONE,
                n = t;
              for (; r > eQ; )
                r & e0 && (i = e.mul(i, n)), (n = e.sqr(n)), (r >>= e0);
              return i;
            })(o, e, t),
          div: (t, r) => e6(t * e9(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => e9(t, e),
          sqrt:
            i.sqrt ||
            ((t) => (
              n ||
                (n = (function (e) {
                  if (e % e3 === e2) {
                    let t = (e + e0) / e3;
                    return function (e, r) {
                      let i = e.pow(r, t);
                      if (!e.eql(e.sqr(i), r))
                        throw Error("Cannot find square root");
                      return i;
                    };
                  }
                  if (e % e4 === e5) {
                    let t = (e - e5) / e4;
                    return function (e, r) {
                      let i = e.mul(r, e1),
                        n = e.pow(i, t),
                        s = e.mul(r, n),
                        a = e.mul(e.mul(s, e1), n),
                        o = e.mul(s, e.sub(a, e.ONE));
                      if (!e.eql(e.sqr(o), r))
                        throw Error("Cannot find square root");
                      return o;
                    };
                  }
                  return (function (e) {
                    let t,
                      r,
                      i,
                      n = (e - e0) / e1;
                    for (t = e - e0, r = 0; t % e1 === eQ; t /= e1, r++);
                    for (
                      i = e1;
                      i < e &&
                      (function (e, t, r) {
                        if (t < eQ)
                          throw Error(
                            "invalid exponent, negatives unsupported"
                          );
                        if (r <= eQ) throw Error("invalid modulus");
                        if (r === e0) return eQ;
                        let i = e0;
                        for (; t > eQ; )
                          t & e0 && (i = (i * e) % r),
                            (e = (e * e) % r),
                            (t >>= e0);
                        return i;
                      })(i, n, e) !==
                        e - e0;
                      i++
                    )
                      if (i > 1e3)
                        throw Error(
                          "Cannot find square root: likely non-prime P"
                        );
                    if (1 === r) {
                      let t = (e + e0) / e3;
                      return function (e, r) {
                        let i = e.pow(r, t);
                        if (!e.eql(e.sqr(i), r))
                          throw Error("Cannot find square root");
                        return i;
                      };
                    }
                    let s = (t + e0) / e1;
                    return function (e, a) {
                      if (e.pow(a, n) === e.neg(e.ONE))
                        throw Error("Cannot find square root");
                      let o = r,
                        c = e.pow(e.mul(e.ONE, i), t),
                        l = e.pow(a, s),
                        d = e.pow(a, t);
                      for (; !e.eql(d, e.ONE); ) {
                        if (e.eql(d, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(d); t < o && !e.eql(r, e.ONE); t++)
                          r = e.sqr(r);
                        let r = e.pow(c, e0 << BigInt(o - t - 1));
                        (c = e.sqr(r)),
                          (l = e.mul(l, r)),
                          (d = e.mul(d, c)),
                          (o = t);
                      }
                      return l;
                    };
                  })(e);
                })(e)),
              n(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let r = Array(t.length),
                i = t.reduce(
                  (t, i, n) => (e.is0(i) ? t : ((r[n] = t), e.mul(t, i))),
                  e.ONE
                ),
                n = e.inv(i);
              return (
                t.reduceRight(
                  (t, i, n) =>
                    e.is0(i) ? t : ((r[n] = e.mul(t, r[n])), e.mul(t, i)),
                  n
                ),
                r
              );
            })(o, e),
          cmov: (e, t, r) => (r ? t : e),
          toBytes: (e) => (r ? ez(e, a) : eq(e, a)),
          fromBytes: (e) => {
            if (e.length !== a)
              throw Error(
                "Field.fromBytes: expected " + a + " bytes, got " + e.length
              );
            return r ? eH(e) : eB(eL(e));
          },
        });
        return Object.freeze(o);
      }
      let tr = BigInt(0),
        ti = BigInt(1);
      function tn(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function ts(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function ta(e, t) {
        return (
          ts(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }
        );
      }
      let to = new WeakMap(),
        tc = new WeakMap();
      function tl(e) {
        return tc.get(e) || 1;
      }
      let td = BigInt(0),
        th = BigInt(1),
        tu = BigInt(2),
        tp = BigInt(8),
        tf = { zip215: !0 };
      BigInt(0), BigInt(1);
      let tg = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        ),
        tm = BigInt(
          "19681161376707505956807079304988542015446066515923890162744021073123829784752"
        );
      BigInt(0);
      let ty = BigInt(1),
        tw = BigInt(2);
      BigInt(3);
      let tb = BigInt(5),
        tv = BigInt(8),
        tC = tt(tg, void 0, !0),
        tE = (function (e) {
          var t;
          let r = (function (e) {
              let t =
                (eY(
                  e.Fp,
                  e7.reduce((e, t) => ((e[t] = "function"), e), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger",
                  })
                ),
                eY(
                  e,
                  { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                  { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
                ),
                Object.freeze({
                  ...te(e.n, e.nBitLength),
                  ...e,
                  p: e.Fp.ORDER,
                }));
              return (
                eY(
                  e,
                  {
                    hash: "function",
                    a: "bigint",
                    d: "bigint",
                    randomBytes: "function",
                  },
                  {
                    adjustScalarBytes: "function",
                    domain: "function",
                    uvRatio: "function",
                    mapToCurve: "function",
                  }
                ),
                Object.freeze({ ...t })
              );
            })(e),
            {
              Fp: i,
              n: n,
              prehash: s,
              hash: a,
              randomBytes: o,
              nByteLength: c,
              h: l,
            } = r,
            d = tu << (BigInt(8 * c) - th),
            h = i.create,
            u = tt(r.n, r.nBitLength),
            p =
              r.uvRatio ||
              ((e, t) => {
                try {
                  return { isValid: !0, value: i.sqrt(e * i.inv(t)) };
                } catch {
                  return { isValid: !1, value: td };
                }
              }),
            f = r.adjustScalarBytes || ((e) => e),
            g =
              r.domain ||
              ((e, t, r) => {
                if ((eU("phflag", r), t.length || r))
                  throw Error("Contexts/pre-hash are not supported");
                return e;
              });
          function m(e, t) {
            eG("coordinate " + e, t, td, d);
          }
          function y(e) {
            if (!(e instanceof v)) throw Error("ExtendedPoint expected");
          }
          let w = eX((e, t) => {
              let { ex: r, ey: n, ez: s } = e,
                a = e.is0();
              null == t && (t = a ? tp : i.inv(s));
              let o = h(r * t),
                c = h(n * t),
                l = h(s * t);
              if (a) return { x: td, y: th };
              if (l !== th) throw Error("invZ was invalid");
              return { x: o, y: c };
            }),
            b = eX((e) => {
              let { a: t, d: i } = r;
              if (e.is0()) throw Error("bad point: ZERO");
              let { ex: n, ey: s, ez: a, et: o } = e,
                c = h(n * n),
                l = h(s * s),
                d = h(a * a),
                u = h(d * d),
                p = h(c * t);
              if (h(d * h(p + l)) !== h(u + h(i * h(c * l))))
                throw Error("bad point: equation left != right (1)");
              if (h(n * s) !== h(a * o))
                throw Error("bad point: equation left != right (2)");
              return !0;
            });
          class v {
            constructor(e, t, r, i) {
              (this.ex = e),
                (this.ey = t),
                (this.ez = r),
                (this.et = i),
                m("x", e),
                m("y", t),
                m("z", r),
                m("t", i),
                Object.freeze(this);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static fromAffine(e) {
              if (e instanceof v) throw Error("extended point not allowed");
              let { x: t, y: r } = e || {};
              return m("x", t), m("y", r), new v(t, r, th, h(t * r));
            }
            static normalizeZ(e) {
              let t = i.invertBatch(e.map((e) => e.ez));
              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
            }
            static msm(e, t) {
              return (function (e, t, r, i) {
                if (
                  ((function (e, t) {
                    if (!Array.isArray(e)) throw Error("array expected");
                    e.forEach((e, r) => {
                      if (!(e instanceof t))
                        throw Error("invalid point at index " + r);
                    });
                  })(r, e),
                  (function (e, t) {
                    if (!Array.isArray(e))
                      throw Error("array of scalars expected");
                    e.forEach((e, r) => {
                      if (!t.isValid(e))
                        throw Error("invalid scalar at index " + r);
                    });
                  })(i, t),
                  r.length !== i.length)
                )
                  throw Error(
                    "arrays of points and scalars must have equal length"
                  );
                let n = e.ZERO,
                  s = (function (e) {
                    let t;
                    for (t = 0; e > eO; e >>= eP, t += 1);
                    return t;
                  })(BigInt(r.length)),
                  a = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
                  o = (1 << a) - 1,
                  c = Array(o + 1).fill(n),
                  l = Math.floor((t.BITS - 1) / a) * a,
                  d = n;
                for (let e = l; e >= 0; e -= a) {
                  c.fill(n);
                  for (let t = 0; t < i.length; t++) {
                    let n = Number((i[t] >> BigInt(e)) & BigInt(o));
                    c[n] = c[n].add(r[t]);
                  }
                  let t = n;
                  for (let e = c.length - 1, r = n; e > 0; e--)
                    (r = r.add(c[e])), (t = t.add(r));
                  if (((d = d.add(t)), 0 !== e))
                    for (let e = 0; e < a; e++) d = d.double();
                }
                return d;
              })(v, u, e, t);
            }
            _setWindowSize(e) {
              x.setWindowSize(this, e);
            }
            assertValidity() {
              b(this);
            }
            equals(e) {
              y(e);
              let { ex: t, ey: r, ez: i } = this,
                { ex: n, ey: s, ez: a } = e,
                o = h(t * a),
                c = h(n * i),
                l = h(r * a),
                d = h(s * i);
              return o === c && l === d;
            }
            is0() {
              return this.equals(v.ZERO);
            }
            negate() {
              return new v(h(-this.ex), this.ey, this.ez, h(-this.et));
            }
            double() {
              let { a: e } = r,
                { ex: t, ey: i, ez: n } = this,
                s = h(t * t),
                a = h(i * i),
                o = h(tu * h(n * n)),
                c = h(e * s),
                l = t + i,
                d = h(h(l * l) - s - a),
                u = c + a,
                p = u - o,
                f = c - a,
                g = h(d * p),
                m = h(u * f),
                y = h(d * f);
              return new v(g, m, h(p * u), y);
            }
            add(e) {
              y(e);
              let { a: t, d: i } = r,
                { ex: n, ey: s, ez: a, et: o } = this,
                { ex: c, ey: l, ez: d, et: u } = e;
              if (t === BigInt(-1)) {
                let e = h((s - n) * (l + c)),
                  t = h((s + n) * (l - c)),
                  r = h(t - e);
                if (r === td) return this.double();
                let i = h(a * tu * u),
                  p = h(o * tu * d),
                  f = p + i,
                  g = t + e,
                  m = p - i,
                  y = h(f * r),
                  w = h(g * m),
                  b = h(f * m);
                return new v(y, w, h(r * g), b);
              }
              let p = h(n * c),
                f = h(s * l),
                g = h(o * i * u),
                m = h(a * d),
                w = h((n + s) * (c + l) - p - f),
                b = m - g,
                C = m + g,
                E = h(f - t * p),
                x = h(w * b),
                A = h(C * E),
                _ = h(w * E);
              return new v(x, A, h(b * C), _);
            }
            subtract(e) {
              return this.add(e.negate());
            }
            wNAF(e) {
              return x.wNAFCached(this, e, v.normalizeZ);
            }
            multiply(e) {
              eG("scalar", e, th, n);
              let { p: t, f: r } = this.wNAF(e);
              return v.normalizeZ([t, r])[0];
            }
            multiplyUnsafe(e, t = v.ZERO) {
              return (
                eG("scalar", e, td, n),
                e === td
                  ? E
                  : this.is0() || e === th
                  ? this
                  : x.wNAFCachedUnsafe(this, e, v.normalizeZ, t)
              );
            }
            isSmallOrder() {
              return this.multiplyUnsafe(l).is0();
            }
            isTorsionFree() {
              return x.unsafeLadder(this, n).is0();
            }
            toAffine(e) {
              return w(this, e);
            }
            clearCofactor() {
              let { h: e } = r;
              return e === th ? this : this.multiplyUnsafe(e);
            }
            static fromHex(e, t = !1) {
              let { d: n, a: s } = r,
                a = i.BYTES;
              (e = eV("pointHex", e, a)), eU("zip215", t);
              let o = e.slice(),
                c = e[a - 1];
              o[a - 1] = -129 & c;
              let l = eH(o);
              eG("pointHex.y", l, td, t ? d : i.ORDER);
              let u = h(l * l),
                { isValid: f, value: g } = p(h(u - th), h(n * u - s));
              if (!f) throw Error("Point.fromHex: invalid y coordinate");
              let m = (g & th) === th,
                y = (128 & c) != 0;
              if (!t && g === td && y)
                throw Error("Point.fromHex: x=0 and x_0=1");
              return y !== m && (g = h(-g)), v.fromAffine({ x: g, y: l });
            }
            static fromPrivateKey(e) {
              return A(e).point;
            }
            toRawBytes() {
              let { x: e, y: t } = this.toAffine(),
                r = ez(t, i.BYTES);
              return (r[r.length - 1] |= e & th ? 128 : 0), r;
            }
            toHex() {
              return eL(this.toRawBytes());
            }
          }
          (v.BASE = new v(r.Gx, r.Gy, th, h(r.Gx * r.Gy))),
            (v.ZERO = new v(td, th, th, td));
          let { BASE: C, ZERO: E } = v,
            x =
              ((t = 8 * c),
              {
                constTimeNegate: tn,
                hasPrecomputes: (e) => 1 !== tl(e),
                unsafeLadder(e, t, r = v.ZERO) {
                  let i = e;
                  for (; t > tr; )
                    t & ti && (r = r.add(i)), (i = i.double()), (t >>= ti);
                  return r;
                },
                precomputeWindow(e, r) {
                  let { windows: i, windowSize: n } = ta(r, t),
                    s = [],
                    a = e,
                    o = a;
                  for (let e = 0; e < i; e++) {
                    (o = a), s.push(o);
                    for (let e = 1; e < n; e++) (o = o.add(a)), s.push(o);
                    a = o.double();
                  }
                  return s;
                },
                wNAF(e, r, i) {
                  let { windows: n, windowSize: s } = ta(e, t),
                    a = v.ZERO,
                    o = v.BASE,
                    c = BigInt(2 ** e - 1),
                    l = 2 ** e,
                    d = BigInt(e);
                  for (let e = 0; e < n; e++) {
                    let t = e * s,
                      n = Number(i & c);
                    (i >>= d), n > s && ((n -= l), (i += ti));
                    let h = t + Math.abs(n) - 1,
                      u = e % 2 != 0,
                      p = n < 0;
                    0 === n
                      ? (o = o.add(tn(u, r[t])))
                      : (a = a.add(tn(p, r[h])));
                  }
                  return { p: a, f: o };
                },
                wNAFUnsafe(e, r, i, n = v.ZERO) {
                  let { windows: s, windowSize: a } = ta(e, t),
                    o = BigInt(2 ** e - 1),
                    c = 2 ** e,
                    l = BigInt(e);
                  for (let e = 0; e < s; e++) {
                    let t = e * a;
                    if (i === tr) break;
                    let s = Number(i & o);
                    if (((i >>= l), s > a && ((s -= c), (i += ti)), 0 === s))
                      continue;
                    let d = r[t + Math.abs(s) - 1];
                    s < 0 && (d = d.negate()), (n = n.add(d));
                  }
                  return n;
                },
                getPrecomputes(e, t, r) {
                  let i = to.get(t);
                  return (
                    i ||
                      ((i = this.precomputeWindow(t, e)),
                      1 !== e && to.set(t, r(i))),
                    i
                  );
                },
                wNAFCached(e, t, r) {
                  let i = tl(e);
                  return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                },
                wNAFCachedUnsafe(e, t, r, i) {
                  let n = tl(e);
                  return 1 === n
                    ? this.unsafeLadder(e, t, i)
                    : this.wNAFUnsafe(n, this.getPrecomputes(n, e, r), t, i);
                },
                setWindowSize(e, r) {
                  ts(r, t), tc.set(e, r), to.delete(e);
                },
              });
          function A(e) {
            let t = i.BYTES;
            e = eV("private key", e, t);
            let r = eV("hashed private key", a(e), 2 * t),
              s = f(r.slice(0, t)),
              o = r.slice(t, 2 * t),
              c = e6(eH(s), n),
              l = C.multiply(c),
              d = l.toRawBytes();
            return { head: s, prefix: o, scalar: c, point: l, pointBytes: d };
          }
          function _(e = new Uint8Array(), ...t) {
            return e6(eH(a(g(eZ(...t), eV("context", e), !!s))), n);
          }
          return (
            C._setWindowSize(8),
            {
              CURVE: r,
              getPublicKey: function (e) {
                return A(e).pointBytes;
              },
              sign: function (e, t, r = {}) {
                (e = eV("message", e)), s && (e = s(e));
                let { prefix: a, scalar: o, pointBytes: c } = A(t),
                  l = _(r.context, a, e),
                  d = C.multiply(l).toRawBytes(),
                  h = e6(l + _(r.context, d, c, e) * o, n);
                return (
                  eG("signature.s", h, td, n),
                  eV("result", eZ(d, ez(h, i.BYTES)), 2 * i.BYTES)
                );
              },
              verify: function (e, t, r, n = tf) {
                let a,
                  o,
                  c,
                  { context: l, zip215: d } = n,
                  h = i.BYTES;
                (e = eV("signature", e, 2 * h)),
                  (t = eV("message", t)),
                  (r = eV("publicKey", r, h)),
                  void 0 !== d && eU("zip215", d),
                  s && (t = s(t));
                let u = eH(e.slice(h, 2 * h));
                try {
                  (a = v.fromHex(r, d)),
                    (o = v.fromHex(e.slice(0, h), d)),
                    (c = C.multiplyUnsafe(u));
                } catch {
                  return !1;
                }
                if (!d && a.isSmallOrder()) return !1;
                let p = _(l, o.toRawBytes(), a.toRawBytes(), t);
                return o
                  .add(a.multiplyUnsafe(p))
                  .subtract(c)
                  .clearCofactor()
                  .equals(v.ZERO);
              },
              ExtendedPoint: v,
              utils: {
                getExtendedPublicKey: A,
                randomPrivateKey: () => o(i.BYTES),
                precompute: (e = 8, t = v.BASE) => (
                  t._setWindowSize(e), t.multiply(BigInt(3)), t
                ),
              },
            }
          );
        })({
          a: BigInt(-1),
          d: BigInt(
            "37095705934669439343138083508754565189542113879843219016388785533085940283555"
          ),
          Fp: tC,
          n: BigInt(
            "7237005577332262213973186563042994240857116359379907606001950938285454250989"
          ),
          h: tv,
          Gx: BigInt(
            "15112221349535400772501151409588531511454012693041857206046113283949847762202"
          ),
          Gy: BigInt(
            "46316835694926478169428394003475163141307993866256225615783033603165251855960"
          ),
          hash: eT,
          randomBytes: ev,
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          uvRatio: function (e, t) {
            let r = e6(t * t * t, tg),
              i = (function (e) {
                let t = BigInt(10),
                  r = BigInt(20),
                  i = BigInt(40),
                  n = BigInt(80),
                  s = (((e * e) % tg) * e) % tg,
                  a = (e8(s, tw, tg) * s) % tg,
                  o = (e8(a, ty, tg) * e) % tg,
                  c = (e8(o, tb, tg) * o) % tg,
                  l = (e8(c, t, tg) * c) % tg,
                  d = (e8(l, r, tg) * l) % tg,
                  h = (e8(d, i, tg) * d) % tg,
                  u = (e8(h, n, tg) * h) % tg,
                  p = (e8(u, n, tg) * h) % tg,
                  f = (e8(p, t, tg) * c) % tg;
                return { pow_p_5_8: (e8(f, tw, tg) * e) % tg, b2: s };
              })(e * e6(r * r * t, tg)).pow_p_5_8,
              n = e6(e * r * i, tg),
              s = e6(t * n * n, tg),
              a = n,
              o = e6(n * tm, tg),
              c = s === e,
              l = s === e6(-e, tg),
              d = s === e6(-e * tm, tg);
            return (
              c && (n = a),
              (l || d) && (n = o),
              (e6(n, tg) & e0) === e0 && (n = e6(-n, tg)),
              { isValid: c || l, value: n }
            );
          },
        }),
        tx = "base64url",
        tA = "utf8",
        t_ = "utf8",
        tI = "base58btc";
      function tS(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function tk(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? tS(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function tN(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = tk(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return tS(r);
      }
      var tT = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === c; ) i++, t++;
            for (
              var s = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var h = 0, u = s - 1;
                (0 !== d || h < n) && -1 !== u;
                u--, h++
              )
                (d += (o * a[u]) >>> 0),
                  (a[u] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * d + 1) >>> 0, l = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], u = 0, p = a - 1;
                (0 !== h || u < i) && -1 !== p;
                p--, u++
              )
                (h += (256 * l[p]) >>> 0),
                  (l[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = u), n++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let tO = (e) => {
        if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
          return e;
        if (e instanceof ArrayBuffer) return new Uint8Array(e);
        if (ArrayBuffer.isView(e))
          return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        throw Error("Unknown type, must be binary type");
      };
      class tP {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class tR {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return tD(this, e);
        }
      }
      class t$ {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return tD(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let tD = (e, t) =>
        new t$({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class tU {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new tP(e, t, r)),
            (this.decoder = new tR(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let tM = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new tU(e, t, r, i),
        tL = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = tT(r, t);
          return tM({ prefix: e, name: t, encode: i, decode: (e) => tO(n(e)) });
        },
        tB = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          tM({
            prefix: t,
            name: e,
            encode: (e) =>
              ((e, t, r) => {
                let i = "=" === t[t.length - 1],
                  n = (1 << r) - 1,
                  s = "",
                  a = 0,
                  o = 0;
                for (let i = 0; i < e.length; ++i)
                  for (o = (o << 8) | e[i], a += 8; a > r; )
                    (a -= r), (s += t[n & (o >> a)]);
                if ((a && (s += t[n & (o << (r - a))]), i))
                  for (; (s.length * r) & 7; ) s += "=";
                return s;
              })(e, i, r),
            decode: (t) =>
              ((e, t, r, i) => {
                let n = {};
                for (let e = 0; e < t.length; ++e) n[t[e]] = e;
                let s = e.length;
                for (; "=" === e[s - 1]; ) --s;
                let a = new Uint8Array(((s * r) / 8) | 0),
                  o = 0,
                  c = 0,
                  l = 0;
                for (let t = 0; t < s; ++t) {
                  let s = n[e[t]];
                  if (void 0 === s) throw SyntaxError(`Non-${i} character`);
                  (c = (c << r) | s),
                    (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
                }
                if (o >= r || 255 & (c << (8 - o)))
                  throw SyntaxError("Unexpected end of data");
                return a;
              })(t, i, r, e),
          });
      var tW = Object.freeze({
          __proto__: null,
          identity: tM({
            prefix: "\0",
            name: "identity",
            encode: (e) => new TextDecoder().decode(e),
            decode: (e) => new TextEncoder().encode(e),
          }),
        }),
        tj = Object.freeze({
          __proto__: null,
          base2: tB({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        tF = Object.freeze({
          __proto__: null,
          base8: tB({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        tH = Object.freeze({
          __proto__: null,
          base10: tL({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        tq = Object.freeze({
          __proto__: null,
          base16: tB({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: tB({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let tz = tB({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        tV = tB({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        tZ = tB({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        tK = tB({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        tG = tB({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        tJ = tB({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        tY = tB({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var tX = Object.freeze({
          __proto__: null,
          base32: tz,
          base32upper: tV,
          base32pad: tZ,
          base32padupper: tK,
          base32hex: tG,
          base32hexupper: tJ,
          base32hexpad: tY,
          base32hexpadupper: tB({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: tB({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        tQ = Object.freeze({
          __proto__: null,
          base36: tL({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: tL({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        t0 = Object.freeze({
          __proto__: null,
          base58btc: tL({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: tL({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let t1 = tB({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        t2 = tB({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var t3 = Object.freeze({
        __proto__: null,
        base64: t1,
        base64pad: t2,
        base64url: tB({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: tB({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let t5 = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        t4 = t5.reduce((e, t, r) => ((e[r] = t), e), []),
        t6 = t5.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var t8 = Object.freeze({
        __proto__: null,
        base256emoji: tM({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += t4[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = t6[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function t9(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (t9.bytes = r - i + 1), t;
      }
      var t7 = {
        encode: t9,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let re = (e, t, r = 0) => (t7.encode(e, t, r), t),
        rt = (e) => t7.encodingLength(e),
        rr = (e, t) => {
          let r = t.byteLength,
            i = rt(e),
            n = i + rt(r),
            s = new Uint8Array(n + r);
          return re(e, s, 0), re(r, s, i), s.set(t, n), new ri(e, r, t, s);
        };
      class ri {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let rn = ({ name: e, code: t, encode: r }) => new rs(e, t, r);
      class rs {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? rr(this.code, t)
              : t.then((e) => rr(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let ra = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var ro = Object.freeze({
          __proto__: null,
          sha256: rn({ name: "sha2-256", code: 18, encode: ra("SHA-256") }),
          sha512: rn({ name: "sha2-512", code: 19, encode: ra("SHA-512") }),
        }),
        rc = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: tO,
            digest: (e) => rr(0, tO(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let rl = {
        ...tW,
        ...tj,
        ...tF,
        ...tH,
        ...tq,
        ...tX,
        ...tQ,
        ...t0,
        ...t3,
        ...t8,
      };
      function rd(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...ro, ...rc });
      let rh = rd(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        ru = rd(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = tk((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        rp = {
          utf8: rh,
          "utf-8": rh,
          hex: rl.base16,
          latin1: ru,
          ascii: ru,
          binary: ru,
          ...rl,
        };
      function rf(e, t = "utf8") {
        let r = rp[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      function rg(e, t = "utf8") {
        let r = rp[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? tS(globalThis.Buffer.from(e, "utf-8"))
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function rm(e) {
        return (0, W.j)(rf(rg(e, tx), tA));
      }
      function ry(e) {
        return rf(rg((0, W.h)(e), tA), tx);
      }
      function rw(e) {
        return ["did:key", "z" + rf(tN([rg("K36", tI), e]), tI)].join(":");
      }
      function rb(e) {
        let t = e.split("."),
          r = rm(t[0]),
          i = rm(t[1]);
        return {
          header: r,
          payload: i,
          signature: rg(t[2], tx),
          data: rg(t.slice(0, 2).join("."), t_),
        };
      }
      function rv(e = ev(32)) {
        let t = tE.getPublicKey(e);
        return { secretKey: tN([e, t]), publicKey: t };
      }
      async function rC(e, t, r, i, n = (0, v.fromMiliseconds)(Date.now())) {
        let s = { alg: "EdDSA", typ: "JWT" },
          a = { iss: rw(i.publicKey), sub: e, aud: t, iat: n, exp: n + r },
          o = rg(
            [ry((c = { header: s, payload: a }).header), ry(c.payload)].join(
              "."
            ),
            t_
          );
        var c,
          l = {
            header: s,
            payload: a,
            signature: tE.sign(o, i.secretKey.slice(0, 32)),
          };
        return [ry(l.header), ry(l.payload), rf(l.signature, tx)].join(".");
      }
      var rE = r(95704),
        rx = function (e, t, r) {
          if (r || 2 == arguments.length)
            for (var i, n = 0, s = t.length; n < s; n++)
              (!i && n in t) ||
                (i || (i = Array.prototype.slice.call(t, 0, n)), (i[n] = t[n]));
          return e.concat(i || Array.prototype.slice.call(t));
        },
        rA = function (e, t, r) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.type = "browser");
        },
        r_ = function (e) {
          (this.version = e),
            (this.type = "node"),
            (this.name = "node"),
            (this.os = rE.platform);
        },
        rI = function (e, t, r, i) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.bot = i),
            (this.type = "bot-device");
        },
        rS = function () {
          (this.type = "bot"),
            (this.bot = !0),
            (this.name = "bot"),
            (this.version = null),
            (this.os = null);
        },
        rk = function () {
          (this.type = "react-native"),
            (this.name = "react-native"),
            (this.version = null),
            (this.os = null);
        },
        rN =
          /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
        rT = [
          ["aol", /AOLShield\/([0-9\._]+)/],
          ["edge", /Edge\/([0-9\._]+)/],
          ["edge-ios", /EdgiOS\/([0-9\._]+)/],
          ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
          ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
          ["samsung", /SamsungBrowser\/([0-9\.]+)/],
          ["silk", /\bSilk\/([0-9._-]+)\b/],
          ["miui", /MiuiBrowser\/([0-9\.]+)$/],
          ["beaker", /BeakerBrowser\/([0-9\.]+)/],
          ["edge-chromium", /EdgA?\/([0-9\.]+)/],
          [
            "chromium-webview",
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
          ],
          ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
          ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
          ["fxios", /FxiOS\/([0-9\.]+)/],
          ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
          ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
          ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
          ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
          [
            "pie",
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
          ],
          ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
          ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ["ie", /MSIE\s(7\.0)/],
          ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ["android", /Android\s([0-9\.]+)/],
          ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ["safari", /Version\/([0-9\._]+).*Safari/],
          ["facebook", /FB[AS]V\/([0-9\.]+)/],
          ["instagram", /Instagram\s([0-9\.]+)/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          ["curl", /^curl\/([0-9\.]+)$/],
          [
            "searchbot",
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ],
        rO = [
          ["iOS", /iP(hone|od|ad)/],
          ["Android OS", /Android/],
          ["BlackBerry OS", /BlackBerry|BB10/],
          ["Windows Mobile", /IEMobile/],
          ["Amazon OS", /Kindle/],
          ["Windows 3.11", /Win16/],
          ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
          ["Windows 98", /(Windows 98)|(Win98)/],
          ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
          ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
          ["Windows Server 2003", /(Windows NT 5.2)/],
          ["Windows Vista", /(Windows NT 6.0)/],
          ["Windows 7", /(Windows NT 6.1)/],
          ["Windows 8", /(Windows NT 6.2)/],
          ["Windows 8.1", /(Windows NT 6.3)/],
          ["Windows 10", /(Windows NT 10.0)/],
          ["Windows ME", /Windows ME/],
          ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
          ["Open BSD", /OpenBSD/],
          ["Sun OS", /SunOS/],
          ["Chrome OS", /CrOS/],
          ["Linux", /(Linux)|(X11)/],
          ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
          ["QNX", /QNX/],
          ["BeOS", /BeOS/],
          ["OS/2", /OS\/2/],
        ],
        rP = r(26662),
        rR = r(88955);
      let r$ = "2.31.0",
        rD = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${r$}`,
        };
      class rU extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof rU
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof rU && t.cause.docsPath) || t.docsPath,
            n = rD.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(n ? [`Docs: ${n}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(rD.version ? [`Version: ${rD.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = r$);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      function rM(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      class rL extends rU {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      function rB(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let i = e.replace("0x", "");
              if (i.length > 2 * r)
                throw new rL({
                  size: Math.ceil(i.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${i["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new rL({ size: e.length, targetSize: r, type: "bytes" });
              let i = new Uint8Array(r);
              for (let n = 0; n < r; n++) {
                let s = "right" === t;
                i[s ? n : r - n - 1] = e[s ? n : e.length - n - 1];
              }
              return i;
            })(e, { dir: t, size: r });
      }
      class rW extends rU {
        constructor({ max: e, min: t, signed: r, size: i, value: n }) {
          super(
            `Number "${n}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class rj extends rU {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      function rF(e) {
        return rM(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
      }
      function rH(e, { size: t }) {
        if (rF(e) > t) throw new rj({ givenSize: rF(e), maxSize: t });
      }
      function rq(e, t = {}) {
        let { signed: r } = t;
        t.size && rH(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let n = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(n) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * n, "f")}`) - 1n;
      }
      let rz = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function rV(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? rK(e, t)
          : "string" == typeof e
          ? (function (e, t = {}) {
              return rZ(rG.encode(e), t);
            })(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? (rH(r, { size: t.size }), rB(r, { size: t.size }))
                : r;
            })(e, t)
          : rZ(e, t);
      }
      function rZ(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += rz[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? (rH(i, { size: t.size }), rB(i, { dir: "right", size: t.size }))
          : i;
      }
      function rK(e, t = {}) {
        let r,
          { signed: i, size: n } = t,
          s = BigInt(e);
        n
          ? (r = i
              ? (1n << (8n * BigInt(n) - 1n)) - 1n
              : 2n ** (8n * BigInt(n)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let a = "bigint" == typeof r && i ? -r - 1n : 0;
        if ((r && s > r) || s < a) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new rW({
            max: r ? `${r}${t}` : void 0,
            min: `${a}${t}`,
            signed: i,
            size: n,
            value: `${e}${t}`,
          });
        }
        let o = `0x${(i && s < 0
          ? (1n << BigInt(8 * n)) + BigInt(s)
          : s
        ).toString(16)}`;
        return n ? rB(o, { size: n }) : o;
      }
      let rG = new TextEncoder(),
        rJ = new TextEncoder(),
        rY = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function rX(e) {
        return e >= rY.zero && e <= rY.nine
          ? e - rY.zero
          : e >= rY.A && e <= rY.F
          ? e - (rY.A - 10)
          : e >= rY.a && e <= rY.f
          ? e - (rY.a - 10)
          : void 0;
      }
      function rQ(e, t = {}) {
        let r = e;
        t.size &&
          (rH(r, { size: t.size }),
          (r = rB(r, { dir: "right", size: t.size })));
        let i = r.slice(2);
        i.length % 2 && (i = `0${i}`);
        let n = i.length / 2,
          s = new Uint8Array(n);
        for (let e = 0, t = 0; e < n; e++) {
          let r = rX(i.charCodeAt(t++)),
            n = rX(i.charCodeAt(t++));
          if (void 0 === r || void 0 === n)
            throw new rU(
              `Invalid byte sequence ("${i[t - 2]}${i[t - 1]}" in "${i}").`
            );
          s[e] = 16 * r + n;
        }
        return s;
      }
      function r0(e, t = {}) {
        let r = rJ.encode(e);
        return "number" == typeof t.size
          ? (rH(r, { size: t.size }), rB(r, { dir: "right", size: t.size }))
          : r;
      }
      var r1 = r(56341),
        r2 = r(93878);
      let r3 = BigInt(0),
        r5 = BigInt(1),
        r4 = BigInt(2),
        r6 = BigInt(7),
        r8 = BigInt(256),
        r9 = BigInt(113),
        r7 = [],
        ie = [],
        it = [];
      for (let e = 0, t = r5, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          r7.push(2 * (5 * i + r)),
          ie.push((((e + 1) * (e + 2)) / 2) % 64);
        let n = r3;
        for (let e = 0; e < 7; e++)
          (t = ((t << r5) ^ ((t >> r6) * r9)) % r8) & r4 &&
            (n ^= r5 << ((r5 << BigInt(e)) - r5));
        it.push(n);
      }
      let ir = (0, r1.lD)(it, !0),
        ii = ir[0],
        is = ir[1],
        ia = (e, t, r) => (r > 32 ? (0, r1.WM)(e, t, r) : (0, r1.P5)(e, t, r)),
        io = (e, t, r) => (r > 32 ? (0, r1.im)(e, t, r) : (0, r1.B4)(e, t, r));
      class ic extends r2.Vw {
        constructor(e, t, r, i = !1, n = 24) {
          if (
            (super(),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (this.enableXOF = !1),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = n),
            (0, r2.Fe)(r),
            !(0 < e && e < 200))
          )
            throw Error("only keccak-f1600 function is supported");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, r2.DH)(this.state));
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          (0, r2.fd)(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    n = (t + 2) % 10,
                    s = r[n],
                    a = r[n + 1],
                    o = ia(s, a, 1) ^ r[i],
                    c = io(s, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  n = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = ie[r],
                    s = ia(t, n, i),
                    a = io(t, n, i),
                    o = r7[r];
                  (t = e[o]), (n = e[o + 1]), (e[o] = s), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= ii[i]), (e[1] ^= is[i]);
              }
              (0, r2.uH)(r);
            })(this.state32, this.rounds),
            (0, r2.fd)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, r2.CC)(this), (e = (0, r2.ZJ)(e)), (0, r2.DO)(e);
          let { blockLen: t, state: r } = this,
            i = e.length;
          for (let n = 0; n < i; ) {
            let s = Math.min(t - this.pos, i - n);
            for (let t = 0; t < s; t++) r[this.pos++] ^= e[n++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, r2.CC)(this, !1), (0, r2.DO)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
              (this.posOut += s),
              (i += s);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, r2.Fe)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, r2.Ht)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), (0, r2.uH)(this.state);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: n,
            enableXOF: s,
          } = this;
          return (
            e || (e = new ic(t, r, i, s, n)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = n),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = s),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let il = (() => (0, r2.qj)(() => new ic(136, 1, 32)))();
      function id(e, t) {
        let r = il(
          rM(e, { strict: !1 })
            ? (function (e, t = {}) {
                return "number" == typeof e || "bigint" == typeof e
                  ? rQ(rK(e, t))
                  : "boolean" == typeof e
                  ? (function (e, t = {}) {
                      let r = new Uint8Array(1);
                      return ((r[0] = Number(e)), "number" == typeof t.size)
                        ? (rH(r, { size: t.size }), rB(r, { size: t.size }))
                        : r;
                    })(e, t)
                  : rM(e)
                  ? rQ(e, t)
                  : r0(e, t);
              })(e)
            : e
        );
        return "bytes" === (t || "hex") ? r : rV(r);
      }
      class ih extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let iu = new ih(8192);
      async function ip({ hash: e, signature: t }) {
        let i = rM(e) ? e : rV(e),
          { secp256k1: n } = await r.e(9414).then(r.bind(r, 69414)),
          s = (() => {
            if ("object" == typeof t && "r" in t && "s" in t) {
              let { r: e, s: r, v: i, yParity: s } = t,
                a = ig(Number(s ?? i));
              return new n.Signature(rq(e), rq(r)).addRecoveryBit(a);
            }
            let e = rM(t) ? t : rV(t);
            if (65 !== rF(e)) throw Error("invalid signature length");
            let r = ig(
              (function (e, t = {}) {
                return Number(rq(e, t));
              })(`0x${e.slice(130)}`)
            );
            return n.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(
              r
            );
          })()
            .recoverPublicKey(i.substring(2))
            .toHex(!1);
        return `0x${s}`;
      }
      function ig(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error("Invalid yParityOrV value");
      }
      async function im({ hash: e, signature: t }) {
        var r = await ip({ hash: e, signature: t });
        let i = id(`0x${r.substring(4)}`).substring(26);
        return (function (e, t) {
          if (iu.has(`${e}.undefined`)) return iu.get(`${e}.${void 0}`);
          let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
            i = id(r0(r), "bytes"),
            n = (t ? r.substring(`${t}0x`.length) : r).split("");
          for (let e = 0; e < 40; e += 2)
            i[e >> 1] >> 4 >= 8 && n[e] && (n[e] = n[e].toUpperCase()),
              (15 & i[e >> 1]) >= 8 &&
                n[e + 1] &&
                (n[e + 1] = n[e + 1].toUpperCase());
          let s = `0x${n.join("")}`;
          return iu.set(`${e}.${t}`, s), s;
        })(`0x${i}`);
      }
      var iy = r(8444);
      function iw(e) {
        return `${e < 0 ? "-" : ""}0x${Math.abs(e)
          .toString(16)
          .padStart(2, "0")}`;
      }
      class ib {
        constructor(e, t) {
          (this.type = e), (this.data = t);
        }
      }
      class iv extends Error {
        constructor(e) {
          super(e),
            Object.setPrototypeOf(this, Object.create(iv.prototype)),
            Object.defineProperty(this, "name", {
              configurable: !0,
              enumerable: !1,
              value: iv.name,
            });
        }
      }
      function iC(e, t, r) {
        let i = Math.floor(r / 0x100000000);
        e.setUint32(t, i), e.setUint32(t + 4, r);
      }
      function iE(e, t) {
        return 0x100000000 * e.getInt32(t) + e.getUint32(t + 4);
      }
      let ix = {
        type: -1,
        encode: function (e) {
          return e instanceof Date
            ? (function ({ sec: e, nsec: t }) {
                if (e >= 0 && t >= 0 && e <= 0x3ffffffff)
                  if (0 === t && e <= 0xffffffff) {
                    let t = new Uint8Array(4);
                    return new DataView(t.buffer).setUint32(0, e), t;
                  } else {
                    let r = e / 0x100000000,
                      i = new Uint8Array(8),
                      n = new DataView(i.buffer);
                    return (
                      n.setUint32(0, (t << 2) | (3 & r)),
                      n.setUint32(4, 0 | e),
                      i
                    );
                  }
                {
                  let r = new Uint8Array(12),
                    i = new DataView(r.buffer);
                  return i.setUint32(0, t), iC(i, 4, e), r;
                }
              })(
                (function (e) {
                  let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    i = (t - 1e3 * r) * 1e6,
                    n = Math.floor(i / 1e9);
                  return { sec: r + n, nsec: i - 1e9 * n };
                })(e)
              )
            : null;
        },
        decode: function (e) {
          let t = (function (e) {
            let t = new DataView(e.buffer, e.byteOffset, e.byteLength);
            switch (e.byteLength) {
              case 4:
                return { sec: t.getUint32(0), nsec: 0 };
              case 8: {
                let e = t.getUint32(0);
                return {
                  sec: (3 & e) * 0x100000000 + t.getUint32(4),
                  nsec: e >>> 2,
                };
              }
              case 12:
                return { sec: iE(t, 4), nsec: t.getUint32(0) };
              default:
                throw new iv(
                  `Unrecognized data size for timestamp (expected 4, 8, or 12): ${e.length}`
                );
            }
          })(e);
          return new Date(1e3 * t.sec + t.nsec / 1e6);
        },
      };
      class iA {
        constructor() {
          (this.builtInEncoders = []),
            (this.builtInDecoders = []),
            (this.encoders = []),
            (this.decoders = []),
            this.register(ix);
        }
        register({ type: e, encode: t, decode: r }) {
          if (e >= 0) (this.encoders[e] = t), (this.decoders[e] = r);
          else {
            let i = -1 - e;
            (this.builtInEncoders[i] = t), (this.builtInDecoders[i] = r);
          }
        }
        tryToEncode(e, t) {
          for (let r = 0; r < this.builtInEncoders.length; r++) {
            let i = this.builtInEncoders[r];
            if (null != i) {
              let n = i(e, t);
              if (null != n) return new ib(-1 - r, n);
            }
          }
          for (let r = 0; r < this.encoders.length; r++) {
            let i = this.encoders[r];
            if (null != i) {
              let n = i(e, t);
              if (null != n) return new ib(r, n);
            }
          }
          return e instanceof ib ? e : null;
        }
        decode(e, t, r) {
          let i = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
          return i ? i(e, t, r) : new ib(t, e);
        }
      }
      iA.defaultCodec = new iA();
      let i_ = new TextEncoder();
      function iI(e, t, r) {
        let i = t,
          n = i + r,
          s = [],
          a = "";
        for (; i < n; ) {
          let t = e[i++];
          if ((128 & t) == 0) s.push(t);
          else if ((224 & t) == 192) {
            let r = 63 & e[i++];
            s.push(((31 & t) << 6) | r);
          } else if ((240 & t) == 224) {
            let r = 63 & e[i++],
              n = 63 & e[i++];
            s.push(((31 & t) << 12) | (r << 6) | n);
          } else if ((248 & t) == 240) {
            let r = 63 & e[i++],
              n =
                ((7 & t) << 18) |
                (r << 12) |
                ((63 & e[i++]) << 6) |
                (63 & e[i++]);
            n > 65535 &&
              ((n -= 65536),
              s.push(((n >>> 10) & 1023) | 55296),
              (n = 56320 | (1023 & n))),
              s.push(n);
          } else s.push(t);
          s.length >= 4096 &&
            ((a += String.fromCharCode(...s)), (s.length = 0));
        }
        return s.length > 0 && (a += String.fromCharCode(...s)), a;
      }
      let iS = new TextDecoder();
      function ik(e) {
        return e instanceof Uint8Array
          ? e
          : ArrayBuffer.isView(e)
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e instanceof ArrayBuffer ||
            ("undefined" != typeof SharedArrayBuffer &&
              e instanceof SharedArrayBuffer)
          ? new Uint8Array(e)
          : Uint8Array.from(e);
      }
      class iN {
        constructor(e = 16, t = 16) {
          (this.hit = 0),
            (this.miss = 0),
            (this.maxKeyLength = e),
            (this.maxLengthPerKey = t),
            (this.caches = []);
          for (let e = 0; e < this.maxKeyLength; e++) this.caches.push([]);
        }
        canBeCached(e) {
          return e > 0 && e <= this.maxKeyLength;
        }
        find(e, t, r) {
          let i = this.caches[r - 1];
          e: for (let n of i) {
            let i = n.bytes;
            for (let n = 0; n < r; n++) if (i[n] !== e[t + n]) continue e;
            return n.str;
          }
          return null;
        }
        store(e, t) {
          let r = this.caches[e.length - 1],
            i = { bytes: e, str: t };
          r.length >= this.maxLengthPerKey
            ? (r[(Math.random() * r.length) | 0] = i)
            : r.push(i);
        }
        decode(e, t, r) {
          let i = this.find(e, t, r);
          if (null != i) return this.hit++, i;
          this.miss++;
          let n = iI(e, t, r),
            s = Uint8Array.prototype.slice.call(e, t, t + r);
          return this.store(s, n), n;
        }
      }
      let iT = "array",
        iO = "map_key",
        iP = "map_value",
        iR = (e) => {
          if ("string" == typeof e || "number" == typeof e) return e;
          throw new iv(
            "The type of key must be string or number but " + typeof e
          );
        };
      class i$ {
        constructor() {
          (this.stack = []), (this.stackHeadPosition = -1);
        }
        get length() {
          return this.stackHeadPosition + 1;
        }
        top() {
          return this.stack[this.stackHeadPosition];
        }
        pushArrayState(e) {
          let t = this.getUninitializedStateFromPool();
          (t.type = iT), (t.position = 0), (t.size = e), (t.array = Array(e));
        }
        pushMapState(e) {
          let t = this.getUninitializedStateFromPool();
          (t.type = iO), (t.readCount = 0), (t.size = e), (t.map = {});
        }
        getUninitializedStateFromPool() {
          return (
            this.stackHeadPosition++,
            this.stackHeadPosition === this.stack.length &&
              this.stack.push({
                type: void 0,
                size: 0,
                array: void 0,
                position: 0,
                readCount: 0,
                map: void 0,
                key: null,
              }),
            this.stack[this.stackHeadPosition]
          );
        }
        release(e) {
          if (this.stack[this.stackHeadPosition] !== e)
            throw Error(
              "Invalid stack state. Released state is not on top of the stack."
            );
          e.type === iT &&
            ((e.size = 0),
            (e.array = void 0),
            (e.position = 0),
            (e.type = void 0)),
            (e.type === iO || e.type === iP) &&
              ((e.size = 0),
              (e.map = void 0),
              (e.readCount = 0),
              (e.type = void 0)),
            this.stackHeadPosition--;
        }
        reset() {
          (this.stack.length = 0), (this.stackHeadPosition = -1);
        }
      }
      let iD = new DataView(new ArrayBuffer(0)),
        iU = new Uint8Array(iD.buffer);
      try {
        iD.getInt8(0);
      } catch (e) {
        if (!(e instanceof RangeError))
          throw Error(
            "This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access"
          );
      }
      let iM = RangeError("Insufficient data"),
        iL = new iN();
      class iB {
        constructor(e) {
          (this.totalPos = 0),
            (this.pos = 0),
            (this.view = iD),
            (this.bytes = iU),
            (this.headByte = -1),
            (this.stack = new i$()),
            (this.entered = !1),
            (this.extensionCodec = e?.extensionCodec ?? iA.defaultCodec),
            (this.context = e?.context),
            (this.useBigInt64 = e?.useBigInt64 ?? !1),
            (this.rawStrings = e?.rawStrings ?? !1),
            (this.maxStrLength = e?.maxStrLength ?? 0xffffffff),
            (this.maxBinLength = e?.maxBinLength ?? 0xffffffff),
            (this.maxArrayLength = e?.maxArrayLength ?? 0xffffffff),
            (this.maxMapLength = e?.maxMapLength ?? 0xffffffff),
            (this.maxExtLength = e?.maxExtLength ?? 0xffffffff),
            (this.keyDecoder = e?.keyDecoder !== void 0 ? e.keyDecoder : iL),
            (this.mapKeyConverter = e?.mapKeyConverter ?? iR);
        }
        clone() {
          return new iB({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder,
          });
        }
        reinitializeState() {
          (this.totalPos = 0), (this.headByte = -1), this.stack.reset();
        }
        setBuffer(e) {
          let t = ik(e);
          (this.bytes = t),
            (this.view = new DataView(t.buffer, t.byteOffset, t.byteLength)),
            (this.pos = 0);
        }
        appendBuffer(e) {
          if (-1 !== this.headByte || this.hasRemaining(1)) {
            let t = this.bytes.subarray(this.pos),
              r = ik(e),
              i = new Uint8Array(t.length + r.length);
            i.set(t), i.set(r, t.length), this.setBuffer(i);
          } else this.setBuffer(e);
        }
        hasRemaining(e) {
          return this.view.byteLength - this.pos >= e;
        }
        createExtraByteError(e) {
          let { view: t, pos: r } = this;
          return RangeError(
            `Extra ${t.byteLength - r} of ${
              t.byteLength
            } byte(s) found at buffer[${e}]`
          );
        }
        decode(e) {
          if (this.entered) return this.clone().decode(e);
          try {
            (this.entered = !0), this.reinitializeState(), this.setBuffer(e);
            let t = this.doDecodeSync();
            if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);
            return t;
          } finally {
            this.entered = !1;
          }
        }
        *decodeMulti(e) {
          if (this.entered) {
            let t = this.clone();
            yield* t.decodeMulti(e);
            return;
          }
          try {
            for (
              this.entered = !0, this.reinitializeState(), this.setBuffer(e);
              this.hasRemaining(1);

            )
              yield this.doDecodeSync();
          } finally {
            this.entered = !1;
          }
        }
        async decodeAsync(e) {
          if (this.entered) return this.clone().decodeAsync(e);
          try {
            let t;
            this.entered = !0;
            let r = !1;
            for await (let i of e) {
              if (r)
                throw (
                  ((this.entered = !1),
                  this.createExtraByteError(this.totalPos))
                );
              this.appendBuffer(i);
              try {
                (t = this.doDecodeSync()), (r = !0);
              } catch (e) {
                if (!(e instanceof RangeError)) throw e;
              }
              this.totalPos += this.pos;
            }
            if (r) {
              if (this.hasRemaining(1))
                throw this.createExtraByteError(this.totalPos);
              return t;
            }
            let { headByte: i, pos: n, totalPos: s } = this;
            throw RangeError(
              `Insufficient data in parsing ${iw(
                i
              )} at ${s} (${n} in the current buffer)`
            );
          } finally {
            this.entered = !1;
          }
        }
        decodeArrayStream(e) {
          return this.decodeMultiAsync(e, !0);
        }
        decodeStream(e) {
          return this.decodeMultiAsync(e, !1);
        }
        async *decodeMultiAsync(e, t) {
          if (this.entered) {
            let r = this.clone();
            yield* r.decodeMultiAsync(e, t);
            return;
          }
          try {
            this.entered = !0;
            let r = t,
              i = -1;
            for await (let n of e) {
              if (t && 0 === i) throw this.createExtraByteError(this.totalPos);
              this.appendBuffer(n),
                r && ((i = this.readArraySize()), (r = !1), this.complete());
              try {
                for (; yield this.doDecodeSync(), 0 != --i; );
              } catch (e) {
                if (!(e instanceof RangeError)) throw e;
              }
              this.totalPos += this.pos;
            }
          } finally {
            this.entered = !1;
          }
        }
        doDecodeSync() {
          t: for (;;) {
            let e,
              t = this.readHeadByte();
            if (t >= 224) e = t - 256;
            else if (t < 192)
              if (t < 128) e = t;
              else if (t < 144) {
                let r = t - 128;
                if (0 !== r) {
                  this.pushMapState(r), this.complete();
                  continue;
                }
                e = {};
              } else if (t < 160) {
                let r = t - 144;
                if (0 !== r) {
                  this.pushArrayState(r), this.complete();
                  continue;
                }
                e = [];
              } else {
                let r = t - 160;
                e = this.decodeString(r, 0);
              }
            else if (192 === t) e = null;
            else if (194 === t) e = !1;
            else if (195 === t) e = !0;
            else if (202 === t) e = this.readF32();
            else if (203 === t) e = this.readF64();
            else if (204 === t) e = this.readU8();
            else if (205 === t) e = this.readU16();
            else if (206 === t) e = this.readU32();
            else if (207 === t)
              e = this.useBigInt64 ? this.readU64AsBigInt() : this.readU64();
            else if (208 === t) e = this.readI8();
            else if (209 === t) e = this.readI16();
            else if (210 === t) e = this.readI32();
            else if (211 === t)
              e = this.useBigInt64 ? this.readI64AsBigInt() : this.readI64();
            else if (217 === t) {
              let t = this.lookU8();
              e = this.decodeString(t, 1);
            } else if (218 === t) {
              let t = this.lookU16();
              e = this.decodeString(t, 2);
            } else if (219 === t) {
              let t = this.lookU32();
              e = this.decodeString(t, 4);
            } else if (220 === t) {
              let t = this.readU16();
              if (0 !== t) {
                this.pushArrayState(t), this.complete();
                continue;
              }
              e = [];
            } else if (221 === t) {
              let t = this.readU32();
              if (0 !== t) {
                this.pushArrayState(t), this.complete();
                continue;
              }
              e = [];
            } else if (222 === t) {
              let t = this.readU16();
              if (0 !== t) {
                this.pushMapState(t), this.complete();
                continue;
              }
              e = {};
            } else if (223 === t) {
              let t = this.readU32();
              if (0 !== t) {
                this.pushMapState(t), this.complete();
                continue;
              }
              e = {};
            } else if (196 === t) {
              let t = this.lookU8();
              e = this.decodeBinary(t, 1);
            } else if (197 === t) {
              let t = this.lookU16();
              e = this.decodeBinary(t, 2);
            } else if (198 === t) {
              let t = this.lookU32();
              e = this.decodeBinary(t, 4);
            } else if (212 === t) e = this.decodeExtension(1, 0);
            else if (213 === t) e = this.decodeExtension(2, 0);
            else if (214 === t) e = this.decodeExtension(4, 0);
            else if (215 === t) e = this.decodeExtension(8, 0);
            else if (216 === t) e = this.decodeExtension(16, 0);
            else if (199 === t) {
              let t = this.lookU8();
              e = this.decodeExtension(t, 1);
            } else if (200 === t) {
              let t = this.lookU16();
              e = this.decodeExtension(t, 2);
            } else if (201 === t) {
              let t = this.lookU32();
              e = this.decodeExtension(t, 4);
            } else throw new iv(`Unrecognized type byte: ${iw(t)}`);
            this.complete();
            let r = this.stack;
            for (; r.length > 0; ) {
              let t = r.top();
              if (t.type === iT)
                if (
                  ((t.array[t.position] = e),
                  t.position++,
                  t.position === t.size)
                )
                  (e = t.array), r.release(t);
                else continue t;
              else if (t.type === iO) {
                if ("__proto__" === e)
                  throw new iv("The key __proto__ is not allowed");
                (t.key = this.mapKeyConverter(e)), (t.type = iP);
                continue t;
              } else if (
                ((t.map[t.key] = e), t.readCount++, t.readCount === t.size)
              )
                (e = t.map), r.release(t);
              else {
                (t.key = null), (t.type = iO);
                continue t;
              }
            }
            return e;
          }
        }
        readHeadByte() {
          return (
            -1 === this.headByte && (this.headByte = this.readU8()),
            this.headByte
          );
        }
        complete() {
          this.headByte = -1;
        }
        readArraySize() {
          let e = this.readHeadByte();
          switch (e) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (e < 160) return e - 144;
              throw new iv(`Unrecognized array type byte: ${iw(e)}`);
          }
        }
        pushMapState(e) {
          if (e > this.maxMapLength)
            throw new iv(
              `Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`
            );
          this.stack.pushMapState(e);
        }
        pushArrayState(e) {
          if (e > this.maxArrayLength)
            throw new iv(
              `Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`
            );
          this.stack.pushArrayState(e);
        }
        decodeString(e, t) {
          return !this.rawStrings || this.stateIsMapKey()
            ? this.decodeUtf8String(e, t)
            : this.decodeBinary(e, t);
        }
        decodeUtf8String(e, t) {
          let r;
          if (e > this.maxStrLength)
            throw new iv(
              `Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`
            );
          if (this.bytes.byteLength < this.pos + t + e) throw iM;
          let i = this.pos + t;
          return (
            (r =
              this.stateIsMapKey() && this.keyDecoder?.canBeCached(e)
                ? this.keyDecoder.decode(this.bytes, i, e)
                : (function (e, t, r) {
                    if (!(r > 200)) return iI(e, t, r);
                    let i = e.subarray(t, t + r);
                    return iS.decode(i);
                  })(this.bytes, i, e)),
            (this.pos += t + e),
            r
          );
        }
        stateIsMapKey() {
          return this.stack.length > 0 && this.stack.top().type === iO;
        }
        decodeBinary(e, t) {
          if (e > this.maxBinLength)
            throw new iv(
              `Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`
            );
          if (!this.hasRemaining(e + t)) throw iM;
          let r = this.pos + t,
            i = this.bytes.subarray(r, r + e);
          return (this.pos += t + e), i;
        }
        decodeExtension(e, t) {
          if (e > this.maxExtLength)
            throw new iv(
              `Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`
            );
          let r = this.view.getInt8(this.pos + t),
            i = this.decodeBinary(e, t + 1);
          return this.extensionCodec.decode(i, r, this.context);
        }
        lookU8() {
          return this.view.getUint8(this.pos);
        }
        lookU16() {
          return this.view.getUint16(this.pos);
        }
        lookU32() {
          return this.view.getUint32(this.pos);
        }
        readU8() {
          let e = this.view.getUint8(this.pos);
          return this.pos++, e;
        }
        readI8() {
          let e = this.view.getInt8(this.pos);
          return this.pos++, e;
        }
        readU16() {
          let e = this.view.getUint16(this.pos);
          return (this.pos += 2), e;
        }
        readI16() {
          let e = this.view.getInt16(this.pos);
          return (this.pos += 2), e;
        }
        readU32() {
          let e = this.view.getUint32(this.pos);
          return (this.pos += 4), e;
        }
        readI32() {
          let e = this.view.getInt32(this.pos);
          return (this.pos += 4), e;
        }
        readU64() {
          var e, t;
          let r =
            ((e = this.view),
            (t = this.pos),
            0x100000000 * e.getUint32(t) + e.getUint32(t + 4));
          return (this.pos += 8), r;
        }
        readI64() {
          let e = iE(this.view, this.pos);
          return (this.pos += 8), e;
        }
        readU64AsBigInt() {
          let e = this.view.getBigUint64(this.pos);
          return (this.pos += 8), e;
        }
        readI64AsBigInt() {
          let e = this.view.getBigInt64(this.pos);
          return (this.pos += 8), e;
        }
        readF32() {
          let e = this.view.getFloat32(this.pos);
          return (this.pos += 4), e;
        }
        readF64() {
          let e = this.view.getFloat64(this.pos);
          return (this.pos += 8), e;
        }
      }
      class iW {
        constructor(e) {
          (this.entered = !1),
            (this.extensionCodec = e?.extensionCodec ?? iA.defaultCodec),
            (this.context = e?.context),
            (this.useBigInt64 = e?.useBigInt64 ?? !1),
            (this.maxDepth = e?.maxDepth ?? 100),
            (this.initialBufferSize = e?.initialBufferSize ?? 2048),
            (this.sortKeys = e?.sortKeys ?? !1),
            (this.forceFloat32 = e?.forceFloat32 ?? !1),
            (this.ignoreUndefined = e?.ignoreUndefined ?? !1),
            (this.forceIntegerToFloat = e?.forceIntegerToFloat ?? !1),
            (this.pos = 0),
            (this.view = new DataView(new ArrayBuffer(this.initialBufferSize))),
            (this.bytes = new Uint8Array(this.view.buffer));
        }
        clone() {
          return new iW({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat,
          });
        }
        reinitializeState() {
          this.pos = 0;
        }
        encodeSharedRef(e) {
          if (this.entered) return this.clone().encodeSharedRef(e);
          try {
            return (
              (this.entered = !0),
              this.reinitializeState(),
              this.doEncode(e, 1),
              this.bytes.subarray(0, this.pos)
            );
          } finally {
            this.entered = !1;
          }
        }
        encode(e) {
          if (this.entered) return this.clone().encode(e);
          try {
            return (
              (this.entered = !0),
              this.reinitializeState(),
              this.doEncode(e, 1),
              this.bytes.slice(0, this.pos)
            );
          } finally {
            this.entered = !1;
          }
        }
        doEncode(e, t) {
          if (t > this.maxDepth) throw Error(`Too deep objects in depth ${t}`);
          null == e
            ? this.encodeNil()
            : "boolean" == typeof e
            ? this.encodeBoolean(e)
            : "number" == typeof e
            ? this.forceIntegerToFloat
              ? this.encodeNumberAsFloat(e)
              : this.encodeNumber(e)
            : "string" == typeof e
            ? this.encodeString(e)
            : this.useBigInt64 && "bigint" == typeof e
            ? this.encodeBigInt64(e)
            : this.encodeObject(e, t);
        }
        ensureBufferSizeToWrite(e) {
          let t = this.pos + e;
          this.view.byteLength < t && this.resizeBuffer(2 * t);
        }
        resizeBuffer(e) {
          let t = new ArrayBuffer(e),
            r = new Uint8Array(t),
            i = new DataView(t);
          r.set(this.bytes), (this.view = i), (this.bytes = r);
        }
        encodeNil() {
          this.writeU8(192);
        }
        encodeBoolean(e) {
          !1 === e ? this.writeU8(194) : this.writeU8(195);
        }
        encodeNumber(e) {
          !this.forceIntegerToFloat && Number.isSafeInteger(e)
            ? e >= 0
              ? e < 128
                ? this.writeU8(e)
                : e < 256
                ? (this.writeU8(204), this.writeU8(e))
                : e < 65536
                ? (this.writeU8(205), this.writeU16(e))
                : e < 0x100000000
                ? (this.writeU8(206), this.writeU32(e))
                : this.useBigInt64
                ? this.encodeNumberAsFloat(e)
                : (this.writeU8(207), this.writeU64(e))
              : e >= -32
              ? this.writeU8(224 | (e + 32))
              : e >= -128
              ? (this.writeU8(208), this.writeI8(e))
              : e >= -32768
              ? (this.writeU8(209), this.writeI16(e))
              : e >= -0x80000000
              ? (this.writeU8(210), this.writeI32(e))
              : this.useBigInt64
              ? this.encodeNumberAsFloat(e)
              : (this.writeU8(211), this.writeI64(e))
            : this.encodeNumberAsFloat(e);
        }
        encodeNumberAsFloat(e) {
          this.forceFloat32
            ? (this.writeU8(202), this.writeF32(e))
            : (this.writeU8(203), this.writeF64(e));
        }
        encodeBigInt64(e) {
          e >= BigInt(0)
            ? (this.writeU8(207), this.writeBigUint64(e))
            : (this.writeU8(211), this.writeBigInt64(e));
        }
        writeStringHeader(e) {
          if (e < 32) this.writeU8(160 + e);
          else if (e < 256) this.writeU8(217), this.writeU8(e);
          else if (e < 65536) this.writeU8(218), this.writeU16(e);
          else if (e < 0x100000000) this.writeU8(219), this.writeU32(e);
          else throw Error(`Too long string: ${e} bytes in UTF-8`);
        }
        encodeString(e) {
          let t = (function (e) {
            let t = e.length,
              r = 0,
              i = 0;
            for (; i < t; ) {
              let n = e.charCodeAt(i++);
              if ((0xffffff80 & n) == 0) {
                r++;
                continue;
              }
              if ((0xfffff800 & n) == 0) r += 2;
              else {
                if (n >= 55296 && n <= 56319 && i < t) {
                  let t = e.charCodeAt(i);
                  (64512 & t) == 56320 &&
                    (++i, (n = ((1023 & n) << 10) + (1023 & t) + 65536));
                }
                (0xffff0000 & n) == 0 ? (r += 3) : (r += 4);
              }
            }
            return r;
          })(e);
          this.ensureBufferSizeToWrite(5 + t),
            this.writeStringHeader(t),
            (function (e, t, r) {
              if (e.length > 50) i_.encodeInto(e, t.subarray(r));
              else
                !(function (e, t, r) {
                  let i = e.length,
                    n = r,
                    s = 0;
                  for (; s < i; ) {
                    let r = e.charCodeAt(s++);
                    if ((0xffffff80 & r) == 0) {
                      t[n++] = r;
                      continue;
                    }
                    if ((0xfffff800 & r) == 0) t[n++] = ((r >> 6) & 31) | 192;
                    else {
                      if (r >= 55296 && r <= 56319 && s < i) {
                        let t = e.charCodeAt(s);
                        (64512 & t) == 56320 &&
                          (++s, (r = ((1023 & r) << 10) + (1023 & t) + 65536));
                      }
                      (0xffff0000 & r) == 0
                        ? (t[n++] = ((r >> 12) & 15) | 224)
                        : ((t[n++] = ((r >> 18) & 7) | 240),
                          (t[n++] = ((r >> 12) & 63) | 128)),
                        (t[n++] = ((r >> 6) & 63) | 128);
                    }
                    t[n++] = (63 & r) | 128;
                  }
                })(e, t, r);
            })(e, this.bytes, this.pos),
            (this.pos += t);
        }
        encodeObject(e, t) {
          let r = this.extensionCodec.tryToEncode(e, this.context);
          if (null != r) this.encodeExtension(r);
          else if (Array.isArray(e)) this.encodeArray(e, t);
          else if (ArrayBuffer.isView(e)) this.encodeBinary(e);
          else if ("object" == typeof e) this.encodeMap(e, t);
          else
            throw Error(
              `Unrecognized object: ${Object.prototype.toString.apply(e)}`
            );
        }
        encodeBinary(e) {
          let t = e.byteLength;
          if (t < 256) this.writeU8(196), this.writeU8(t);
          else if (t < 65536) this.writeU8(197), this.writeU16(t);
          else if (t < 0x100000000) this.writeU8(198), this.writeU32(t);
          else throw Error(`Too large binary: ${t}`);
          let r = ik(e);
          this.writeU8a(r);
        }
        encodeArray(e, t) {
          let r = e.length;
          if (r < 16) this.writeU8(144 + r);
          else if (r < 65536) this.writeU8(220), this.writeU16(r);
          else if (r < 0x100000000) this.writeU8(221), this.writeU32(r);
          else throw Error(`Too large array: ${r}`);
          for (let r of e) this.doEncode(r, t + 1);
        }
        countWithoutUndefined(e, t) {
          let r = 0;
          for (let i of t) void 0 !== e[i] && r++;
          return r;
        }
        encodeMap(e, t) {
          let r = Object.keys(e);
          this.sortKeys && r.sort();
          let i = this.ignoreUndefined
            ? this.countWithoutUndefined(e, r)
            : r.length;
          if (i < 16) this.writeU8(128 + i);
          else if (i < 65536) this.writeU8(222), this.writeU16(i);
          else if (i < 0x100000000) this.writeU8(223), this.writeU32(i);
          else throw Error(`Too large map object: ${i}`);
          for (let i of r) {
            let r = e[i];
            (this.ignoreUndefined && void 0 === r) ||
              (this.encodeString(i), this.doEncode(r, t + 1));
          }
        }
        encodeExtension(e) {
          if ("function" == typeof e.data) {
            let t = e.data(this.pos + 6),
              r = t.length;
            if (r >= 0x100000000)
              throw Error(`Too large extension object: ${r}`);
            this.writeU8(201),
              this.writeU32(r),
              this.writeI8(e.type),
              this.writeU8a(t);
            return;
          }
          let t = e.data.length;
          if (1 === t) this.writeU8(212);
          else if (2 === t) this.writeU8(213);
          else if (4 === t) this.writeU8(214);
          else if (8 === t) this.writeU8(215);
          else if (16 === t) this.writeU8(216);
          else if (t < 256) this.writeU8(199), this.writeU8(t);
          else if (t < 65536) this.writeU8(200), this.writeU16(t);
          else if (t < 0x100000000) this.writeU8(201), this.writeU32(t);
          else throw Error(`Too large extension object: ${t}`);
          this.writeI8(e.type), this.writeU8a(e.data);
        }
        writeU8(e) {
          this.ensureBufferSizeToWrite(1),
            this.view.setUint8(this.pos, e),
            this.pos++;
        }
        writeU8a(e) {
          let t = e.length;
          this.ensureBufferSizeToWrite(t),
            this.bytes.set(e, this.pos),
            (this.pos += t);
        }
        writeI8(e) {
          this.ensureBufferSizeToWrite(1),
            this.view.setInt8(this.pos, e),
            this.pos++;
        }
        writeU16(e) {
          this.ensureBufferSizeToWrite(2),
            this.view.setUint16(this.pos, e),
            (this.pos += 2);
        }
        writeI16(e) {
          this.ensureBufferSizeToWrite(2),
            this.view.setInt16(this.pos, e),
            (this.pos += 2);
        }
        writeU32(e) {
          this.ensureBufferSizeToWrite(4),
            this.view.setUint32(this.pos, e),
            (this.pos += 4);
        }
        writeI32(e) {
          this.ensureBufferSizeToWrite(4),
            this.view.setInt32(this.pos, e),
            (this.pos += 4);
        }
        writeF32(e) {
          this.ensureBufferSizeToWrite(4),
            this.view.setFloat32(this.pos, e),
            (this.pos += 4);
        }
        writeF64(e) {
          this.ensureBufferSizeToWrite(8),
            this.view.setFloat64(this.pos, e),
            (this.pos += 8);
        }
        writeU64(e) {
          var t, r;
          this.ensureBufferSizeToWrite(8),
            (t = this.view),
            (r = this.pos),
            t.setUint32(r, e / 0x100000000),
            t.setUint32(r + 4, e),
            (this.pos += 8);
        }
        writeI64(e) {
          this.ensureBufferSizeToWrite(8),
            iC(this.view, this.pos, e),
            (this.pos += 8);
        }
        writeBigUint64(e) {
          this.ensureBufferSizeToWrite(8),
            this.view.setBigUint64(this.pos, e),
            (this.pos += 8);
        }
        writeBigInt64(e) {
          this.ensureBufferSizeToWrite(8),
            this.view.setBigInt64(this.pos, e),
            (this.pos += 8);
        }
      }
      function ij(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function iF(e, t) {
        return (
          !!Array.isArray(t) &&
          (0 === t.length ||
            (e
              ? t.every((e) => "string" == typeof e)
              : t.every((e) => Number.isSafeInteger(e))))
        );
      }
      function iH(e, t) {
        if ("string" != typeof t) throw Error(`${e}: string expected`);
        return !0;
      }
      function iq(e) {
        if (!Number.isSafeInteger(e)) throw Error(`invalid integer: ${e}`);
      }
      function iz(e) {
        if (!Array.isArray(e)) throw Error("array expected");
      }
      function iV(e, t) {
        if (!iF(!0, t)) throw Error(`${e}: array of strings expected`);
      }
      function iZ(e, t) {
        if (!iF(!1, t)) throw Error(`${e}: array of numbers expected`);
      }
      function iK(...e) {
        let t = (e) => e,
          r = (e, t) => (r) => e(t(r));
        return {
          encode: e.map((e) => e.encode).reduceRight(r, t),
          decode: e.map((e) => e.decode).reduce(r, t),
        };
      }
      function iG(e) {
        let t = "string" == typeof e ? e.split("") : e,
          r = t.length;
        iV("alphabet", t);
        let i = new Map(t.map((e, t) => [e, t]));
        return {
          encode: (i) => (
            iz(i),
            i.map((i) => {
              if (!Number.isSafeInteger(i) || i < 0 || i >= r)
                throw Error(
                  `alphabet.encode: digit index outside alphabet "${i}". Allowed: ${e}`
                );
              return t[i];
            })
          ),
          decode: (t) => (
            iz(t),
            t.map((t) => {
              iH("alphabet.decode", t);
              let r = i.get(t);
              if (void 0 === r)
                throw Error(`Unknown letter: "${t}". Allowed: ${e}`);
              return r;
            })
          ),
        };
      }
      function iJ(e = "") {
        return (
          iH("join", e),
          {
            encode: (t) => (iV("join.decode", t), t.join(e)),
            decode: (t) => (iH("join.decode", t), t.split(e)),
          }
        );
      }
      function iY(e, t, r) {
        if (t < 2)
          throw Error(
            `convertRadix: invalid from=${t}, base cannot be less than 2`
          );
        if (r < 2)
          throw Error(
            `convertRadix: invalid to=${r}, base cannot be less than 2`
          );
        if ((iz(e), !e.length)) return [];
        let i = 0,
          n = [],
          s = Array.from(e, (e) => {
            if ((iq(e), e < 0 || e >= t)) throw Error(`invalid integer: ${e}`);
            return e;
          }),
          a = s.length;
        for (;;) {
          let e = 0,
            o = !0;
          for (let n = i; n < a; n++) {
            let a = s[n],
              c = t * e,
              l = c + a;
            if (!Number.isSafeInteger(l) || c / t !== e || l - a !== c)
              throw Error("convertRadix: carry overflow");
            let d = l / r;
            e = l % r;
            let h = Math.floor(d);
            if (((s[n] = h), !Number.isSafeInteger(h) || h * r + e !== l))
              throw Error("convertRadix: carry overflow");
            o && (h ? (o = !1) : (i = n));
          }
          if ((n.push(e), o)) break;
        }
        for (let t = 0; t < e.length - 1 && 0 === e[t]; t++) n.push(0);
        return n.reverse();
      }
      let iX = (e, t) => (0 === t ? e : iX(t, e % t)),
        iQ = (e, t) => e + (t - iX(e, t)),
        i0 = (() => {
          let e = [];
          for (let t = 0; t < 40; t++) e.push(2 ** t);
          return e;
        })();
      function i1(e, t, r, i) {
        if ((iz(e), t <= 0 || t > 32))
          throw Error(`convertRadix2: wrong from=${t}`);
        if (r <= 0 || r > 32) throw Error(`convertRadix2: wrong to=${r}`);
        if (iQ(t, r) > 32)
          throw Error(
            `convertRadix2: carry overflow from=${t} to=${r} carryBits=${iQ(
              t,
              r
            )}`
          );
        let n = 0,
          s = 0,
          a = i0[t],
          o = i0[r] - 1,
          c = [];
        for (let i of e) {
          if ((iq(i), i >= a))
            throw Error(`convertRadix2: invalid data word=${i} from=${t}`);
          if (((n = (n << t) | i), s + t > 32))
            throw Error(`convertRadix2: carry overflow pos=${s} from=${t}`);
          for (s += t; s >= r; s -= r) c.push(((n >> (s - r)) & o) >>> 0);
          let e = i0[s];
          if (void 0 === e) throw Error("invalid carry");
          n &= e - 1;
        }
        if (((n = (n << (r - s)) & o), !i && s >= t))
          throw Error("Excess padding");
        if (!i && n > 0) throw Error(`Non-zero padding: ${n}`);
        return i && s > 0 && c.push(n >>> 0), c;
      }
      let i2 = iK(
          (function (e, t = !1) {
            if ((iq(5), e <= 0 || e > 32))
              throw Error("radix2: bits should be in (0..32]");
            if (iQ(8, e) > 32 || iQ(e, 8) > 32)
              throw Error("radix2: carry overflow");
            return {
              encode: (r) => {
                if (!ij(r))
                  throw Error("radix2.encode input should be Uint8Array");
                return i1(Array.from(r), 8, e, !t);
              },
              decode: (r) => (
                iZ("radix2.decode", r), Uint8Array.from(i1(r, e, 8, t))
              ),
            };
          })(5),
          iG("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),
          (function (e, t = "=") {
            return (
              iq(5),
              iH("padding", t),
              {
                encode(r) {
                  for (iV("padding.encode", r); (r.length * e) % 8; ) r.push(t);
                  return r;
                },
                decode(r) {
                  iV("padding.decode", r);
                  let i = r.length;
                  if ((i * e) % 8)
                    throw Error(
                      "padding: invalid, string should have whole number of bytes"
                    );
                  for (; i > 0 && r[i - 1] === t; i--)
                    if (((i - 1) * e) % 8 == 0)
                      throw Error(
                        "padding: invalid, string has too much padding"
                      );
                  return r.slice(0, i);
                },
              }
            );
          })(5),
          iJ("")
        ),
        i3 =
          "function" == typeof Uint8Array.from([]).toBase64 &&
          "function" == typeof Uint8Array.fromBase64;
      (i = 58), iq(58);
      "function" == typeof Uint8Array.from([]).toHex && Uint8Array.fromHex;
      function i5(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function i4(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? i5(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function i6(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = i4(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return i5(r);
      }
      let i8 = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === c; ) i++, t++;
            for (
              var s = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var h = 0, u = s - 1;
                (0 !== d || h < n) && -1 !== u;
                u--, h++
              )
                (d += (o * a[u]) >>> 0),
                  (a[u] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * d + 1) >>> 0, l = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], u = 0, p = a - 1;
                (0 !== h || u < i) && -1 !== p;
                p--, u++
              )
                (h += (256 * l[p]) >>> 0),
                  (l[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = u), n++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      new Uint8Array(0);
      let i9 = (e) => {
        if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
          return e;
        if (e instanceof ArrayBuffer) return new Uint8Array(e);
        if (ArrayBuffer.isView(e))
          return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        throw Error("Unknown type, must be binary type");
      };
      class i7 {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class ne {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return nr(this, e);
        }
      }
      class nt {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return nr(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let nr = (e, t) =>
        new nt({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class ni {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new i7(e, t, r)),
            (this.decoder = new ne(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let nn = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new ni(e, t, r, i),
        ns = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = i8(r, t);
          return nn({ prefix: e, name: t, encode: i, decode: (e) => i9(n(e)) });
        },
        na = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          nn({
            prefix: t,
            name: e,
            encode: (e) =>
              ((e, t, r) => {
                let i = "=" === t[t.length - 1],
                  n = (1 << r) - 1,
                  s = "",
                  a = 0,
                  o = 0;
                for (let i = 0; i < e.length; ++i)
                  for (o = (o << 8) | e[i], a += 8; a > r; )
                    (a -= r), (s += t[n & (o >> a)]);
                if ((a && (s += t[n & (o << (r - a))]), i))
                  for (; (s.length * r) & 7; ) s += "=";
                return s;
              })(e, i, r),
            decode: (t) =>
              ((e, t, r, i) => {
                let n = {};
                for (let e = 0; e < t.length; ++e) n[t[e]] = e;
                let s = e.length;
                for (; "=" === e[s - 1]; ) --s;
                let a = new Uint8Array(((s * r) / 8) | 0),
                  o = 0,
                  c = 0,
                  l = 0;
                for (let t = 0; t < s; ++t) {
                  let s = n[e[t]];
                  if (void 0 === s) throw SyntaxError(`Non-${i} character`);
                  (c = (c << r) | s),
                    (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
                }
                if (o >= r || 255 & (c << (8 - o)))
                  throw SyntaxError("Unexpected end of data");
                return a;
              })(t, i, r, e),
          }),
        no = nn({
          prefix: "\0",
          name: "identity",
          encode: (e) => new TextDecoder().decode(e),
          decode: (e) => new TextEncoder().encode(e),
        }),
        nc = na({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
        nl = na({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3,
        }),
        nd = ns({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        nh = na({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4,
        }),
        nu = na({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4,
        }),
        np = na({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        nf = na({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        ng = na({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        nm = na({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        ny = na({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        nw = na({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        nb = na({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        }),
        nv = na({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5,
        }),
        nC = na({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5,
        }),
        nE = ns({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
        }),
        nx = ns({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        }),
        nA = ns({
          name: "base58btc",
          prefix: "z",
          alphabet:
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        }),
        n_ = ns({
          name: "base58flickr",
          prefix: "Z",
          alphabet:
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        }),
        nI = na({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        nS = na({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        nk = na({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        nN = na({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
        nT = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        nO = nT.reduce((e, t, r) => ((e[r] = t), e), []),
        nP = nT.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []),
        nR = nn({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += nO[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = nP[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        });
      function n$(e, t, r) {
        t = t || [];
        for (var i = (r = r || 0); e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (n$.bytes = r - i + 1), t;
      }
      function nD(e, t) {
        var r,
          i = 0,
          t = t || 0,
          n = 0,
          s = t,
          a = e.length;
        do {
          if (s >= a)
            throw ((nD.bytes = 0), RangeError("Could not decode varint"));
          (r = e[s++]),
            (i += n < 28 ? (127 & r) << n : (127 & r) * Math.pow(2, n)),
            (n += 7);
        } while (r >= 128);
        return (nD.bytes = s - t), i;
      }
      let nU = {
          encode: n$,
          decode: nD,
          encodingLength: function (e) {
            return e < 128
              ? 1
              : e < 16384
              ? 2
              : e < 2097152
              ? 3
              : e < 0x10000000
              ? 4
              : e < 0x800000000
              ? 5
              : e < 0x40000000000
              ? 6
              : e < 0x2000000000000
              ? 7
              : e < 0x100000000000000
              ? 8
              : e < 0x8000000000000000
              ? 9
              : 10;
          },
        },
        nM = (e, t = 0) => [nU.decode(e, t), nU.decode.bytes],
        nL = (e, t, r = 0) => (nU.encode(e, t, r), t),
        nB = (e) => nU.encodingLength(e),
        nW = (e, t) => {
          let r = t.byteLength,
            i = nB(e),
            n = i + nB(r),
            s = new Uint8Array(n + r);
          return nL(e, s, 0), nL(r, s, i), s.set(t, n), new nj(e, r, t, s);
        };
      class nj {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let nF = ({ name: e, code: t, encode: r }) => new nH(e, t, r);
      class nH {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? nW(this.code, t)
              : t.then((e) => nW(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let nq = (e) => async (t) =>
          new Uint8Array(await crypto.subtle.digest(e, t)),
        nz = nF({ name: "sha2-256", code: 18, encode: nq("SHA-256") }),
        nV = nF({ name: "sha2-512", code: 19, encode: nq("SHA-512") }),
        nZ = {
          code: 0,
          name: "identity",
          encode: i9,
          digest: (e) => nW(0, i9(e)),
        },
        nK = "raw",
        nG = 85,
        nJ = (e) => i9(e),
        nY = (e) => i9(e),
        nX = new TextEncoder(),
        nQ = new TextDecoder(),
        n0 = "json",
        n1 = 512,
        n2 = (e) => nX.encode(JSON.stringify(e)),
        n3 = (e) => JSON.parse(nQ.decode(e));
      class n5 {
        constructor(e, t, r, i) {
          (this.code = t),
            (this.version = e),
            (this.multihash = r),
            (this.bytes = i),
            (this.byteOffset = i.byteOffset),
            (this.byteLength = i.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
              byteOffset: si,
              byteLength: si,
              code: sr,
              version: sr,
              multihash: sr,
              bytes: sr,
              _baseCache: si,
              asCID: si,
            });
        }
        toV0() {
          if (0 === this.version) return this;
          {
            let { code: e, multihash: t } = this;
            if (e !== n9)
              throw Error("Cannot convert a non dag-pb CID to CIDv0");
            if (t.code !== n7)
              throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            return n5.createV0(t);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash,
                r = nW(e, t);
              return n5.createV1(this.code, r);
            }
            case 1:
              return this;
            default:
              throw Error(
                `Can not convert CID version ${this.version} to version 0. This is a bug please report`
              );
          }
        }
        equals(e) {
          var t, r;
          return (
            e &&
            this.code === e.code &&
            this.version === e.version &&
            ((t = this.multihash) === (r = e.multihash) ||
              (t.code === r.code &&
                t.size === r.size &&
                ((e, t) => {
                  if (e === t) return !0;
                  if (e.byteLength !== t.byteLength) return !1;
                  for (let r = 0; r < e.byteLength; r++)
                    if (e[r] !== t[r]) return !1;
                  return !0;
                })(t.bytes, r.bytes)))
          );
        }
        toString(e) {
          let { bytes: t, version: r, _baseCache: i } = this;
          return 0 === r
            ? n6(t, i, e || nA.encoder)
            : n8(t, i, e || np.encoder);
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes,
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(e) {
          return sn(/^0\.0/, ss), !!(e && (e[st] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw Error("Deprecated, use .toString()");
        }
        get codec() {
          throw Error(
            '"codec" property is deprecated, use integer "code" property instead'
          );
        }
        get buffer() {
          throw Error(
            "Deprecated .buffer property, use .bytes to get Uint8Array instead"
          );
        }
        get multibaseName() {
          throw Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof n5) return e;
          if (null != e && e.asCID === e) {
            let { version: t, code: r, multihash: i, bytes: n } = e;
            return new n5(t, r, i, n || se(t, r, i.bytes));
          }
          if (null == e || !0 !== e[st]) return null;
          {
            let { version: t, multihash: r, code: i } = e,
              n = ((e) => {
                let t = i9(e),
                  [r, i] = nM(t),
                  [n, s] = nM(t.subarray(i)),
                  a = t.subarray(i + s);
                if (a.byteLength !== n) throw Error("Incorrect length");
                return new nj(r, n, a, t);
              })(r);
            return n5.create(t, i, n);
          }
        }
        static create(e, t, r) {
          if ("number" != typeof t)
            throw Error("String codecs are no longer supported");
          switch (e) {
            case 0:
              if (t === n9) return new n5(e, t, r, r.bytes);
              throw Error(
                `Version 0 CID must use dag-pb (code: ${n9}) block encoding`
              );
            case 1: {
              let i = se(e, t, r.bytes);
              return new n5(e, t, r, i);
            }
            default:
              throw Error("Invalid version");
          }
        }
        static createV0(e) {
          return n5.create(0, n9, e);
        }
        static createV1(e, t) {
          return n5.create(1, e, t);
        }
        static decode(e) {
          let [t, r] = n5.decodeFirst(e);
          if (r.length) throw Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          let t = n5.inspectBytes(e),
            r = t.size - t.multihashSize,
            i = i9(e.subarray(r, r + t.multihashSize));
          if (i.byteLength !== t.multihashSize) throw Error("Incorrect length");
          let n = i.subarray(t.multihashSize - t.digestSize),
            s = new nj(t.multihashCode, t.digestSize, n, i);
          return [
            0 === t.version ? n5.createV0(s) : n5.createV1(t.codec, s),
            e.subarray(t.size),
          ];
        }
        static inspectBytes(e) {
          let t = 0,
            r = () => {
              let [r, i] = nM(e.subarray(t));
              return (t += i), r;
            },
            i = r(),
            n = n9;
          if (
            (18 === i ? ((i = 0), (t = 0)) : 1 === i && (n = r()),
            0 !== i && 1 !== i)
          )
            throw RangeError(`Invalid CID version ${i}`);
          let s = t,
            a = r(),
            o = r(),
            c = t + o;
          return {
            version: i,
            codec: n,
            multihashCode: a,
            digestSize: o,
            multihashSize: c - s,
            size: c,
          };
        }
        static parse(e, t) {
          let [r, i] = n4(e, t),
            n = n5.decode(i);
          return n._baseCache.set(r, e), n;
        }
      }
      let n4 = (e, t) => {
          switch (e[0]) {
            case "Q": {
              let r = t || nA;
              return [nA.prefix, r.decode(`${nA.prefix}${e}`)];
            }
            case nA.prefix: {
              let r = t || nA;
              return [nA.prefix, r.decode(e)];
            }
            case np.prefix: {
              let r = t || np;
              return [np.prefix, r.decode(e)];
            }
            default:
              if (null == t)
                throw Error(
                  "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
                );
              return [e[0], t.decode(e)];
          }
        },
        n6 = (e, t, r) => {
          let { prefix: i } = r;
          if (i !== nA.prefix)
            throw Error(`Cannot string encode V0 in ${r.name} encoding`);
          let n = t.get(i);
          if (null != n) return n;
          {
            let n = r.encode(e).slice(1);
            return t.set(i, n), n;
          }
        },
        n8 = (e, t, r) => {
          let { prefix: i } = r,
            n = t.get(i);
          if (null != n) return n;
          {
            let n = r.encode(e);
            return t.set(i, n), n;
          }
        },
        n9 = 112,
        n7 = 18,
        se = (e, t, r) => {
          let i = nB(e),
            n = i + nB(t),
            s = new Uint8Array(n + r.byteLength);
          return nL(e, s, 0), nL(t, s, i), s.set(r, n), s;
        },
        st = Symbol.for("@ipld/js-cid/CID"),
        sr = { writable: !1, configurable: !1, enumerable: !0 },
        si = { writable: !1, enumerable: !1, configurable: !1 },
        sn = (e, t) => {
          if (e.test("0.0.0-dev")) console.warn(t);
          else throw Error(t);
        },
        ss = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        sa = { ...n, ...s, ...a, ...o, ...c, ...l, ...d, ...h, ...u, ...p };
      function so(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...f, ...g });
      let sc = so(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        sl = so(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = i4((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        sd = {
          utf8: sc,
          "utf-8": sc,
          hex: sa.base16,
          latin1: sl,
          ascii: sl,
          binary: sl,
          ...sa,
        };
      function sh(e, t = "utf8") {
        let r = sd[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? i5(globalThis.Buffer.from(e, "utf-8"))
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function su(e, t = "utf8") {
        let r = sd[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      let sp = {
        waku: {
          publish: "waku_publish",
          batchPublish: "waku_batchPublish",
          subscribe: "waku_subscribe",
          batchSubscribe: "waku_batchSubscribe",
          subscription: "waku_subscription",
          unsubscribe: "waku_unsubscribe",
          batchUnsubscribe: "waku_batchUnsubscribe",
          batchFetchMessages: "waku_batchFetchMessages",
        },
        irn: {
          publish: "irn_publish",
          batchPublish: "irn_batchPublish",
          subscribe: "irn_subscribe",
          batchSubscribe: "irn_batchSubscribe",
          subscription: "irn_subscription",
          unsubscribe: "irn_unsubscribe",
          batchUnsubscribe: "irn_batchUnsubscribe",
          batchFetchMessages: "irn_batchFetchMessages",
        },
        iridium: {
          publish: "iridium_publish",
          batchPublish: "iridium_batchPublish",
          subscribe: "iridium_subscribe",
          batchSubscribe: "iridium_batchSubscribe",
          subscription: "iridium_subscription",
          unsubscribe: "iridium_unsubscribe",
          batchUnsubscribe: "iridium_batchUnsubscribe",
          batchFetchMessages: "iridium_batchFetchMessages",
        },
      };
      var sf = r(7873),
        sg = r(95704),
        sm = r(81029).Buffer;
      function sy(e) {
        let [t, r] = e.split(":");
        return { namespace: t, reference: r };
      }
      function sw(e, t) {
        return e.includes(":") ? [e] : t.chains || [];
      }
      var sb = Object.defineProperty,
        sv = Object.defineProperties,
        sC = Object.getOwnPropertyDescriptors,
        sE = Object.getOwnPropertySymbols,
        sx = Object.prototype.hasOwnProperty,
        sA = Object.prototype.propertyIsEnumerable,
        s_ = (e, t, r) =>
          t in e
            ? sb(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sI = (e, t) => {
          for (var r in t || (t = {})) sx.call(t, r) && s_(e, r, t[r]);
          if (sE) for (var r of sE(t)) sA.call(t, r) && s_(e, r, t[r]);
          return e;
        },
        sS = (e, t, r) => s_(e, "symbol" != typeof t ? t + "" : t, r);
      let sk = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      };
      function sN() {
        return (
          "u" > typeof sg &&
          "u" > typeof sg.versions &&
          "u" > typeof sg.versions.node
        );
      }
      function sT() {
        return (
          !(0, rP.getDocument)() &&
          !!(0, rP.getNavigator)() &&
          "ReactNative" === navigator.product
        );
      }
      function sO() {
        return !sN() && !!(0, rP.getNavigator)() && !!(0, rP.getDocument)();
      }
      function sP() {
        return sT()
          ? sk.reactNative
          : sN()
          ? sk.node
          : sO()
          ? sk.browser
          : sk.unknown;
      }
      function sR() {
        var e;
        try {
          return sT() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Application)
            ? null == (e = r.g.Application)
              ? void 0
              : e.applicationId
            : void 0;
        } catch {
          return;
        }
      }
      function s$() {
        return (
          (0, rR.g)() || { name: "", description: "", url: "", icons: [""] }
        );
      }
      function sD(e, t, i) {
        let n = (function () {
            if (
              sP() === sk.reactNative &&
              "u" > typeof r.g &&
              "u" > typeof (null == r.g ? void 0 : r.g.Platform)
            ) {
              let { OS: e, Version: t } = r.g.Platform;
              return [e, t].join("-");
            }
            let e =
              "undefined" == typeof document &&
              "undefined" != typeof navigator &&
              "ReactNative" === navigator.product
                ? new rk()
                : "undefined" != typeof navigator
                ? (function (e) {
                    var t =
                      "" !== e &&
                      rT.reduce(function (t, r) {
                        var i = r[0],
                          n = r[1];
                        if (t) return t;
                        var s = n.exec(e);
                        return !!s && [i, s];
                      }, !1);
                    if (!t) return null;
                    var r = t[0],
                      i = t[1];
                    if ("searchbot" === r) return new rS();
                    var n =
                      i[1] && i[1].split(".").join("_").split("_").slice(0, 3);
                    n
                      ? n.length < 3 &&
                        (n = rx(
                          rx([], n, !0),
                          (function (e) {
                            for (var t = [], r = 0; r < e; r++) t.push("0");
                            return t;
                          })(3 - n.length),
                          !0
                        ))
                      : (n = []);
                    var s = n.join("."),
                      a = (function (e) {
                        for (var t = 0, r = rO.length; t < r; t++) {
                          var i = rO[t],
                            n = i[0];
                          if (i[1].exec(e)) return n;
                        }
                        return null;
                      })(e),
                      o = rN.exec(e);
                    return o && o[1] ? new rI(r, s, a, o[1]) : new rA(r, s, a);
                  })(navigator.userAgent)
                : void 0 !== rE && rE.version
                ? new r_(rE.version.slice(1))
                : null;
            if (null === e) return "unknown";
            let t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
            return "browser" === e.type
              ? [t, e.name, e.version].join("-")
              : [t, e.version].join("-");
          })(),
          s = (function () {
            var e;
            let t = sP();
            return t === sk.browser
              ? [
                  t,
                  (null == (e = (0, rP.getLocation)()) ? void 0 : e.host) ||
                    "unknown",
                ].join(":")
              : t;
          })();
        return [[e, t].join("-"), ["js", i].join("-"), n, s].join("/");
      }
      function sU(e, t) {
        return e.filter((e) => t.includes(e)).length === e.length;
      }
      function sM(e) {
        return Object.fromEntries(e.entries());
      }
      function sL(e) {
        return new Map(Object.entries(e));
      }
      function sB(e = v.FIVE_MINUTES, t) {
        let r,
          i,
          n,
          s,
          a = (0, v.toMiliseconds)(e || v.FIVE_MINUTES);
        return {
          resolve: (e) => {
            n && r && (clearTimeout(n), r(e), (s = Promise.resolve(e)));
          },
          reject: (e) => {
            n && i && (clearTimeout(n), i(e));
          },
          done: () =>
            new Promise((e, o) => {
              if (s) return e(s);
              (n = setTimeout(() => {
                let e = Error(t);
                (s = Promise.reject(e)), o(e);
              }, a)),
                (r = e),
                (i = o);
            }),
        };
      }
      function sW(e, t, r) {
        return new Promise(async (i, n) => {
          let s = setTimeout(() => n(Error(r)), t);
          try {
            let t = await e;
            i(t);
          } catch (e) {
            n(e);
          }
          clearTimeout(s);
        });
      }
      function sj(e, t) {
        if ("string" == typeof t && t.startsWith(`${e}:`)) return t;
        if ("topic" === e.toLowerCase()) {
          if ("string" != typeof t)
            throw Error(
              'Value must be "string" for expirer target type: topic'
            );
          return `topic:${t}`;
        }
        if ("id" === e.toLowerCase()) {
          if ("number" != typeof t)
            throw Error('Value must be "number" for expirer target type: id');
          return `id:${t}`;
        }
        throw Error(`Unknown expirer target type: ${e}`);
      }
      function sF(e) {
        let [t, r] = e.split(":"),
          i = { id: void 0, topic: void 0 };
        if ("topic" === t && "string" == typeof r) i.topic = r;
        else if ("id" === t && Number.isInteger(Number(r))) i.id = Number(r);
        else
          throw Error(
            `Invalid target, expected id:number or topic:string, got ${t}:${r}`
          );
        return i;
      }
      function sH(e, t) {
        return (0, v.fromMiliseconds)(
          (t || Date.now()) + (0, v.toMiliseconds)(e)
        );
      }
      function sq(e) {
        return Date.now() >= (0, v.toMiliseconds)(e);
      }
      function sz(e, t) {
        return `${e}${t ? `:${t}` : ""}`;
      }
      function sV(e = [], t = []) {
        return [...new Set([...e, ...t])];
      }
      async function sZ({ id: e, topic: t, wcDeepLink: i }) {
        var n, s;
        try {
          if (!i) return;
          let a = "string" == typeof i ? JSON.parse(i) : i,
            o = a?.href;
          if ("string" != typeof o) return;
          let c = (function (e, t, r) {
              let i = `requestId=${t}&sessionTopic=${r}`;
              e.endsWith("/") && (e = e.slice(0, -1));
              let n = `${e}`;
              if (e.startsWith("https://t.me")) {
                let t = e.includes("?") ? "&startapp=" : "?startapp=";
                n = `${n}${t}${(function (e, t = !1) {
                  let r = sm.from(e).toString("base64");
                  return t ? r.replace(/[=]/g, "") : r;
                })(i, !0)}`;
              } else n = `${n}/wc?${i}`;
              return n;
            })(o, e, t),
            l = sP();
          if (l === sk.browser) {
            let e;
            if (!(null != (n = (0, rP.getDocument)()) && n.hasFocus()))
              return void console.warn(
                "Document does not have focus, skipping deeplink."
              );
            (s = c),
              (e = "_self"),
              !(function () {
                try {
                  return window.self !== window.top;
                } catch {
                  return !1;
                }
              })()
                ? (("u" > typeof window &&
                    (window.TelegramWebviewProxy ||
                      window.Telegram ||
                      window.TelegramWebviewProxyProto)) ||
                    s.startsWith("https://") ||
                    s.startsWith("http://")) &&
                  (e = "_blank")
                : (e = "_top"),
              window.open(s, e, "noreferrer noopener");
          } else
            l === sk.reactNative &&
              "u" > typeof (null == r.g ? void 0 : r.g.Linking) &&
              (await r.g.Linking.openURL(c));
        } catch (e) {
          console.error(e);
        }
      }
      async function sK(e, t) {
        let r = "";
        try {
          if (sO() && (r = localStorage.getItem(t))) return r;
          r = await e.getItem(t);
        } catch (e) {
          console.error(e);
        }
        return r;
      }
      function sG(e, t) {
        if (!e.includes(t)) return null;
        let r = e.split(/([&,?,=])/),
          i = r.indexOf(t);
        return r[i + 2];
      }
      function sJ() {
        return "u" > typeof crypto && null != crypto && crypto.randomUUID
          ? crypto.randomUUID()
          : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
              let t = (16 * Math.random()) | 0;
              return ("x" === e ? t : (3 & t) | 8).toString(16);
            });
      }
      function sY() {
        return "u" > typeof sg && "true" === sg.env.IS_VITEST;
      }
      function sX(e) {
        return sm.from(e, "base64").toString("utf-8");
      }
      class sQ {
        constructor({ limit: e }) {
          sS(this, "limit"),
            sS(this, "set"),
            (this.limit = e),
            (this.set = new Set());
        }
        add(e) {
          if (!this.set.has(e)) {
            if (this.set.size >= this.limit) {
              let e = this.set.values().next().value;
              e && this.set.delete(e);
            }
            this.set.add(e);
          }
        }
        has(e) {
          return this.set.has(e);
        }
      }
      let s0 = BigInt(0x100000000 - 1),
        s1 = BigInt(32);
      function s2(e, t = !1) {
        return t
          ? { h: Number(e & s0), l: Number((e >> s1) & s0) }
          : { h: 0 | Number((e >> s1) & s0), l: 0 | Number(e & s0) };
      }
      function s3(e, t = !1) {
        let r = e.length,
          i = new Uint32Array(r),
          n = new Uint32Array(r);
        for (let s = 0; s < r; s++) {
          let { h: r, l: a } = s2(e[s], t);
          [i[s], n[s]] = [r, a];
        }
        return [i, n];
      }
      let s5 = (e, t, r) => e >>> r,
        s4 = (e, t, r) => (e << (32 - r)) | (t >>> r),
        s6 = (e, t, r) => (e >>> r) | (t << (32 - r)),
        s8 = (e, t, r) => (e << (32 - r)) | (t >>> r),
        s9 = (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
        s7 = (e, t, r) => (e >>> (r - 32)) | (t << (64 - r));
      function ae(e, t, r, i) {
        let n = (t >>> 0) + (i >>> 0);
        return { h: (e + r + ((n / 0x100000000) | 0)) | 0, l: 0 | n };
      }
      let at = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
        ar = (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
        ai = (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
        an = (e, t, r, i, n) => (t + r + i + n + ((e / 0x100000000) | 0)) | 0,
        as = (e, t, r, i, n) =>
          (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
        aa = (e, t, r, i, n, s) =>
          (t + r + i + n + s + ((e / 0x100000000) | 0)) | 0,
        ao =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0;
      function ac(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function al(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function ad(e, ...t) {
        if (!ac(e)) throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function ah(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.createHasher");
        al(e.outputLen), al(e.blockLen);
      }
      function au(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function ap(e, t) {
        ad(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      function af(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function ag(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      function am(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function ay(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let aw = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function ab(e) {
        return (
          ((e << 24) & 0xff000000) |
          ((e << 8) & 0xff0000) |
          ((e >>> 8) & 65280) |
          ((e >>> 24) & 255)
        );
      }
      let av = aw ? (e) => e : (e) => ab(e),
        aC = aw
          ? (e) => e
          : function (e) {
              for (let t = 0; t < e.length; t++) e[t] = ab(e[t]);
              return e;
            },
        aE =
          "function" == typeof Uint8Array.from([]).toHex &&
          "function" == typeof Uint8Array.fromHex,
        ax = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
      function aA(e) {
        if ((ad(e), aE)) return e.toHex();
        let t = "";
        for (let r = 0; r < e.length; r++) t += ax[e[r]];
        return t;
      }
      let a_ = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function aI(e) {
        return e >= a_._0 && e <= a_._9
          ? e - a_._0
          : e >= a_.A && e <= a_.F
          ? e - (a_.A - 10)
          : e >= a_.a && e <= a_.f
          ? e - (a_.a - 10)
          : void 0;
      }
      function aS(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        if (aE) return Uint8Array.fromHex(e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, n = 0; t < r; t++, n += 2) {
          let r = aI(e.charCodeAt(n)),
            s = aI(e.charCodeAt(n + 1));
          if (void 0 === r || void 0 === s)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[n] + e[n + 1]) +
                '" at index ' +
                n
            );
          i[t] = 16 * r + s;
        }
        return i;
      }
      function ak(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e) throw Error("string expected");
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          ad(e),
          e
        );
      }
      function aN(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          ad(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let n = e[t];
          r.set(n, i), (i += n.length);
        }
        return r;
      }
      class aT {}
      function aO(e) {
        let t = (t) => e().update(ak(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function aP(e = 32) {
        if (ao && "function" == typeof ao.getRandomValues)
          return ao.getRandomValues(new Uint8Array(e));
        if (ao && "function" == typeof ao.randomBytes)
          return Uint8Array.from(ao.randomBytes(e));
        throw Error("crypto.getRandomValues must be defined");
      }
      let aR = BigInt(0),
        a$ = BigInt(1),
        aD = BigInt(2),
        aU = BigInt(7),
        aM = BigInt(256),
        aL = BigInt(113),
        aB = [],
        aW = [],
        aj = [];
      for (let e = 0, t = a$, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          aB.push(2 * (5 * i + r)),
          aW.push((((e + 1) * (e + 2)) / 2) % 64);
        let n = aR;
        for (let e = 0; e < 7; e++)
          (t = ((t << a$) ^ ((t >> aU) * aL)) % aM) & aD &&
            (n ^= a$ << ((a$ << BigInt(e)) - a$));
        aj.push(n);
      }
      let aF = s3(aj, !0),
        aH = aF[0],
        aq = aF[1],
        az = (e, t, r) =>
          r > 32
            ? ((e, t, r) => (t << (r - 32)) | (e >>> (64 - r)))(e, t, r)
            : ((e, t, r) => (e << r) | (t >>> (32 - r)))(e, t, r),
        aV = (e, t, r) =>
          r > 32
            ? ((e, t, r) => (e << (r - 32)) | (t >>> (64 - r)))(e, t, r)
            : ((e, t, r) => (t << r) | (e >>> (32 - r)))(e, t, r);
      class aZ extends aT {
        constructor(e, t, r, i = !1, n = 24) {
          if (
            (super(),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (this.enableXOF = !1),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = n),
            al(r),
            !(0 < e && e < 200))
          )
            throw Error("only keccak-f1600 function is supported");
          (this.state = new Uint8Array(200)), (this.state32 = af(this.state));
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          aC(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    n = (t + 2) % 10,
                    s = r[n],
                    a = r[n + 1],
                    o = az(s, a, 1) ^ r[i],
                    c = aV(s, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  n = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = aW[r],
                    s = az(t, n, i),
                    a = aV(t, n, i),
                    o = aB[r];
                  (t = e[o]), (n = e[o + 1]), (e[o] = s), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= aH[i]), (e[1] ^= aq[i]);
              }
              ag(r);
            })(this.state32, this.rounds),
            aC(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          au(this), ad((e = ak(e)));
          let { blockLen: t, state: r } = this,
            i = e.length;
          for (let n = 0; n < i; ) {
            let s = Math.min(t - this.pos, i - n);
            for (let t = 0; t < s; t++) r[this.pos++] ^= e[n++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          au(this, !1), ad(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
              (this.posOut += s),
              (i += s);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return al(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if ((ap(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), ag(this.state);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: n,
            enableXOF: s,
          } = this;
          return (
            e || (e = new aZ(t, r, i, s, n)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = n),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = s),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let aK = aO(() => new aZ(136, 1, 32));
      class aG extends aT {
        constructor(e, t, r, i) {
          super(),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.buffer = new Uint8Array(e)),
            (this.view = am(this.buffer));
        }
        update(e) {
          au(this), ad((e = ak(e)));
          let { view: t, buffer: r, blockLen: i } = this,
            n = e.length;
          for (let s = 0; s < n; ) {
            let a = Math.min(i - this.pos, n - s);
            if (a === i) {
              let t = am(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + a), this.pos),
              (this.pos += a),
              (s += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          au(this), ap(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: n } = this,
            { pos: s } = this;
          (t[s++] = 128),
            ag(this.buffer.subarray(s)),
            this.padOffset > i - s && (this.process(r, 0), (s = 0));
          for (let e = s; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(0xffffffff),
              a = Number((r >> n) & s),
              o = Number(r & s),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), n),
            this.process(r, 0);
          let a = am(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = o / 4,
            l = this.get();
          if (c > l.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, l[e], n);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.destroyed = s),
            (e.finished = n),
            (e.length = i),
            (e.pos = a),
            i % t && e.buffer.set(r),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
      }
      let aJ = Uint32Array.from([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        aY = Uint32Array.from([
          0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a,
          0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31,
          0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d,
          0xbefa4fa4,
        ]),
        aX = Uint32Array.from([
          0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372,
          0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1,
          0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19,
          0x137e2179,
        ]),
        aQ = Uint32Array.from([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        a0 = new Uint32Array(64);
      class a1 extends aG {
        constructor(e = 32) {
          super(64, e, 8, !1),
            (this.A = 0 | aJ[0]),
            (this.B = 0 | aJ[1]),
            (this.C = 0 | aJ[2]),
            (this.D = 0 | aJ[3]),
            (this.E = 0 | aJ[4]),
            (this.F = 0 | aJ[5]),
            (this.G = 0 | aJ[6]),
            (this.H = 0 | aJ[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: n, F: s, G: a, H: o } = this;
          return [e, t, r, i, n, s, a, o];
        }
        set(e, t, r, i, n, s, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | n),
            (this.F = 0 | s),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) a0[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = a0[e - 15],
              r = a0[e - 2],
              i = ay(t, 7) ^ ay(t, 18) ^ (t >>> 3),
              n = ay(r, 17) ^ ay(r, 19) ^ (r >>> 10);
            a0[e] = (n + a0[e - 7] + i + a0[e - 16]) | 0;
          }
          let { A: r, B: i, C: n, D: s, E: a, F: o, G: c, H: l } = this;
          for (let e = 0; e < 64; e++) {
            var d, h, u, p;
            let t =
                (l +
                  (ay(a, 6) ^ ay(a, 11) ^ ay(a, 25)) +
                  (((d = a) & o) ^ (~d & c)) +
                  aQ[e] +
                  a0[e]) |
                0,
              f =
                ((ay(r, 2) ^ ay(r, 13) ^ ay(r, 22)) +
                  (((h = r) & (u = i)) ^ (h & (p = n)) ^ (u & p))) |
                0;
            (l = c),
              (c = o),
              (o = a),
              (a = (s + t) | 0),
              (s = n),
              (n = i),
              (i = r),
              (r = (t + f) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (n = (n + this.C) | 0),
            (s = (s + this.D) | 0),
            (a = (a + this.E) | 0),
            (o = (o + this.F) | 0),
            (c = (c + this.G) | 0),
            (l = (l + this.H) | 0),
            this.set(r, i, n, s, a, o, c, l);
        }
        roundClean() {
          ag(a0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), ag(this.buffer);
        }
      }
      let a2 = s3(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        a3 = a2[0],
        a5 = a2[1],
        a4 = new Uint32Array(80),
        a6 = new Uint32Array(80);
      class a8 extends aG {
        constructor(e = 64) {
          super(128, e, 16, !1),
            (this.Ah = 0 | aX[0]),
            (this.Al = 0 | aX[1]),
            (this.Bh = 0 | aX[2]),
            (this.Bl = 0 | aX[3]),
            (this.Ch = 0 | aX[4]),
            (this.Cl = 0 | aX[5]),
            (this.Dh = 0 | aX[6]),
            (this.Dl = 0 | aX[7]),
            (this.Eh = 0 | aX[8]),
            (this.El = 0 | aX[9]),
            (this.Fh = 0 | aX[10]),
            (this.Fl = 0 | aX[11]),
            (this.Gh = 0 | aX[12]),
            (this.Gl = 0 | aX[13]),
            (this.Hh = 0 | aX[14]),
            (this.Hl = 0 | aX[15]);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: n,
            Cl: s,
            Dh: a,
            Dl: o,
            Eh: c,
            El: l,
            Fh: d,
            Fl: h,
            Gh: u,
            Gl: p,
            Hh: f,
            Hl: g,
          } = this;
          return [e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g];
        }
        set(e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | n),
            (this.Cl = 0 | s),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | c),
            (this.El = 0 | l),
            (this.Fh = 0 | d),
            (this.Fl = 0 | h),
            (this.Gh = 0 | u),
            (this.Gl = 0 | p),
            (this.Hh = 0 | f),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (a4[r] = e.getUint32(t)), (a6[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | a4[e - 15],
              r = 0 | a6[e - 15],
              i = s6(t, r, 1) ^ s6(t, r, 8) ^ s5(t, r, 7),
              n = s8(t, r, 1) ^ s8(t, r, 8) ^ s4(t, r, 7),
              s = 0 | a4[e - 2],
              a = 0 | a6[e - 2],
              o = s6(s, a, 19) ^ s9(s, a, 61) ^ s5(s, a, 6),
              c = ai(
                n,
                s8(s, a, 19) ^ s7(s, a, 61) ^ s4(s, a, 6),
                a6[e - 7],
                a6[e - 16]
              ),
              l = an(c, i, o, a4[e - 7], a4[e - 16]);
            (a4[e] = 0 | l), (a6[e] = 0 | c);
          }
          let {
            Ah: r,
            Al: i,
            Bh: n,
            Bl: s,
            Ch: a,
            Cl: o,
            Dh: c,
            Dl: l,
            Eh: d,
            El: h,
            Fh: u,
            Fl: p,
            Gh: f,
            Gl: g,
            Hh: m,
            Hl: y,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t = s6(d, h, 14) ^ s6(d, h, 18) ^ s9(d, h, 41),
              w = s8(d, h, 14) ^ s8(d, h, 18) ^ s7(d, h, 41),
              b = (d & u) ^ (~d & f),
              v = as(y, w, (h & p) ^ (~h & g), a5[e], a6[e]),
              C = aa(v, m, t, b, a3[e], a4[e]),
              E = 0 | v,
              x = s6(r, i, 28) ^ s9(r, i, 34) ^ s9(r, i, 39),
              A = s8(r, i, 28) ^ s7(r, i, 34) ^ s7(r, i, 39),
              _ = (r & n) ^ (r & a) ^ (n & a),
              I = (i & s) ^ (i & o) ^ (s & o);
            (m = 0 | f),
              (y = 0 | g),
              (f = 0 | u),
              (g = 0 | p),
              (u = 0 | d),
              (p = 0 | h),
              ({ h: d, l: h } = ae(0 | c, 0 | l, 0 | C, 0 | E)),
              (c = 0 | a),
              (l = 0 | o),
              (a = 0 | n),
              (o = 0 | s),
              (n = 0 | r),
              (s = 0 | i);
            let S = at(E, A, I);
            (r = ar(S, C, x, _)), (i = 0 | S);
          }
          ({ h: r, l: i } = ae(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: n, l: s } = ae(0 | this.Bh, 0 | this.Bl, 0 | n, 0 | s)),
            ({ h: a, l: o } = ae(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: c, l: l } = ae(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
            ({ h: d, l: h } = ae(0 | this.Eh, 0 | this.El, 0 | d, 0 | h)),
            ({ h: u, l: p } = ae(0 | this.Fh, 0 | this.Fl, 0 | u, 0 | p)),
            ({ h: f, l: g } = ae(0 | this.Gh, 0 | this.Gl, 0 | f, 0 | g)),
            ({ h: m, l: y } = ae(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
            this.set(r, i, n, s, a, o, c, l, d, h, u, p, f, g, m, y);
        }
        roundClean() {
          ag(a4, a6);
        }
        destroy() {
          ag(this.buffer),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      class a9 extends a8 {
        constructor() {
          super(48),
            (this.Ah = 0 | aY[0]),
            (this.Al = 0 | aY[1]),
            (this.Bh = 0 | aY[2]),
            (this.Bl = 0 | aY[3]),
            (this.Ch = 0 | aY[4]),
            (this.Cl = 0 | aY[5]),
            (this.Dh = 0 | aY[6]),
            (this.Dl = 0 | aY[7]),
            (this.Eh = 0 | aY[8]),
            (this.El = 0 | aY[9]),
            (this.Fh = 0 | aY[10]),
            (this.Fl = 0 | aY[11]),
            (this.Gh = 0 | aY[12]),
            (this.Gl = 0 | aY[13]),
            (this.Hh = 0 | aY[14]),
            (this.Hl = 0 | aY[15]);
        }
      }
      let a7 = Uint32Array.from([
        0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151,
        0x96387719, 0x5940eabd, 0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992,
        0x2b0199fc, 0x2c85b8aa, 0xeb72ddc, 0x81c52ca2,
      ]);
      class oe extends a8 {
        constructor() {
          super(32),
            (this.Ah = 0 | a7[0]),
            (this.Al = 0 | a7[1]),
            (this.Bh = 0 | a7[2]),
            (this.Bl = 0 | a7[3]),
            (this.Ch = 0 | a7[4]),
            (this.Cl = 0 | a7[5]),
            (this.Dh = 0 | a7[6]),
            (this.Dl = 0 | a7[7]),
            (this.Eh = 0 | a7[8]),
            (this.El = 0 | a7[9]),
            (this.Fh = 0 | a7[10]),
            (this.Fl = 0 | a7[11]),
            (this.Gh = 0 | a7[12]),
            (this.Gl = 0 | a7[13]),
            (this.Hh = 0 | a7[14]),
            (this.Hl = 0 | a7[15]);
        }
      }
      let ot = aO(() => new a1()),
        or = aO(() => new a8()),
        oi = aO(() => new a9()),
        on = aO(() => new oe()),
        os = Uint8Array.from([
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9,
          15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10,
          14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0,
          15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6,
          10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4,
          10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4,
          8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10,
          2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6,
          7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0,
          2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
          7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2,
          4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4,
          13, 7, 5, 15, 14, 1, 9,
        ]),
        oa = Uint32Array.from([
          0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b,
          0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f,
          0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179,
          0x5be0cd19,
        ]),
        oo = new Uint32Array(32);
      function oc(e, t, r, i, n, s) {
        let a = n[s],
          o = n[s + 1],
          c = oo[2 * e],
          l = oo[2 * e + 1],
          d = oo[2 * t],
          h = oo[2 * t + 1],
          u = oo[2 * r],
          p = oo[2 * r + 1],
          f = oo[2 * i],
          g = oo[2 * i + 1],
          m = at(c, d, a);
        (l = ar(m, l, h, o)),
          (c = 0 | m),
          ({ Dh: g, Dl: f } = { Dh: g ^ l, Dl: f ^ c }),
          ({ Dh: g, Dl: f } = { Dh: f, Dl: g }),
          ({ h: p, l: u } = ae(p, u, g, f)),
          ({ Bh: h, Bl: d } = { Bh: h ^ p, Bl: d ^ u }),
          ({ Bh: h, Bl: d } = { Bh: s6(h, d, 24), Bl: s8(h, d, 24) }),
          (oo[2 * e] = c),
          (oo[2 * e + 1] = l),
          (oo[2 * t] = d),
          (oo[2 * t + 1] = h),
          (oo[2 * r] = u),
          (oo[2 * r + 1] = p),
          (oo[2 * i] = f),
          (oo[2 * i + 1] = g);
      }
      function ol(e, t, r, i, n, s) {
        let a = n[s],
          o = n[s + 1],
          c = oo[2 * e],
          l = oo[2 * e + 1],
          d = oo[2 * t],
          h = oo[2 * t + 1],
          u = oo[2 * r],
          p = oo[2 * r + 1],
          f = oo[2 * i],
          g = oo[2 * i + 1],
          m = at(c, d, a);
        (l = ar(m, l, h, o)),
          (c = 0 | m),
          ({ Dh: g, Dl: f } = { Dh: g ^ l, Dl: f ^ c }),
          ({ Dh: g, Dl: f } = { Dh: s6(g, f, 16), Dl: s8(g, f, 16) }),
          ({ h: p, l: u } = ae(p, u, g, f)),
          ({ Bh: h, Bl: d } = { Bh: h ^ p, Bl: d ^ u }),
          ({ Bh: h, Bl: d } = { Bh: s9(h, d, 63), Bl: s7(h, d, 63) }),
          (oo[2 * e] = c),
          (oo[2 * e + 1] = l),
          (oo[2 * t] = d),
          (oo[2 * t + 1] = h),
          (oo[2 * r] = u),
          (oo[2 * r + 1] = p),
          (oo[2 * i] = f),
          (oo[2 * i + 1] = g);
      }
      class od extends aT {
        constructor(e, t) {
          super(),
            (this.finished = !1),
            (this.destroyed = !1),
            (this.length = 0),
            (this.pos = 0),
            al(e),
            al(t),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.buffer = new Uint8Array(e)),
            (this.buffer32 = af(this.buffer));
        }
        update(e) {
          au(this), ad((e = ak(e)));
          let { blockLen: t, buffer: r, buffer32: i } = this,
            n = e.length,
            s = e.byteOffset,
            a = e.buffer;
          for (let o = 0; o < n; ) {
            this.pos === t &&
              (aC(i), this.compress(i, 0, !1), aC(i), (this.pos = 0));
            let c = Math.min(t - this.pos, n - o),
              l = s + o;
            if (c === t && !(l % 4) && o + c < n) {
              let e = new Uint32Array(a, l, Math.floor((n - o) / 4));
              aC(e);
              for (let r = 0; o + t < n; r += i.length, o += t)
                (this.length += t), this.compress(e, r, !1);
              aC(e);
              continue;
            }
            r.set(e.subarray(o, o + c), this.pos),
              (this.pos += c),
              (this.length += c),
              (o += c);
          }
          return this;
        }
        digestInto(e) {
          au(this), ap(e, this);
          let { pos: t, buffer32: r } = this;
          (this.finished = !0),
            ag(this.buffer.subarray(t)),
            aC(r),
            this.compress(r, 0, !0),
            aC(r);
          let i = af(e);
          this.get().forEach((e, t) => (i[t] = av(e)));
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          let {
            buffer: t,
            length: r,
            finished: i,
            destroyed: n,
            outputLen: s,
            pos: a,
          } = this;
          return (
            e || (e = new this.constructor({ dkLen: s })),
            e.set(...this.get()),
            e.buffer.set(t),
            (e.destroyed = n),
            (e.finished = i),
            (e.length = r),
            (e.pos = a),
            (e.outputLen = s),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
      }
      class oh extends od {
        constructor(e = {}) {
          let t = void 0 === e.dkLen ? 64 : e.dkLen;
          super(128, t),
            (this.v0l = 0 | oa[0]),
            (this.v0h = 0 | oa[1]),
            (this.v1l = 0 | oa[2]),
            (this.v1h = 0 | oa[3]),
            (this.v2l = 0 | oa[4]),
            (this.v2h = 0 | oa[5]),
            (this.v3l = 0 | oa[6]),
            (this.v3h = 0 | oa[7]),
            (this.v4l = 0 | oa[8]),
            (this.v4h = 0 | oa[9]),
            (this.v5l = 0 | oa[10]),
            (this.v5h = 0 | oa[11]),
            (this.v6l = 0 | oa[12]),
            (this.v6h = 0 | oa[13]),
            (this.v7l = 0 | oa[14]),
            (this.v7h = 0 | oa[15]),
            (function (e, t = {}, r, i, n) {
              if ((al(64), e < 0 || e > 64))
                throw Error("outputLen bigger than keyLen");
              let { key: s, salt: a, personalization: o } = t;
              if (void 0 !== s && (s.length < 1 || s.length > r))
                throw Error("key length must be undefined or 1.." + r);
              if (void 0 !== a && 16 !== a.length)
                throw Error("salt must be undefined or 16");
              if (void 0 !== o && 16 !== o.length)
                throw Error("personalization must be undefined or 16");
            })(t, e, 64, 16, 16);
          let { key: r, personalization: i, salt: n } = e,
            s = 0;
          if (
            (void 0 !== r && (s = (r = ak(r)).length),
            (this.v0l ^= this.outputLen | (s << 8) | 0x1010000),
            void 0 !== n)
          ) {
            let e = af((n = ak(n)));
            (this.v4l ^= av(e[0])),
              (this.v4h ^= av(e[1])),
              (this.v5l ^= av(e[2])),
              (this.v5h ^= av(e[3]));
          }
          if (void 0 !== i) {
            let e = af((i = ak(i)));
            (this.v6l ^= av(e[0])),
              (this.v6h ^= av(e[1])),
              (this.v7l ^= av(e[2])),
              (this.v7h ^= av(e[3]));
          }
          if (void 0 !== r) {
            let e = new Uint8Array(this.blockLen);
            e.set(r), this.update(e);
          }
        }
        get() {
          let {
            v0l: e,
            v0h: t,
            v1l: r,
            v1h: i,
            v2l: n,
            v2h: s,
            v3l: a,
            v3h: o,
            v4l: c,
            v4h: l,
            v5l: d,
            v5h: h,
            v6l: u,
            v6h: p,
            v7l: f,
            v7h: g,
          } = this;
          return [e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g];
        }
        set(e, t, r, i, n, s, a, o, c, l, d, h, u, p, f, g) {
          (this.v0l = 0 | e),
            (this.v0h = 0 | t),
            (this.v1l = 0 | r),
            (this.v1h = 0 | i),
            (this.v2l = 0 | n),
            (this.v2h = 0 | s),
            (this.v3l = 0 | a),
            (this.v3h = 0 | o),
            (this.v4l = 0 | c),
            (this.v4h = 0 | l),
            (this.v5l = 0 | d),
            (this.v5h = 0 | h),
            (this.v6l = 0 | u),
            (this.v6h = 0 | p),
            (this.v7l = 0 | f),
            (this.v7h = 0 | g);
        }
        compress(e, t, r) {
          this.get().forEach((e, t) => (oo[t] = e)), oo.set(oa, 16);
          let { h: i, l: n } = s2(BigInt(this.length));
          (oo[24] = oa[8] ^ n),
            (oo[25] = oa[9] ^ i),
            r && ((oo[28] = ~oo[28]), (oo[29] = ~oo[29]));
          let s = 0;
          for (let r = 0; r < 12; r++)
            oc(0, 4, 8, 12, e, t + 2 * os[s++]),
              ol(0, 4, 8, 12, e, t + 2 * os[s++]),
              oc(1, 5, 9, 13, e, t + 2 * os[s++]),
              ol(1, 5, 9, 13, e, t + 2 * os[s++]),
              oc(2, 6, 10, 14, e, t + 2 * os[s++]),
              ol(2, 6, 10, 14, e, t + 2 * os[s++]),
              oc(3, 7, 11, 15, e, t + 2 * os[s++]),
              ol(3, 7, 11, 15, e, t + 2 * os[s++]),
              oc(0, 5, 10, 15, e, t + 2 * os[s++]),
              ol(0, 5, 10, 15, e, t + 2 * os[s++]),
              oc(1, 6, 11, 12, e, t + 2 * os[s++]),
              ol(1, 6, 11, 12, e, t + 2 * os[s++]),
              oc(2, 7, 8, 13, e, t + 2 * os[s++]),
              ol(2, 7, 8, 13, e, t + 2 * os[s++]),
              oc(3, 4, 9, 14, e, t + 2 * os[s++]),
              ol(3, 4, 9, 14, e, t + 2 * os[s++]);
          (this.v0l ^= oo[0] ^ oo[16]),
            (this.v0h ^= oo[1] ^ oo[17]),
            (this.v1l ^= oo[2] ^ oo[18]),
            (this.v1h ^= oo[3] ^ oo[19]),
            (this.v2l ^= oo[4] ^ oo[20]),
            (this.v2h ^= oo[5] ^ oo[21]),
            (this.v3l ^= oo[6] ^ oo[22]),
            (this.v3h ^= oo[7] ^ oo[23]),
            (this.v4l ^= oo[8] ^ oo[24]),
            (this.v4h ^= oo[9] ^ oo[25]),
            (this.v5l ^= oo[10] ^ oo[26]),
            (this.v5h ^= oo[11] ^ oo[27]),
            (this.v6l ^= oo[12] ^ oo[28]),
            (this.v6h ^= oo[13] ^ oo[29]),
            (this.v7l ^= oo[14] ^ oo[30]),
            (this.v7h ^= oo[15] ^ oo[31]),
            ag(oo);
        }
        destroy() {
          (this.destroyed = !0),
            ag(this.buffer32),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let ou = (function (e) {
        let t = (t, r) => e(r).update(ak(t)).digest(),
          r = e({});
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = (t) => e(t)),
          t
        );
      })((e) => new oh(e));
      function op(e) {
        let t = `Ethereum Signed Message:
${e.length}`,
          r = new TextEncoder().encode(t + e);
        return "0x" + sm.from(aK(r)).toString("hex");
      }
      async function of(e, t, r, i, n, s) {
        switch (r.t) {
          case "eip191":
            return await og(e, t, r.s);
          case "eip1271":
            return await om(e, t, r.s, i, n, s);
          default:
            throw Error(
              `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
            );
        }
      }
      async function og(e, t, r) {
        return (
          (await im({ hash: op(t), signature: r })).toLowerCase() ===
          e.toLowerCase()
        );
      }
      async function om(e, t, r, i, n, s) {
        let a = sy(i);
        if (!a.namespace || !a.reference)
          throw Error(
            `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
          );
        try {
          let a = "0x1626ba7e",
            o = r.substring(2),
            c = (o.length / 2).toString(16).padStart(64, "0"),
            l = (t.startsWith("0x") ? t : op(t)).substring(2),
            d =
              a +
              l +
              "0000000000000000000000000000000000000000000000000000000000000040" +
              c +
              o,
            h = await fetch(
              `${
                s || "https://rpc.walletconnect.org/v1"
              }/?chainId=${i}&projectId=${n}`,
              {
                headers: { "Content-Type": "application/json" },
                method: "POST",
                body: JSON.stringify({
                  id: Date.now() + Math.floor(1e3 * Math.random()),
                  jsonrpc: "2.0",
                  method: "eth_call",
                  params: [{ to: e, data: d }, "latest"],
                }),
              }
            ),
            { result: u } = await h.json();
          return !!u && u.slice(0, a.length).toLowerCase() === a.toLowerCase();
        } catch (e) {
          return console.error("isValidEip1271Signature: ", e), !1;
        }
      }
      function oy(e) {
        let t = new Uint8Array(
          ot(
            (function (e) {
              if (e instanceof Uint8Array) return e;
              if (Array.isArray(e)) return new Uint8Array(e);
              if ("object" == typeof e && null != e && e.data)
                return new Uint8Array(Object.values(e.data));
              if ("object" == typeof e && e)
                return new Uint8Array(Object.values(e));
              throw Error(
                "getNearUint8ArrayFromBytes: Unexpected result type from bytes array"
              );
            })(e)
          )
        );
        return iy.A.encode(t);
      }
      function ow(e) {
        var t;
        let r = ((t = sm.from(e, "base64")), new iB(void 0).decode(t)).txn;
        if (!r) throw Error("Invalid signed transaction: missing 'txn' field");
        let i = new iW(void 0).encodeSharedRef(r),
          n = sm.from("TX"),
          s = on(sm.concat([n, sm.from(i)]));
        return i2.encode(s).replace(/=+$/, "");
      }
      function ob(e) {
        let t = [],
          r = BigInt(e);
        for (; r >= BigInt(128); )
          t.push(Number((r & BigInt(127)) | BigInt(128))), (r >>= BigInt(7));
        return t.push(Number(r)), sm.from(t);
      }
      var ov = Object.defineProperty,
        oC = Object.defineProperties,
        oE = Object.getOwnPropertyDescriptors,
        ox = Object.getOwnPropertySymbols,
        oA = Object.prototype.hasOwnProperty,
        o_ = Object.prototype.propertyIsEnumerable,
        oI = (e, t, r) =>
          t in e
            ? ov(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r);
      let oS = (e) => e?.split(":"),
        ok = (e) => {
          let t = e && oS(e);
          if (t) return t[2] + ":" + t[3];
        },
        oN = (e) => {
          let t = e && oS(e);
          if (t) return t.pop();
        };
      async function oT(e) {
        let { cacao: t, projectId: r } = e,
          { s: i, p: n } = t,
          s = oO(n, n.iss),
          a = oN(n.iss);
        return await of(a, s, i, ok(n.iss), r);
      }
      let oO = (e, t) => {
        let r = `${e.domain} wants you to sign in with your Ethereum account:`,
          i = oN(t);
        if (!e.aud && !e.uri)
          throw Error(
            "Either `aud` or `uri` is required to construct the message"
          );
        let n = e.statement || void 0,
          s = `URI: ${e.aud || e.uri}`,
          a = `Version: ${e.version}`,
          o = `Chain ID: ${((e) => {
            let t = e && oS(e);
            if (t) return e.includes("did:pkh:") ? t[3] : t[1];
          })(t)}`,
          c = `Nonce: ${e.nonce}`,
          l = `Issued At: ${e.iat}`,
          d = e.exp ? `Expiration Time: ${e.exp}` : void 0,
          h = e.nbf ? `Not Before: ${e.nbf}` : void 0,
          u = e.requestId ? `Request ID: ${e.requestId}` : void 0,
          p = e.resources
            ? `Resources:${e.resources
                .map(
                  (e) => `
- ${e}`
                )
                .join("")}`
            : void 0,
          f = oM(e.resources);
        return (
          f &&
            (n = (function (e = "", t) {
              oP(t);
              let r =
                "I further authorize the stated URI to perform the following actions on my behalf: ";
              if (e.includes(r)) return e;
              let i = [],
                n = 0;
              Object.keys(t.att).forEach((e) => {
                let r = Object.keys(t.att[e]).map((e) => ({
                  ability: e.split("/")[0],
                  action: e.split("/")[1],
                }));
                r.sort((e, t) => e.action.localeCompare(t.action));
                let s = {};
                r.forEach((e) => {
                  s[e.ability] || (s[e.ability] = []),
                    s[e.ability].push(e.action);
                });
                let a = Object.keys(s).map(
                  (t) => (
                    n++, `(${n}) '${t}': '${s[t].join("', '")}' for '${e}'.`
                  )
                );
                i.push(a.join(", ").replace(".,", "."));
              });
              let s = i.join(" "),
                a = `${r}${s}`;
              return `${e ? e + " " : ""}${a}`;
            })(n, o$(f))),
          [r, i, "", n, "", s, a, o, c, l, d, h, u, p].filter((e) => null != e)
            .join(`
`)
        );
      };
      function oP(e) {
        if (!e) throw Error("No recap provided, value is undefined");
        if (!e.att) throw Error("No `att` property found");
        let t = Object.keys(e.att);
        if (!(null != t && t.length))
          throw Error("No resources found in `att` property");
        t.forEach((t) => {
          let r = e.att[t];
          if (Array.isArray(r) || "object" != typeof r)
            throw Error(`Resource must be an object: ${t}`);
          if (!Object.keys(r).length)
            throw Error(`Resource object is empty: ${t}`);
          Object.keys(r).forEach((e) => {
            let t = r[e];
            if (!Array.isArray(t))
              throw Error(
                `Ability limits ${e} must be an array of objects, found: ${t}`
              );
            if (!t.length)
              throw Error(
                `Value of ${e} is empty array, must be an array with objects`
              );
            t.forEach((t) => {
              if ("object" != typeof t)
                throw Error(
                  `Ability limits (${e}) must be an array of objects, found: ${t}`
                );
            });
          });
        });
      }
      function oR(e) {
        return (
          oP(e),
          `urn:recap:${sm
            .from(JSON.stringify(e))
            .toString("base64")
            .replace(/=/g, "")}`
        );
      }
      function o$(e) {
        var t;
        let r =
          ((t = e.replace("urn:recap:", "")),
          JSON.parse(sm.from(t, "base64").toString("utf-8")));
        return oP(r), r;
      }
      function oD(e) {
        var t;
        let r = o$(e);
        oP(r);
        let i = null == (t = r.att) ? void 0 : t.eip155;
        return i ? Object.keys(i).map((e) => e.split("/")[1]) : [];
      }
      function oU(e) {
        let t = o$(e);
        oP(t);
        let r = [];
        return (
          Object.values(t.att).forEach((e) => {
            Object.values(e).forEach((e) => {
              var t;
              null != (t = e?.[0]) && t.chains && r.push(e[0].chains);
            });
          }),
          [...new Set(r.flat())]
        );
      }
      function oM(e) {
        if (!e) return;
        let t = e?.[e.length - 1];
        return t && t.includes("urn:recap:") ? t : void 0;
      }
      function oL(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function oB(e) {
        if ("boolean" != typeof e) throw Error(`boolean expected, not ${e}`);
      }
      function oW(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function oj(e, ...t) {
        if (!oL(e)) throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function oF(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function oH(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function oq(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      let oz = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function oV(e) {
        if ("string" == typeof e)
          e = (function (e) {
            if ("string" != typeof e) throw Error("string expected");
            return new Uint8Array(new TextEncoder().encode(e));
          })(e);
        else if (oL(e)) e = oG(e);
        else throw Error("Uint8Array expected, got " + typeof e);
        return e;
      }
      function oZ(e, t, r = !0) {
        if (void 0 === t) return new Uint8Array(e);
        if (t.length !== e)
          throw Error(
            "invalid output length, expected " + e + ", got: " + t.length
          );
        if (r && t.byteOffset % 4 != 0)
          throw Error("invalid output, must be aligned");
        return t;
      }
      function oK(e, t, r, i) {
        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, r, i);
        let n = BigInt(32),
          s = BigInt(0xffffffff),
          a = Number((r >> n) & s),
          o = Number(r & s),
          c = 4 * !!i,
          l = 4 * !i;
        e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
      }
      function oG(e) {
        return Uint8Array.from(e);
      }
      let oJ = (e) => Uint8Array.from(e.split("").map((e) => e.charCodeAt(0))),
        oY = oJ("expand 16-byte k"),
        oX = oJ("expand 32-byte k"),
        oQ = oH(oY),
        o0 = oH(oX);
      function o1(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function o2(e) {
        return e.byteOffset % 4 == 0;
      }
      let o3 = 0x100000000 - 1,
        o5 = new Uint32Array(),
        o4 = (e, t) => (255 & e[t++]) | ((255 & e[t++]) << 8);
      class o6 {
        constructor(e) {
          (this.blockLen = 16),
            (this.outputLen = 16),
            (this.buffer = new Uint8Array(16)),
            (this.r = new Uint16Array(10)),
            (this.h = new Uint16Array(10)),
            (this.pad = new Uint16Array(8)),
            (this.pos = 0),
            (this.finished = !1),
            oj((e = oV(e)), 32);
          let t = o4(e, 0),
            r = o4(e, 2),
            i = o4(e, 4),
            n = o4(e, 6),
            s = o4(e, 8),
            a = o4(e, 10),
            o = o4(e, 12),
            c = o4(e, 14);
          (this.r[0] = 8191 & t),
            (this.r[1] = ((t >>> 13) | (r << 3)) & 8191),
            (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
            (this.r[3] = ((i >>> 7) | (n << 9)) & 8191),
            (this.r[4] = ((n >>> 4) | (s << 12)) & 255),
            (this.r[5] = (s >>> 1) & 8190),
            (this.r[6] = ((s >>> 14) | (a << 2)) & 8191),
            (this.r[7] = ((a >>> 11) | (o << 5)) & 8065),
            (this.r[8] = ((o >>> 8) | (c << 8)) & 8191),
            (this.r[9] = (c >>> 5) & 127);
          for (let t = 0; t < 8; t++) this.pad[t] = o4(e, 16 + 2 * t);
        }
        process(e, t, r = !1) {
          let { h: i, r: n } = this,
            s = n[0],
            a = n[1],
            o = n[2],
            c = n[3],
            l = n[4],
            d = n[5],
            h = n[6],
            u = n[7],
            p = n[8],
            f = n[9],
            g = o4(e, t + 0),
            m = o4(e, t + 2),
            y = o4(e, t + 4),
            w = o4(e, t + 6),
            b = o4(e, t + 8),
            v = o4(e, t + 10),
            C = o4(e, t + 12),
            E = o4(e, t + 14),
            x = i[0] + (8191 & g),
            A = i[1] + (((g >>> 13) | (m << 3)) & 8191),
            _ = i[2] + (((m >>> 10) | (y << 6)) & 8191),
            I = i[3] + (((y >>> 7) | (w << 9)) & 8191),
            S = i[4] + (((w >>> 4) | (b << 12)) & 8191),
            k = i[5] + ((b >>> 1) & 8191),
            N = i[6] + (((b >>> 14) | (v << 2)) & 8191),
            T = i[7] + (((v >>> 11) | (C << 5)) & 8191),
            O = i[8] + (((C >>> 8) | (E << 8)) & 8191),
            P = i[9] + ((E >>> 5) | (2048 * !r)),
            R = 0,
            $ = 0 + x * s + 5 * f * A + 5 * p * _ + 5 * u * I + 5 * h * S;
          (R = $ >>> 13),
            ($ &= 8191),
            ($ += 5 * d * k + 5 * l * N + 5 * c * T + 5 * o * O + 5 * a * P),
            (R += $ >>> 13),
            ($ &= 8191);
          let D = R + x * a + A * s + 5 * f * _ + 5 * p * I + 5 * u * S;
          (R = D >>> 13),
            (D &= 8191),
            (D += 5 * h * k + 5 * d * N + 5 * l * T + 5 * c * O + 5 * o * P),
            (R += D >>> 13),
            (D &= 8191);
          let U = R + x * o + A * a + _ * s + 5 * f * I + 5 * p * S;
          (R = U >>> 13),
            (U &= 8191),
            (U += 5 * u * k + 5 * h * N + 5 * d * T + 5 * l * O + 5 * c * P),
            (R += U >>> 13),
            (U &= 8191);
          let M = R + x * c + A * o + _ * a + I * s + 5 * f * S;
          (R = M >>> 13),
            (M &= 8191),
            (M += 5 * p * k + 5 * u * N + 5 * h * T + 5 * d * O + 5 * l * P),
            (R += M >>> 13),
            (M &= 8191);
          let L = R + x * l + A * c + _ * o + I * a + S * s;
          (R = L >>> 13),
            (L &= 8191),
            (L += 5 * f * k + 5 * p * N + 5 * u * T + 5 * h * O + 5 * d * P),
            (R += L >>> 13),
            (L &= 8191);
          let B = R + x * d + A * l + _ * c + I * o + S * a;
          (R = B >>> 13),
            (B &= 8191),
            (B += k * s + 5 * f * N + 5 * p * T + 5 * u * O + 5 * h * P),
            (R += B >>> 13),
            (B &= 8191);
          let W = R + x * h + A * d + _ * l + I * c + S * o;
          (R = W >>> 13),
            (W &= 8191),
            (W += k * a + N * s + 5 * f * T + 5 * p * O + 5 * u * P),
            (R += W >>> 13),
            (W &= 8191);
          let j = R + x * u + A * h + _ * d + I * l + S * c;
          (R = j >>> 13),
            (j &= 8191),
            (j += k * o + N * a + T * s + 5 * f * O + 5 * p * P),
            (R += j >>> 13),
            (j &= 8191);
          let F = R + x * p + A * u + _ * h + I * d + S * l;
          (R = F >>> 13),
            (F &= 8191),
            (F += k * c + N * o + T * a + O * s + 5 * f * P),
            (R += F >>> 13),
            (F &= 8191);
          let H = R + x * f + A * p + _ * u + I * h + S * d;
          (R = H >>> 13),
            (H &= 8191),
            (H += k * l + N * c + T * o + O * a + P * s),
            (R += H >>> 13),
            (H &= 8191),
            ($ = 8191 & (R = ((R = ((R << 2) + R) | 0) + $) | 0)),
            (R >>>= 13),
            (D += R),
            (i[0] = $),
            (i[1] = D),
            (i[2] = U),
            (i[3] = M),
            (i[4] = L),
            (i[5] = B),
            (i[6] = W),
            (i[7] = j),
            (i[8] = F),
            (i[9] = H);
        }
        finalize() {
          let { h: e, pad: t } = this,
            r = new Uint16Array(10),
            i = e[1] >>> 13;
          e[1] &= 8191;
          for (let t = 2; t < 10; t++)
            (e[t] += i), (i = e[t] >>> 13), (e[t] &= 8191);
          (e[0] += 5 * i),
            (i = e[0] >>> 13),
            (e[0] &= 8191),
            (e[1] += i),
            (i = e[1] >>> 13),
            (e[1] &= 8191),
            (e[2] += i),
            (r[0] = e[0] + 5),
            (i = r[0] >>> 13),
            (r[0] &= 8191);
          for (let t = 1; t < 10; t++)
            (r[t] = e[t] + i), (i = r[t] >>> 13), (r[t] &= 8191);
          r[9] -= 8192;
          let n = (1 ^ i) - 1;
          for (let e = 0; e < 10; e++) r[e] &= n;
          n = ~n;
          for (let t = 0; t < 10; t++) e[t] = (e[t] & n) | r[t];
          (e[0] = (e[0] | (e[1] << 13)) & 65535),
            (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
            (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
            (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
            (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
            (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
            (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
            (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
          let s = e[0] + t[0];
          e[0] = 65535 & s;
          for (let r = 1; r < 8; r++)
            (s = (((e[r] + t[r]) | 0) + (s >>> 16)) | 0), (e[r] = 65535 & s);
          oq(r);
        }
        update(e) {
          oF(this), oj((e = oV(e)));
          let { buffer: t, blockLen: r } = this,
            i = e.length;
          for (let n = 0; n < i; ) {
            let s = Math.min(r - this.pos, i - n);
            if (s === r) {
              for (; r <= i - n; n += r) this.process(e, n);
              continue;
            }
            t.set(e.subarray(n, n + s), this.pos),
              (this.pos += s),
              (n += s),
              this.pos === r && (this.process(t, 0, !1), (this.pos = 0));
          }
          return this;
        }
        destroy() {
          oq(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
          oF(this),
            (function (e, t) {
              oj(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, h: r } = this,
            { pos: i } = this;
          if (i) {
            for (t[i++] = 1; i < 16; i++) t[i] = 0;
            this.process(t, 0, !0);
          }
          this.finalize();
          let n = 0;
          for (let t = 0; t < 8; t++)
            (e[n++] = r[t] >>> 0), (e[n++] = r[t] >>> 8);
          return e;
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
      }
      let o8 = (function (e) {
          let t = (t, r) => e(r).update(oV(t)).digest(),
            r = e(new Uint8Array(32));
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = (t) => e(t)),
            t
          );
        })((e) => new o6(e)),
        o9 = (function (e, t) {
          let {
            allowShortKeys: r,
            extendNonceFn: i,
            counterLength: n,
            counterRight: s,
            rounds: a,
          } = (function (e, t) {
            if (null == t || "object" != typeof t)
              throw Error("options must be defined");
            return Object.assign(e, t);
          })(
            {
              allowShortKeys: !1,
              counterLength: 8,
              counterRight: !1,
              rounds: 20,
            },
            t
          );
          if ("function" != typeof e) throw Error("core must be a function");
          return (
            oW(n),
            oW(a),
            oB(s),
            oB(r),
            (t, o, c, l, d = 0) => {
              oj(t), oj(o), oj(c);
              let h = c.length;
              if (
                (void 0 === l && (l = new Uint8Array(h)),
                oj(l),
                oW(d),
                d < 0 || d >= o3)
              )
                throw Error("arx: counter overflow");
              if (l.length < h)
                throw Error(
                  `arx: output (${l.length}) is shorter than data (${h})`
                );
              let u = [],
                p = t.length,
                f,
                g;
              if (32 === p) u.push((f = oG(t))), (g = o0);
              else if (16 === p && r)
                (f = new Uint8Array(32)).set(t),
                  f.set(t, 16),
                  (g = oQ),
                  u.push(f);
              else throw Error(`arx: invalid 32-byte key, got length=${p}`);
              o2(o) || u.push((o = oG(o)));
              let m = oH(f);
              if (i) {
                if (24 !== o.length)
                  throw Error("arx: extended nonce must be 24 bytes");
                i(g, m, oH(o.subarray(0, 16)), m), (o = o.subarray(16));
              }
              let y = 16 - n;
              if (y !== o.length)
                throw Error(`arx: nonce must be ${y} or 16 bytes`);
              if (12 !== y) {
                let e = new Uint8Array(12);
                e.set(o, s ? 0 : 12 - o.length), (o = e), u.push(o);
              }
              return (
                (function (e, t, r, i, n, s, a, o) {
                  let c = n.length,
                    l = new Uint8Array(64),
                    d = oH(l),
                    h = o2(n) && o2(s),
                    u = h ? oH(n) : o5,
                    p = h ? oH(s) : o5;
                  for (let f = 0; f < c; a++) {
                    if ((e(t, r, i, d, a, o), a >= o3))
                      throw Error("arx: counter overflow");
                    let g = Math.min(64, c - f);
                    if (h && 64 === g) {
                      let e = f / 4;
                      if (f % 4 != 0)
                        throw Error("arx: invalid block position");
                      for (let t = 0, r; t < 16; t++)
                        p[(r = e + t)] = u[r] ^ d[t];
                      f += 64;
                      continue;
                    }
                    for (let e = 0, t; e < g; e++) s[(t = f + e)] = n[t] ^ l[e];
                    f += g;
                  }
                })(e, g, m, oH(o), c, l, d, a),
                oq(...u),
                l
              );
            }
          );
        })(
          function (e, t, r, i, n, s = 20) {
            let a = e[0],
              o = e[1],
              c = e[2],
              l = e[3],
              d = t[0],
              h = t[1],
              u = t[2],
              p = t[3],
              f = t[4],
              g = t[5],
              m = t[6],
              y = t[7],
              w = r[0],
              b = r[1],
              v = r[2],
              C = a,
              E = o,
              x = c,
              A = l,
              _ = d,
              I = h,
              S = u,
              k = p,
              N = f,
              T = g,
              O = m,
              P = y,
              R = n,
              $ = w,
              D = b,
              U = v;
            for (let e = 0; e < s; e += 2)
              (N = (N + (R = o1(R ^ (C = (C + _) | 0), 16))) | 0),
                (C = (C + (_ = o1(_ ^ N, 12))) | 0),
                (N = (N + (R = o1(R ^ C, 8))) | 0),
                (_ = o1(_ ^ N, 7)),
                (T = (T + ($ = o1($ ^ (E = (E + I) | 0), 16))) | 0),
                (E = (E + (I = o1(I ^ T, 12))) | 0),
                (T = (T + ($ = o1($ ^ E, 8))) | 0),
                (I = o1(I ^ T, 7)),
                (O = (O + (D = o1(D ^ (x = (x + S) | 0), 16))) | 0),
                (x = (x + (S = o1(S ^ O, 12))) | 0),
                (O = (O + (D = o1(D ^ x, 8))) | 0),
                (S = o1(S ^ O, 7)),
                (P = (P + (U = o1(U ^ (A = (A + k) | 0), 16))) | 0),
                (A = (A + (k = o1(k ^ P, 12))) | 0),
                (P = (P + (U = o1(U ^ A, 8))) | 0),
                (k = o1(k ^ P, 7)),
                (O = (O + (U = o1(U ^ (C = (C + I) | 0), 16))) | 0),
                (C = (C + (I = o1(I ^ O, 12))) | 0),
                (O = (O + (U = o1(U ^ C, 8))) | 0),
                (I = o1(I ^ O, 7)),
                (P = (P + (R = o1(R ^ (E = (E + S) | 0), 16))) | 0),
                (E = (E + (S = o1(S ^ P, 12))) | 0),
                (P = (P + (R = o1(R ^ E, 8))) | 0),
                (S = o1(S ^ P, 7)),
                (N = (N + ($ = o1($ ^ (x = (x + k) | 0), 16))) | 0),
                (x = (x + (k = o1(k ^ N, 12))) | 0),
                (N = (N + ($ = o1($ ^ x, 8))) | 0),
                (k = o1(k ^ N, 7)),
                (T = (T + (D = o1(D ^ (A = (A + _) | 0), 16))) | 0),
                (A = (A + (_ = o1(_ ^ T, 12))) | 0),
                (T = (T + (D = o1(D ^ A, 8))) | 0),
                (_ = o1(_ ^ T, 7));
            let M = 0;
            (i[M++] = (a + C) | 0),
              (i[M++] = (o + E) | 0),
              (i[M++] = (c + x) | 0),
              (i[M++] = (l + A) | 0),
              (i[M++] = (d + _) | 0),
              (i[M++] = (h + I) | 0),
              (i[M++] = (u + S) | 0),
              (i[M++] = (p + k) | 0),
              (i[M++] = (f + N) | 0),
              (i[M++] = (g + T) | 0),
              (i[M++] = (m + O) | 0),
              (i[M++] = (y + P) | 0),
              (i[M++] = (n + R) | 0),
              (i[M++] = (w + $) | 0),
              (i[M++] = (b + D) | 0),
              (i[M++] = (v + U) | 0);
          },
          { counterRight: !1, counterLength: 4, allowShortKeys: !1 }
        ),
        o7 = new Uint8Array(16),
        ce = (e, t) => {
          e.update(t);
          let r = t.length % 16;
          r && e.update(o7.subarray(r));
        },
        ct = new Uint8Array(32);
      function cr(e, t, r, i, n) {
        let s = e(t, r, ct),
          a = o8.create(s);
        n && ce(a, n), ce(a, i);
        let o = (function (e, t, r) {
          oB(r);
          let i = new Uint8Array(16),
            n = new DataView(i.buffer, i.byteOffset, i.byteLength);
          return oK(n, 0, BigInt(t), r), oK(n, 8, BigInt(e), r), i;
        })(i.length, n ? n.length : 0, !0);
        a.update(o);
        let c = a.digest();
        return oq(s, o), c;
      }
      let ci = ((e, t) => {
        function r(i, ...n) {
          if ((oj(i), !oz))
            throw Error("Non little-endian hardware is not yet supported");
          if (void 0 !== e.nonceLength) {
            let t = n[0];
            if (!t) throw Error("nonce / iv required");
            e.varSizeNonce ? oj(t) : oj(t, e.nonceLength);
          }
          let s = e.tagLength;
          s && void 0 !== n[1] && oj(n[1]);
          let a = t(i, ...n),
            o = (e, t) => {
              if (void 0 !== t) {
                if (2 !== e) throw Error("cipher output not supported");
                oj(t);
              }
            },
            c = !1;
          return {
            encrypt(e, t) {
              if (c)
                throw Error("cannot encrypt() twice with same key + nonce");
              return (c = !0), oj(e), o(a.encrypt.length, t), a.encrypt(e, t);
            },
            decrypt(e, t) {
              if ((oj(e), s && e.length < s))
                throw Error(
                  "invalid ciphertext length: smaller than tagLength=" + s
                );
              return o(a.decrypt.length, t), a.decrypt(e, t);
            },
          };
        }
        return Object.assign(r, e), r;
      })(
        { blockSize: 64, nonceLength: 12, tagLength: 16 },
        ((e) => (t, r, i) => ({
          encrypt(n, s) {
            let a = n.length;
            (s = oZ(a + 16, s, !1)).set(n);
            let o = s.subarray(0, -16);
            e(t, r, o, o, 1);
            let c = cr(e, t, r, o, i);
            return s.set(c, a), oq(c), s;
          },
          decrypt(n, s) {
            s = oZ(n.length - 16, s, !1);
            let a = n.subarray(0, -16),
              o = n.subarray(-16),
              c = cr(e, t, r, a, i);
            if (
              !(function (e, t) {
                if (e.length !== t.length) return !1;
                let r = 0;
                for (let i = 0; i < e.length; i++) r |= e[i] ^ t[i];
                return 0 === r;
              })(o, c)
            )
              throw Error("invalid tag");
            return s.set(n.subarray(0, -16)), e(t, r, s, s, 1), oq(c), s;
          },
        }))(o9)
      );
      class cn extends aT {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), ah(e);
          let r = ak(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            n = new Uint8Array(i);
          n.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < n.length; e++) n[e] ^= 54;
          this.iHash.update(n), (this.oHash = e.create());
          for (let e = 0; e < n.length; e++) n[e] ^= 106;
          this.oHash.update(n), ag(n);
        }
        update(e) {
          return au(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          au(this),
            ad(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: n,
            blockLen: s,
            outputLen: a,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = n),
            (e.blockLen = s),
            (e.outputLen = a),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let cs = (e, t, r) => new cn(e, t).update(r).digest();
      cs.create = (e, t) => new cn(e, t);
      let ca = Uint8Array.from([0]),
        co = Uint8Array.of(),
        cc = BigInt(0),
        cl = BigInt(1);
      function cd(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      function ch(e) {
        let t = e.toString(16);
        return 1 & t.length ? "0" + t : t;
      }
      function cu(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? cc : BigInt("0x" + e);
      }
      function cp(e) {
        return ad(e), cu(aA(Uint8Array.from(e).reverse()));
      }
      function cf(e, t) {
        return aS(e.toString(16).padStart(2 * t, "0"));
      }
      function cg(e, t) {
        return cf(e, t).reverse();
      }
      function cm(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = aS(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (ac(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let n = i.length;
        if ("number" == typeof r && n !== r)
          throw Error(e + " of length " + r + " expected, got " + n);
        return i;
      }
      let cy = (e) => "bigint" == typeof e && cc <= e;
      function cw(e, t, r, i) {
        if (!(cy(t) && cy(r) && cy(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let cb = (e) => (cl << BigInt(e)) - cl;
      function cv(e, t, r = {}) {
        if (!e || "object" != typeof e)
          throw Error("expected valid options object");
        function i(t, r, i) {
          let n = e[t];
          if (i && void 0 === n) return;
          let s = typeof n;
          if (s !== r || null === n)
            throw Error(`param "${t}" is invalid: expected ${r}, got ${s}`);
        }
        Object.entries(t).forEach(([e, t]) => i(e, t, !1)),
          Object.entries(r).forEach(([e, t]) => i(e, t, !0));
      }
      function cC(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let n = t.get(r);
          if (void 0 !== n) return n;
          let s = e(r, ...i);
          return t.set(r, s), s;
        };
      }
      let cE = BigInt(0),
        cx = BigInt(1),
        cA = BigInt(2),
        c_ = BigInt(3),
        cI = BigInt(4),
        cS = BigInt(5),
        ck = BigInt(8);
      function cN(e, t) {
        let r = e % t;
        return r >= cE ? r : t + r;
      }
      function cT(e, t, r) {
        let i = e;
        for (; t-- > cE; ) (i *= i), (i %= r);
        return i;
      }
      function cO(e, t) {
        if (e === cE) throw Error("invert: expected non-zero number");
        if (t <= cE) throw Error("invert: expected positive modulus, got " + t);
        let r = cN(e, t),
          i = t,
          n = cE,
          s = cx;
        for (; r !== cE; ) {
          let e = i / r,
            t = i % r,
            a = n - s * e;
          (i = r), (r = t), (n = s), (s = a);
        }
        if (i !== cx) throw Error("invert: does not exist");
        return cN(n, t);
      }
      function cP(e, t) {
        let r = (e.ORDER + cx) / cI,
          i = e.pow(t, r);
        if (!e.eql(e.sqr(i), t)) throw Error("Cannot find square root");
        return i;
      }
      function cR(e, t) {
        let r = (e.ORDER - cS) / ck,
          i = e.mul(t, cA),
          n = e.pow(i, r),
          s = e.mul(t, n),
          a = e.mul(e.mul(s, cA), n),
          o = e.mul(s, e.sub(a, e.ONE));
        if (!e.eql(e.sqr(o), t)) throw Error("Cannot find square root");
        return o;
      }
      let c$ = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function cD(e, t, r = !1) {
        let i = Array(t.length).fill(r ? e.ZERO : void 0),
          n = t.reduce(
            (t, r, n) => (e.is0(r) ? t : ((i[n] = t), e.mul(t, r))),
            e.ONE
          ),
          s = e.inv(n);
        return (
          t.reduceRight(
            (t, r, n) =>
              e.is0(r) ? t : ((i[n] = e.mul(t, i[n])), e.mul(t, r)),
            s
          ),
          i
        );
      }
      function cU(e, t) {
        let r = (e.ORDER - cx) / cA,
          i = e.pow(t, r),
          n = e.eql(i, e.ONE),
          s = e.eql(i, e.ZERO),
          a = e.eql(i, e.neg(e.ONE));
        if (!n && !s && !a) throw Error("invalid Legendre symbol result");
        return n ? 1 : s ? 0 : -1;
      }
      function cM(e, t, r = !1, i = {}) {
        let n, s, a;
        if (e <= cE) throw Error("invalid field: expected ORDER > 0, got " + e);
        if ("object" == typeof t && null != t) {
          if (i.sqrt || r) throw Error("cannot specify opts in two arguments");
          t.BITS && (n = t.BITS),
            t.sqrt && (s = t.sqrt),
            "boolean" == typeof t.isLE && (r = t.isLE);
        } else "number" == typeof t && (n = t), i.sqrt && (s = i.sqrt);
        let { nBitLength: o, nByteLength: c } = (function (e, t) {
          void 0 !== t && al(t);
          let r = void 0 !== t ? t : e.toString(2).length,
            i = Math.ceil(r / 8);
          return { nBitLength: r, nByteLength: i };
        })(e, n);
        if (c > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let l = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: o,
          BYTES: c,
          MASK: cb(o),
          ZERO: cE,
          ONE: cx,
          create: (t) => cN(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return cE <= t && t < e;
          },
          is0: (e) => e === cE,
          isValidNot0: (e) => !l.is0(e) && l.isValid(e),
          isOdd: (e) => (e & cx) === cx,
          neg: (t) => cN(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => cN(t * t, e),
          add: (t, r) => cN(t + r, e),
          sub: (t, r) => cN(t - r, e),
          mul: (t, r) => cN(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < cE)
                throw Error("invalid exponent, negatives unsupported");
              if (r === cE) return e.ONE;
              if (r === cx) return t;
              let i = e.ONE,
                n = t;
              for (; r > cE; )
                r & cx && (i = e.mul(i, n)), (n = e.sqr(n)), (r >>= cx);
              return i;
            })(l, e, t),
          div: (t, r) => cN(t * cO(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => cO(t, e),
          sqrt:
            s ||
            ((t) => (
              a ||
                (a =
                  e % cI === c_
                    ? cP
                    : e % ck === cS
                    ? cR
                    : (function (e) {
                        if (e < BigInt(3))
                          throw Error("sqrt is not defined for small field");
                        let t = e - cx,
                          r = 0;
                        for (; t % cA === cE; ) (t /= cA), r++;
                        let i = cA,
                          n = cM(e);
                        for (; 1 === cU(n, i); )
                          if (i++ > 1e3)
                            throw Error(
                              "Cannot find square root: probably non-prime P"
                            );
                        if (1 === r) return cP;
                        let s = n.pow(i, t),
                          a = (t + cx) / cA;
                        return function (e, i) {
                          if (e.is0(i)) return i;
                          if (1 !== cU(e, i))
                            throw Error("Cannot find square root");
                          let n = r,
                            o = e.mul(e.ONE, s),
                            c = e.pow(i, t),
                            l = e.pow(i, a);
                          for (; !e.eql(c, e.ONE); ) {
                            if (e.is0(c)) return e.ZERO;
                            let t = 1,
                              r = e.sqr(c);
                            for (; !e.eql(r, e.ONE); )
                              if ((t++, (r = e.sqr(r)), t === n))
                                throw Error("Cannot find square root");
                            let i = cx << BigInt(n - t - 1),
                              s = e.pow(o, i);
                            (n = t),
                              (o = e.sqr(s)),
                              (c = e.mul(c, o)),
                              (l = e.mul(l, s));
                          }
                          return l;
                        };
                      })(e)),
              a(l, t)
            )),
          toBytes: (e) => (r ? cg(e, c) : cf(e, c)),
          fromBytes: (e) => {
            if (e.length !== c)
              throw Error(
                "Field.fromBytes: expected " + c + " bytes, got " + e.length
              );
            return r ? cp(e) : cu(aA(e));
          },
          invertBatch: (e) => cD(l, e),
          cmov: (e, t, r) => (r ? t : e),
        });
        return Object.freeze(l);
      }
      function cL(e) {
        if ("bigint" != typeof e) throw Error("field order must be bigint");
        return Math.ceil(e.toString(2).length / 8);
      }
      function cB(e) {
        let t = cL(e);
        return t + Math.ceil(t / 2);
      }
      let cW = BigInt(0),
        cj = BigInt(1);
      function cF(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function cH(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function cq(e, t) {
        cH(e, t);
        let r = Math.ceil(t / e) + 1,
          i = 2 ** (e - 1),
          n = 2 ** e;
        return {
          windows: r,
          windowSize: i,
          mask: cb(e),
          maxNumber: n,
          shiftBy: BigInt(e),
        };
      }
      function cz(e, t, r) {
        let { windowSize: i, mask: n, maxNumber: s, shiftBy: a } = r,
          o = Number(e & n),
          c = e >> a;
        o > i && ((o -= s), (c += cj));
        let l = t * i;
        return {
          nextN: c,
          offset: l + Math.abs(o) - 1,
          isZero: 0 === o,
          isNeg: o < 0,
          isNegF: t % 2 != 0,
          offsetF: l,
        };
      }
      let cV = new WeakMap(),
        cZ = new WeakMap();
      function cK(e) {
        return cZ.get(e) || 1;
      }
      function cG(e) {
        if (e !== cW) throw Error("invalid wNAF");
      }
      function cJ(e, t) {
        if (!t) return cM(e);
        if (t.ORDER !== e)
          throw Error("Field.ORDER must match order: Fp == p, Fn == n");
        return (
          cv(
            t,
            c$.reduce((e, t) => ((e[t] = "function"), e), {
              ORDER: "bigint",
              MASK: "bigint",
              BYTES: "number",
              BITS: "number",
            })
          ),
          t
        );
      }
      BigInt(0), BigInt(1), BigInt(2), BigInt(8);
      let cY = BigInt(0),
        cX = BigInt(1),
        cQ = BigInt(2);
      BigInt(0);
      let c0 = BigInt(1),
        c1 = BigInt(2),
        c2 = BigInt(3),
        c3 = BigInt(5),
        c5 = BigInt(8),
        c4 = {
          p: BigInt(
            "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
          ),
          n: BigInt(
            "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
          ),
          h: c5,
          a: BigInt(
            "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
          ),
          d: BigInt(
            "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
          ),
          Gx: BigInt(
            "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
          ),
          Gy: BigInt(
            "0x6666666666666666666666666666666666666666666666666666666666666658"
          ),
        };
      function c6(e) {
        return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
      }
      let c8 = (() => {
        let e = c4.p;
        return (function (e) {
          let {
              P: t,
              type: r,
              adjustScalarBytes: i,
              powPminus2: n,
              randomBytes: s,
            } = (cv(e, {
              adjustScalarBytes: "function",
              powPminus2: "function",
            }),
            Object.freeze({ ...e })),
            a = "x25519" === r;
          if (!a && "x448" !== r) throw Error("invalid type");
          let o = s || aP,
            c = a ? 255 : 448,
            l = a ? 32 : 56,
            d = BigInt(a ? 9 : 5),
            h = BigInt(a ? 121665 : 39081),
            u = a ? cQ ** BigInt(254) : cQ ** BigInt(447),
            p =
              u +
              (a
                ? BigInt(8) * cQ ** BigInt(251) - cX
                : BigInt(4) * cQ ** BigInt(445) - cX) +
              cX,
            f = (e) => cN(e, t),
            g = cg(f(d), l);
          function m(e, r) {
            let s = (function (e, r) {
              cw("u", e, cY, t), cw("scalar", r, u, p);
              let i = cX,
                s = cY,
                a = e,
                o = cX,
                l = cY;
              for (let t = BigInt(c - 1); t >= cY; t--) {
                let n = (r >> t) & cX;
                (l ^= n),
                  ({ x_2: i, x_3: a } = w(l, i, a)),
                  ({ x_2: s, x_3: o } = w(l, s, o)),
                  (l = n);
                let c = i + s,
                  d = f(c * c),
                  u = i - s,
                  p = f(u * u),
                  g = d - p,
                  m = a + o,
                  y = f((a - o) * c),
                  b = f(m * u),
                  v = y + b,
                  C = y - b;
                (a = f(v * v)),
                  (o = f(e * f(C * C))),
                  (i = f(d * p)),
                  (s = f(g * (d + f(h * g))));
              }
              return (
                ({ x_2: i, x_3: a } = w(l, i, a)),
                ({ x_2: s, x_3: o } = w(l, s, o)),
                f(i * n(s))
              );
            })(
              (function (e) {
                let t = cm("u coordinate", e, l);
                return a && (t[31] &= 127), f(cp(t));
              })(r),
              cp(i(cm("scalar", e, l)))
            );
            if (s === cY) throw Error("invalid private or public key received");
            return cg(f(s), l);
          }
          function y(e) {
            return m(e, g);
          }
          function w(e, t, r) {
            let i = f(e * (t - r));
            return { x_2: (t = f(t - i)), x_3: (r = f(r + i)) };
          }
          return {
            scalarMult: m,
            scalarMultBase: y,
            getSharedSecret: (e, t) => m(e, t),
            getPublicKey: (e) => y(e),
            utils: { randomPrivateKey: () => o(l) },
            GuBytes: g.slice(),
          };
        })({
          P: e,
          type: "x25519",
          powPminus2: (t) => {
            let { pow_p_5_8: r, b2: i } = (function (e) {
              let t = BigInt(10),
                r = BigInt(20),
                i = BigInt(40),
                n = BigInt(80),
                s = c4.p,
                a = (((e * e) % s) * e) % s,
                o = (cT(a, c1, s) * a) % s,
                c = (cT(o, c0, s) * e) % s,
                l = (cT(c, c3, s) * c) % s,
                d = (cT(l, t, s) * l) % s,
                h = (cT(d, r, s) * d) % s,
                u = (cT(h, i, s) * h) % s,
                p = (cT(u, n, s) * u) % s,
                f = (cT(p, n, s) * u) % s,
                g = (cT(f, t, s) * l) % s;
              return { pow_p_5_8: (cT(g, c1, s) * e) % s, b2: a };
            })(t);
            return cN(cT(r, c2, e) * i, e);
          },
          adjustScalarBytes: c6,
        });
      })();
      function c9(e) {
        void 0 !== e.lowS && cd("lowS", e.lowS),
          void 0 !== e.prehash && cd("prehash", e.prehash);
      }
      class c7 extends Error {
        constructor(e = "") {
          super(e);
        }
      }
      let le = {
          Err: c7,
          _tlv: {
            encode: (e, t) => {
              let { Err: r } = le;
              if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
              if (1 & t.length) throw new r("tlv.encode: unpadded data");
              let i = t.length / 2,
                n = ch(i);
              if ((n.length / 2) & 128)
                throw new r("tlv.encode: long form length too big");
              let s = i > 127 ? ch((n.length / 2) | 128) : "";
              return ch(e) + s + n + t;
            },
            decode(e, t) {
              let { Err: r } = le,
                i = 0;
              if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
              if (t.length < 2 || t[i++] !== e)
                throw new r("tlv.decode: wrong tlv");
              let n = t[i++],
                s = 0;
              if (128 & n) {
                let e = 127 & n;
                if (!e)
                  throw new r(
                    "tlv.decode(long): indefinite length not supported"
                  );
                if (e > 4)
                  throw new r("tlv.decode(long): byte length is too big");
                let a = t.subarray(i, i + e);
                if (a.length !== e)
                  throw new r("tlv.decode: length bytes not complete");
                if (0 === a[0])
                  throw new r("tlv.decode(long): zero leftmost byte");
                for (let e of a) s = (s << 8) | e;
                if (((i += e), s < 128))
                  throw new r("tlv.decode(long): not minimal encoding");
              } else s = n;
              let a = t.subarray(i, i + s);
              if (a.length !== s) throw new r("tlv.decode: wrong value length");
              return { v: a, l: t.subarray(i + s) };
            },
          },
          _int: {
            encode(e) {
              let { Err: t } = le;
              if (e < lt)
                throw new t("integer: negative integers are not allowed");
              let r = ch(e);
              if (
                (8 & Number.parseInt(r[0], 16) && (r = "00" + r), 1 & r.length)
              )
                throw new t("unexpected DER parsing assertion: unpadded hex");
              return r;
            },
            decode(e) {
              let { Err: t } = le;
              if (128 & e[0])
                throw new t("invalid signature integer: negative");
              if (0 === e[0] && !(128 & e[1]))
                throw new t(
                  "invalid signature integer: unnecessary leading zero"
                );
              return cu(aA(e));
            },
          },
          toSig(e) {
            let { Err: t, _int: r, _tlv: i } = le,
              n = cm("signature", e),
              { v: s, l: a } = i.decode(48, n);
            if (a.length)
              throw new t("invalid signature: left bytes after parsing");
            let { v: o, l: c } = i.decode(2, s),
              { v: l, l: d } = i.decode(2, c);
            if (d.length)
              throw new t("invalid signature: left bytes after parsing");
            return { r: r.decode(o), s: r.decode(l) };
          },
          hexFromSig(e) {
            let { _tlv: t, _int: r } = le,
              i = t.encode(2, r.encode(e.r)),
              n = t.encode(2, r.encode(e.s));
            return t.encode(48, i + n);
          },
        },
        lt = BigInt(0),
        lr = BigInt(1),
        li = BigInt(2),
        ln = BigInt(3),
        ls = BigInt(4);
      function la(e, t, r) {
        let { BYTES: i } = e;
        return function (n) {
          let s;
          if ("bigint" == typeof n) s = n;
          else {
            let r = cm("private key", n);
            if (t) {
              if (!t.includes(2 * r.length)) throw Error("invalid private key");
              let e = new Uint8Array(i);
              e.set(r, e.length - r.length), (r = e);
            }
            try {
              s = e.fromBytes(r);
            } catch {
              throw Error(
                `invalid private key: expected ui8a of size ${i}, got ${typeof n}`
              );
            }
          }
          if ((r && (s = e.create(s)), !e.isValidNot0(s)))
            throw Error("invalid private key: out of range [1..N-1]");
          return s;
        };
      }
      function lo(e) {
        return Uint8Array.of(e ? 2 : 3);
      }
      function lc(e, t) {
        let r = (t) =>
          (function (e) {
            let {
                CURVE: t,
                curveOpts: r,
                ecdsaOpts: i,
              } = (function (e) {
                let { CURVE: t, curveOpts: r } = (function (e) {
                  let t = {
                      a: e.a,
                      b: e.b,
                      p: e.Fp.ORDER,
                      n: e.n,
                      h: e.h,
                      Gx: e.Gx,
                      Gy: e.Gy,
                    },
                    r = {
                      Fp: e.Fp,
                      Fn: cM(t.n, e.nBitLength),
                      allowedPrivateKeyLengths: e.allowedPrivateKeyLengths,
                      allowInfinityPoint: e.allowInfinityPoint,
                      endo: e.endo,
                      wrapPrivateKey: e.wrapPrivateKey,
                      isTorsionFree: e.isTorsionFree,
                      clearCofactor: e.clearCofactor,
                      fromBytes: e.fromBytes,
                      toBytes: e.toBytes,
                    };
                  return { CURVE: t, curveOpts: r };
                })(e);
                return {
                  CURVE: t,
                  curveOpts: r,
                  ecdsaOpts: {
                    hash: e.hash,
                    hmac: e.hmac,
                    randomBytes: e.randomBytes,
                    lowS: e.lowS,
                    bits2int: e.bits2int,
                    bits2int_modN: e.bits2int_modN,
                  },
                };
              })(e),
              n = (function (e, t, r = {}) {
                cv(
                  t,
                  { hash: "function" },
                  {
                    hmac: "function",
                    lowS: "boolean",
                    randomBytes: "function",
                    bits2int: "function",
                    bits2int_modN: "function",
                  }
                );
                let i = t.randomBytes || aP,
                  n = t.hmac || ((e, ...r) => cs(t.hash, e, aN(...r))),
                  { Fp: s, Fn: a } = e,
                  { ORDER: o, BITS: c } = a;
                function l(e, t) {
                  if (!a.isValidNot0(t))
                    throw Error(
                      `invalid signature ${e}: out of range 1..CURVE.n`
                    );
                }
                class d {
                  constructor(e, t, r) {
                    l("r", e),
                      l("s", t),
                      (this.r = e),
                      (this.s = t),
                      null != r && (this.recovery = r),
                      Object.freeze(this);
                  }
                  static fromCompact(e) {
                    let t = a.BYTES,
                      r = cm("compactSignature", e, 2 * t);
                    return new d(
                      a.fromBytes(r.subarray(0, t)),
                      a.fromBytes(r.subarray(t, 2 * t))
                    );
                  }
                  static fromDER(e) {
                    let { r: t, s: r } = le.toSig(cm("DER", e));
                    return new d(t, r);
                  }
                  assertValidity() {}
                  addRecoveryBit(e) {
                    return new d(this.r, this.s, e);
                  }
                  recoverPublicKey(t) {
                    let r = s.ORDER,
                      { r: i, s: n, recovery: c } = this;
                    if (null == c || ![0, 1, 2, 3].includes(c))
                      throw Error("recovery id invalid");
                    if (o * li < r && c > 1)
                      throw Error("recovery id is ambiguous for h>1 curve");
                    let l = 2 === c || 3 === c ? i + o : i;
                    if (!s.isValid(l))
                      throw Error("recovery id 2 or 3 invalid");
                    let d = s.toBytes(l),
                      h = e.fromHex(aN(lo((1 & c) == 0), d)),
                      u = a.inv(l),
                      p = f(cm("msgHash", t)),
                      g = a.create(-p * u),
                      m = a.create(n * u),
                      y = e.BASE.multiplyUnsafe(g).add(h.multiplyUnsafe(m));
                    if (y.is0()) throw Error("point at infinify");
                    return y.assertValidity(), y;
                  }
                  hasHighS() {
                    return this.s > o >> lr;
                  }
                  normalizeS() {
                    return this.hasHighS()
                      ? new d(this.r, a.neg(this.s), this.recovery)
                      : this;
                  }
                  toBytes(e) {
                    if ("compact" === e)
                      return aN(a.toBytes(this.r), a.toBytes(this.s));
                    if ("der" === e) return aS(le.hexFromSig(this));
                    throw Error("invalid format");
                  }
                  toDERRawBytes() {
                    return this.toBytes("der");
                  }
                  toDERHex() {
                    return aA(this.toBytes("der"));
                  }
                  toCompactRawBytes() {
                    return this.toBytes("compact");
                  }
                  toCompactHex() {
                    return aA(this.toBytes("compact"));
                  }
                }
                let h = la(a, r.allowedPrivateKeyLengths, r.wrapPrivateKey);
                function u(t) {
                  if ("bigint" == typeof t) return !1;
                  if (t instanceof e) return !0;
                  let i = cm("key", t).length,
                    n = s.BYTES,
                    o = n + 1;
                  if (!(r.allowedPrivateKeyLengths || a.BYTES === o))
                    return i === o || i === 2 * n + 1;
                }
                let p =
                    t.bits2int ||
                    function (e) {
                      if (e.length > 8192) throw Error("input is too large");
                      let t = cu(aA(e)),
                        r = 8 * e.length - c;
                      return r > 0 ? t >> BigInt(r) : t;
                    },
                  f =
                    t.bits2int_modN ||
                    function (e) {
                      return a.create(p(e));
                    },
                  g = cb(c);
                function m(e) {
                  return cw("num < 2^" + c, e, lt, g), a.toBytes(e);
                }
                let y = { lowS: t.lowS, prehash: !1 },
                  w = { lowS: t.lowS, prehash: !1 };
                return (
                  e.BASE.precompute(8),
                  Object.freeze({
                    getPublicKey: function (t, r = !0) {
                      return e.fromPrivateKey(t).toBytes(r);
                    },
                    getSharedSecret: function (t, r, i = !0) {
                      if (!0 === u(t))
                        throw Error("first arg must be private key");
                      if (!1 === u(r))
                        throw Error("second arg must be public key");
                      return e.fromHex(r).multiply(h(t)).toBytes(i);
                    },
                    sign: function (r, c, l = y) {
                      let { seed: u, k2sig: g } = (function (r, n, c = y) {
                        if (["recovered", "canonical"].some((e) => e in c))
                          throw Error("sign() legacy options not supported");
                        let { hash: l } = t,
                          { lowS: u, prehash: g, extraEntropy: w } = c;
                        null == u && (u = !0),
                          (r = cm("msgHash", r)),
                          c9(c),
                          g && (r = cm("prehashed msgHash", l(r)));
                        let b = f(r),
                          v = h(n),
                          C = [m(v), m(b)];
                        if (null != w && !1 !== w) {
                          let e = !0 === w ? i(s.BYTES) : w;
                          C.push(cm("extraEntropy", e));
                        }
                        return {
                          seed: aN(...C),
                          k2sig: function (t) {
                            var r;
                            let i = p(t);
                            if (!a.isValidNot0(i)) return;
                            let n = a.inv(i),
                              s = e.BASE.multiply(i).toAffine(),
                              c = a.create(s.x);
                            if (c === lt) return;
                            let l = a.create(n * a.create(b + c * v));
                            if (l === lt) return;
                            let h = (2 * (s.x !== c)) | Number(s.y & lr),
                              f = l;
                            return (
                              u &&
                                l > o >> lr &&
                                ((f = (r = l) > o >> lr ? a.neg(r) : r),
                                (h ^= 1)),
                              new d(c, f, h)
                            );
                          },
                        };
                      })(r, c, l);
                      return (function (e, t, r) {
                        if ("number" != typeof e || e < 2)
                          throw Error("hashLen must be a number");
                        if ("number" != typeof t || t < 2)
                          throw Error("qByteLen must be a number");
                        if ("function" != typeof r)
                          throw Error("hmacFn must be a function");
                        let i = (e) => new Uint8Array(e),
                          n = (e) => Uint8Array.of(e),
                          s = i(e),
                          a = i(e),
                          o = 0,
                          c = () => {
                            s.fill(1), a.fill(0), (o = 0);
                          },
                          l = (...e) => r(a, s, ...e),
                          d = (e = i(0)) => {
                            (a = l(n(0), e)),
                              (s = l()),
                              0 !== e.length && ((a = l(n(1), e)), (s = l()));
                          },
                          h = () => {
                            if (o++ >= 1e3)
                              throw Error("drbg: tried 1000 values");
                            let e = 0,
                              r = [];
                            for (; e < t; ) {
                              let t = (s = l()).slice();
                              r.push(t), (e += s.length);
                            }
                            return aN(...r);
                          };
                        return (e, t) => {
                          let r;
                          for (c(), d(e); !(r = t(h())); ) d();
                          return c(), r;
                        };
                      })(
                        t.hash.outputLen,
                        a.BYTES,
                        n
                      )(u, g);
                    },
                    verify: function (r, i, n, s = w) {
                      let o, c;
                      (i = cm("msgHash", i)), (n = cm("publicKey", n)), c9(s);
                      let { lowS: l, prehash: h, format: u } = s;
                      if ("strict" in s)
                        throw Error("options.strict was renamed to lowS");
                      if (void 0 !== u && !["compact", "der", "js"].includes(u))
                        throw Error('format must be "compact", "der" or "js"');
                      let p = "string" == typeof r || ac(r),
                        g =
                          !p &&
                          !u &&
                          "object" == typeof r &&
                          null !== r &&
                          "bigint" == typeof r.r &&
                          "bigint" == typeof r.s;
                      if (!p && !g)
                        throw Error(
                          "invalid signature, expected Uint8Array, hex string or Signature instance"
                        );
                      try {
                        if (g)
                          if (void 0 === u || "js" === u) o = new d(r.r, r.s);
                          else throw Error("invalid format");
                        if (p) {
                          try {
                            "compact" !== u && (o = d.fromDER(r));
                          } catch (e) {
                            if (!(e instanceof le.Err)) throw e;
                          }
                          o || "der" === u || (o = d.fromCompact(r));
                        }
                        c = e.fromHex(n);
                      } catch {
                        return !1;
                      }
                      if (!o || (l && o.hasHighS())) return !1;
                      h && (i = t.hash(i));
                      let { r: m, s: y } = o,
                        b = f(i),
                        v = a.inv(y),
                        C = a.create(b * v),
                        E = a.create(m * v),
                        x = e.BASE.multiplyUnsafe(C).add(c.multiplyUnsafe(E));
                      return !x.is0() && a.create(x.x) === m;
                    },
                    utils: {
                      isValidPrivateKey(e) {
                        try {
                          return h(e), !0;
                        } catch {
                          return !1;
                        }
                      },
                      normPrivateKeyToScalar: h,
                      randomPrivateKey: () =>
                        (function (e, t, r = !1) {
                          let i = e.length,
                            n = cL(t),
                            s = cB(t);
                          if (i < 16 || i < s || i > 1024)
                            throw Error(
                              "expected " + s + "-1024 bytes of input, got " + i
                            );
                          let a = cN(r ? cp(e) : cu(aA(e)), t - cx) + cx;
                          return r ? cg(a, n) : cf(a, n);
                        })(i(cB(o)), o),
                      precompute: (t = 8, r = e.BASE) => r.precompute(t, !1),
                    },
                    Point: e,
                    Signature: d,
                  })
                );
              })(
                (function (e, t = {}) {
                  var r, i, n;
                  let { Fp: s, Fn: a } = (function (e, t, r = {}) {
                      if (!t || "object" != typeof t)
                        throw Error(`expected valid ${e} CURVE object`);
                      for (let e of ["p", "n", "h"]) {
                        let r = t[e];
                        if (!("bigint" == typeof r && r > cW))
                          throw Error(`CURVE.${e} must be positive bigint`);
                      }
                      let i = cJ(t.p, r.Fp),
                        n = cJ(t.n, r.Fn);
                      for (let r of [
                        "Gx",
                        "Gy",
                        "a",
                        "weierstrass" === e ? "b" : "d",
                      ])
                        if (!i.isValid(t[r]))
                          throw Error(
                            `CURVE.${r} must be valid field element of CURVE.Fp`
                          );
                      return { Fp: i, Fn: n };
                    })("weierstrass", e, t),
                    { h: o, n: c } = e;
                  cv(
                    t,
                    {},
                    {
                      allowInfinityPoint: "boolean",
                      clearCofactor: "function",
                      isTorsionFree: "function",
                      fromBytes: "function",
                      toBytes: "function",
                      endo: "object",
                      wrapPrivateKey: "boolean",
                    }
                  );
                  let { endo: l } = t;
                  if (
                    l &&
                    (!s.is0(e.a) ||
                      "bigint" != typeof l.beta ||
                      "function" != typeof l.splitScalar)
                  )
                    throw Error(
                      'invalid endo: expected "beta": bigint and "splitScalar": function'
                    );
                  function d() {
                    if (!s.isOdd)
                      throw Error(
                        "compression is not supported: Field does not have .isOdd()"
                      );
                  }
                  let h =
                      t.toBytes ||
                      function (e, t, r) {
                        let { x: i, y: n } = t.toAffine(),
                          a = s.toBytes(i);
                        return (cd("isCompressed", r), r)
                          ? (d(), aN(lo(!s.isOdd(n)), a))
                          : aN(Uint8Array.of(4), a, s.toBytes(n));
                      },
                    u =
                      t.fromBytes ||
                      function (e) {
                        ad(e);
                        let t = s.BYTES,
                          r = t + 1,
                          i = 2 * t + 1,
                          n = e.length,
                          a = e[0],
                          o = e.subarray(1);
                        if (n === r && (2 === a || 3 === a)) {
                          let e,
                            t = s.fromBytes(o);
                          if (!s.isValid(t))
                            throw Error("bad point: is not on curve, wrong x");
                          let r = p(t);
                          try {
                            e = s.sqrt(r);
                          } catch (e) {
                            throw Error(
                              "bad point: is not on curve, sqrt error" +
                                (e instanceof Error ? ": " + e.message : "")
                            );
                          }
                          return (
                            d(),
                            ((1 & a) == 1) !== s.isOdd(e) && (e = s.neg(e)),
                            { x: t, y: e }
                          );
                        }
                        if (n === i && 4 === a) {
                          let e = s.fromBytes(o.subarray(0 * t, +t)),
                            r = s.fromBytes(o.subarray(+t, 2 * t));
                          if (!f(e, r))
                            throw Error("bad point: is not on curve");
                          return { x: e, y: r };
                        }
                        throw Error(
                          `bad point: got length ${n}, expected compressed=${r} or uncompressed=${i}`
                        );
                      },
                    p =
                      ((r = e.a),
                      (i = e.b),
                      function (e) {
                        let t = s.sqr(e),
                          n = s.mul(t, e);
                        return s.add(s.add(n, s.mul(e, r)), i);
                      });
                  function f(e, t) {
                    let r = s.sqr(t),
                      i = p(e);
                    return s.eql(r, i);
                  }
                  if (!f(e.Gx, e.Gy))
                    throw Error("bad curve params: generator point");
                  let g = s.mul(s.pow(e.a, ln), ls),
                    m = s.mul(s.sqr(e.b), BigInt(27));
                  if (s.is0(s.add(g, m)))
                    throw Error("bad curve params: a or b");
                  function y(e, t, r = !1) {
                    if (!s.isValid(t) || (r && s.is0(t)))
                      throw Error(`bad point coordinate ${e}`);
                    return t;
                  }
                  function w(e) {
                    if (!(e instanceof E))
                      throw Error("ProjectivePoint expected");
                  }
                  let b = cC((e, t) => {
                      let { px: r, py: i, pz: n } = e;
                      if (s.eql(n, s.ONE)) return { x: r, y: i };
                      let a = e.is0();
                      null == t && (t = a ? s.ONE : s.inv(n));
                      let o = s.mul(r, t),
                        c = s.mul(i, t),
                        l = s.mul(n, t);
                      if (a) return { x: s.ZERO, y: s.ZERO };
                      if (!s.eql(l, s.ONE)) throw Error("invZ was invalid");
                      return { x: o, y: c };
                    }),
                    v = cC((e) => {
                      if (e.is0()) {
                        if (t.allowInfinityPoint && !s.is0(e.py)) return;
                        throw Error("bad point: ZERO");
                      }
                      let { x: r, y: i } = e.toAffine();
                      if (!s.isValid(r) || !s.isValid(i))
                        throw Error("bad point: x or y not field elements");
                      if (!f(r, i))
                        throw Error("bad point: equation left != right");
                      if (!e.isTorsionFree())
                        throw Error("bad point: not in prime-order subgroup");
                      return !0;
                    });
                  function C(e, t, r, i, n) {
                    return (
                      (r = new E(s.mul(r.px, e), r.py, r.pz)),
                      (t = cF(i, t)),
                      (r = cF(n, r)),
                      t.add(r)
                    );
                  }
                  class E {
                    constructor(e, t, r) {
                      (this.px = y("x", e)),
                        (this.py = y("y", t, !0)),
                        (this.pz = y("z", r)),
                        Object.freeze(this);
                    }
                    static fromAffine(e) {
                      let { x: t, y: r } = e || {};
                      if (!e || !s.isValid(t) || !s.isValid(r))
                        throw Error("invalid affine point");
                      if (e instanceof E)
                        throw Error("projective point not allowed");
                      return s.is0(t) && s.is0(r) ? E.ZERO : new E(t, r, s.ONE);
                    }
                    get x() {
                      return this.toAffine().x;
                    }
                    get y() {
                      return this.toAffine().y;
                    }
                    static normalizeZ(e) {
                      let t = cD(
                        E.Fp,
                        e.map((e) => e.pz)
                      );
                      return e
                        .map((e, r) => e.toAffine(t[r]))
                        .map(E.fromAffine);
                    }
                    static fromBytes(e) {
                      return ad(e), E.fromHex(e);
                    }
                    static fromHex(e) {
                      let t = E.fromAffine(u(cm("pointHex", e)));
                      return t.assertValidity(), t;
                    }
                    static fromPrivateKey(e) {
                      let r = la(
                        a,
                        t.allowedPrivateKeyLengths,
                        t.wrapPrivateKey
                      );
                      return E.BASE.multiply(r(e));
                    }
                    static msm(e, t) {
                      return (function (e, t, r, i) {
                        (function (e, t) {
                          if (!Array.isArray(e)) throw Error("array expected");
                          e.forEach((e, r) => {
                            if (!(e instanceof t))
                              throw Error("invalid point at index " + r);
                          });
                        })(r, e),
                          (function (e, t) {
                            if (!Array.isArray(e))
                              throw Error("array of scalars expected");
                            e.forEach((e, r) => {
                              if (!t.isValid(e))
                                throw Error("invalid scalar at index " + r);
                            });
                          })(i, t);
                        let n = r.length,
                          s = i.length;
                        if (n !== s)
                          throw Error(
                            "arrays of points and scalars must have equal length"
                          );
                        let a = e.ZERO,
                          o = (function (e) {
                            let t;
                            for (t = 0; e > cc; e >>= cl, t += 1);
                            return t;
                          })(BigInt(n)),
                          c = 1;
                        o > 12
                          ? (c = o - 3)
                          : o > 4
                          ? (c = o - 2)
                          : o > 0 && (c = 2);
                        let l = cb(c),
                          d = Array(Number(l) + 1).fill(a),
                          h = Math.floor((t.BITS - 1) / c) * c,
                          u = a;
                        for (let e = h; e >= 0; e -= c) {
                          d.fill(a);
                          for (let t = 0; t < s; t++) {
                            let n = Number((i[t] >> BigInt(e)) & l);
                            d[n] = d[n].add(r[t]);
                          }
                          let t = a;
                          for (let e = d.length - 1, r = a; e > 0; e--)
                            (r = r.add(d[e])), (t = t.add(r));
                          if (((u = u.add(t)), 0 !== e))
                            for (let e = 0; e < c; e++) u = u.double();
                        }
                        return u;
                      })(E, a, e, t);
                    }
                    precompute(e = 8, t = !0) {
                      return (
                        A.setWindowSize(this, e), t || this.multiply(ln), this
                      );
                    }
                    _setWindowSize(e) {
                      this.precompute(e);
                    }
                    assertValidity() {
                      v(this);
                    }
                    hasEvenY() {
                      let { y: e } = this.toAffine();
                      if (!s.isOdd) throw Error("Field doesn't support isOdd");
                      return !s.isOdd(e);
                    }
                    equals(e) {
                      w(e);
                      let { px: t, py: r, pz: i } = this,
                        { px: n, py: a, pz: o } = e,
                        c = s.eql(s.mul(t, o), s.mul(n, i)),
                        l = s.eql(s.mul(r, o), s.mul(a, i));
                      return c && l;
                    }
                    negate() {
                      return new E(this.px, s.neg(this.py), this.pz);
                    }
                    double() {
                      let { a: t, b: r } = e,
                        i = s.mul(r, ln),
                        { px: n, py: a, pz: o } = this,
                        c = s.ZERO,
                        l = s.ZERO,
                        d = s.ZERO,
                        h = s.mul(n, n),
                        u = s.mul(a, a),
                        p = s.mul(o, o),
                        f = s.mul(n, a);
                      return (
                        (f = s.add(f, f)),
                        (d = s.mul(n, o)),
                        (d = s.add(d, d)),
                        (c = s.mul(t, d)),
                        (l = s.mul(i, p)),
                        (l = s.add(c, l)),
                        (c = s.sub(u, l)),
                        (l = s.add(u, l)),
                        (l = s.mul(c, l)),
                        (c = s.mul(f, c)),
                        (d = s.mul(i, d)),
                        (p = s.mul(t, p)),
                        (f = s.sub(h, p)),
                        (f = s.mul(t, f)),
                        (f = s.add(f, d)),
                        (d = s.add(h, h)),
                        (h = s.add(d, h)),
                        (h = s.add(h, p)),
                        (h = s.mul(h, f)),
                        (l = s.add(l, h)),
                        (p = s.mul(a, o)),
                        (p = s.add(p, p)),
                        (h = s.mul(p, f)),
                        (c = s.sub(c, h)),
                        (d = s.mul(p, u)),
                        (d = s.add(d, d)),
                        new E(c, l, (d = s.add(d, d)))
                      );
                    }
                    add(t) {
                      w(t);
                      let { px: r, py: i, pz: n } = this,
                        { px: a, py: o, pz: c } = t,
                        l = s.ZERO,
                        d = s.ZERO,
                        h = s.ZERO,
                        u = e.a,
                        p = s.mul(e.b, ln),
                        f = s.mul(r, a),
                        g = s.mul(i, o),
                        m = s.mul(n, c),
                        y = s.add(r, i),
                        b = s.add(a, o);
                      (y = s.mul(y, b)),
                        (b = s.add(f, g)),
                        (y = s.sub(y, b)),
                        (b = s.add(r, n));
                      let v = s.add(a, c);
                      return (
                        (b = s.mul(b, v)),
                        (v = s.add(f, m)),
                        (b = s.sub(b, v)),
                        (v = s.add(i, n)),
                        (l = s.add(o, c)),
                        (v = s.mul(v, l)),
                        (l = s.add(g, m)),
                        (v = s.sub(v, l)),
                        (h = s.mul(u, b)),
                        (l = s.mul(p, m)),
                        (h = s.add(l, h)),
                        (l = s.sub(g, h)),
                        (h = s.add(g, h)),
                        (d = s.mul(l, h)),
                        (g = s.add(f, f)),
                        (g = s.add(g, f)),
                        (m = s.mul(u, m)),
                        (b = s.mul(p, b)),
                        (g = s.add(g, m)),
                        (m = s.sub(f, m)),
                        (m = s.mul(u, m)),
                        (b = s.add(b, m)),
                        (f = s.mul(g, b)),
                        (d = s.add(d, f)),
                        (f = s.mul(v, b)),
                        (l = s.mul(y, l)),
                        (l = s.sub(l, f)),
                        (f = s.mul(y, g)),
                        (h = s.mul(v, h)),
                        new E(l, d, (h = s.add(h, f)))
                      );
                    }
                    subtract(e) {
                      return this.add(e.negate());
                    }
                    is0() {
                      return this.equals(E.ZERO);
                    }
                    multiply(e) {
                      let r,
                        i,
                        { endo: n } = t;
                      if (!a.isValidNot0(e))
                        throw Error("invalid scalar: out of range");
                      let s = (e) => A.wNAFCached(this, e, E.normalizeZ);
                      if (n) {
                        let {
                            k1neg: t,
                            k1: a,
                            k2neg: o,
                            k2: c,
                          } = n.splitScalar(e),
                          { p: l, f: d } = s(a),
                          { p: h, f: u } = s(c);
                        (i = d.add(u)), (r = C(n.beta, l, h, t, o));
                      } else {
                        let { p: t, f: n } = s(e);
                        (r = t), (i = n);
                      }
                      return E.normalizeZ([r, i])[0];
                    }
                    multiplyUnsafe(e) {
                      let { endo: r } = t;
                      if (!a.isValid(e))
                        throw Error("invalid scalar: out of range");
                      if (e === lt || this.is0()) return E.ZERO;
                      if (e === lr) return this;
                      if (A.hasPrecomputes(this)) return this.multiply(e);
                      if (!r) return A.wNAFCachedUnsafe(this, e);
                      {
                        let {
                            k1neg: t,
                            k1: i,
                            k2neg: n,
                            k2: s,
                          } = r.splitScalar(e),
                          { p1: a, p2: o } = (function (e, t, r, i) {
                            let n = t,
                              s = e.ZERO,
                              a = e.ZERO;
                            for (; r > cW || i > cW; )
                              r & cj && (s = s.add(n)),
                                i & cj && (a = a.add(n)),
                                (n = n.double()),
                                (r >>= cj),
                                (i >>= cj);
                            return { p1: s, p2: a };
                          })(E, this, i, s);
                        return C(r.beta, a, o, t, n);
                      }
                    }
                    multiplyAndAddUnsafe(e, t, r) {
                      let i = this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));
                      return i.is0() ? void 0 : i;
                    }
                    toAffine(e) {
                      return b(this, e);
                    }
                    isTorsionFree() {
                      let { isTorsionFree: e } = t;
                      return (
                        o === lr ||
                        (e ? e(E, this) : A.wNAFCachedUnsafe(this, c).is0())
                      );
                    }
                    clearCofactor() {
                      let { clearCofactor: e } = t;
                      return o === lr
                        ? this
                        : e
                        ? e(E, this)
                        : this.multiplyUnsafe(o);
                    }
                    toBytes(e = !0) {
                      return (
                        cd("isCompressed", e),
                        this.assertValidity(),
                        h(E, this, e)
                      );
                    }
                    toRawBytes(e = !0) {
                      return this.toBytes(e);
                    }
                    toHex(e = !0) {
                      return aA(this.toBytes(e));
                    }
                    toString() {
                      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
                    }
                  }
                  (E.BASE = new E(e.Gx, e.Gy, s.ONE)),
                    (E.ZERO = new E(s.ZERO, s.ONE, s.ZERO)),
                    (E.Fp = s),
                    (E.Fn = a);
                  let x = a.BITS,
                    A =
                      ((n = t.endo ? Math.ceil(x / 2) : x),
                      {
                        constTimeNegate: cF,
                        hasPrecomputes: (e) => 1 !== cK(e),
                        unsafeLadder(e, t, r = E.ZERO) {
                          let i = e;
                          for (; t > cW; )
                            t & cj && (r = r.add(i)),
                              (i = i.double()),
                              (t >>= cj);
                          return r;
                        },
                        precomputeWindow(e, t) {
                          let { windows: r, windowSize: i } = cq(t, n),
                            s = [],
                            a = e,
                            o = a;
                          for (let e = 0; e < r; e++) {
                            (o = a), s.push(o);
                            for (let e = 1; e < i; e++)
                              (o = o.add(a)), s.push(o);
                            a = o.double();
                          }
                          return s;
                        },
                        wNAF(e, t, r) {
                          let i = E.ZERO,
                            s = E.BASE,
                            a = cq(e, n);
                          for (let e = 0; e < a.windows; e++) {
                            let {
                              nextN: n,
                              offset: o,
                              isZero: c,
                              isNeg: l,
                              isNegF: d,
                              offsetF: h,
                            } = cz(r, e, a);
                            (r = n),
                              c
                                ? (s = s.add(cF(d, t[h])))
                                : (i = i.add(cF(l, t[o])));
                          }
                          return cG(r), { p: i, f: s };
                        },
                        wNAFUnsafe(e, t, r, i = E.ZERO) {
                          let s = cq(e, n);
                          for (let e = 0; e < s.windows && r !== cW; e++) {
                            let {
                              nextN: n,
                              offset: a,
                              isZero: o,
                              isNeg: c,
                            } = cz(r, e, s);
                            if (((r = n), !o)) {
                              let e = t[a];
                              i = i.add(c ? e.negate() : e);
                            }
                          }
                          return cG(r), i;
                        },
                        getPrecomputes(e, t, r) {
                          let i = cV.get(t);
                          return (
                            i ||
                              ((i = this.precomputeWindow(t, e)),
                              1 !== e &&
                                ("function" == typeof r && (i = r(i)),
                                cV.set(t, i))),
                            i
                          );
                        },
                        wNAFCached(e, t, r) {
                          let i = cK(e);
                          return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                        },
                        wNAFCachedUnsafe(e, t, r, i) {
                          let n = cK(e);
                          return 1 === n
                            ? this.unsafeLadder(e, t, i)
                            : this.wNAFUnsafe(
                                n,
                                this.getPrecomputes(n, e, r),
                                t,
                                i
                              );
                        },
                        setWindowSize(e, t) {
                          cH(t, n), cZ.set(e, t), cV.delete(e);
                        },
                      });
                  return E;
                })(t, r),
                i,
                r
              );
            return Object.assign({}, n, { ProjectivePoint: n.Point, CURVE: e });
          })({ ...e, hash: t });
        return { ...r(t), create: r };
      }
      let ll = {
          p: BigInt(
            "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
          ),
          n: BigInt(
            "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
          ),
          h: BigInt(1),
          a: BigInt(
            "0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"
          ),
          b: BigInt(
            "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
          ),
          Gx: BigInt(
            "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
          ),
          Gy: BigInt(
            "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
          ),
        },
        ld = {
          p: BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"
          ),
          n: BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"
          ),
          h: BigInt(1),
          a: BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"
          ),
          b: BigInt(
            "0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"
          ),
          Gx: BigInt(
            "0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"
          ),
          Gy: BigInt(
            "0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"
          ),
        },
        lh = {
          p: BigInt(
            "0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          ),
          n: BigInt(
            "0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"
          ),
          h: BigInt(1),
          a: BigInt(
            "0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"
          ),
          b: BigInt(
            "0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"
          ),
          Gx: BigInt(
            "0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"
          ),
          Gy: BigInt(
            "0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"
          ),
        },
        lu = cM(ll.p),
        lp = cM(ld.p),
        lf = cM(lh.p),
        lg = lc({ ...ll, Fp: lu, lowS: !1 }, ot);
      lc({ ...ld, Fp: lp, lowS: !1 }, oi),
        lc(
          {
            ...lh,
            Fp: lf,
            lowS: !1,
            allowedPrivateKeyLengths: [130, 131, 132],
          },
          or
        );
      let lm = "base10",
        ly = "base16",
        lw = "base64pad",
        lb = "base64url",
        lv = "utf8";
      function lC() {
        return su(aP(32), ly);
      }
      function lE(e) {
        return su(ot(sh(e, ly)), ly);
      }
      function lx(e) {
        return su(ot(sh(e, lv)), ly);
      }
      function lA(e) {
        return Number(su(e, lm));
      }
      function l_(e) {
        return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      function lI(e) {
        let t = e.replace(/-/g, "+").replace(/_/g, "/"),
          r = (4 - (t.length % 4)) % 4;
        return t + "=".repeat(r);
      }
      function lS(e) {
        if (2 === lA(e.type)) return su(i6([e.type, e.sealed]), lw);
        if (1 === lA(e.type)) {
          if (typeof e.senderPublicKey > "u")
            throw Error("Missing sender public key for type 1 envelope");
          return su(i6([e.type, e.senderPublicKey, e.iv, e.sealed]), lw);
        }
        return su(i6([e.type, e.iv, e.sealed]), lw);
      }
      function lk(e) {
        let t = sh((e.encoding || lw) === lb ? lI(e.encoded) : e.encoded, lw),
          r = t.slice(0, 1);
        if (1 === lA(r)) {
          let e = t.slice(1, 33),
            i = t.slice(33, 45);
          return { type: r, sealed: t.slice(45), iv: i, senderPublicKey: e };
        }
        if (2 === lA(r)) return { type: r, sealed: t.slice(1), iv: aP(12) };
        let i = t.slice(1, 13);
        return { type: r, sealed: t.slice(13), iv: i };
      }
      function lN(e) {
        let t = e?.type || 0;
        if (1 === t) {
          if (typeof e?.senderPublicKey > "u")
            throw Error("missing sender public key");
          if (typeof e?.receiverPublicKey > "u")
            throw Error("missing receiver public key");
        }
        return {
          type: t,
          senderPublicKey: e?.senderPublicKey,
          receiverPublicKey: e?.receiverPublicKey,
        };
      }
      function lT(e) {
        return (
          1 === e.type &&
          "string" == typeof e.senderPublicKey &&
          "string" == typeof e.receiverPublicKey
        );
      }
      function lO(e) {
        return e?.relay || { protocol: "irn" };
      }
      function lP(e) {
        let t = sp[e];
        if (typeof t > "u") throw Error(`Relay Protocol not supported: ${e}`);
        return t;
      }
      function lR(e) {
        var t;
        if (!e.includes("wc:")) {
          let t = sX(e);
          null != t && t.includes("wc:") && (e = t);
        }
        let r = (e = (e = e.includes("wc://")
            ? e.replace("wc://", "")
            : e).includes("wc:")
            ? e.replace("wc:", "")
            : e).indexOf(":"),
          i = -1 !== e.indexOf("?") ? e.indexOf("?") : void 0,
          n = e.substring(0, r),
          s = e.substring(r + 1, i).split("@"),
          a = new URLSearchParams("u" > typeof i ? e.substring(i) : ""),
          o = {};
        a.forEach((e, t) => {
          o[t] = e;
        });
        let c = "string" == typeof o.methods ? o.methods.split(",") : void 0;
        return {
          protocol: n,
          topic: (t = s[0]).startsWith("//") ? t.substring(2) : t,
          version: parseInt(s[1], 10),
          symKey: o.symKey,
          relay: (function (e, t = "-") {
            let r = {},
              i = "relay" + t;
            return (
              Object.keys(e).forEach((t) => {
                if (t.startsWith(i)) {
                  let n = t.replace(i, ""),
                    s = e[t];
                  r[n] = s;
                }
              }),
              r
            );
          })(o),
          methods: c,
          expiryTimestamp: o.expiryTimestamp
            ? parseInt(o.expiryTimestamp, 10)
            : void 0,
        };
      }
      function l$(e) {
        let t = new URLSearchParams(),
          r = (function (e, t = "-") {
            let r = {};
            return (
              Object.keys(e).forEach((i) => {
                e[i] && (r["relay" + t + i] = e[i]);
              }),
              r
            );
          })(e.relay);
        Object.keys(r)
          .sort()
          .forEach((e) => {
            t.set(e, r[e]);
          }),
          t.set("symKey", e.symKey),
          e.expiryTimestamp &&
            t.set("expiryTimestamp", e.expiryTimestamp.toString()),
          e.methods && t.set("methods", e.methods.join(","));
        let i = t.toString();
        return `${e.protocol}:${e.topic}@${e.version}?${i}`;
      }
      function lD(e, t, r) {
        return `${e}?wc_ev=${r}&topic=${t}`;
      }
      var lU = Object.defineProperty,
        lM = Object.defineProperties,
        lL = Object.getOwnPropertyDescriptors,
        lB = Object.getOwnPropertySymbols,
        lW = Object.prototype.hasOwnProperty,
        lj = Object.prototype.propertyIsEnumerable,
        lF = (e, t, r) =>
          t in e
            ? lU(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        lH = (e, t) => {
          for (var r in t || (t = {})) lW.call(t, r) && lF(e, r, t[r]);
          if (lB) for (var r of lB(t)) lj.call(t, r) && lF(e, r, t[r]);
          return e;
        },
        lq = (e, t) => lM(e, lL(t));
      function lz(e) {
        let t = [];
        return (
          e.forEach((e) => {
            let [r, i] = e.split(":");
            t.push(`${r}:${i}`);
          }),
          t
        );
      }
      function lV(e) {
        return e.includes(":");
      }
      function lZ(e) {
        return lV(e) ? e.split(":")[0] : e;
      }
      function lK(e) {
        var t, r, i;
        let n = {};
        if (!l1(e)) return n;
        for (let [s, a] of Object.entries(e)) {
          let e = lV(s) ? [s] : a.chains,
            o = a.methods || [],
            c = a.events || [],
            l = lZ(s);
          n[l] = lq(lH({}, n[l]), {
            chains: sV(e, null == (t = n[l]) ? void 0 : t.chains),
            methods: sV(o, null == (r = n[l]) ? void 0 : r.methods),
            events: sV(c, null == (i = n[l]) ? void 0 : i.events),
          });
        }
        return n;
      }
      function lG(e, t) {
        let r = (function (e) {
          let t = {};
          return (
            e?.forEach((e) => {
              var r;
              let [i, n] = e.split(":");
              t[i] ||
                (t[i] = { accounts: [], chains: [], events: [], methods: [] }),
                t[i].accounts.push(e),
                null == (r = t[i].chains) || r.push(`${i}:${n}`);
            }),
            t
          );
        })((t = t.map((e) => e.replace("did:pkh:", ""))));
        for (let [t, i] of Object.entries(r))
          i.methods ? (i.methods = sV(i.methods, e)) : (i.methods = e),
            (i.events = ["chainChanged", "accountsChanged"]);
        return r;
      }
      let lJ = {
          INVALID_METHOD: { message: "Invalid method.", code: 1001 },
          INVALID_EVENT: { message: "Invalid event.", code: 1002 },
          INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003,
          },
          INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004,
          },
          INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005,
          },
          UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
          UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
          UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003,
          },
          UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004,
          },
          USER_REJECTED: { message: "User rejected.", code: 5e3 },
          USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001,
          },
          USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002,
          },
          USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003,
          },
          UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
          UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
          UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
          UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103,
          },
          UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104,
          },
          USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
          SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3,
          },
          WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001,
          },
        },
        lY = {
          NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
          NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
          RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
          RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
          MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
          EXPIRED: { message: "Expired.", code: 6 },
          UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
          MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
          NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9,
          },
        };
      function lX(e, t) {
        let { message: r, code: i } = lY[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function lQ(e, t) {
        let { message: r, code: i } = lJ[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function l0(e, t) {
        return (
          !!Array.isArray(e) && (!("u" > typeof t) || !e.length || e.every(t))
        );
      }
      function l1(e) {
        return (
          Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
        );
      }
      function l2(e) {
        return typeof e > "u";
      }
      function l3(e, t) {
        return !!(t && l2(e)) || ("string" == typeof e && !!e.trim().length);
      }
      function l5(e, t) {
        return !!(t && l2(e)) || ("number" == typeof e && !isNaN(e));
      }
      function l4(e) {
        return !!(l3(e, !1) && e.includes(":")) && 2 === e.split(":").length;
      }
      function l6(e) {
        let t = !0;
        return (
          l0(e) ? e.length && (t = e.every((e) => l3(e, !1))) : (t = !1), t
        );
      }
      function l8(e, t) {
        let r = null;
        return (
          Object.values(e).forEach((e) => {
            var i;
            let n;
            if (r) return;
            let s =
              ((i = `${t}, namespace`),
              (n = null),
              l6(e?.methods)
                ? l6(e?.events) ||
                  (n = lQ(
                    "UNSUPPORTED_EVENTS",
                    `${i}, events should be an array of strings or empty array for no events`
                  ))
                : (n = lQ(
                    "UNSUPPORTED_METHODS",
                    `${i}, methods should be an array of strings or empty array for no methods`
                  )),
              n);
            s && (r = s);
          }),
          r
        );
      }
      function l9(e, t) {
        let r = null;
        if (e && l1(e)) {
          let i,
            n = l8(e, t);
          n && (r = n);
          let s =
            ((i = null),
            Object.values(e).forEach((e) => {
              var r, n;
              let s;
              if (i) return;
              let a =
                ((r = e?.accounts),
                (n = `${t} namespace`),
                (s = null),
                l0(r)
                  ? r.forEach((e) => {
                      s ||
                        (function (e) {
                          if (l3(e, !1) && e.includes(":")) {
                            let t = e.split(":");
                            if (3 === t.length) {
                              let e = t[0] + ":" + t[1];
                              return !!t[2] && l4(e);
                            }
                          }
                          return !1;
                        })(e) ||
                        (s = lQ(
                          "UNSUPPORTED_ACCOUNTS",
                          `${n}, account ${e} should be a string and conform to "namespace:chainId:address" format`
                        ));
                    })
                  : (s = lQ(
                      "UNSUPPORTED_ACCOUNTS",
                      `${n}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
                    )),
                s);
              a && (i = a);
            }),
            i);
          s && (r = s);
        } else
          r = lX(
            "MISSING_OR_INVALID",
            `${t}, namespaces should be an object with data`
          );
        return r;
      }
      function l7(e) {
        return l3(e.protocol, !0);
      }
      function de(e) {
        return "u" > typeof e;
      }
      function dt(e, t) {
        return !(
          !l4(t) ||
          !(function (e) {
            let t = [];
            return (
              Object.values(e).forEach((e) => {
                t.push(...lz(e.accounts));
              }),
              t
            );
          })(e).includes(t)
        );
      }
      function dr(e, t, r) {
        let i = null,
          n = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                var i;
                r.includes(":")
                  ? (t[r] = e[r])
                  : null == (i = e[r].chains) ||
                    i.forEach((i) => {
                      t[i] = { methods: e[r].methods, events: e[r].events };
                    });
              }),
              t
            );
          })(e),
          s = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                if (r.includes(":")) t[r] = e[r];
                else {
                  let i = lz(e[r].accounts);
                  i?.forEach((i) => {
                    t[i] = {
                      accounts: e[r].accounts.filter((e) =>
                        e.includes(`${i}:`)
                      ),
                      methods: e[r].methods,
                      events: e[r].events,
                    };
                  });
                }
              }),
              t
            );
          })(t),
          a = Object.keys(n),
          o = Object.keys(s),
          c = di(Object.keys(e)),
          l = di(Object.keys(t)),
          d = c.filter((e) => !l.includes(e));
        return (
          d.length &&
            (i = lX(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(t).toString()}`
            )),
          sU(a, o) ||
            (i = lX(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`
            )),
          Object.keys(t).forEach((e) => {
            if (!e.includes(":") || i) return;
            let n = lz(t[e].accounts);
            n.includes(e) ||
              (i = lX(
                "NON_CONFORMING_NAMESPACES",
                `${r} namespaces accounts don't satisfy namespace accounts for ${e}
        Required: ${e}
        Approved: ${n.toString()}`
              ));
          }),
          a.forEach((e) => {
            i ||
              (sU(n[e].methods, s[e].methods)
                ? sU(n[e].events, s[e].events) ||
                  (i = lX(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces events don't satisfy namespace events for ${e}`
                  ))
                : (i = lX(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces methods don't satisfy namespace methods for ${e}`
                  )));
          }),
          i
        );
      }
      function di(e) {
        return [
          ...new Set(e.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
        ];
      }
      function dn() {
        let e = sP();
        return new Promise((t) => {
          switch (e) {
            case sk.browser:
              t(sO() && navigator?.onLine);
              break;
            case sk.reactNative:
              t(ds());
              break;
            case sk.node:
            default:
              t(!0);
          }
        });
      }
      async function ds() {
        if (sT() && "u" > typeof r.g && null != r.g && r.g.NetInfo) {
          let e = await (null == r.g ? void 0 : r.g.NetInfo.fetch());
          return e?.isConnected;
        }
        return !0;
      }
      let da = {};
      class dc {
        static get(e) {
          return da[e];
        }
        static set(e, t) {
          da[e] = t;
        }
        static delete(e) {
          delete da[e];
        }
      }
      function dl(e) {
        return new Uint8Array(
          e
            .replace(/^0x/, "")
            .match(/.{1,2}/g)
            .map((e) => parseInt(e, 16))
        );
      }
      let dd = "INTERNAL_ERROR",
        dh = "SERVER_ERROR",
        du = [-32700, -32600, -32601, -32602, -32603],
        dp = {
          PARSE_ERROR: { code: -32700, message: "Parse error" },
          INVALID_REQUEST: { code: -32600, message: "Invalid Request" },
          METHOD_NOT_FOUND: { code: -32601, message: "Method not found" },
          INVALID_PARAMS: { code: -32602, message: "Invalid params" },
          [dd]: { code: -32603, message: "Internal error" },
          [dh]: { code: -32e3, message: "Server error" },
        };
      function df(e) {
        return Object.keys(dp).includes(e) ? dp[e] : dp[dh];
      }
      function dg(e, t, r) {
        return e.message.includes("getaddrinfo ENOTFOUND") ||
          e.message.includes("connect ECONNREFUSED")
          ? Error(`Unavailable ${r} RPC url at ${t}`)
          : e;
      }
      var dm = r(87822);
      function dy(e = 3) {
        return (
          Date.now() * Math.pow(10, e) +
          Math.floor(Math.random() * Math.pow(10, e))
        );
      }
      function dw(e = 6) {
        return BigInt(dy(e));
      }
      function db(e, t, r) {
        return { id: r || dy(), jsonrpc: "2.0", method: e, params: t };
      }
      function dv(e, t) {
        return { id: e, jsonrpc: "2.0", result: t };
      }
      function dC(e, t, r) {
        var i, n, s;
        return {
          id: e,
          jsonrpc: "2.0",
          error:
            ((i = t),
            (n = r),
            void 0 === i
              ? df(dd)
              : ("string" == typeof i &&
                  (i = Object.assign(Object.assign({}, df(dh)), {
                    message: i,
                  })),
                void 0 !== n && (i.data = n),
                (s = i.code),
                du.includes(s) &&
                  (i = (function (e) {
                    let t = Object.values(dp).find((t) => t.code === e);
                    return t || dp[dh];
                  })(i.code)),
                i)),
        };
      }
      class dE {}
      class dx extends dE {
        constructor() {
          super();
        }
      }
      class dA extends dx {
        constructor(e) {
          super();
        }
      }
      function d_(e, t) {
        let r = (function (e) {
          let t = e.match(RegExp(/^\w+:/, "gi"));
          if (t && t.length) return t[0];
        })(e);
        return void 0 !== r && new RegExp(t).test(r);
      }
      function dI(e) {
        return d_(e, "^https?:");
      }
      function dS(e) {
        return d_(e, "^wss?:");
      }
      function dk(e) {
        return (
          "object" == typeof e &&
          "id" in e &&
          "jsonrpc" in e &&
          "2.0" === e.jsonrpc
        );
      }
      function dN(e) {
        return dk(e) && "method" in e;
      }
      function dT(e) {
        return dk(e) && (dO(e) || dP(e));
      }
      function dO(e) {
        return "result" in e;
      }
      function dP(e) {
        return "error" in e;
      }
      class dR extends dA {
        constructor(e) {
          super(e),
            (this.events = new w.EventEmitter()),
            (this.hasRegisteredEventListeners = !1),
            (this.connection = this.setConnection(e)),
            this.connection.connected && this.registerEventListeners();
        }
        async connect(e = this.connection) {
          await this.open(e);
        }
        async disconnect() {
          await this.close();
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async request(e, t) {
          return this.requestStrict(
            db(e.method, e.params || [], e.id || dw().toString()),
            t
          );
        }
        async requestStrict(e, t) {
          return new Promise(async (r, i) => {
            if (!this.connection.connected)
              try {
                await this.open();
              } catch (e) {
                i(e);
              }
            this.events.on(`${e.id}`, (e) => {
              dP(e) ? i(e.error) : r(e.result);
            });
            try {
              await this.connection.send(e, t);
            } catch (e) {
              i(e);
            }
          });
        }
        setConnection(e = this.connection) {
          return e;
        }
        onPayload(e) {
          this.events.emit("payload", e),
            dT(e)
              ? this.events.emit(`${e.id}`, e)
              : this.events.emit("message", { type: e.method, data: e.params });
        }
        onClose(e) {
          e &&
            3e3 === e.code &&
            this.events.emit(
              "error",
              Error(
                `WebSocket connection closed abnormally with code: ${e.code} ${
                  e.reason ? `(${e.reason})` : ""
                }`
              )
            ),
            this.events.emit("disconnect");
        }
        async open(e = this.connection) {
          (this.connection === e && this.connection.connected) ||
            (this.connection.connected && this.close(),
            "string" == typeof e &&
              (await this.connection.open(e), (e = this.connection)),
            (this.connection = this.setConnection(e)),
            await this.connection.open(),
            this.registerEventListeners(),
            this.events.emit("connect"));
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          this.hasRegisteredEventListeners ||
            (this.connection.on("payload", (e) => this.onPayload(e)),
            this.connection.on("close", (e) => this.onClose(e)),
            this.connection.on("error", (e) => this.events.emit("error", e)),
            this.connection.on("register_error", (e) => this.onClose()),
            (this.hasRegisteredEventListeners = !0));
        }
      }
      let d$ = (e) => e.split("?")[0],
        dD =
          "u" > typeof WebSocket
            ? WebSocket
            : "u" > typeof r.g && "u" > typeof r.g.WebSocket
            ? r.g.WebSocket
            : "u" > typeof window && "u" > typeof window.WebSocket
            ? window.WebSocket
            : "u" > typeof self && "u" > typeof self.WebSocket
            ? self.WebSocket
            : r(55762);
      class dU {
        constructor(e) {
          if (
            ((this.url = e),
            (this.events = new w.EventEmitter()),
            (this.registering = !1),
            !dS(e))
          )
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          this.url = e;
        }
        get connected() {
          return "u" > typeof this.socket;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          return new Promise((e, t) => {
            if (typeof this.socket > "u")
              return void t(Error("Connection already closed"));
            (this.socket.onclose = (t) => {
              this.onClose(t), e();
            }),
              this.socket.close();
          });
        }
        async send(e) {
          typeof this.socket > "u" && (this.socket = await this.register());
          try {
            this.socket.send((0, W.h)(e));
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        register(e = this.url) {
          if (!dS(e))
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if ((this.resetMaxListeners(), typeof this.socket > "u"))
                      return t(
                        Error("WebSocket connection is missing or invalid")
                      );
                    e(this.socket);
                  });
              })
            );
          }
          return (
            (this.url = e),
            (this.registering = !0),
            new Promise((t, i) => {
              let n = (0, dm.isReactNative)()
                  ? void 0
                  : {
                      rejectUnauthorized: !RegExp(
                        "wss?://localhost(:d{2,5})?"
                      ).test(e),
                    },
                s = new dD(e, [], n);
              "u" > typeof WebSocket ||
              ("u" > typeof r.g && "u" > typeof r.g.WebSocket) ||
              ("u" > typeof window && "u" > typeof window.WebSocket) ||
              ("u" > typeof self && "u" > typeof self.WebSocket)
                ? (s.onerror = (e) => {
                    i(this.emitError(e.error));
                  })
                : s.on("error", (e) => {
                    i(this.emitError(e));
                  }),
                (s.onopen = () => {
                  this.onOpen(s), t(s);
                });
            })
          );
        }
        onOpen(e) {
          (e.onmessage = (e) => this.onPayload(e)),
            (e.onclose = (e) => this.onClose(e)),
            (this.socket = e),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose(e) {
          (this.socket = void 0),
            (this.registering = !1),
            this.events.emit("close", e);
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, W.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = dC(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return dg(e, d$(t), "WS");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
        emitError(e) {
          let t = this.parseError(
            Error(
              e?.message ||
                `WebSocket connection failed for host: ${d$(this.url)}`
            )
          );
          return this.events.emit("register_error", t), t;
        }
      }
      var dM = r(81029).Buffer,
        dL = r(95704);
      let dB = "core",
        dW = `wc@2:${dB}:`,
        dj = { logger: "error" },
        dF = { database: ":memory:" },
        dH = "client_ed25519_seed",
        dq = v.ONE_DAY,
        dz = v.SIX_HOURS,
        dV = "wss://relay.walletconnect.org",
        dZ = {
          message: "relayer_message",
          message_ack: "relayer_message_ack",
          connect: "relayer_connect",
          disconnect: "relayer_disconnect",
          error: "relayer_error",
          connection_stalled: "relayer_connection_stalled",
          publish: "relayer_publish",
        },
        dK = {
          payload: "payload",
          connect: "connect",
          disconnect: "disconnect",
          error: "error",
        },
        dG = "2.21.7",
        dJ = { link_mode: "link_mode", relay: "relay" },
        dY = { inbound: "inbound", outbound: "outbound" },
        dX = "WALLETCONNECT_LINK_MODE_APPS",
        dQ = {
          created: "subscription_created",
          deleted: "subscription_deleted",
          sync: "subscription_sync",
          resubscribed: "subscription_resubscribed",
        },
        d0 =
          (v.FIVE_SECONDS,
          {
            wc_pairingDelete: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 1e3 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 1001 },
            },
            wc_pairingPing: {
              req: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1002 },
              res: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1003 },
            },
            unregistered_method: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
            },
          }),
        d1 = {
          create: "pairing_create",
          expire: "pairing_expire",
          delete: "pairing_delete",
          ping: "pairing_ping",
        },
        d2 = {
          created: "history_created",
          updated: "history_updated",
          deleted: "history_deleted",
          sync: "history_sync",
        },
        d3 = {
          created: "expirer_created",
          deleted: "expirer_deleted",
          expired: "expirer_expired",
          sync: "expirer_sync",
        },
        d5 = "https://verify.walletconnect.org",
        d4 = `${d5}/v3`,
        d6 = ["https://verify.walletconnect.com", d5],
        d8 = {
          pairing_started: "pairing_started",
          pairing_uri_validation_success: "pairing_uri_validation_success",
          pairing_uri_not_expired: "pairing_uri_not_expired",
          store_new_pairing: "store_new_pairing",
          subscribing_pairing_topic: "subscribing_pairing_topic",
          subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
          existing_pairing: "existing_pairing",
          pairing_not_expired: "pairing_not_expired",
          emit_inactive_pairing: "emit_inactive_pairing",
          emit_session_proposal: "emit_session_proposal",
        },
        d9 = {
          no_internet_connection: "no_internet_connection",
          malformed_pairing_uri: "malformed_pairing_uri",
          active_pairing_already_exists: "active_pairing_already_exists",
          subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
          pairing_expired: "pairing_expired",
          proposal_listener_not_found: "proposal_listener_not_found",
        },
        d7 = {
          session_approve_started: "session_approve_started",
          session_namespaces_validation_success:
            "session_namespaces_validation_success",
          subscribing_session_topic: "subscribing_session_topic",
          subscribe_session_topic_success: "subscribe_session_topic_success",
          session_approve_publish_success: "session_approve_publish_success",
          store_session: "store_session",
        },
        he = {
          no_internet_connection: "no_internet_connection",
          proposal_expired: "proposal_expired",
          subscribe_session_topic_failure: "subscribe_session_topic_failure",
          session_approve_namespace_validation_failure:
            "session_approve_namespace_validation_failure",
          proposal_not_found: "proposal_not_found",
        },
        ht = {
          authenticated_session_approve_started:
            "authenticated_session_approve_started",
          create_authenticated_session_topic:
            "create_authenticated_session_topic",
          cacaos_verified: "cacaos_verified",
          store_authenticated_session: "store_authenticated_session",
          subscribing_authenticated_session_topic:
            "subscribing_authenticated_session_topic",
          subscribe_authenticated_session_topic_success:
            "subscribe_authenticated_session_topic_success",
          publishing_authenticated_session_approve:
            "publishing_authenticated_session_approve",
        },
        hr = {
          no_internet_connection: "no_internet_connection",
          invalid_cacao: "invalid_cacao",
          subscribe_authenticated_session_topic_failure:
            "subscribe_authenticated_session_topic_failure",
          authenticated_session_approve_publish_failure:
            "authenticated_session_approve_publish_failure",
          authenticated_session_pending_request_not_found:
            "authenticated_session_pending_request_not_found",
        };
      var hi = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === c; ) i++, t++;
            for (
              var s = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var h = 0, u = s - 1;
                (0 !== d || h < n) && -1 !== u;
                u--, h++
              )
                (d += (o * a[u]) >>> 0),
                  (a[u] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * d + 1) >>> 0, l = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], u = 0, p = a - 1;
                (0 !== h || u < i) && -1 !== p;
                p--, u++
              )
                (h += (256 * l[p]) >>> 0),
                  (l[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = u), n++;
            }
            for (var f = a - i; f !== a && 0 === l[f]; ) f++;
            for (var g = c.repeat(r); f < a; ++f) g += e.charAt(l[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let hn = (e) => {
        if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
          return e;
        if (e instanceof ArrayBuffer) return new Uint8Array(e);
        if (ArrayBuffer.isView(e))
          return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        throw Error("Unknown type, must be binary type");
      };
      class hs {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class ha {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return hc(this, e);
        }
      }
      class ho {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return hc(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let hc = (e, t) =>
        new ho({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class hl {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new hs(e, t, r)),
            (this.decoder = new ha(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let hd = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new hl(e, t, r, i),
        hh = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = hi(r, t);
          return hd({ prefix: e, name: t, encode: i, decode: (e) => hn(n(e)) });
        },
        hu = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          hd({
            prefix: t,
            name: e,
            encode: (e) =>
              ((e, t, r) => {
                let i = "=" === t[t.length - 1],
                  n = (1 << r) - 1,
                  s = "",
                  a = 0,
                  o = 0;
                for (let i = 0; i < e.length; ++i)
                  for (o = (o << 8) | e[i], a += 8; a > r; )
                    (a -= r), (s += t[n & (o >> a)]);
                if ((a && (s += t[n & (o << (r - a))]), i))
                  for (; (s.length * r) & 7; ) s += "=";
                return s;
              })(e, i, r),
            decode: (t) =>
              ((e, t, r, i) => {
                let n = {};
                for (let e = 0; e < t.length; ++e) n[t[e]] = e;
                let s = e.length;
                for (; "=" === e[s - 1]; ) --s;
                let a = new Uint8Array(((s * r) / 8) | 0),
                  o = 0,
                  c = 0,
                  l = 0;
                for (let t = 0; t < s; ++t) {
                  let s = n[e[t]];
                  if (void 0 === s) throw SyntaxError(`Non-${i} character`);
                  (c = (c << r) | s),
                    (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
                }
                if (o >= r || 255 & (c << (8 - o)))
                  throw SyntaxError("Unexpected end of data");
                return a;
              })(t, i, r, e),
          });
      var hp = Object.freeze({
          __proto__: null,
          identity: hd({
            prefix: "\0",
            name: "identity",
            encode: (e) => new TextDecoder().decode(e),
            decode: (e) => new TextEncoder().encode(e),
          }),
        }),
        hf = Object.freeze({
          __proto__: null,
          base2: hu({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        hg = Object.freeze({
          __proto__: null,
          base8: hu({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        hm = Object.freeze({
          __proto__: null,
          base10: hh({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        hy = Object.freeze({
          __proto__: null,
          base16: hu({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: hu({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let hw = hu({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        hb = hu({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        hv = hu({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        hC = hu({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        hE = hu({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        hx = hu({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        hA = hu({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var h_ = Object.freeze({
          __proto__: null,
          base32: hw,
          base32upper: hb,
          base32pad: hv,
          base32padupper: hC,
          base32hex: hE,
          base32hexupper: hx,
          base32hexpad: hA,
          base32hexpadupper: hu({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: hu({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        hI = Object.freeze({
          __proto__: null,
          base36: hh({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: hh({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        hS = Object.freeze({
          __proto__: null,
          base58btc: hh({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: hh({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let hk = hu({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        hN = hu({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var hT = Object.freeze({
        __proto__: null,
        base64: hk,
        base64pad: hN,
        base64url: hu({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: hu({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let hO = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        hP = hO.reduce((e, t, r) => ((e[r] = t), e), []),
        hR = hO.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var h$ = Object.freeze({
        __proto__: null,
        base256emoji: hd({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += hP[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = hR[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function hD(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (hD.bytes = r - i + 1), t;
      }
      var hU = {
        encode: hD,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let hM = (e, t, r = 0) => (hU.encode(e, t, r), t),
        hL = (e) => hU.encodingLength(e),
        hB = (e, t) => {
          let r = t.byteLength,
            i = hL(e),
            n = i + hL(r),
            s = new Uint8Array(n + r);
          return hM(e, s, 0), hM(r, s, i), s.set(t, n), new hW(e, r, t, s);
        };
      class hW {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let hj = ({ name: e, code: t, encode: r }) => new hF(e, t, r);
      class hF {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? hB(this.code, t)
              : t.then((e) => hB(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let hH = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var hq = Object.freeze({
          __proto__: null,
          sha256: hj({ name: "sha2-256", code: 18, encode: hH("SHA-256") }),
          sha512: hj({ name: "sha2-512", code: 19, encode: hH("SHA-512") }),
        }),
        hz = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: hn,
            digest: (e) => hB(0, hn(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let hV = {
        ...hp,
        ...hf,
        ...hg,
        ...hm,
        ...hy,
        ...h_,
        ...hI,
        ...hS,
        ...hT,
        ...h$,
      };
      function hZ(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function hK(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...hq, ...hz });
      let hG = hK(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        hJ = hK(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = (function (e = 0) {
              return null != globalThis.Buffer &&
                null != globalThis.Buffer.allocUnsafe
                ? hZ(globalThis.Buffer.allocUnsafe(e))
                : new Uint8Array(e);
            })((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        hY = {
          utf8: hG,
          "utf-8": hG,
          hex: hV.base16,
          latin1: hJ,
          ascii: hJ,
          binary: hJ,
          ...hV,
        };
      var hX = Object.defineProperty,
        hQ = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? hX(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class h0 {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            hQ(this, "keychain", new Map()),
            hQ(this, "name", "keychain"),
            hQ(this, "version", "0.3"),
            hQ(this, "initialized", !1),
            hQ(this, "storagePrefix", dW),
            hQ(this, "init", async () => {
              if (!this.initialized) {
                let e = await this.getKeyChain();
                "u" > typeof e && (this.keychain = e), (this.initialized = !0);
              }
            }),
            hQ(
              this,
              "has",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            hQ(this, "set", async (e, t) => {
              this.isInitialized(),
                this.keychain.set(e, t),
                await this.persist();
            }),
            hQ(this, "get", (e) => {
              this.isInitialized();
              let t = this.keychain.get(e);
              if (typeof t > "u") {
                let { message: t } = lX(
                  "NO_MATCHING_KEY",
                  `${this.name}: ${e}`
                );
                throw Error(t);
              }
              return t;
            }),
            hQ(this, "del", async (e) => {
              this.isInitialized(),
                this.keychain.delete(e),
                await this.persist();
            }),
            (this.core = e),
            (this.logger = (0, G.U5)(t, this.name));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        async setKeyChain(e) {
          await this.core.storage.setItem(this.storageKey, sM(e));
        }
        async getKeyChain() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? sL(e) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var h1 = Object.defineProperty,
        h2 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? h1(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class h3 {
        constructor(e, t, r) {
          (this.core = e),
            (this.logger = t),
            h2(this, "name", "crypto"),
            h2(this, "keychain"),
            h2(this, "randomSessionIdentifier", lC()),
            h2(this, "initialized", !1),
            h2(this, "init", async () => {
              this.initialized ||
                (await this.keychain.init(), (this.initialized = !0));
            }),
            h2(
              this,
              "hasKeys",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            h2(
              this,
              "getClientId",
              async () => (
                this.isInitialized(),
                rw(rv(await this.getClientSeed()).publicKey)
              )
            ),
            h2(this, "generateKeyPair", () => {
              this.isInitialized();
              let e = (function () {
                let e = c8.utils.randomPrivateKey(),
                  t = c8.getPublicKey(e);
                return { privateKey: su(e, ly), publicKey: su(t, ly) };
              })();
              return this.setPrivateKey(e.publicKey, e.privateKey);
            }),
            h2(this, "signJWT", async (e) => {
              this.isInitialized();
              let t = rv(await this.getClientSeed()),
                r = this.randomSessionIdentifier;
              return await rC(r, e, dq, t);
            }),
            h2(this, "generateSharedKey", (e, t, r) => {
              this.isInitialized();
              let i = (function (e, t) {
                var r;
                let i,
                  n = c8.getSharedSecret(sh(e, ly), sh(t, ly));
                return su(
                  ((i = void 0),
                  (function (e, t, r, i = 32) {
                    ah(e), al(i);
                    let n = e.outputLen;
                    if (i > 255 * n)
                      throw Error("Length should be <= 255*HashLen");
                    let s = Math.ceil(i / n);
                    void 0 === r && (r = co);
                    let a = new Uint8Array(s * n),
                      o = cs.create(e, t),
                      c = o._cloneInto(),
                      l = new Uint8Array(o.outputLen);
                    for (let e = 0; e < s; e++)
                      (ca[0] = e + 1),
                        c
                          .update(0 === e ? co : l)
                          .update(r)
                          .update(ca)
                          .digestInto(l),
                        a.set(l, n * e),
                        o._cloneInto(c);
                    return o.destroy(), c.destroy(), ag(l, ca), a.slice(0, i);
                  })(
                    ot,
                    ((r = void 0),
                    ah(ot),
                    void 0 === r && (r = new Uint8Array(ot.outputLen)),
                    cs(ot, ak(r), ak(n))),
                    i,
                    32
                  )),
                  ly
                );
              })(this.getPrivateKey(e), t);
              return this.setSymKey(i, r);
            }),
            h2(this, "setSymKey", async (e, t) => {
              this.isInitialized();
              let r = t || lE(e);
              return await this.keychain.set(r, e), r;
            }),
            h2(this, "deleteKeyPair", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            h2(this, "deleteSymKey", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            h2(this, "encode", async (e, t, r) => {
              this.isInitialized();
              let i = lN(r),
                n = (0, W.h)(t);
              if (2 === i.type)
                return (function (e, t) {
                  let r = sh("2", lm),
                    i = aP(12),
                    n = lS({ type: r, sealed: sh(e, lv), iv: i });
                  return t === lb ? l_(n) : n;
                })(n, r?.encoding);
              if (lT(i)) {
                let t = i.senderPublicKey,
                  r = i.receiverPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              let s = this.getSymKey(e),
                { type: a, senderPublicKey: o } = i;
              return (function (e) {
                var t;
                let r =
                  ((t = "u" > typeof e.type ? e.type : 0), sh(`${t}`, lm));
                if (1 === lA(r) && typeof e.senderPublicKey > "u")
                  throw Error("Missing sender public key for type 1 envelope");
                let i =
                    "u" > typeof e.senderPublicKey
                      ? sh(e.senderPublicKey, ly)
                      : void 0,
                  n = "u" > typeof e.iv ? sh(e.iv, ly) : aP(12),
                  s = lS({
                    type: r,
                    sealed: ci(sh(e.symKey, ly), n).encrypt(sh(e.message, lv)),
                    iv: n,
                    senderPublicKey: i,
                  });
                return e.encoding === lb ? l_(s) : s;
              })({
                type: a,
                symKey: s,
                message: n,
                senderPublicKey: o,
                encoding: r?.encoding,
              });
            }),
            h2(this, "decode", async (e, t, r) => {
              this.isInitialized();
              let i = (function (e, t) {
                let r = lk({ encoded: e, encoding: t?.encoding });
                return lN({
                  type: lA(r.type),
                  senderPublicKey:
                    "u" > typeof r.senderPublicKey
                      ? su(r.senderPublicKey, ly)
                      : void 0,
                  receiverPublicKey: t?.receiverPublicKey,
                });
              })(t, r);
              if (2 === i.type) {
                let e = (function (e, t) {
                  let { sealed: r } = lk({ encoded: e, encoding: t });
                  return su(r, lv);
                })(t, r?.encoding);
                return (0, W.j)(e);
              }
              if (lT(i)) {
                let t = i.receiverPublicKey,
                  r = i.senderPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              try {
                let i = this.getSymKey(e),
                  n = (function (e) {
                    let t = sh(e.symKey, ly),
                      { sealed: r, iv: i } = lk({
                        encoded: e.encoded,
                        encoding: e.encoding,
                      }),
                      n = ci(t, i).decrypt(r);
                    if (null === n) throw Error("Failed to decrypt");
                    return su(n, lv);
                  })({ symKey: i, encoded: t, encoding: r?.encoding });
                return (0, W.j)(n);
              } catch (t) {
                this.logger.error(
                  `Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`
                ),
                  this.logger.error(t);
              }
            }),
            h2(this, "getPayloadType", (e, t = lw) =>
              lA(lk({ encoded: e, encoding: t }).type)
            ),
            h2(this, "getPayloadSenderPublicKey", (e, t = lw) => {
              let r = lk({ encoded: e, encoding: t });
              return r.senderPublicKey ? su(r.senderPublicKey, ly) : void 0;
            }),
            (this.core = e),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.keychain = r || new h0(this.core, this.logger));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        async setPrivateKey(e, t) {
          return await this.keychain.set(e, t), e;
        }
        getPrivateKey(e) {
          return this.keychain.get(e);
        }
        async getClientSeed() {
          let e = "";
          try {
            e = this.keychain.get(dH);
          } catch {
            (e = lC()), await this.keychain.set(dH, e);
          }
          return (function (e, t = "utf8") {
            let r = hY[t];
            if (!r) throw Error(`Unsupported encoding "${t}"`);
            return ("utf8" === t || "utf-8" === t) &&
              null != globalThis.Buffer &&
              null != globalThis.Buffer.from
              ? hZ(globalThis.Buffer.from(e, "utf-8"))
              : r.decoder.decode(`${r.prefix}${e}`);
          })(e, "base16");
        }
        getSymKey(e) {
          return this.keychain.get(e);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var h5 = Object.defineProperty,
        h4 = Object.defineProperties,
        h6 = Object.getOwnPropertyDescriptors,
        h8 = Object.getOwnPropertySymbols,
        h9 = Object.prototype.hasOwnProperty,
        h7 = Object.prototype.propertyIsEnumerable,
        ue = (e, t, r) =>
          t in e
            ? h5(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ut = (e, t, r) => ue(e, "symbol" != typeof t ? t + "" : t, r);
      class ur extends et {
        constructor(e, t) {
          super(e, t),
            (this.logger = e),
            (this.core = t),
            ut(this, "messages", new Map()),
            ut(this, "messagesWithoutClientAck", new Map()),
            ut(this, "name", "messages"),
            ut(this, "version", "0.3"),
            ut(this, "initialized", !1),
            ut(this, "storagePrefix", dW),
            ut(this, "init", async () => {
              if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                  let e = await this.getRelayerMessages();
                  "u" > typeof e && (this.messages = e);
                  let t = await this.getRelayerMessagesWithoutClientAck();
                  "u" > typeof t && (this.messagesWithoutClientAck = t),
                    this.logger.debug(
                      `Successfully Restored records for ${this.name}`
                    ),
                    this.logger.trace({
                      type: "method",
                      method: "restore",
                      size: this.messages.size,
                    });
                } catch (e) {
                  this.logger.debug(
                    `Failed to Restore records for ${this.name}`
                  ),
                    this.logger.error(e);
                } finally {
                  this.initialized = !0;
                }
              }
            }),
            ut(this, "set", async (e, t, r) => {
              this.isInitialized();
              let i = lx(t),
                n = this.messages.get(e);
              if ((typeof n > "u" && (n = {}), "u" > typeof n[i])) return i;
              if (((n[i] = t), this.messages.set(e, n), r === dY.inbound)) {
                let r = this.messagesWithoutClientAck.get(e) || {};
                this.messagesWithoutClientAck.set(
                  e,
                  h4(
                    ((e, t) => {
                      for (var r in t || (t = {}))
                        h9.call(t, r) && ue(e, r, t[r]);
                      if (h8)
                        for (var r of h8(t)) h7.call(t, r) && ue(e, r, t[r]);
                      return e;
                    })({}, r),
                    h6({ [i]: t })
                  )
                );
              }
              return await this.persist(), i;
            }),
            ut(this, "get", (e) => {
              this.isInitialized();
              let t = this.messages.get(e);
              return typeof t > "u" && (t = {}), t;
            }),
            ut(this, "getWithoutAck", (e) => {
              this.isInitialized();
              let t = {};
              for (let r of e) {
                let e = this.messagesWithoutClientAck.get(r) || {};
                t[r] = Object.values(e);
              }
              return t;
            }),
            ut(
              this,
              "has",
              (e, t) => (this.isInitialized(), "u" > typeof this.get(e)[lx(t)])
            ),
            ut(this, "ack", async (e, t) => {
              this.isInitialized();
              let r = this.messagesWithoutClientAck.get(e);
              if (typeof r > "u") return;
              let i = lx(t);
              delete r[i],
                0 === Object.keys(r).length
                  ? this.messagesWithoutClientAck.delete(e)
                  : this.messagesWithoutClientAck.set(e, r),
                await this.persist();
            }),
            ut(this, "del", async (e) => {
              this.isInitialized(),
                this.messages.delete(e),
                this.messagesWithoutClientAck.delete(e),
                await this.persist();
            }),
            (this.logger = (0, G.U5)(e, this.name)),
            (this.core = t);
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get storageKeyWithoutClientAck() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name +
            "_withoutClientAck"
          );
        }
        async setRelayerMessages(e) {
          await this.core.storage.setItem(this.storageKey, sM(e));
        }
        async setRelayerMessagesWithoutClientAck(e) {
          await this.core.storage.setItem(
            this.storageKeyWithoutClientAck,
            sM(e)
          );
        }
        async getRelayerMessages() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? sL(e) : void 0;
        }
        async getRelayerMessagesWithoutClientAck() {
          let e = await this.core.storage.getItem(
            this.storageKeyWithoutClientAck
          );
          return "u" > typeof e ? sL(e) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages),
            await this.setRelayerMessagesWithoutClientAck(
              this.messagesWithoutClientAck
            );
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var ui = Object.defineProperty,
        un = Object.defineProperties,
        us = Object.getOwnPropertyDescriptors,
        ua = Object.getOwnPropertySymbols,
        uo = Object.prototype.hasOwnProperty,
        uc = Object.prototype.propertyIsEnumerable,
        ul = (e, t, r) =>
          t in e
            ? ui(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ud = (e, t) => {
          for (var r in t || (t = {})) uo.call(t, r) && ul(e, r, t[r]);
          if (ua) for (var r of ua(t)) uc.call(t, r) && ul(e, r, t[r]);
          return e;
        },
        uh = (e, t) => un(e, us(t)),
        uu = (e, t, r) => ul(e, "symbol" != typeof t ? t + "" : t, r);
      class up extends er {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            uu(this, "events", new w.EventEmitter()),
            uu(this, "name", "publisher"),
            uu(this, "queue", new Map()),
            uu(this, "publishTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            uu(
              this,
              "initialPublishTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            uu(this, "needsTransportRestart", !1),
            uu(this, "publish", async (e, t, r) => {
              var i, n, s, a, o;
              this.logger.debug("Publishing Payload"),
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { topic: e, message: t, opts: r },
                });
              let c = r?.ttl || dz,
                l = r?.prompt || !1,
                d = r?.tag || 0,
                h = r?.id || dw().toString(),
                u = lP(lO().protocol),
                p = {
                  id: h,
                  method: r?.publishMethod || u.publish,
                  params: ud(
                    {
                      topic: e,
                      message: t,
                      ttl: c,
                      prompt: l,
                      tag: d,
                      attestation: r?.attestation,
                    },
                    r?.tvf && { tvf: r.tvf }
                  ),
                },
                f = `Failed to publish payload, please try again. id:${h} tag:${d}`;
              try {
                l2(null == (i = p.params) ? void 0 : i.prompt) &&
                  (null == (n = p.params) || delete n.prompt),
                  l2(null == (s = p.params) ? void 0 : s.tag) &&
                    (null == (a = p.params) || delete a.tag);
                let o = new Promise(async (e) => {
                  let t = ({ id: r }) => {
                    var i;
                    (null == (i = p.id) ? void 0 : i.toString()) ===
                      r.toString() &&
                      (this.removeRequestFromQueue(r),
                      this.relayer.events.removeListener(dZ.publish, t),
                      e());
                  };
                  this.relayer.events.on(dZ.publish, t);
                  let i = sW(
                    new Promise((e, t) => {
                      this.rpcPublish(p, r)
                        .then(e)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial publish, retrying.... id:${h} tag:${d}`
                  );
                  try {
                    await i, this.events.removeListener(dZ.publish, t);
                  } catch (e) {
                    this.queue.set(h, { request: p, opts: r, attempt: 1 }),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { id: h, topic: e, message: t, opts: r },
                }),
                  await sW(o, this.publishTimeout, f);
              } catch (e) {
                if (
                  (this.logger.debug("Failed to Publish Payload"),
                  this.logger.error(e),
                  null != (o = r?.internal) && o.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(h);
              }
            }),
            uu(this, "publishCustom", async (e) => {
              var t, r, i, n, s;
              this.logger.debug("Publishing custom payload"),
                this.logger.trace({
                  type: "method",
                  method: "publishCustom",
                  params: e,
                });
              let { payload: a, opts: o = {} } = e,
                {
                  attestation: c,
                  tvf: l,
                  publishMethod: d,
                  prompt: h,
                  tag: u,
                  ttl: p = v.FIVE_MINUTES,
                } = o,
                f = o.id || dw().toString(),
                g = lP(lO().protocol),
                m = d || g.publish,
                y = {
                  id: f,
                  method: m,
                  params: ud(
                    uh(ud({}, a), {
                      ttl: p,
                      prompt: h,
                      tag: u,
                      attestation: c,
                    }),
                    l
                  ),
                },
                w = `Failed to publish custom payload, please try again. id:${f} tag:${u}`;
              try {
                l2(null == (t = y.params) ? void 0 : t.prompt) &&
                  (null == (r = y.params) || delete r.prompt),
                  l2(null == (i = y.params) ? void 0 : i.tag) &&
                    (null == (n = y.params) || delete n.tag);
                let e = new Promise(async (e) => {
                  let t = ({ id: r }) => {
                    var i;
                    (null == (i = y.id) ? void 0 : i.toString()) ===
                      r.toString() &&
                      (this.removeRequestFromQueue(r),
                      this.relayer.events.removeListener(dZ.publish, t),
                      e());
                  };
                  this.relayer.events.on(dZ.publish, t);
                  let r = sW(
                    new Promise((e, t) => {
                      this.rpcPublish(y, o)
                        .then(e)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial custom payload publish, retrying.... method:${m} id:${f} tag:${u}`
                  );
                  try {
                    await r, this.events.removeListener(dZ.publish, t);
                  } catch (e) {
                    this.queue.set(f, { request: y, opts: o, attempt: 1 }),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { id: f, payload: a, opts: o },
                }),
                  await sW(e, this.publishTimeout, w);
              } catch (e) {
                if (
                  (this.logger.debug("Failed to Publish Payload"),
                  this.logger.error(e),
                  null != (s = o?.internal) && s.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(f);
              }
            }),
            uu(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            uu(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            uu(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            uu(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.relayer = e),
            (this.logger = (0, G.U5)(t, this.name)),
            this.registerEventListeners();
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        async rpcPublish(e, t) {
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "message",
              direction: "outgoing",
              request: e,
            });
          let r = await this.relayer.request(e);
          return (
            this.relayer.events.emit(dZ.publish, ud(ud({}, e), t)),
            this.logger.debug("Successfully Published Payload"),
            r
          );
        }
        removeRequestFromQueue(e) {
          this.queue.delete(e);
        }
        checkQueue() {
          this.queue.forEach(async (e, t) => {
            var r;
            let i = e.attempt + 1;
            this.queue.set(t, uh(ud({}, e), { attempt: i })),
              this.logger.warn(
                {},
                `Publisher: queue->publishing: ${e.request.id}, tag: ${
                  null == (r = e.request.params) ? void 0 : r.tag
                }, attempt: ${i}`
              ),
              await this.rpcPublish(e.request, e.opts),
              this.logger.warn(
                {},
                `Publisher: queue->published: ${e.request.id}`
              );
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(A.pulse, () => {
            if (this.needsTransportRestart) {
              (this.needsTransportRestart = !1),
                this.relayer.events.emit(dZ.connection_stalled);
              return;
            }
            this.checkQueue();
          }),
            this.relayer.on(dZ.message_ack, (e) => {
              this.removeRequestFromQueue(e.id.toString());
            });
        }
      }
      var uf = Object.defineProperty,
        ug = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? uf(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class um {
        constructor() {
          ug(this, "map", new Map()),
            ug(this, "set", (e, t) => {
              let r = this.get(e);
              this.exists(e, t) || this.map.set(e, [...r, t]);
            }),
            ug(this, "get", (e) => this.map.get(e) || []),
            ug(this, "exists", (e, t) => this.get(e).includes(t)),
            ug(this, "delete", (e, t) => {
              if (typeof t > "u") return void this.map.delete(e);
              if (!this.map.has(e)) return;
              let r = this.get(e);
              if (!this.exists(e, t)) return;
              let i = r.filter((e) => e !== t);
              if (!i.length) return void this.map.delete(e);
              this.map.set(e, i);
            }),
            ug(this, "clear", () => {
              this.map.clear();
            });
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      }
      var uy = Object.defineProperty,
        uw = Object.defineProperties,
        ub = Object.getOwnPropertyDescriptors,
        uv = Object.getOwnPropertySymbols,
        uC = Object.prototype.hasOwnProperty,
        uE = Object.prototype.propertyIsEnumerable,
        ux = (e, t, r) =>
          t in e
            ? uy(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uA = (e, t) => {
          for (var r in t || (t = {})) uC.call(t, r) && ux(e, r, t[r]);
          if (uv) for (var r of uv(t)) uE.call(t, r) && ux(e, r, t[r]);
          return e;
        },
        u_ = (e, t) => uw(e, ub(t)),
        uI = (e, t, r) => ux(e, "symbol" != typeof t ? t + "" : t, r);
      class uS extends es {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            uI(this, "subscriptions", new Map()),
            uI(this, "topicMap", new um()),
            uI(this, "events", new w.EventEmitter()),
            uI(this, "name", "subscription"),
            uI(this, "version", "0.3"),
            uI(this, "pending", new Map()),
            uI(this, "cached", []),
            uI(this, "initialized", !1),
            uI(this, "storagePrefix", dW),
            uI(this, "subscribeTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            uI(
              this,
              "initialSubscribeTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            uI(this, "clientId"),
            uI(this, "batchSubscribeTopicsLimit", 500),
            uI(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                this.registerEventListeners(),
                await this.restore()),
                (this.initialized = !0);
            }),
            uI(this, "subscribe", async (e, t) => {
              var r;
              this.isInitialized(),
                this.logger.debug("Subscribing Topic"),
                this.logger.trace({
                  type: "method",
                  method: "subscribe",
                  params: { topic: e, opts: t },
                });
              try {
                let i = lO(t),
                  n = { topic: e, relay: i, transportType: t?.transportType };
                (null != (r = t?.internal) && r.skipSubscribe) ||
                  this.pending.set(e, n);
                let s = await this.rpcSubscribe(e, i, t);
                return (
                  "string" == typeof s &&
                    (this.onSubscribe(s, n),
                    this.logger.debug("Successfully Subscribed Topic"),
                    this.logger.trace({
                      type: "method",
                      method: "subscribe",
                      params: { topic: e, opts: t },
                    })),
                  s
                );
              } catch (e) {
                throw (
                  (this.logger.debug("Failed to Subscribe Topic"),
                  this.logger.error(e),
                  e)
                );
              }
            }),
            uI(this, "unsubscribe", async (e, t) => {
              this.isInitialized(),
                "u" > typeof t?.id
                  ? await this.unsubscribeById(e, t.id, t)
                  : await this.unsubscribeByTopic(e, t);
            }),
            uI(
              this,
              "isSubscribed",
              (e) =>
                new Promise((t) => {
                  t(this.topicMap.topics.includes(e));
                })
            ),
            uI(
              this,
              "isKnownTopic",
              (e) =>
                new Promise((t) => {
                  t(
                    this.topicMap.topics.includes(e) ||
                      this.pending.has(e) ||
                      this.cached.some((t) => t.topic === e)
                  );
                })
            ),
            uI(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            uI(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            uI(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            uI(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            uI(this, "start", async () => {
              await this.onConnect();
            }),
            uI(this, "stop", async () => {
              await this.onDisconnect();
            }),
            uI(this, "restart", async () => {
              await this.restore(), await this.onRestart();
            }),
            uI(this, "checkPending", async () => {
              if (
                0 === this.pending.size &&
                (!this.initialized || !this.relayer.connected)
              )
                return;
              let e = [];
              this.pending.forEach((t) => {
                e.push(t);
              }),
                await this.batchSubscribe(e);
            }),
            uI(this, "registerEventListeners", () => {
              this.relayer.core.heartbeat.on(A.pulse, async () => {
                await this.checkPending();
              }),
                this.events.on(dQ.created, async (e) => {
                  let t = dQ.created;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                }),
                this.events.on(dQ.deleted, async (e) => {
                  let t = dQ.deleted;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                });
            }),
            (this.relayer = e),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.clientId = "");
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.relayer.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        get hasAnyTopics() {
          return (
            this.topicMap.topics.length > 0 ||
            this.pending.size > 0 ||
            this.cached.length > 0 ||
            this.subscriptions.size > 0
          );
        }
        hasSubscription(e, t) {
          let r = !1;
          try {
            r = this.getSubscription(e).topic === t;
          } catch {}
          return r;
        }
        reset() {
          (this.cached = []), (this.initialized = !0);
        }
        onDisable() {
          this.values.length > 0 && (this.cached = this.values),
            this.subscriptions.clear(),
            this.topicMap.clear();
        }
        async unsubscribeByTopic(e, t) {
          let r = this.topicMap.get(e);
          await Promise.all(
            r.map(async (r) => await this.unsubscribeById(e, r, t))
          );
        }
        async unsubscribeById(e, t, r) {
          this.logger.debug("Unsubscribing Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: t, opts: r },
            });
          try {
            let i = lO(r);
            await this.restartToComplete({ topic: e, id: t, relay: i }),
              await this.rpcUnsubscribe(e, t, i);
            let n = lQ("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, n),
              this.logger.debug("Successfully Unsubscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: { topic: e, id: t, opts: r },
              });
          } catch (e) {
            throw (
              (this.logger.debug("Failed to Unsubscribe Topic"),
              this.logger.error(e),
              e)
            );
          }
        }
        async rpcSubscribe(e, t, r) {
          var i, n;
          let s = await this.getSubscriptionId(e);
          if (null != (i = r?.internal) && i.skipSubscribe) return s;
          (r && r?.transportType !== dJ.relay) ||
            (await this.restartToComplete({ topic: e, id: e, relay: t }));
          let a = { method: lP(t.protocol).subscribe, params: { topic: e } };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: a,
            });
          let o = null == (n = r?.internal) ? void 0 : n.throwOnFailedPublish;
          try {
            if (r?.transportType === dJ.link_mode)
              return (
                setTimeout(() => {
                  (this.relayer.connected || this.relayer.connecting) &&
                    this.relayer.request(a).catch((e) => this.logger.warn(e));
                }, (0, v.toMiliseconds)(v.ONE_SECOND)),
                s
              );
            let t = new Promise(async (t) => {
                let r = (i) => {
                  i.topic === e &&
                    (this.events.removeListener(dQ.created, r), t(i.id));
                };
                this.events.on(dQ.created, r);
                try {
                  let i = await sW(
                    new Promise((e, t) => {
                      this.relayer
                        .request(a)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        })
                        .then(e);
                    }),
                    this.initialSubscribeTimeout,
                    `Subscribing to ${e} failed, please try again`
                  );
                  this.events.removeListener(dQ.created, r), t(i);
                } catch {}
              }),
              i = await sW(
                t,
                this.subscribeTimeout,
                `Subscribing to ${e} failed, please try again`
              );
            if (!i && o)
              throw Error(`Subscribing to ${e} failed, please try again`);
            return i ? s : null;
          } catch (e) {
            if (
              (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
              this.relayer.events.emit(dZ.connection_stalled),
              o)
            )
              throw e;
          }
          return null;
        }
        async rpcBatchSubscribe(e) {
          if (!e.length) return;
          let t = {
            method: lP(e[0].relay.protocol).batchSubscribe,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: t,
            });
          try {
            await await sW(
              new Promise((e) => {
                this.relayer
                  .request(t)
                  .catch((e) => this.logger.warn(e))
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchSubscribe failed, please try again"
            );
          } catch {
            this.relayer.events.emit(dZ.connection_stalled);
          }
        }
        async rpcBatchFetchMessages(e) {
          let t;
          if (!e.length) return;
          let r = {
            method: lP(e[0].relay.protocol).batchFetchMessages,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: r,
            });
          try {
            t = await await sW(
              new Promise((e, t) => {
                this.relayer
                  .request(r)
                  .catch((e) => {
                    this.logger.warn(e), t(e);
                  })
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchFetchMessages failed, please try again"
            );
          } catch {
            this.relayer.events.emit(dZ.connection_stalled);
          }
          return t;
        }
        rpcUnsubscribe(e, t, r) {
          let i = {
            method: lP(r.protocol).unsubscribe,
            params: { topic: e, id: t },
          };
          return (
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: i,
            }),
            this.relayer.request(i)
          );
        }
        onSubscribe(e, t) {
          this.setSubscription(e, u_(uA({}, t), { id: e })),
            this.pending.delete(t.topic);
        }
        onBatchSubscribe(e) {
          e.length &&
            e.forEach((e) => {
              this.setSubscription(e.id, uA({}, e)),
                this.pending.delete(e.topic);
            });
        }
        async onUnsubscribe(e, t, r) {
          this.events.removeAllListeners(t),
            this.hasSubscription(t, e) && this.deleteSubscription(t, r),
            await this.relayer.messages.del(e);
        }
        async setRelayerSubscriptions(e) {
          await this.relayer.core.storage.setItem(this.storageKey, e);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e, t) {
          this.logger.debug("Setting subscription"),
            this.logger.trace({
              type: "method",
              method: "setSubscription",
              id: e,
              subscription: t,
            }),
            this.addSubscription(e, t);
        }
        addSubscription(e, t) {
          this.subscriptions.set(e, uA({}, t)),
            this.topicMap.set(t.topic, e),
            this.events.emit(dQ.created, t);
        }
        getSubscription(e) {
          this.logger.debug("Getting subscription"),
            this.logger.trace({
              type: "method",
              method: "getSubscription",
              id: e,
            });
          let t = this.subscriptions.get(e);
          if (!t) {
            let { message: t } = lX("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        deleteSubscription(e, t) {
          this.logger.debug("Deleting subscription"),
            this.logger.trace({
              type: "method",
              method: "deleteSubscription",
              id: e,
              reason: t,
            });
          let r = this.getSubscription(e);
          this.subscriptions.delete(e),
            this.topicMap.delete(r.topic, e),
            this.events.emit(dQ.deleted, u_(uA({}, r), { reason: t }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values),
            this.events.emit(dQ.sync);
        }
        async onRestart() {
          if (this.cached.length) {
            let e = [...this.cached],
              t = Math.ceil(
                this.cached.length / this.batchSubscribeTopicsLimit
              );
            for (let r = 0; r < t; r++) {
              let t = e.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(t);
            }
          }
          this.events.emit(dQ.resubscribed);
        }
        async restore() {
          try {
            let e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (
              this.subscriptions.size &&
              !e.every((e) => {
                var t;
                return (
                  e.topic ===
                  (null == (t = this.subscriptions.get(e.id))
                    ? void 0
                    : t.topic)
                );
              })
            ) {
              let { message: e } = lX("RESTORE_WILL_OVERRIDE", this.name);
              throw (
                (this.logger.error(e),
                this.logger.error(
                  `${this.name}: ${JSON.stringify(this.values)}`
                ),
                Error(e))
              );
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored subscriptions for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values,
              });
          } catch (e) {
            this.logger.debug(
              `Failed to Restore subscriptions for ${this.name}`
            ),
              this.logger.error(e);
          }
        }
        async batchSubscribe(e) {
          e.length &&
            (await this.rpcBatchSubscribe(e),
            this.onBatchSubscribe(
              await Promise.all(
                e.map(async (e) =>
                  u_(uA({}, e), { id: await this.getSubscriptionId(e.topic) })
                )
              )
            ));
        }
        async batchFetchMessages(e) {
          var t;
          if (!e.length) return;
          this.logger.trace(
            `Fetching batch messages for ${e.length} subscriptions`
          );
          let r = await this.rpcBatchFetchMessages(e);
          r &&
            r.messages &&
            (await ((t = (0, v.toMiliseconds)(v.ONE_SECOND)),
            new Promise((e) => setTimeout(e, t))),
            await this.relayer.handleBatchMessageEvents(r.messages));
        }
        async onConnect() {
          await this.restart(), this.reset();
        }
        onDisconnect() {
          this.onDisable();
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async restartToComplete(e) {
          this.relayer.connected ||
            this.relayer.connecting ||
            (this.cached.push(e), await this.relayer.transportOpen());
        }
        async getClientId() {
          return (
            this.clientId ||
              (this.clientId = await this.relayer.core.crypto.getClientId()),
            this.clientId
          );
        }
        async getSubscriptionId(e) {
          return lx(e + (await this.getClientId()));
        }
      }
      var uk = Object.defineProperty,
        uN = Object.getOwnPropertySymbols,
        uT = Object.prototype.hasOwnProperty,
        uO = Object.prototype.propertyIsEnumerable,
        uP = (e, t, r) =>
          t in e
            ? uk(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uR = (e, t) => {
          for (var r in t || (t = {})) uT.call(t, r) && uP(e, r, t[r]);
          if (uN) for (var r of uN(t)) uO.call(t, r) && uP(e, r, t[r]);
          return e;
        },
        u$ = (e, t, r) => uP(e, "symbol" != typeof t ? t + "" : t, r);
      class uD extends ei {
        constructor(e) {
          super(e),
            u$(this, "protocol", "wc"),
            u$(this, "version", 2),
            u$(this, "core"),
            u$(this, "logger"),
            u$(this, "events", new w.EventEmitter()),
            u$(this, "provider"),
            u$(this, "messages"),
            u$(this, "subscriber"),
            u$(this, "publisher"),
            u$(this, "name", "relayer"),
            u$(this, "transportExplicitlyClosed", !1),
            u$(this, "initialized", !1),
            u$(this, "connectionAttemptInProgress", !1),
            u$(this, "relayUrl"),
            u$(this, "projectId"),
            u$(this, "packageName"),
            u$(this, "bundleId"),
            u$(this, "hasExperiencedNetworkDisruption", !1),
            u$(this, "pingTimeout"),
            u$(
              this,
              "heartBeatTimeout",
              (0, v.toMiliseconds)(v.THIRTY_SECONDS + v.FIVE_SECONDS)
            ),
            u$(this, "reconnectTimeout"),
            u$(this, "connectPromise"),
            u$(this, "reconnectInProgress", !1),
            u$(this, "requestsInFlight", []),
            u$(this, "connectTimeout", (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            u$(this, "request", async (e) => {
              var t, r;
              this.logger.debug("Publishing Request Payload");
              let i = e.id || dw().toString();
              await this.toEstablishConnection();
              try {
                this.logger.trace(
                  {
                    id: i,
                    method: e.method,
                    topic: null == (t = e.params) ? void 0 : t.topic,
                  },
                  "relayer.request - publishing..."
                );
                let n = `${i}:${
                  (null == (r = e.params) ? void 0 : r.tag) || ""
                }`;
                this.requestsInFlight.push(n);
                let s = await this.provider.request(e);
                return (
                  (this.requestsInFlight = this.requestsInFlight.filter(
                    (e) => e !== n
                  )),
                  s
                );
              } catch (e) {
                throw (this.logger.debug(`Failed to Publish Request: ${i}`), e);
              }
            }),
            u$(this, "resetPingTimeout", () => {
              sN() &&
                (clearTimeout(this.pingTimeout),
                (this.pingTimeout = setTimeout(() => {
                  var e, t, r, i;
                  try {
                    this.logger.debug(
                      {},
                      "pingTimeout: Connection stalled, terminating..."
                    ),
                      null ==
                        (i =
                          null ==
                          (r =
                            null ==
                            (t =
                              null == (e = this.provider)
                                ? void 0
                                : e.connection)
                              ? void 0
                              : t.socket)
                            ? void 0
                            : r.terminate) || i.call(r);
                  } catch (e) {
                    this.logger.warn(e, e?.message);
                  }
                }, this.heartBeatTimeout)));
            }),
            u$(this, "onPayloadHandler", (e) => {
              this.onProviderPayload(e), this.resetPingTimeout();
            }),
            u$(this, "onConnectHandler", () => {
              this.logger.warn({}, "Relayer connected \uD83D\uDEDC"),
                this.startPingTimeout(),
                this.events.emit(dZ.connect);
            }),
            u$(this, "onDisconnectHandler", () => {
              this.logger.warn({}, "Relayer disconnected \uD83D\uDED1"),
                (this.requestsInFlight = []),
                this.onProviderDisconnect();
            }),
            u$(this, "onProviderErrorHandler", (e) => {
              this.logger.fatal(`Fatal socket error: ${e.message}`),
                this.events.emit(dZ.error, e),
                this.logger.fatal(
                  "Fatal socket error received, closing transport"
                ),
                this.transportClose();
            }),
            u$(this, "registerProviderListeners", () => {
              this.provider.on(dK.payload, this.onPayloadHandler),
                this.provider.on(dK.connect, this.onConnectHandler),
                this.provider.on(dK.disconnect, this.onDisconnectHandler),
                this.provider.on(dK.error, this.onProviderErrorHandler);
            }),
            (this.core = e.core),
            (this.logger =
              "u" > typeof e.logger && "string" != typeof e.logger
                ? (0, G.U5)(e.logger, this.name)
                : (0, G.h6)((0, G.iP)({ level: e.logger || "error" }))),
            (this.messages = new ur(this.logger, e.core)),
            (this.subscriber = new uS(this, this.logger)),
            (this.publisher = new up(this, this.logger)),
            (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || dV),
            sT() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
            (null == r.g ? void 0 : r.g.Platform.OS) === "android"
              ? (this.packageName = sR())
              : sT() &&
                "u" > typeof r.g &&
                "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
                (null == r.g ? void 0 : r.g.Platform.OS) === "ios" &&
                (this.bundleId = sR()),
            (this.provider = {});
        }
        async init() {
          this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await Promise.all([this.messages.init(), this.subscriber.init()]),
            (this.initialized = !0),
            this.transportOpen().catch((e) => this.logger.warn(e, e?.message));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get connected() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 1
          );
        }
        get connecting() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 0 || void 0 !== this.connectPromise
          );
        }
        async publish(e, t, r) {
          this.isInitialized(),
            await this.publisher.publish(e, t, r),
            await this.recordMessageEvent(
              {
                topic: e,
                message: t,
                publishedAt: Date.now(),
                transportType: dJ.relay,
              },
              dY.outbound
            );
        }
        async publishCustom(e) {
          this.isInitialized(), await this.publisher.publishCustom(e);
        }
        async subscribe(e, t) {
          var r, i, n;
          this.isInitialized(),
            (null != t && t.transportType && t?.transportType !== "relay") ||
              (await this.toEstablishConnection());
          let s =
              typeof (null == (r = t?.internal)
                ? void 0
                : r.throwOnFailedPublish) > "u" ||
              (null == (i = t?.internal) ? void 0 : i.throwOnFailedPublish),
            a =
              (null == (n = this.subscriber.topicMap.get(e)) ? void 0 : n[0]) ||
              "",
            o,
            c = (t) => {
              t.topic === e && (this.subscriber.off(dQ.created, c), o());
            };
          return (
            await Promise.all([
              new Promise((e) => {
                (o = e), this.subscriber.on(dQ.created, c);
              }),
              new Promise(async (r, i) => {
                (a =
                  (await this.subscriber
                    .subscribe(
                      e,
                      uR({ internal: { throwOnFailedPublish: s } }, t)
                    )
                    .catch((e) => {
                      s && i(e);
                    })) || a),
                  r();
              }),
            ]),
            a
          );
        }
        async unsubscribe(e, t) {
          this.isInitialized(), await this.subscriber.unsubscribe(e, t);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async transportDisconnect() {
          this.provider.disconnect &&
          (this.hasExperiencedNetworkDisruption || this.connected)
            ? await sW(
                this.provider.disconnect(),
                2e3,
                "provider.disconnect()"
              ).catch(() => this.onProviderDisconnect())
            : this.onProviderDisconnect();
        }
        async transportClose() {
          (this.transportExplicitlyClosed = !0),
            await this.transportDisconnect();
        }
        async transportOpen(e) {
          if (!this.subscriber.hasAnyTopics)
            return void this.logger.info(
              "Starting WS connection skipped because the client has no topics to work with."
            );
          if (
            (this.connectPromise
              ? (this.logger.debug(
                  {},
                  "Waiting for existing connection attempt to resolve..."
                ),
                await this.connectPromise,
                this.logger.debug({}, "Existing connection attempt resolved"))
              : ((this.connectPromise = new Promise(async (t, r) => {
                  await this.connect(e)
                    .then(t)
                    .catch(r)
                    .finally(() => {
                      this.connectPromise = void 0;
                    });
                })),
                await this.connectPromise),
            !this.connected)
          )
            throw Error(
              `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
            );
        }
        async restartTransport(e) {
          this.logger.debug({}, "Restarting transport..."),
            this.connectionAttemptInProgress ||
              ((this.relayUrl = e || this.relayUrl),
              await this.confirmOnlineStateOrThrow(),
              await this.transportClose(),
              await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!(await dn()))
            throw Error(
              "No internet connection detected. Please restart your network and try again."
            );
        }
        async handleBatchMessageEvents(e) {
          if (e?.length === 0)
            return void this.logger.trace(
              "Batch message events is empty. Ignoring..."
            );
          let t = e.sort((e, t) => e.publishedAt - t.publishedAt);
          for (let e of (this.logger.debug(
            `Batch of ${t.length} message events sorted`
          ),
          t))
            try {
              await this.onMessageEvent(e);
            } catch (e) {
              this.logger.warn(
                e,
                "Error while processing batch message event: " + e?.message
              );
            }
          this.logger.trace(`Batch of ${t.length} message events processed`);
        }
        async onLinkMessageEvent(e, t) {
          let { topic: r } = e;
          if (!t.sessionExists) {
            let e = sH(v.FIVE_MINUTES);
            await this.core.pairing.pairings.set(r, {
              topic: r,
              expiry: e,
              relay: { protocol: "irn" },
              active: !1,
            });
          }
          this.events.emit(dZ.message, e),
            await this.recordMessageEvent(e, dY.inbound);
        }
        async connect(e) {
          await this.confirmOnlineStateOrThrow(),
            e &&
              e !== this.relayUrl &&
              ((this.relayUrl = e), await this.transportDisconnect()),
            (this.connectionAttemptInProgress = !0),
            (this.transportExplicitlyClosed = !1);
          let t = 1;
          for (; t < 6; ) {
            try {
              if (this.transportExplicitlyClosed) break;
              this.logger.debug(
                {},
                `Connecting to ${this.relayUrl}, attempt: ${t}...`
              ),
                await this.createProvider(),
                await new Promise(async (e, t) => {
                  let r = () => {
                    t(Error("Connection interrupted while trying to connect"));
                  };
                  this.provider.once(dK.disconnect, r),
                    await sW(
                      new Promise((e, t) => {
                        this.provider.connect().then(e).catch(t);
                      }),
                      this.connectTimeout,
                      `Socket stalled when trying to connect to ${this.relayUrl}`
                    )
                      .catch((e) => {
                        t(e);
                      })
                      .finally(() => {
                        this.provider.off(dK.disconnect, r),
                          clearTimeout(this.reconnectTimeout);
                      }),
                    await new Promise(async (e, r) => {
                      let i = () => {
                        t(
                          Error(
                            "Connection interrupted while trying to subscribe"
                          )
                        );
                      };
                      this.provider.once(dK.disconnect, i),
                        await this.subscriber
                          .start()
                          .then(e)
                          .catch(r)
                          .finally(() => {
                            this.provider.off(dK.disconnect, i);
                          });
                    }),
                    (this.hasExperiencedNetworkDisruption = !1),
                    e();
                });
            } catch (e) {
              await this.subscriber.stop(),
                this.logger.warn({}, e.message),
                (this.hasExperiencedNetworkDisruption = !0);
            } finally {
              this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
              this.logger.debug(
                {},
                `Connected to ${this.relayUrl} successfully on attempt: ${t}`
              );
              break;
            }
            await new Promise((e) => setTimeout(e, (0, v.toMiliseconds)(+t))),
              t++;
          }
        }
        startPingTimeout() {
          var e, t, r, i, n;
          if (sN())
            try {
              null !=
                (t = null == (e = this.provider) ? void 0 : e.connection) &&
                t.socket &&
                (null ==
                  (n =
                    null ==
                    (i = null == (r = this.provider) ? void 0 : r.connection)
                      ? void 0
                      : i.socket) ||
                  n.on("ping", () => {
                    this.resetPingTimeout();
                  })),
                this.resetPingTimeout();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          let e = await this.core.crypto.signJWT(this.relayUrl);
          (this.provider = new dR(
            new dU(
              (function ({
                protocol: e,
                version: t,
                relayUrl: r,
                sdkVersion: i,
                auth: n,
                projectId: s,
                useOnCloseEvent: a,
                bundleId: o,
                packageName: c,
              }) {
                let l = r.split("?"),
                  d = sD(e, t, i),
                  h = (function (e, t) {
                    let r = new URLSearchParams(e);
                    for (let e of Object.keys(t).sort())
                      if (t.hasOwnProperty(e)) {
                        let i = t[e];
                        void 0 !== i && r.set(e, i);
                      }
                    return r.toString();
                  })(l[1] || "", {
                    auth: n,
                    ua: d,
                    projectId: s,
                    useOnCloseEvent: a || void 0,
                    packageName: c || void 0,
                    bundleId: o || void 0,
                  });
                return l[0] + "?" + h;
              })({
                sdkVersion: dG,
                protocol: this.protocol,
                version: this.version,
                relayUrl: this.relayUrl,
                projectId: this.projectId,
                auth: e,
                useOnCloseEvent: !0,
                bundleId: this.bundleId,
                packageName: this.packageName,
              })
            )
          )),
            this.registerProviderListeners();
        }
        async recordMessageEvent(e, t) {
          let { topic: r, message: i } = e;
          await this.messages.set(r, i, t);
        }
        async shouldIgnoreMessageEvent(e) {
          let { topic: t, message: r } = e;
          if (!r || 0 === r.length)
            return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
          if (!(await this.subscriber.isKnownTopic(t)))
            return (
              this.logger.warn(`Ignoring message for unknown topic ${t}`), !0
            );
          let i = this.messages.has(t, r);
          return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i;
        }
        async onProviderPayload(e) {
          if (
            (this.logger.debug("Incoming Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "incoming",
              payload: e,
            }),
            dN(e))
          ) {
            if (!e.method.endsWith("_subscription")) return;
            let t = e.params,
              { topic: r, message: i, publishedAt: n, attestation: s } = t.data,
              a = {
                topic: r,
                message: i,
                publishedAt: n,
                transportType: dJ.relay,
                attestation: s,
              };
            this.logger.debug("Emitting Relayer Payload"),
              this.logger.trace(uR({ type: "event", event: t.id }, a)),
              this.events.emit(t.id, a),
              await this.acknowledgePayload(e),
              await this.onMessageEvent(a);
          } else dT(e) && this.events.emit(dZ.message_ack, e);
        }
        async onMessageEvent(e) {
          (await this.shouldIgnoreMessageEvent(e)) ||
            (await this.recordMessageEvent(e, dY.inbound),
            this.events.emit(dZ.message, e));
        }
        async acknowledgePayload(e) {
          let t = dv(e.id, !0);
          await this.provider.connection.send(t);
        }
        unregisterProviderListeners() {
          this.provider.off(dK.payload, this.onPayloadHandler),
            this.provider.off(dK.connect, this.onConnectHandler),
            this.provider.off(dK.disconnect, this.onDisconnectHandler),
            this.provider.off(dK.error, this.onProviderErrorHandler),
            clearTimeout(this.pingTimeout);
        }
        async registerEventListeners() {
          let e = await dn();
          (function (e) {
            var t, i;
            switch (sP()) {
              case sk.browser:
                (t = e),
                  !sT() &&
                    sO() &&
                    (window.addEventListener("online", () => t(!0)),
                    window.addEventListener("offline", () => t(!1)));
                break;
              case sk.reactNative:
                (i = e),
                  sT() &&
                    "u" > typeof r.g &&
                    null != r.g &&
                    r.g.NetInfo &&
                    r.g?.NetInfo.addEventListener((e) => i(e?.isConnected));
              case sk.node:
            }
          })(async (t) => {
            e !== t &&
              ((e = t),
              t
                ? await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  )
                : ((this.hasExperiencedNetworkDisruption = !0),
                  await this.transportDisconnect(),
                  (this.transportExplicitlyClosed = !1)));
          }),
            this.core.heartbeat.on(A.pulse, async () => {
              var e;
              if (
                !this.transportExplicitlyClosed &&
                !this.connected &&
                (!(sO() && (0, rP.getDocument)()) ||
                  (null == (e = (0, rP.getDocument)())
                    ? void 0
                    : e.visibilityState) === "visible")
              )
                try {
                  await this.confirmOnlineStateOrThrow(),
                    await this.transportOpen();
                } catch (e) {
                  this.logger.warn(e, e?.message);
                }
            });
        }
        async onProviderDisconnect() {
          clearTimeout(this.pingTimeout),
            this.events.emit(dZ.disconnect),
            (this.connectionAttemptInProgress = !1),
            !this.reconnectInProgress &&
              ((this.reconnectInProgress = !0),
              await this.subscriber.stop(),
              this.subscriber.hasAnyTopics &&
                (this.transportExplicitlyClosed ||
                  (this.reconnectTimeout = setTimeout(async () => {
                    await this.transportOpen().catch((e) =>
                      this.logger.error(e, e?.message)
                    ),
                      (this.reconnectTimeout = void 0),
                      (this.reconnectInProgress = !1);
                  }, (0, v.toMiliseconds)(0.1)))));
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async toEstablishConnection() {
          if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
            if (this.connectPromise) return void (await this.connectPromise);
            await this.connect();
          }
        }
      }
      function uU(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function uM(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let uL = "[object Arguments]",
        uB = "[object Object]";
      function uW() {}
      function uj(e) {
        if (!e || "object" != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t ||
            t === Object.prototype ||
            null === Object.getPrototypeOf(t)) &&
          "[object Object]" === Object.prototype.toString.call(e)
        );
      }
      var uF = Object.defineProperty,
        uH = Object.getOwnPropertySymbols,
        uq = Object.prototype.hasOwnProperty,
        uz = Object.prototype.propertyIsEnumerable,
        uV = (e, t, r) =>
          t in e
            ? uF(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uZ = (e, t) => {
          for (var r in t || (t = {})) uq.call(t, r) && uV(e, r, t[r]);
          if (uH) for (var r of uH(t)) uz.call(t, r) && uV(e, r, t[r]);
          return e;
        },
        uK = (e, t, r) => uV(e, "symbol" != typeof t ? t + "" : t, r);
      class uG extends en {
        constructor(e, t, r, i = dW, n) {
          super(e, t, r, i),
            (this.core = e),
            (this.logger = t),
            (this.name = r),
            uK(this, "map", new Map()),
            uK(this, "version", "0.3"),
            uK(this, "cached", []),
            uK(this, "initialized", !1),
            uK(this, "getKey"),
            uK(this, "storagePrefix", dW),
            uK(this, "recentlyDeleted", []),
            uK(this, "recentlyDeletedLimit", 200),
            uK(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => {
                  this.getKey && null !== e && !l2(e)
                    ? this.map.set(this.getKey(e), e)
                    : (function (e) {
                        var t;
                        return null == (t = e?.proposer) ? void 0 : t.publicKey;
                      })(e)
                    ? this.map.set(e.id, e)
                    : e?.topic && this.map.set(e.topic, e);
                }),
                (this.cached = []),
                (this.initialized = !0));
            }),
            uK(this, "set", async (e, t) => {
              this.isInitialized(),
                this.map.has(e)
                  ? await this.update(e, t)
                  : (this.logger.debug("Setting value"),
                    this.logger.trace({
                      type: "method",
                      method: "set",
                      key: e,
                      value: t,
                    }),
                    this.map.set(e, t),
                    await this.persist());
            }),
            uK(
              this,
              "get",
              (e) => (
                this.isInitialized(),
                this.logger.debug("Getting value"),
                this.logger.trace({ type: "method", method: "get", key: e }),
                this.getData(e)
              )
            ),
            uK(
              this,
              "getAll",
              (e) => (
                this.isInitialized(),
                e
                  ? this.values.filter((t) =>
                      Object.keys(e).every((r) => {
                        var i;
                        return (
                          (i = t[r]),
                          (function e(t, r, i, n, s, a, o) {
                            let c = o(t, r, i, n, s, a);
                            if (void 0 !== c) return c;
                            if (typeof t == typeof r)
                              switch (typeof t) {
                                case "bigint":
                                case "string":
                                case "boolean":
                                case "symbol":
                                case "undefined":
                                case "function":
                                  return t === r;
                                case "number":
                                  return t === r || Object.is(t, r);
                              }
                            return (function t(r, i, n, s) {
                              if (Object.is(r, i)) return !0;
                              let a = uM(r),
                                o = uM(i);
                              if (
                                (a === uL && (a = uB),
                                o === uL && (o = uB),
                                a !== o)
                              )
                                return !1;
                              switch (a) {
                                case "[object String]":
                                  return r.toString() === i.toString();
                                case "[object Number]": {
                                  let e = r.valueOf(),
                                    t = i.valueOf();
                                  return (
                                    e === t ||
                                    (Number.isNaN(e) && Number.isNaN(t))
                                  );
                                }
                                case "[object Boolean]":
                                case "[object Date]":
                                case "[object Symbol]":
                                  return Object.is(r.valueOf(), i.valueOf());
                                case "[object RegExp]":
                                  return (
                                    r.source === i.source && r.flags === i.flags
                                  );
                                case "[object Function]":
                                  return r === i;
                              }
                              let c = (n = n ?? new Map()).get(r),
                                l = n.get(i);
                              if (null != c && null != l) return c === i;
                              n.set(r, i), n.set(i, r);
                              try {
                                switch (a) {
                                  case "[object Map]":
                                    if (r.size !== i.size) return !1;
                                    for (let [t, a] of r.entries())
                                      if (
                                        !i.has(t) ||
                                        !e(a, i.get(t), t, r, i, n, s)
                                      )
                                        return !1;
                                    return !0;
                                  case "[object Set]": {
                                    if (r.size !== i.size) return !1;
                                    let t = Array.from(r.values()),
                                      a = Array.from(i.values());
                                    for (let o = 0; o < t.length; o++) {
                                      let c = t[o],
                                        l = a.findIndex((t) =>
                                          e(c, t, void 0, r, i, n, s)
                                        );
                                      if (-1 === l) return !1;
                                      a.splice(l, 1);
                                    }
                                    return !0;
                                  }
                                  case "[object Array]":
                                  case "[object Uint8Array]":
                                  case "[object Uint8ClampedArray]":
                                  case "[object Uint16Array]":
                                  case "[object Uint32Array]":
                                  case "[object BigUint64Array]":
                                  case "[object Int8Array]":
                                  case "[object Int16Array]":
                                  case "[object Int32Array]":
                                  case "[object BigInt64Array]":
                                  case "[object Float32Array]":
                                  case "[object Float64Array]":
                                    if (
                                      ("u" > typeof dM &&
                                        dM.isBuffer(r) !== dM.isBuffer(i)) ||
                                      r.length !== i.length
                                    )
                                      return !1;
                                    for (let t = 0; t < r.length; t++)
                                      if (!e(r[t], i[t], t, r, i, n, s))
                                        return !1;
                                    return !0;
                                  case "[object ArrayBuffer]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        n,
                                        s
                                      )
                                    );
                                  case "[object DataView]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      r.byteOffset === i.byteOffset &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        n,
                                        s
                                      )
                                    );
                                  case "[object Error]":
                                    return (
                                      r.name === i.name &&
                                      r.message === i.message
                                    );
                                  case uB: {
                                    if (
                                      !(
                                        t(r.constructor, i.constructor, n, s) ||
                                        (uj(r) && uj(i))
                                      )
                                    )
                                      return !1;
                                    let a = [...Object.keys(r), ...uU(r)],
                                      o = [...Object.keys(i), ...uU(i)];
                                    if (a.length !== o.length) return !1;
                                    for (let t = 0; t < a.length; t++) {
                                      let o = a[t],
                                        c = r[o];
                                      if (!Object.hasOwn(i, o)) return !1;
                                      let l = i[o];
                                      if (!e(c, l, o, r, i, n, s)) return !1;
                                    }
                                    return !0;
                                  }
                                  default:
                                    return !1;
                                }
                              } finally {
                                n.delete(r), n.delete(i);
                              }
                            })(t, r, a, o);
                          })(i, e[r], void 0, void 0, void 0, void 0, uW)
                        );
                      })
                    )
                  : this.values
              )
            ),
            uK(this, "update", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Updating value"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  key: e,
                  update: t,
                });
              let r = uZ(uZ({}, this.getData(e)), t);
              this.map.set(e, r), await this.persist();
            }),
            uK(this, "delete", async (e, t) => {
              this.isInitialized(),
                this.map.has(e) &&
                  (this.logger.debug("Deleting value"),
                  this.logger.trace({
                    type: "method",
                    method: "delete",
                    key: e,
                    reason: t,
                  }),
                  this.map.delete(e),
                  this.addToRecentlyDeleted(e),
                  await this.persist());
            }),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.storagePrefix = i),
            (this.getKey = n);
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        addToRecentlyDeleted(e) {
          this.recentlyDeleted.push(e),
            this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
              this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
        }
        async setDataStore(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e) {
          let t = this.map.get(e);
          if (!t) {
            if (this.recentlyDeleted.includes(e)) {
              let { message: t } = lX(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${this.name}: ${e}`
              );
              throw (this.logger.error(t), Error(t));
            }
            let { message: t } = lX("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.error(t), Error(t));
          }
          return t;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            let e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
              let { message: e } = lX("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored value for ${this.name}`),
              this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
              this.logger.error(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var uJ = Object.defineProperty,
        uY = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? uJ(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class uX {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            uY(this, "name", "pairing"),
            uY(this, "version", "0.3"),
            uY(this, "events", new (b())()),
            uY(this, "pairings"),
            uY(this, "initialized", !1),
            uY(this, "storagePrefix", dW),
            uY(this, "ignoredPayloadTypes", [1]),
            uY(this, "registeredMethods", []),
            uY(this, "init", async () => {
              this.initialized ||
                (await this.pairings.init(),
                await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                (this.initialized = !0),
                this.logger.trace("Initialized"));
            }),
            uY(this, "register", ({ methods: e }) => {
              this.isInitialized(),
                (this.registeredMethods = [
                  ...new Set([...this.registeredMethods, ...e]),
                ]);
            }),
            uY(this, "create", async (e) => {
              this.isInitialized();
              let t = lC(),
                r = await this.core.crypto.setSymKey(t),
                i = sH(v.FIVE_MINUTES),
                n = { protocol: "irn" },
                s = {
                  topic: r,
                  expiry: i,
                  relay: n,
                  active: !1,
                  methods: e?.methods,
                },
                a = l$({
                  protocol: this.core.protocol,
                  version: this.core.version,
                  topic: r,
                  symKey: t,
                  relay: n,
                  expiryTimestamp: i,
                  methods: e?.methods,
                });
              return (
                this.events.emit(d1.create, s),
                this.core.expirer.set(r, i),
                await this.pairings.set(r, s),
                await this.core.relayer.subscribe(r, {
                  transportType: e?.transportType,
                  internal: e?.internal,
                }),
                { topic: r, uri: a }
              );
            }),
            uY(this, "pair", async (e) => {
              let t;
              this.isInitialized();
              let r = this.core.eventClient.createEvent({
                properties: { topic: e?.uri, trace: [d8.pairing_started] },
              });
              this.isValidPair(e, r);
              let {
                topic: i,
                symKey: n,
                relay: s,
                expiryTimestamp: a,
                methods: o,
              } = lR(e.uri);
              if (
                ((r.props.properties.topic = i),
                r.addTrace(d8.pairing_uri_validation_success),
                r.addTrace(d8.pairing_uri_not_expired),
                this.pairings.keys.includes(i))
              ) {
                if (
                  ((t = this.pairings.get(i)),
                  r.addTrace(d8.existing_pairing),
                  t.active)
                )
                  throw (
                    (r.setError(d9.active_pairing_already_exists),
                    Error(
                      `Pairing already exists: ${i}. Please try again with a new connection URI.`
                    ))
                  );
                r.addTrace(d8.pairing_not_expired);
              }
              let c = a || sH(v.FIVE_MINUTES),
                l = { topic: i, relay: s, expiry: c, active: !1, methods: o };
              this.core.expirer.set(i, c),
                await this.pairings.set(i, l),
                r.addTrace(d8.store_new_pairing),
                e.activatePairing && (await this.activate({ topic: i })),
                this.events.emit(d1.create, l),
                r.addTrace(d8.emit_inactive_pairing),
                this.core.crypto.keychain.has(i) ||
                  (await this.core.crypto.setSymKey(n, i)),
                r.addTrace(d8.subscribing_pairing_topic);
              try {
                await this.core.relayer.confirmOnlineStateOrThrow();
              } catch {
                r.setError(d9.no_internet_connection);
              }
              try {
                await this.core.relayer.subscribe(i, { relay: s });
              } catch (e) {
                throw (r.setError(d9.subscribe_pairing_topic_failure), e);
              }
              return r.addTrace(d8.subscribe_pairing_topic_success), l;
            }),
            uY(this, "activate", async ({ topic: e }) => {
              this.isInitialized();
              let t = sH(v.FIVE_MINUTES);
              this.core.expirer.set(e, t),
                await this.pairings.update(e, { active: !0, expiry: t });
            }),
            uY(this, "ping", async (e) => {
              this.isInitialized(),
                await this.isValidPing(e),
                this.logger.warn(
                  "ping() is deprecated and will be removed in the next major release."
                );
              let { topic: t } = e;
              if (this.pairings.keys.includes(t)) {
                let e = await this.sendRequest(t, "wc_pairingPing", {}),
                  { done: r, resolve: i, reject: n } = sB();
                this.events.once(sz("pairing_ping", e), ({ error: e }) => {
                  e ? n(e) : i();
                }),
                  await r();
              }
            }),
            uY(this, "updateExpiry", async ({ topic: e, expiry: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { expiry: t });
            }),
            uY(this, "updateMetadata", async ({ topic: e, metadata: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { peerMetadata: t });
            }),
            uY(
              this,
              "getPairings",
              () => (this.isInitialized(), this.pairings.values)
            ),
            uY(this, "disconnect", async (e) => {
              this.isInitialized(), await this.isValidDisconnect(e);
              let { topic: t } = e;
              this.pairings.keys.includes(t) &&
                (await this.sendRequest(
                  t,
                  "wc_pairingDelete",
                  lQ("USER_DISCONNECTED")
                ),
                await this.deletePairing(t));
            }),
            uY(this, "formatUriFromPairing", (e) => {
              this.isInitialized();
              let { topic: t, relay: r, expiry: i, methods: n } = e,
                s = this.core.crypto.keychain.get(t);
              return l$({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: t,
                symKey: s,
                relay: r,
                expiryTimestamp: i,
                methods: n,
              });
            }),
            uY(this, "sendRequest", async (e, t, r) => {
              let i = db(t, r),
                n = await this.core.crypto.encode(e, i),
                s = d0[t].req;
              return (
                this.core.history.set(e, i),
                this.core.relayer.publish(e, n, s),
                i.id
              );
            }),
            uY(this, "sendResult", async (e, t, r) => {
              let i = dv(e, r),
                n = await this.core.crypto.encode(t, i),
                s = d0[(await this.core.history.get(t, e)).request.method].res;
              await this.core.relayer.publish(t, n, s),
                await this.core.history.resolve(i);
            }),
            uY(this, "sendError", async (e, t, r) => {
              let i = dC(e, r),
                n = await this.core.crypto.encode(t, i),
                s = (await this.core.history.get(t, e)).request.method,
                a = d0[s] ? d0[s].res : d0.unregistered_method.res;
              await this.core.relayer.publish(t, n, a),
                await this.core.history.resolve(i);
            }),
            uY(this, "deletePairing", async (e, t) => {
              await this.core.relayer.unsubscribe(e),
                await Promise.all([
                  this.pairings.delete(e, lQ("USER_DISCONNECTED")),
                  this.core.crypto.deleteSymKey(e),
                  t ? Promise.resolve() : this.core.expirer.del(e),
                ]);
            }),
            uY(this, "cleanup", async () => {
              let e = this.pairings.getAll().filter((e) => sq(e.expiry));
              await Promise.all(e.map((e) => this.deletePairing(e.topic)));
            }),
            uY(this, "onRelayEventRequest", async (e) => {
              let { topic: t, payload: r } = e;
              switch (r.method) {
                case "wc_pairingPing":
                  return await this.onPairingPingRequest(t, r);
                case "wc_pairingDelete":
                  return await this.onPairingDeleteRequest(t, r);
                default:
                  return await this.onUnknownRpcMethodRequest(t, r);
              }
            }),
            uY(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r } = e,
                i = (await this.core.history.get(t, r.id)).request.method;
              return "wc_pairingPing" === i
                ? this.onPairingPingResponse(t, r)
                : this.onUnknownRpcMethodResponse(i);
            }),
            uY(this, "onPairingPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult(r, e, !0),
                  this.events.emit(d1.ping, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uY(this, "onPairingPingResponse", (e, t) => {
              let { id: r } = t;
              setTimeout(() => {
                dO(t)
                  ? this.events.emit(sz("pairing_ping", r), {})
                  : dP(t) &&
                    this.events.emit(sz("pairing_ping", r), { error: t.error });
              }, 500);
            }),
            uY(this, "onPairingDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e }),
                  await this.deletePairing(e),
                  this.events.emit(d1.delete, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uY(this, "onUnknownRpcMethodRequest", async (e, t) => {
              let { id: r, method: i } = t;
              try {
                if (this.registeredMethods.includes(i)) return;
                let t = lQ("WC_METHOD_UNSUPPORTED", i);
                await this.sendError(r, e, t), this.logger.error(t);
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uY(this, "onUnknownRpcMethodResponse", (e) => {
              this.registeredMethods.includes(e) ||
                this.logger.error(lQ("WC_METHOD_UNSUPPORTED", e));
            }),
            uY(this, "isValidPair", (e, t) => {
              var r;
              if (!de(e)) {
                let { message: r } = lX(
                  "MISSING_OR_INVALID",
                  `pair() params: ${e}`
                );
                throw (t.setError(d9.malformed_pairing_uri), Error(r));
              }
              if (
                !(function (e) {
                  function t(e) {
                    try {
                      return "u" > typeof new URL(e);
                    } catch {
                      return !1;
                    }
                  }
                  try {
                    if (l3(e, !1)) {
                      if (t(e)) return !0;
                      let r = sX(e);
                      return t(r);
                    }
                  } catch {}
                  return !1;
                })(e.uri)
              ) {
                let { message: r } = lX(
                  "MISSING_OR_INVALID",
                  `pair() uri: ${e.uri}`
                );
                throw (t.setError(d9.malformed_pairing_uri), Error(r));
              }
              let i = lR(e?.uri);
              if (!(null != (r = i?.relay) && r.protocol)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  "pair() uri#relay-protocol"
                );
                throw (t.setError(d9.malformed_pairing_uri), Error(e));
              }
              if (!(null != i && i.symKey)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  "pair() uri#symKey"
                );
                throw (t.setError(d9.malformed_pairing_uri), Error(e));
              }
              if (
                null != i &&
                i.expiryTimestamp &&
                (0, v.toMiliseconds)(i?.expiryTimestamp) < Date.now()
              ) {
                t.setError(d9.pairing_expired);
                let { message: e } = lX(
                  "EXPIRED",
                  "pair() URI has expired. Please try again with a new connection URI."
                );
                throw Error(e);
              }
            }),
            uY(this, "isValidPing", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            uY(this, "isValidDisconnect", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            uY(this, "isValidPairingTopic", async (e) => {
              if (!l3(e, !1)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `pairing topic should be a string: ${e}`
                );
                throw Error(t);
              }
              if (!this.pairings.keys.includes(e)) {
                let { message: t } = lX(
                  "NO_MATCHING_KEY",
                  `pairing topic doesn't exist: ${e}`
                );
                throw Error(t);
              }
              if (sq(this.pairings.get(e).expiry)) {
                await this.deletePairing(e);
                let { message: t } = lX("EXPIRED", `pairing topic: ${e}`);
                throw Error(t);
              }
            }),
            (this.core = e),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.pairings = new uG(
              this.core,
              this.logger,
              this.name,
              this.storagePrefix
            ));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(dZ.message, async (e) => {
            let { topic: t, message: r, transportType: i } = e;
            if (
              this.pairings.keys.includes(t) &&
              i !== dJ.link_mode &&
              !this.ignoredPayloadTypes.includes(
                this.core.crypto.getPayloadType(r)
              )
            )
              try {
                let e = await this.core.crypto.decode(t, r);
                dN(e)
                  ? (this.core.history.set(t, e),
                    await this.onRelayEventRequest({ topic: t, payload: e }))
                  : dT(e) &&
                    (await this.core.history.resolve(e),
                    await this.onRelayEventResponse({ topic: t, payload: e }),
                    this.core.history.delete(t, e.id)),
                  await this.core.relayer.messages.ack(t, r);
              } catch (e) {
                this.logger.error(e);
              }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(d3.expired, async (e) => {
            let { topic: t } = sF(e.target);
            t &&
              this.pairings.keys.includes(t) &&
              (await this.deletePairing(t, !0),
              this.events.emit(d1.expire, { topic: t }));
          });
        }
      }
      var uQ = Object.defineProperty,
        u0 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? uQ(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class u1 extends ee {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            u0(this, "records", new Map()),
            u0(this, "events", new w.EventEmitter()),
            u0(this, "name", "history"),
            u0(this, "version", "0.3"),
            u0(this, "cached", []),
            u0(this, "initialized", !1),
            u0(this, "storagePrefix", dW),
            u0(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.records.set(e.id, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            u0(this, "set", (e, t, r) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Setting JSON-RPC request history record"),
                this.logger.trace({
                  type: "method",
                  method: "set",
                  topic: e,
                  request: t,
                  chainId: r,
                }),
                this.records.has(t.id))
              )
                return;
              let i = {
                id: t.id,
                topic: e,
                request: { method: t.method, params: t.params || null },
                chainId: r,
                expiry: sH(v.THIRTY_DAYS),
              };
              this.records.set(i.id, i),
                this.persist(),
                this.events.emit(d2.created, i);
            }),
            u0(this, "resolve", async (e) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Updating JSON-RPC response history record"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  response: e,
                }),
                !this.records.has(e.id))
              )
                return;
              let t = await this.getRecord(e.id);
              typeof t.response > "u" &&
                ((t.response = dP(e)
                  ? { error: e.error }
                  : { result: e.result }),
                this.records.set(t.id, t),
                this.persist(),
                this.events.emit(d2.updated, t));
            }),
            u0(
              this,
              "get",
              async (e, t) => (
                this.isInitialized(),
                this.logger.debug("Getting record"),
                this.logger.trace({
                  type: "method",
                  method: "get",
                  topic: e,
                  id: t,
                }),
                await this.getRecord(t)
              )
            ),
            u0(this, "delete", (e, t) => {
              this.isInitialized(),
                this.logger.debug("Deleting record"),
                this.logger.trace({ type: "method", method: "delete", id: t }),
                this.values.forEach((r) => {
                  r.topic === e &&
                    (("u" > typeof t && r.id !== t) ||
                      (this.records.delete(r.id),
                      this.events.emit(d2.deleted, r)));
                }),
                this.persist();
            }),
            u0(
              this,
              "exists",
              async (e, t) => (
                this.isInitialized(),
                !!this.records.has(t) && (await this.getRecord(t)).topic === e
              )
            ),
            u0(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            u0(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            u0(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            u0(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, G.U5)(t, this.name));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          let e = [];
          return (
            this.values.forEach((t) => {
              if ("u" > typeof t.response) return;
              let r = {
                topic: t.topic,
                request: db(t.request.method, t.request.params, t.id),
                chainId: t.chainId,
              };
              return e.push(r);
            }),
            e
          );
        }
        async setJsonRpcRecords(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e) {
          this.isInitialized();
          let t = this.records.get(e);
          if (!t) {
            let { message: t } = lX("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(d2.sync);
        }
        async restore() {
          try {
            let e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
              let { message: e } = lX("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(e);
          }
        }
        registerEventListeners() {
          this.events.on(d2.created, (e) => {
            let t = d2.created;
            this.logger.info(`Emitting ${t}`),
              this.logger.debug({ type: "event", event: t, record: e });
          }),
            this.events.on(d2.updated, (e) => {
              let t = d2.updated;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.events.on(d2.deleted, (e) => {
              let t = d2.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.core.heartbeat.on(A.pulse, () => {
              this.cleanup();
            });
        }
        cleanup() {
          try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t) => {
              (0, v.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 &&
                (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(d2.deleted, t, !1),
                (e = !0));
            }),
              e && this.persist();
          } catch (e) {
            this.logger.warn(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var u2 = Object.defineProperty,
        u3 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? u2(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class u5 extends ea {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            u3(this, "expirations", new Map()),
            u3(this, "events", new w.EventEmitter()),
            u3(this, "name", "expirer"),
            u3(this, "version", "0.3"),
            u3(this, "cached", []),
            u3(this, "initialized", !1),
            u3(this, "storagePrefix", dW),
            u3(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.expirations.set(e.target, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            u3(this, "has", (e) => {
              try {
                let t = this.formatTarget(e);
                return "u" > typeof this.getExpiration(t);
              } catch {
                return !1;
              }
            }),
            u3(this, "set", (e, t) => {
              this.isInitialized();
              let r = this.formatTarget(e),
                i = { target: r, expiry: t };
              this.expirations.set(r, i),
                this.checkExpiry(r, i),
                this.events.emit(d3.created, { target: r, expiration: i });
            }),
            u3(this, "get", (e) => {
              this.isInitialized();
              let t = this.formatTarget(e);
              return this.getExpiration(t);
            }),
            u3(this, "del", (e) => {
              if ((this.isInitialized(), this.has(e))) {
                let t = this.formatTarget(e),
                  r = this.getExpiration(t);
                this.expirations.delete(t),
                  this.events.emit(d3.deleted, { target: t, expiration: r });
              }
            }),
            u3(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            u3(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            u3(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            u3(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, G.U5)(t, this.name));
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e) {
          if ("string" == typeof e) return sj("topic", e);
          if ("number" == typeof e) return sj("id", e);
          let { message: t } = lX("UNKNOWN_TYPE", `Target type: ${typeof e}`);
          throw Error(t);
        }
        async setExpirations(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(d3.sync);
        }
        async restore() {
          try {
            let e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
              let { message: e } = lX("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored expirations for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
              this.logger.error(e);
          }
        }
        getExpiration(e) {
          let t = this.expirations.get(e);
          if (!t) {
            let { message: t } = lX("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.warn(t), Error(t));
          }
          return t;
        }
        checkExpiry(e, t) {
          let { expiry: r } = t;
          (0, v.toMiliseconds)(r) - Date.now() <= 0 && this.expire(e, t);
        }
        expire(e, t) {
          this.expirations.delete(e),
            this.events.emit(d3.expired, { target: e, expiration: t });
        }
        checkExpirations() {
          this.core.relayer.connected &&
            this.expirations.forEach((e, t) => this.checkExpiry(t, e));
        }
        registerEventListeners() {
          this.core.heartbeat.on(A.pulse, () => this.checkExpirations()),
            this.events.on(d3.created, (e) => {
              let t = d3.created;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(d3.expired, (e) => {
              let t = d3.expired;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(d3.deleted, (e) => {
              let t = d3.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            });
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var u4 = Object.defineProperty,
        u6 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? u4(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class u8 extends eo {
        constructor(e, t, r) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            (this.store = r),
            u6(this, "name", "verify-api"),
            u6(this, "abortController"),
            u6(this, "isDevEnv"),
            u6(this, "verifyUrlV3", d4),
            u6(this, "storagePrefix", dW),
            u6(this, "version", 2),
            u6(this, "publicKey"),
            u6(this, "fetchPromise"),
            u6(this, "init", async () => {
              var e;
              this.isDevEnv ||
                ((this.publicKey = await this.store.getItem(this.storeKey)),
                this.publicKey &&
                  (0, v.toMiliseconds)(
                    null == (e = this.publicKey) ? void 0 : e.expiresAt
                  ) < Date.now() &&
                  (this.logger.debug("verify v2 public key expired"),
                  await this.removePublicKey()));
            }),
            u6(this, "register", async (e) => {
              if (!sO() || this.isDevEnv) return;
              let t = window.location.origin,
                { id: r, decryptedId: i } = e,
                n = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${r}&decryptedId=${i}`;
              try {
                let e = (0, rP.getDocument)(),
                  t = this.startAbortTimer(5 * v.ONE_SECOND),
                  i = await new Promise((i, s) => {
                    let a = () => {
                      window.removeEventListener("message", c),
                        e.body.removeChild(o),
                        s("attestation aborted");
                    };
                    this.abortController.signal.addEventListener("abort", a);
                    let o = e.createElement("iframe");
                    (o.src = n),
                      (o.style.display = "none"),
                      o.addEventListener("error", a, {
                        signal: this.abortController.signal,
                      });
                    let c = (n) => {
                      if (n.data && "string" == typeof n.data)
                        try {
                          let s = JSON.parse(n.data);
                          if ("verify_attestation" === s.type) {
                            if (rb(s.attestation).payload.id !== r) return;
                            clearInterval(t),
                              e.body.removeChild(o),
                              this.abortController.signal.removeEventListener(
                                "abort",
                                a
                              ),
                              window.removeEventListener("message", c),
                              i(null === s.attestation ? "" : s.attestation);
                          }
                        } catch (e) {
                          this.logger.warn(e);
                        }
                    };
                    e.body.appendChild(o),
                      window.addEventListener("message", c, {
                        signal: this.abortController.signal,
                      });
                  });
                return this.logger.debug("jwt attestation", i), i;
              } catch (e) {
                this.logger.warn(e);
              }
              return "";
            }),
            u6(this, "resolve", async (e) => {
              if (this.isDevEnv) return "";
              let { attestationId: t, hash: r, encryptedId: i } = e;
              if ("" === t)
                return void this.logger.debug(
                  "resolve: attestationId is empty, skipping"
                );
              if (t) {
                if (rb(t).payload.id !== i) return;
                let e = await this.isValidJwtAttestation(t);
                if (e)
                  return e.isVerified
                    ? e
                    : void this.logger.warn(
                        "resolve: jwt attestation: origin url not verified"
                      );
              }
              if (!r) return;
              let n = this.getVerifyUrl(e?.verifyUrl);
              return this.fetchAttestation(r, n);
            }),
            u6(this, "fetchAttestation", async (e, t) => {
              this.logger.debug(`resolving attestation: ${e} from url: ${t}`);
              let r = this.startAbortTimer(5 * v.ONE_SECOND),
                i = await fetch(`${t}/attestation/${e}?v2Supported=true`, {
                  signal: this.abortController.signal,
                });
              return (
                clearTimeout(r), 200 === i.status ? await i.json() : void 0
              );
            }),
            u6(this, "getVerifyUrl", (e) => {
              let t = e || d5;
              return (
                d6.includes(t) ||
                  (this.logger.info(
                    `verify url: ${t}, not included in trusted list, assigning default: ${d5}`
                  ),
                  (t = d5)),
                t
              );
            }),
            u6(this, "fetchPublicKey", async () => {
              try {
                this.logger.debug(
                  `fetching public key from: ${this.verifyUrlV3}`
                );
                let e = this.startAbortTimer(v.FIVE_SECONDS),
                  t = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal,
                  });
                return clearTimeout(e), await t.json();
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            u6(this, "persistPublicKey", async (e) => {
              this.logger.debug("persisting public key to local storage", e),
                await this.store.setItem(this.storeKey, e),
                (this.publicKey = e);
            }),
            u6(this, "removePublicKey", async () => {
              this.logger.debug("removing verify v2 public key from storage"),
                await this.store.removeItem(this.storeKey),
                (this.publicKey = void 0);
            }),
            u6(this, "isValidJwtAttestation", async (e) => {
              let t = await this.getPublicKey();
              try {
                if (t) return this.validateAttestation(e, t);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
              let r = await this.fetchAndPersistPublicKey();
              try {
                if (r) return this.validateAttestation(e, r);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
            }),
            u6(this, "getPublicKey", async () =>
              this.publicKey
                ? this.publicKey
                : await this.fetchAndPersistPublicKey()
            ),
            u6(this, "fetchAndPersistPublicKey", async () => {
              if (this.fetchPromise)
                return await this.fetchPromise, this.publicKey;
              this.fetchPromise = new Promise(async (e) => {
                let t = await this.fetchPublicKey();
                t && (await this.persistPublicKey(t), e(t));
              });
              let e = await this.fetchPromise;
              return (this.fetchPromise = void 0), e;
            }),
            u6(this, "validateAttestation", (e, t) => {
              let r = (function (e, t) {
                  let [r, i, n] = e.split("."),
                    s = sm.from(lI(n), "base64");
                  if (64 !== s.length) throw Error("Invalid signature length");
                  let a = s.slice(0, 32),
                    o = s.slice(32, 64),
                    c = ot(`${r}.${i}`),
                    l = (function (e) {
                      let t = sm.from(e.x, "base64"),
                        r = sm.from(e.y, "base64");
                      return i6([new Uint8Array([4]), t, r]);
                    })(t);
                  if (!lg.verify(i6([a, o]), c, l))
                    throw Error("Invalid signature");
                  return rb(e).payload;
                })(e, t.publicKey),
                i = {
                  hasExpired: (0, v.toMiliseconds)(r.exp) < Date.now(),
                  payload: r,
                };
              if (i.hasExpired)
                throw (
                  (this.logger.warn("resolve: jwt attestation expired"),
                  Error("JWT attestation expired"))
                );
              return {
                origin: i.payload.origin,
                isScam: i.payload.isScam,
                isVerified: i.payload.isVerified,
              };
            }),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.abortController = new AbortController()),
            (this.isDevEnv = sY()),
            this.init();
        }
        get storeKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//verify:public:key"
          );
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        startAbortTimer(e) {
          return (
            (this.abortController = new AbortController()),
            setTimeout(
              () => this.abortController.abort(),
              (0, v.toMiliseconds)(e)
            )
          );
        }
      }
      var u9 = Object.defineProperty,
        u7 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? u9(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class pe extends ec {
        constructor(e, t) {
          super(e, t),
            (this.projectId = e),
            (this.logger = t),
            u7(this, "context", "echo"),
            u7(this, "registerDeviceToken", async (e) => {
              let {
                  clientId: t,
                  token: r,
                  notificationType: i,
                  enableEncrypted: n = !1,
                } = e,
                s = `https://echo.walletconnect.com/${this.projectId}/clients`;
              await fetch(s, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  client_id: t,
                  type: i,
                  token: r,
                  always_raw: n,
                }),
              });
            }),
            (this.logger = (0, G.U5)(t, this.context));
        }
      }
      var pt = Object.defineProperty,
        pr = Object.getOwnPropertySymbols,
        pi = Object.prototype.hasOwnProperty,
        pn = Object.prototype.propertyIsEnumerable,
        ps = (e, t, r) =>
          t in e
            ? pt(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pa = (e, t) => {
          for (var r in t || (t = {})) pi.call(t, r) && ps(e, r, t[r]);
          if (pr) for (var r of pr(t)) pn.call(t, r) && ps(e, r, t[r]);
          return e;
        },
        po = (e, t, r) => ps(e, "symbol" != typeof t ? t + "" : t, r);
      class pc extends el {
        constructor(e, t, r = !0) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            po(this, "context", "event-client"),
            po(this, "storagePrefix", dW),
            po(this, "storageVersion", 0.1),
            po(this, "events", new Map()),
            po(this, "shouldPersist", !1),
            po(this, "init", async () => {
              if (!sY())
                try {
                  let e = {
                    eventId: sJ(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                      event: "INIT",
                      type: "",
                      properties: {
                        client_id: await this.core.crypto.getClientId(),
                        user_agent: sD(
                          this.core.relayer.protocol,
                          this.core.relayer.version,
                          dG
                        ),
                      },
                    },
                  };
                  await this.sendEvent([e]);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            po(this, "createEvent", (e) => {
              let {
                  event: t = "ERROR",
                  type: r = "",
                  properties: { topic: i, trace: n },
                } = e,
                s = sJ(),
                a = this.core.projectId || "",
                o = pa(
                  {
                    eventId: s,
                    timestamp: Date.now(),
                    props: {
                      event: t,
                      type: r,
                      properties: { topic: i, trace: n },
                    },
                    bundleId: a,
                    domain: this.getAppDomain(),
                  },
                  this.setMethods(s)
                );
              return (
                this.telemetryEnabled &&
                  (this.events.set(s, o), (this.shouldPersist = !0)),
                o
              );
            }),
            po(this, "getEvent", (e) => {
              let { eventId: t, topic: r } = e;
              if (t) return this.events.get(t);
              let i = Array.from(this.events.values()).find(
                (e) => e.props.properties.topic === r
              );
              if (i) return pa(pa({}, i), this.setMethods(i.eventId));
            }),
            po(this, "deleteEvent", (e) => {
              let { eventId: t } = e;
              this.events.delete(t), (this.shouldPersist = !0);
            }),
            po(this, "setEventListeners", () => {
              this.core.heartbeat.on(A.pulse, async () => {
                this.shouldPersist && (await this.persist()),
                  this.events.forEach((e) => {
                    (0, v.fromMiliseconds)(Date.now()) -
                      (0, v.fromMiliseconds)(e.timestamp) >
                      86400 &&
                      (this.events.delete(e.eventId),
                      (this.shouldPersist = !0));
                  });
              });
            }),
            po(this, "setMethods", (e) => ({
              addTrace: (t) => this.addTrace(e, t),
              setError: (t) => this.setError(e, t),
            })),
            po(this, "addTrace", (e, t) => {
              let r = this.events.get(e);
              r &&
                (r.props.properties.trace.push(t),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            po(this, "setError", (e, t) => {
              let r = this.events.get(e);
              r &&
                ((r.props.type = t),
                (r.timestamp = Date.now()),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            po(this, "persist", async () => {
              await this.core.storage.setItem(
                this.storageKey,
                Array.from(this.events.values())
              ),
                (this.shouldPersist = !1);
            }),
            po(this, "restore", async () => {
              try {
                let e =
                  (await this.core.storage.getItem(this.storageKey)) || [];
                if (!e.length) return;
                e.forEach((e) => {
                  this.events.set(
                    e.eventId,
                    pa(pa({}, e), this.setMethods(e.eventId))
                  );
                });
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            po(this, "submit", async () => {
              if (!this.telemetryEnabled || 0 === this.events.size) return;
              let e = [];
              for (let [t, r] of this.events) r.props.type && e.push(r);
              if (0 !== e.length)
                try {
                  if ((await this.sendEvent(e)).ok)
                    for (let t of e)
                      this.events.delete(t.eventId), (this.shouldPersist = !0);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            po(this, "sendEvent", async (e) => {
              let t = this.getAppDomain() ? "" : "&sp=desktop";
              return await fetch(
                `https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${dG}${t}`,
                { method: "POST", body: JSON.stringify(e) }
              );
            }),
            po(this, "getAppDomain", () => s$().url),
            (this.logger = (0, G.U5)(t, this.context)),
            (this.telemetryEnabled = r),
            r
              ? this.restore().then(async () => {
                  await this.submit(), this.setEventListeners();
                })
              : this.persist();
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.storageVersion +
            this.core.customStoragePrefix +
            "//" +
            this.context
          );
        }
      }
      var pl = Object.defineProperty,
        pd = Object.getOwnPropertySymbols,
        ph = Object.prototype.hasOwnProperty,
        pu = Object.prototype.propertyIsEnumerable,
        pp = (e, t, r) =>
          t in e
            ? pl(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pf = (e, t) => {
          for (var r in t || (t = {})) ph.call(t, r) && pp(e, r, t[r]);
          if (pd) for (var r of pd(t)) pu.call(t, r) && pp(e, r, t[r]);
          return e;
        },
        pg = (e, t, r) => pp(e, "symbol" != typeof t ? t + "" : t, r);
      class pm extends X {
        constructor(e) {
          var t;
          super(e),
            pg(this, "protocol", "wc"),
            pg(this, "version", 2),
            pg(this, "name", dB),
            pg(this, "relayUrl"),
            pg(this, "projectId"),
            pg(this, "customStoragePrefix"),
            pg(this, "events", new w.EventEmitter()),
            pg(this, "logger"),
            pg(this, "heartbeat"),
            pg(this, "relayer"),
            pg(this, "crypto"),
            pg(this, "storage"),
            pg(this, "history"),
            pg(this, "expirer"),
            pg(this, "pairing"),
            pg(this, "verify"),
            pg(this, "echoClient"),
            pg(this, "linkModeSupportedApps"),
            pg(this, "eventClient"),
            pg(this, "initialized", !1),
            pg(this, "logChunkController"),
            pg(this, "on", (e, t) => this.events.on(e, t)),
            pg(this, "once", (e, t) => this.events.once(e, t)),
            pg(this, "off", (e, t) => this.events.off(e, t)),
            pg(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            pg(
              this,
              "dispatchEnvelope",
              ({ topic: e, message: t, sessionExists: r }) => {
                if (!e || !t) return;
                let i = {
                  topic: e,
                  message: t,
                  publishedAt: Date.now(),
                  transportType: dJ.link_mode,
                };
                this.relayer.onLinkMessageEvent(i, { sessionExists: r });
              }
            );
          let r = this.getGlobalCore(e?.customStoragePrefix);
          if (r)
            try {
              return (
                (this.customStoragePrefix = r.customStoragePrefix),
                (this.logger = r.logger),
                (this.heartbeat = r.heartbeat),
                (this.crypto = r.crypto),
                (this.history = r.history),
                (this.expirer = r.expirer),
                (this.storage = r.storage),
                (this.relayer = r.relayer),
                (this.pairing = r.pairing),
                (this.verify = r.verify),
                (this.echoClient = r.echoClient),
                (this.linkModeSupportedApps = r.linkModeSupportedApps),
                (this.eventClient = r.eventClient),
                (this.initialized = r.initialized),
                (this.logChunkController = r.logChunkController),
                r
              );
            } catch (e) {
              console.warn("Failed to copy global core", e);
            }
          (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || dV),
            (this.customStoragePrefix =
              null != e && e.customStoragePrefix
                ? `:${e.customStoragePrefix}`
                : "");
          let i = (0, G.iP)({
              level:
                "string" == typeof e?.logger && e.logger ? e.logger : dj.logger,
              name: dB,
            }),
            { logger: n, chunkLoggerController: s } = (0, G.D5)({
              opts: i,
              maxSizeInBytes: e?.maxLogBlobSizeInBytes,
              loggerOverride: e?.logger,
            });
          (this.logChunkController = s),
            null != (t = this.logChunkController) &&
              t.downloadLogsBlobInBrowser &&
              (window.downloadLogsBlobInBrowser = async () => {
                var e, t;
                null != (e = this.logChunkController) &&
                  e.downloadLogsBlobInBrowser &&
                  (null == (t = this.logChunkController) ||
                    t.downloadLogsBlobInBrowser({
                      clientId: await this.crypto.getClientId(),
                    }));
              }),
            (this.logger = (0, G.U5)(n, this.name)),
            (this.heartbeat = new _()),
            (this.crypto = new h3(this, this.logger, e?.keychain)),
            (this.history = new u1(this, this.logger)),
            (this.expirer = new u5(this, this.logger)),
            (this.storage =
              null != e && e.storage
                ? e.storage
                : new K(pf(pf({}, dF), e?.storageOptions))),
            (this.relayer = new uD({
              core: this,
              logger: this.logger,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
            })),
            (this.pairing = new uX(this, this.logger)),
            (this.verify = new u8(this, this.logger, this.storage)),
            (this.echoClient = new pe(this.projectId || "", this.logger)),
            (this.linkModeSupportedApps = []),
            (this.eventClient = new pc(this, this.logger, e?.telemetryEnabled)),
            this.setGlobalCore(this);
        }
        static async init(e) {
          let t = new pm(e);
          await t.initialize();
          let r = await t.crypto.getClientId();
          return await t.storage.setItem("WALLETCONNECT_CLIENT_ID", r), t;
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        async start() {
          this.initialized || (await this.initialize());
        }
        async getLogsBlob() {
          var e;
          return null == (e = this.logChunkController)
            ? void 0
            : e.logsToBlob({ clientId: await this.crypto.getClientId() });
        }
        async addLinkModeSupportedApp(e) {
          this.linkModeSupportedApps.includes(e) ||
            (this.linkModeSupportedApps.push(e),
            await this.storage.setItem(dX, this.linkModeSupportedApps));
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.crypto.init(),
              await this.history.init(),
              await this.expirer.init(),
              await this.relayer.init(),
              await this.heartbeat.init(),
              await this.pairing.init(),
              (this.linkModeSupportedApps =
                (await this.storage.getItem(dX)) || []),
              (this.initialized = !0),
              this.logger.info("Core Initialization Success");
          } catch (e) {
            throw (
              (this.logger.warn(
                `Core Initialization Failure at epoch ${Date.now()}`,
                e
              ),
              this.logger.error(e.message),
              e)
            );
          }
        }
        getGlobalCore(e = "") {
          try {
            if (this.isGlobalCoreDisabled()) return;
            let t = `_walletConnectCore_${e}`,
              r = `${t}_count`;
            return (
              (globalThis[r] = (globalThis[r] || 0) + 1),
              globalThis[r] > 1 &&
                console.warn(
                  `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`
                ),
              globalThis[t]
            );
          } catch (e) {
            console.warn("Failed to get global WalletConnect core", e);
            return;
          }
        }
        setGlobalCore(e) {
          var t;
          try {
            if (this.isGlobalCoreDisabled()) return;
            let r = `_walletConnectCore_${
              (null == (t = e.opts) ? void 0 : t.customStoragePrefix) || ""
            }`;
            globalThis[r] = e;
          } catch (e) {
            console.warn("Failed to set global WalletConnect core", e);
          }
        }
        isGlobalCoreDisabled() {
          try {
            return "u" > typeof dL && "true" === dL.env.DISABLE_GLOBAL_CORE;
          } catch {
            return !0;
          }
        }
      }
      let py = "client",
        pw = `wc@2:${py}:`,
        pb = { name: py, logger: "error" },
        pv = "WALLETCONNECT_DEEPLINK_CHOICE",
        pC = "Proposal expired",
        pE = v.SEVEN_DAYS,
        px = {
          wc_sessionPropose: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1100 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1101 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1120 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1121 },
          },
          wc_sessionSettle: {
            req: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1102 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1103 },
          },
          wc_sessionUpdate: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1104 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1105 },
          },
          wc_sessionExtend: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1106 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1107 },
          },
          wc_sessionRequest: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1108 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1109 },
          },
          wc_sessionEvent: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1110 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1111 },
          },
          wc_sessionDelete: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1112 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1113 },
          },
          wc_sessionPing: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1114 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1115 },
          },
          wc_sessionAuthenticate: {
            req: { ttl: v.ONE_HOUR, prompt: !0, tag: 1116 },
            res: { ttl: v.ONE_HOUR, prompt: !1, tag: 1117 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1118 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1119 },
          },
        },
        pA = { min: v.FIVE_MINUTES, max: v.SEVEN_DAYS },
        p_ = { idle: "IDLE", active: "ACTIVE" },
        pI = {
          eth_sendTransaction: { key: "" },
          eth_sendRawTransaction: { key: "" },
          wallet_sendCalls: { key: "" },
          solana_signTransaction: { key: "signature" },
          solana_signAllTransactions: { key: "transactions" },
          solana_signAndSendTransaction: { key: "signature" },
          sui_signAndExecuteTransaction: { key: "digest" },
          sui_signTransaction: { key: "" },
          hedera_signAndExecuteTransaction: { key: "transactionId" },
          hedera_executeTransaction: { key: "transactionId" },
          near_signTransaction: { key: "" },
          near_signTransactions: { key: "" },
          tron_signTransaction: { key: "txID" },
          xrpl_signTransaction: { key: "" },
          xrpl_signTransactionFor: { key: "" },
          algo_signTxn: { key: "" },
          sendTransfer: { key: "txid" },
          stacks_stxTransfer: { key: "txId" },
          polkadot_signTransaction: { key: "" },
          cosmos_signDirect: { key: "" },
        },
        pS = [
          "wc_sessionPropose",
          "wc_sessionRequest",
          "wc_authRequest",
          "wc_sessionAuthenticate",
        ],
        pk = "wc@1.5:auth:",
        pN = `${pk}:PUB_KEY`;
      var pT = Object.defineProperty,
        pO = Object.defineProperties,
        pP = Object.getOwnPropertyDescriptors,
        pR = Object.getOwnPropertySymbols,
        p$ = Object.prototype.hasOwnProperty,
        pD = Object.prototype.propertyIsEnumerable,
        pU = (e, t, r) =>
          t in e
            ? pT(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pM = (e, t) => {
          for (var r in t || (t = {})) p$.call(t, r) && pU(e, r, t[r]);
          if (pR) for (var r of pR(t)) pD.call(t, r) && pU(e, r, t[r]);
          return e;
        },
        pL = (e, t) => pO(e, pP(t)),
        pB = (e, t, r) => pU(e, "symbol" != typeof t ? t + "" : t, r);
      class pW extends ep {
        constructor(e) {
          super(e),
            pB(this, "name", "engine"),
            pB(this, "events", new (b())()),
            pB(this, "initialized", !1),
            pB(this, "requestQueue", { state: p_.idle, queue: [] }),
            pB(this, "sessionRequestQueue", { state: p_.idle, queue: [] }),
            pB(this, "emittedSessionRequests", new sQ({ limit: 500 })),
            pB(this, "requestQueueDelay", v.ONE_SECOND),
            pB(this, "expectedPairingMethodMap", new Map()),
            pB(this, "recentlyDeletedMap", new Map()),
            pB(this, "recentlyDeletedLimit", 200),
            pB(this, "relayMessageCache", []),
            pB(this, "pendingSessions", new Map()),
            pB(this, "init", async () => {
              this.initialized ||
                (await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                this.registerPairingEvents(),
                await this.registerLinkModeListeners(),
                this.client.core.pairing.register({ methods: Object.keys(px) }),
                (this.initialized = !0),
                setTimeout(async () => {
                  await this.processPendingMessageEvents(),
                    (this.sessionRequestQueue.queue =
                      this.getPendingSessionRequests()),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay)));
            }),
            pB(this, "connect", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              let t = pL(pM({}, e), {
                requiredNamespaces: e.requiredNamespaces || {},
                optionalNamespaces: e.optionalNamespaces || {},
              });
              await this.isValidConnect(t),
                (t.optionalNamespaces = (function (e, t) {
                  var r, i, n, s, a, o;
                  let c = lK(e),
                    l = lK(t),
                    d = {};
                  for (let e of Object.keys(c).concat(Object.keys(l)))
                    d[e] = {
                      chains: sV(
                        null == (r = c[e]) ? void 0 : r.chains,
                        null == (i = l[e]) ? void 0 : i.chains
                      ),
                      methods: sV(
                        null == (n = c[e]) ? void 0 : n.methods,
                        null == (s = l[e]) ? void 0 : s.methods
                      ),
                      events: sV(
                        null == (a = c[e]) ? void 0 : a.events,
                        null == (o = l[e]) ? void 0 : o.events
                      ),
                    };
                  return d;
                })(t.requiredNamespaces, t.optionalNamespaces)),
                (t.requiredNamespaces = {});
              let {
                  pairingTopic: r,
                  requiredNamespaces: i,
                  optionalNamespaces: n,
                  sessionProperties: s,
                  scopedProperties: a,
                  relays: o,
                } = t,
                c = r,
                l,
                d = !1;
              try {
                if (c) {
                  let e = this.client.core.pairing.pairings.get(c);
                  this.client.logger.warn(
                    "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                  ),
                    (d = e.active);
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `connect() -> pairing.get(${c}) failed`
                  ),
                  e)
                );
              }
              if (!c || !d) {
                let { topic: e, uri: t } =
                  await this.client.core.pairing.create({
                    internal: { skipSubscribe: !0 },
                  });
                (c = e), (l = t);
              }
              if (!c) {
                let { message: e } = lX(
                  "NO_MATCHING_KEY",
                  `connect() pairing topic: ${c}`
                );
                throw Error(e);
              }
              let h = await this.client.core.crypto.generateKeyPair(),
                u = px.wc_sessionPropose.req.ttl || v.FIVE_MINUTES,
                p = sH(u),
                f = pL(
                  pM(
                    pM(
                      {
                        requiredNamespaces: i,
                        optionalNamespaces: n,
                        relays: o ?? [{ protocol: "irn" }],
                        proposer: {
                          publicKey: h,
                          metadata: this.client.metadata,
                        },
                        expiryTimestamp: p,
                        pairingTopic: c,
                      },
                      s && { sessionProperties: s }
                    ),
                    a && { scopedProperties: a }
                  ),
                  { id: dy() }
                ),
                g = sz("session_connect", f.id),
                { reject: m, resolve: y, done: w } = sB(u, pC),
                b = ({ id: e }) => {
                  e === f.id &&
                    (this.client.events.off("proposal_expire", b),
                    this.pendingSessions.delete(f.id),
                    this.events.emit(g, { error: { message: pC, code: 0 } }));
                };
              return (
                this.client.events.on("proposal_expire", b),
                this.events.once(g, ({ error: e, session: t }) => {
                  this.client.events.off("proposal_expire", b),
                    e ? m(e) : t && y(t);
                }),
                await this.sendProposeSession({
                  proposal: f,
                  publishOpts: {
                    internal: { throwOnFailedPublish: !0 },
                    tvf: { correlationId: f.id },
                  },
                }),
                await this.setProposal(f.id, f),
                { uri: l, approval: w }
              );
            }),
            pB(this, "pair", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                return await this.client.core.pairing.pair(e);
              } catch (e) {
                throw (this.client.logger.error("pair() failed"), e);
              }
            }),
            pB(this, "approve", async (e) => {
              var t, r, i;
              let n = this.client.core.eventClient.createEvent({
                properties: {
                  topic: null == (t = e?.id) ? void 0 : t.toString(),
                  trace: [d7.session_approve_started],
                },
              });
              try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
              } catch (e) {
                throw (n.setError(he.no_internet_connection), e);
              }
              try {
                await this.isValidProposalId(e?.id);
              } catch (t) {
                throw (
                  (this.client.logger.error(
                    `approve() -> proposal.get(${e?.id}) failed`
                  ),
                  n.setError(he.proposal_not_found),
                  t)
                );
              }
              try {
                await this.isValidApprove(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "approve() -> isValidApprove() failed"
                  ),
                  n.setError(he.session_approve_namespace_validation_failure),
                  e)
                );
              }
              let {
                  id: s,
                  relayProtocol: a,
                  namespaces: o,
                  sessionProperties: c,
                  scopedProperties: l,
                  sessionConfig: d,
                } = e,
                h = this.client.proposal.get(s);
              this.client.core.eventClient.deleteEvent({ eventId: n.eventId });
              let {
                  pairingTopic: u,
                  proposer: p,
                  requiredNamespaces: f,
                  optionalNamespaces: g,
                } = h,
                m =
                  null == (r = this.client.core.eventClient)
                    ? void 0
                    : r.getEvent({ topic: u });
              m ||
                (m =
                  null == (i = this.client.core.eventClient)
                    ? void 0
                    : i.createEvent({
                        type: d7.session_approve_started,
                        properties: {
                          topic: u,
                          trace: [
                            d7.session_approve_started,
                            d7.session_namespaces_validation_success,
                          ],
                        },
                      }));
              let y = await this.client.core.crypto.generateKeyPair(),
                w = p.publicKey,
                b = await this.client.core.crypto.generateSharedKey(y, w),
                v = pM(
                  pM(
                    pM(
                      {
                        relay: { protocol: a ?? "irn" },
                        namespaces: o,
                        controller: {
                          publicKey: y,
                          metadata: this.client.metadata,
                        },
                        expiry: sH(pE),
                      },
                      c && { sessionProperties: c }
                    ),
                    l && { scopedProperties: l }
                  ),
                  d && { sessionConfig: d }
                ),
                C = dJ.relay;
              m.addTrace(d7.subscribing_session_topic);
              try {
                await this.client.core.relayer.subscribe(b, {
                  transportType: C,
                  internal: { skipSubscribe: !0 },
                });
              } catch (e) {
                throw (m.setError(he.subscribe_session_topic_failure), e);
              }
              m.addTrace(d7.subscribe_session_topic_success);
              let E = pL(pM({}, v), {
                topic: b,
                requiredNamespaces: f,
                optionalNamespaces: g,
                pairingTopic: u,
                acknowledged: !1,
                self: v.controller,
                peer: { publicKey: p.publicKey, metadata: p.metadata },
                controller: y,
                transportType: dJ.relay,
              });
              await this.client.session.set(b, E), m.addTrace(d7.store_session);
              try {
                await this.sendApproveSession({
                  sessionTopic: b,
                  proposal: h,
                  pairingProposalResponse: {
                    relay: { protocol: a ?? "irn" },
                    responderPublicKey: y,
                  },
                  sessionSettleRequest: v,
                  publishOpts: {
                    internal: { throwOnFailedPublish: !0 },
                    tvf: { correlationId: s },
                  },
                }),
                  m.addTrace(d7.session_approve_publish_success);
              } catch (e) {
                throw (
                  (this.client.logger.error(e),
                  this.client.session.delete(b, lQ("USER_DISCONNECTED")),
                  await this.client.core.relayer.unsubscribe(b),
                  e)
                );
              }
              return (
                this.client.core.eventClient.deleteEvent({
                  eventId: m.eventId,
                }),
                await this.client.core.pairing.updateMetadata({
                  topic: u,
                  metadata: p.metadata,
                }),
                await this.deleteProposal(s),
                await this.client.core.pairing.activate({ topic: u }),
                await this.setExpiry(b, sH(pE)),
                {
                  topic: b,
                  acknowledged: () =>
                    Promise.resolve(this.client.session.get(b)),
                }
              );
            }),
            pB(this, "reject", async (e) => {
              let t;
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidReject(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "reject() -> isValidReject() failed"
                  ),
                  e)
                );
              }
              let { id: r, reason: i } = e;
              try {
                t = this.client.proposal.get(r).pairingTopic;
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `reject() -> proposal.get(${r}) failed`
                  ),
                  e)
                );
              }
              t &&
                (await this.sendError({
                  id: r,
                  topic: t,
                  error: i,
                  rpcOpts: px.wc_sessionPropose.reject,
                })),
                await this.deleteProposal(r);
            }),
            pB(this, "update", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidUpdate(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "update() -> isValidUpdate() failed"
                  ),
                  e)
                );
              }
              let { topic: t, namespaces: r } = e,
                { done: i, resolve: n, reject: s } = sB(),
                a = dy(),
                o = dw().toString(),
                c = this.client.session.get(t).namespaces;
              return (
                this.events.once(sz("session_update", a), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                await this.client.session.update(t, { namespaces: r }),
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionUpdate",
                  params: { namespaces: r },
                  throwOnFailedPublish: !0,
                  clientRpcId: a,
                  relayRpcId: o,
                }).catch((e) => {
                  this.client.logger.error(e),
                    this.client.session.update(t, { namespaces: c }),
                    s(e);
                }),
                { acknowledged: i }
              );
            }),
            pB(this, "extend", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidExtend(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "extend() -> isValidExtend() failed"
                  ),
                  e)
                );
              }
              let { topic: t } = e,
                r = dy(),
                { done: i, resolve: n, reject: s } = sB();
              return (
                this.events.once(sz("session_extend", r), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                await this.setExpiry(t, sH(pE)),
                this.sendRequest({
                  topic: t,
                  method: "wc_sessionExtend",
                  params: {},
                  clientRpcId: r,
                  throwOnFailedPublish: !0,
                }).catch((e) => {
                  s(e);
                }),
                { acknowledged: i }
              );
            }),
            pB(this, "request", async (e) => {
              this.isInitialized();
              try {
                await this.isValidRequest(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "request() -> isValidRequest() failed"
                  ),
                  e)
                );
              }
              let {
                  chainId: t,
                  request: r,
                  topic: i,
                  expiry: n = px.wc_sessionRequest.req.ttl,
                } = e,
                s = this.client.session.get(i);
              s?.transportType === dJ.relay &&
                (await this.confirmOnlineStateOrThrow());
              let a = dy(),
                o = dw().toString(),
                {
                  done: c,
                  resolve: l,
                  reject: d,
                } = sB(n, "Request expired. Please try again.");
              this.events.once(
                sz("session_request", a),
                ({ error: e, result: t }) => {
                  e ? d(e) : l(t);
                }
              );
              let h = "wc_sessionRequest",
                u = this.getAppLinkIfEnabled(s.peer.metadata, s.transportType);
              if (u)
                return (
                  await this.sendRequest({
                    clientRpcId: a,
                    relayRpcId: o,
                    topic: i,
                    method: h,
                    params: {
                      request: pL(pM({}, r), { expiryTimestamp: sH(n) }),
                      chainId: t,
                    },
                    expiry: n,
                    throwOnFailedPublish: !0,
                    appLink: u,
                  }).catch((e) => d(e)),
                  this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: r,
                    chainId: t,
                    id: a,
                  }),
                  await c()
                );
              let p = {
                request: pL(pM({}, r), { expiryTimestamp: sH(n) }),
                chainId: t,
              };
              return await Promise.all([
                new Promise(async (e) => {
                  await this.sendRequest({
                    clientRpcId: a,
                    relayRpcId: o,
                    topic: i,
                    method: h,
                    params: p,
                    expiry: n,
                    throwOnFailedPublish: !0,
                    tvf: this.getTVFParams(a, p),
                  }).catch((e) => d(e)),
                    this.client.events.emit("session_request_sent", {
                      topic: i,
                      request: r,
                      chainId: t,
                      id: a,
                    }),
                    e();
                }),
                new Promise(async (e) => {
                  var t;
                  if (!(null != (t = s.sessionConfig) && t.disableDeepLink)) {
                    let e = await sK(this.client.core.storage, pv);
                    await sZ({ id: a, topic: i, wcDeepLink: e });
                  }
                  e();
                }),
                c(),
              ]).then((e) => e[2]);
            }),
            pB(this, "respond", async (e) => {
              this.isInitialized(), await this.isValidRespond(e);
              let { topic: t, response: r } = e,
                { id: i } = r,
                n = this.client.session.get(t);
              n.transportType === dJ.relay &&
                (await this.confirmOnlineStateOrThrow());
              let s = this.getAppLinkIfEnabled(
                n.peer.metadata,
                n.transportType
              );
              dO(r)
                ? await this.sendResult({
                    id: i,
                    topic: t,
                    result: r.result,
                    throwOnFailedPublish: !0,
                    appLink: s,
                  })
                : dP(r) &&
                  (await this.sendError({
                    id: i,
                    topic: t,
                    error: r.error,
                    appLink: s,
                  })),
                this.cleanupAfterResponse(e);
            }),
            pB(this, "ping", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidPing(e);
              } catch (e) {
                throw (
                  (this.client.logger.error("ping() -> isValidPing() failed"),
                  e)
                );
              }
              let { topic: t } = e;
              if (this.client.session.keys.includes(t)) {
                let e = dy(),
                  r = dw().toString(),
                  { done: i, resolve: n, reject: s } = sB();
                this.events.once(sz("session_ping", e), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                  await Promise.all([
                    this.sendRequest({
                      topic: t,
                      method: "wc_sessionPing",
                      params: {},
                      throwOnFailedPublish: !0,
                      clientRpcId: e,
                      relayRpcId: r,
                    }),
                    i(),
                  ]);
              } else
                this.client.core.pairing.pairings.keys.includes(t) &&
                  (this.client.logger.warn(
                    "ping() on pairing topic is deprecated and will be removed in the next major release."
                  ),
                  await this.client.core.pairing.ping({ topic: t }));
            }),
            pB(this, "emit", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidEmit(e);
              let { topic: t, event: r, chainId: i } = e,
                n = dw().toString(),
                s = dy();
              await this.sendRequest({
                topic: t,
                method: "wc_sessionEvent",
                params: { event: r, chainId: i },
                throwOnFailedPublish: !0,
                relayRpcId: n,
                clientRpcId: s,
              });
            }),
            pB(this, "disconnect", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidDisconnect(e);
              let { topic: t } = e;
              if (this.client.session.keys.includes(t))
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionDelete",
                  params: lQ("USER_DISCONNECTED"),
                  throwOnFailedPublish: !0,
                }),
                  await this.deleteSession({ topic: t, emitEvent: !1 });
              else if (this.client.core.pairing.pairings.keys.includes(t))
                await this.client.core.pairing.disconnect({ topic: t });
              else {
                let { message: e } = lX(
                  "MISMATCHED_TOPIC",
                  `Session or pairing topic not found: ${t}`
                );
                throw Error(e);
              }
            }),
            pB(
              this,
              "find",
              (e) => (
                this.isInitialized(),
                this.client.session.getAll().filter((t) =>
                  (function (e, t) {
                    let { requiredNamespaces: r } = t,
                      i = Object.keys(e.namespaces),
                      n = Object.keys(r),
                      s = !0;
                    return (
                      !!sU(n, i) &&
                      (i.forEach((t) => {
                        let {
                            accounts: i,
                            methods: n,
                            events: a,
                          } = e.namespaces[t],
                          o = lz(i),
                          c = r[t];
                        (sU(sw(t, c), o) &&
                          sU(c.methods, n) &&
                          sU(c.events, a)) ||
                          (s = !1);
                      }),
                      s)
                    );
                  })(t, e)
                )
              )
            ),
            pB(this, "getPendingSessionRequests", () =>
              this.client.pendingRequest.getAll()
            ),
            pB(this, "authenticate", async (e, t) => {
              var r, i, n;
              let s;
              this.isInitialized(), this.isValidAuthenticate(e);
              let a =
                  t &&
                  this.client.core.linkModeSupportedApps.includes(t) &&
                  (null == (r = this.client.metadata.redirect)
                    ? void 0
                    : r.linkMode),
                o = a ? dJ.link_mode : dJ.relay;
              o === dJ.relay && (await this.confirmOnlineStateOrThrow());
              let {
                  chains: c,
                  statement: l = "",
                  uri: d,
                  domain: h,
                  nonce: u,
                  type: p,
                  exp: f,
                  nbf: g,
                  methods: m = [],
                  expiry: y,
                } = e,
                w = [...(e.resources || [])],
                { topic: b, uri: v } = await this.client.core.pairing.create({
                  methods: ["wc_sessionAuthenticate"],
                  transportType: o,
                });
              this.client.logger.info({
                message: "Generated new pairing",
                pairing: { topic: b, uri: v },
              });
              let C = await this.client.core.crypto.generateKeyPair(),
                E = lE(C);
              if (
                (await Promise.all([
                  this.client.auth.authKeys.set(pN, {
                    responseTopic: E,
                    publicKey: C,
                  }),
                  this.client.auth.pairingTopics.set(E, {
                    topic: E,
                    pairingTopic: b,
                  }),
                ]),
                await this.client.core.relayer.subscribe(E, {
                  transportType: o,
                }),
                this.client.logger.info(
                  `sending request to new pairing topic: ${b}`
                ),
                m.length > 0)
              ) {
                let { namespace: e } = sy(c[0]),
                  t = oR(
                    (function (e, t, r, i = {}) {
                      return (
                        r?.sort((e, t) => e.localeCompare(t)),
                        {
                          att: {
                            [e]: (function (e, t, r = {}) {
                              return Object.assign(
                                {},
                                ...(t = t?.sort((e, t) =>
                                  e.localeCompare(t)
                                )).map((t) => ({ [`${e}/${t}`]: [r] }))
                              );
                            })(t, r, i),
                          },
                        }
                      );
                    })(e, "request", m)
                  );
                oM(w) &&
                  ((i = t),
                  (n = w.pop()),
                  (t = oR(
                    (function (e, t) {
                      oP(e), oP(t);
                      let r = Object.keys(e.att)
                          .concat(Object.keys(t.att))
                          .sort((e, t) => e.localeCompare(t)),
                        i = { att: {} };
                      return (
                        r.forEach((r) => {
                          var n, s;
                          Object.keys(
                            (null == (n = e.att) ? void 0 : n[r]) || {}
                          )
                            .concat(
                              Object.keys(
                                (null == (s = t.att) ? void 0 : s[r]) || {}
                              )
                            )
                            .sort((e, t) => e.localeCompare(t))
                            .forEach((n) => {
                              var s, a;
                              i.att[r] = oC(
                                ((e, t) => {
                                  for (var r in t || (t = {}))
                                    oA.call(t, r) && oI(e, r, t[r]);
                                  if (ox)
                                    for (var r of ox(t))
                                      o_.call(t, r) && oI(e, r, t[r]);
                                  return e;
                                })({}, i.att[r]),
                                oE({
                                  [n]:
                                    (null == (s = e.att[r]) ? void 0 : s[n]) ||
                                    (null == (a = t.att[r]) ? void 0 : a[n]),
                                })
                              );
                            });
                        }),
                        i
                      );
                    })(o$(i), o$(n))
                  ))),
                  w.push(t);
              }
              let x =
                  y && y > px.wc_sessionAuthenticate.req.ttl
                    ? y
                    : px.wc_sessionAuthenticate.req.ttl,
                A = {
                  authPayload: {
                    type: p ?? "caip122",
                    chains: c,
                    statement: l,
                    aud: d,
                    domain: h,
                    version: "1",
                    nonce: u,
                    iat: new Date().toISOString(),
                    exp: f,
                    nbf: g,
                    resources: w,
                  },
                  requester: { publicKey: C, metadata: this.client.metadata },
                  expiryTimestamp: sH(x),
                },
                _ = {
                  requiredNamespaces: {},
                  optionalNamespaces: {
                    eip155: {
                      chains: c,
                      methods: [...new Set(["personal_sign", ...m])],
                      events: ["chainChanged", "accountsChanged"],
                    },
                  },
                  relays: [{ protocol: "irn" }],
                  pairingTopic: b,
                  proposer: { publicKey: C, metadata: this.client.metadata },
                  expiryTimestamp: sH(px.wc_sessionPropose.req.ttl),
                  id: dy(),
                },
                { done: I, resolve: S, reject: k } = sB(x, "Request expired"),
                N = dy(),
                T = sz("session_connect", _.id),
                O = sz("session_request", N),
                P = async ({ error: e, session: t }) => {
                  this.events.off(O, R), e ? k(e) : t && S({ session: t });
                },
                R = async (e) => {
                  var r, i, n;
                  let s;
                  if (
                    (await this.deletePendingAuthRequest(N, {
                      message: "fulfilled",
                      code: 0,
                    }),
                    e.error)
                  ) {
                    let t = lQ(
                      "WC_METHOD_UNSUPPORTED",
                      "wc_sessionAuthenticate"
                    );
                    return e.error.code === t.code
                      ? void 0
                      : (this.events.off(T, P), k(e.error.message));
                  }
                  await this.deleteProposal(_.id), this.events.off(T, P);
                  let { cacaos: a, responder: c } = e.result,
                    l = [],
                    d = [];
                  for (let e of a) {
                    (await oT({
                      cacao: e,
                      projectId: this.client.core.projectId,
                    })) ||
                      (this.client.logger.error(
                        e,
                        "Signature verification failed"
                      ),
                      k(
                        lQ(
                          "SESSION_SETTLEMENT_FAILED",
                          "Signature verification failed"
                        )
                      ));
                    let { p: t } = e,
                      r = oM(t.resources),
                      i = [ok(t.iss)],
                      n = oN(t.iss);
                    if (r) {
                      let e = oD(r),
                        t = oU(r);
                      l.push(...e), i.push(...t);
                    }
                    for (let e of i) d.push(`${e}:${n}`);
                  }
                  let h = await this.client.core.crypto.generateSharedKey(
                    C,
                    c.publicKey
                  );
                  l.length > 0 &&
                    ((s = {
                      topic: h,
                      acknowledged: !0,
                      self: { publicKey: C, metadata: this.client.metadata },
                      peer: c,
                      controller: c.publicKey,
                      expiry: sH(pE),
                      requiredNamespaces: {},
                      optionalNamespaces: {},
                      relay: { protocol: "irn" },
                      pairingTopic: b,
                      namespaces: lG([...new Set(l)], [...new Set(d)]),
                      transportType: o,
                    }),
                    await this.client.core.relayer.subscribe(h, {
                      transportType: o,
                    }),
                    await this.client.session.set(h, s),
                    b &&
                      (await this.client.core.pairing.updateMetadata({
                        topic: b,
                        metadata: c.metadata,
                      })),
                    (s = this.client.session.get(h))),
                    null != (r = this.client.metadata.redirect) &&
                      r.linkMode &&
                      null != (i = c.metadata.redirect) &&
                      i.linkMode &&
                      null != (n = c.metadata.redirect) &&
                      n.universal &&
                      t &&
                      (this.client.core.addLinkModeSupportedApp(
                        c.metadata.redirect.universal
                      ),
                      this.client.session.update(h, {
                        transportType: dJ.link_mode,
                      })),
                    S({ auths: a, session: s });
                };
              this.events.once(T, P), this.events.once(O, R);
              try {
                if (a) {
                  let e = db("wc_sessionAuthenticate", A, N);
                  this.client.core.history.set(b, e);
                  let r = await this.client.core.crypto.encode("", e, {
                    type: 2,
                    encoding: lb,
                  });
                  s = lD(t, b, r);
                } else
                  await Promise.all([
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionAuthenticate",
                      params: A,
                      expiry: e.expiry,
                      throwOnFailedPublish: !0,
                      clientRpcId: N,
                    }),
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionPropose",
                      params: _,
                      expiry: px.wc_sessionPropose.req.ttl,
                      throwOnFailedPublish: !0,
                      clientRpcId: _.id,
                    }),
                  ]);
              } catch (e) {
                throw (this.events.off(T, P), this.events.off(O, R), e);
              }
              return (
                await this.setProposal(_.id, _),
                await this.setAuthRequest(N, {
                  request: pL(pM({}, A), { verifyContext: {} }),
                  pairingTopic: b,
                  transportType: o,
                }),
                { uri: s ?? v, response: I }
              );
            }),
            pB(this, "approveSessionAuthenticate", async (e) => {
              let t,
                { id: r, auths: i } = e,
                n = this.client.core.eventClient.createEvent({
                  properties: {
                    topic: r.toString(),
                    trace: [ht.authenticated_session_approve_started],
                  },
                });
              try {
                this.isInitialized();
              } catch (e) {
                throw (n.setError(hr.no_internet_connection), e);
              }
              let s = this.getPendingAuthRequest(r);
              if (!s)
                throw (
                  (n.setError(
                    hr.authenticated_session_pending_request_not_found
                  ),
                  Error(`Could not find pending auth request with id ${r}`))
                );
              let a = s.transportType || dJ.relay;
              a === dJ.relay && (await this.confirmOnlineStateOrThrow());
              let o = s.requester.publicKey,
                c = await this.client.core.crypto.generateKeyPair(),
                l = lE(o),
                d = { type: 1, receiverPublicKey: o, senderPublicKey: c },
                h = [],
                u = [];
              for (let e of i) {
                if (
                  !(await oT({
                    cacao: e,
                    projectId: this.client.core.projectId,
                  }))
                ) {
                  n.setError(hr.invalid_cacao);
                  let e = lQ(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  );
                  throw (
                    (await this.sendError({
                      id: r,
                      topic: l,
                      error: e,
                      encodeOpts: d,
                    }),
                    Error(e.message))
                  );
                }
                n.addTrace(ht.cacaos_verified);
                let { p: t } = e,
                  i = oM(t.resources),
                  s = [ok(t.iss)],
                  a = oN(t.iss);
                if (i) {
                  let e = oD(i),
                    t = oU(i);
                  h.push(...e), s.push(...t);
                }
                for (let e of s) u.push(`${e}:${a}`);
              }
              let p = await this.client.core.crypto.generateSharedKey(c, o);
              if (
                (n.addTrace(ht.create_authenticated_session_topic),
                h?.length > 0)
              ) {
                (t = {
                  topic: p,
                  acknowledged: !0,
                  self: { publicKey: c, metadata: this.client.metadata },
                  peer: { publicKey: o, metadata: s.requester.metadata },
                  controller: o,
                  expiry: sH(pE),
                  authentication: i,
                  requiredNamespaces: {},
                  optionalNamespaces: {},
                  relay: { protocol: "irn" },
                  pairingTopic: s.pairingTopic,
                  namespaces: lG([...new Set(h)], [...new Set(u)]),
                  transportType: a,
                }),
                  n.addTrace(ht.subscribing_authenticated_session_topic);
                try {
                  await this.client.core.relayer.subscribe(p, {
                    transportType: a,
                  });
                } catch (e) {
                  throw (
                    (n.setError(
                      hr.subscribe_authenticated_session_topic_failure
                    ),
                    e)
                  );
                }
                n.addTrace(ht.subscribe_authenticated_session_topic_success),
                  await this.client.session.set(p, t),
                  n.addTrace(ht.store_authenticated_session),
                  await this.client.core.pairing.updateMetadata({
                    topic: s.pairingTopic,
                    metadata: s.requester.metadata,
                  });
              }
              n.addTrace(ht.publishing_authenticated_session_approve);
              try {
                await this.sendResult({
                  topic: l,
                  id: r,
                  result: {
                    cacaos: i,
                    responder: { publicKey: c, metadata: this.client.metadata },
                  },
                  encodeOpts: d,
                  throwOnFailedPublish: !0,
                  appLink: this.getAppLinkIfEnabled(s.requester.metadata, a),
                });
              } catch (e) {
                throw (
                  (n.setError(hr.authenticated_session_approve_publish_failure),
                  e)
                );
              }
              return (
                await this.client.auth.requests.delete(r, {
                  message: "fulfilled",
                  code: 0,
                }),
                await this.client.core.pairing.activate({
                  topic: s.pairingTopic,
                }),
                this.client.core.eventClient.deleteEvent({
                  eventId: n.eventId,
                }),
                { session: t }
              );
            }),
            pB(this, "rejectSessionAuthenticate", async (e) => {
              this.isInitialized();
              let { id: t, reason: r } = e,
                i = this.getPendingAuthRequest(t);
              if (!i)
                throw Error(`Could not find pending auth request with id ${t}`);
              i.transportType === dJ.relay &&
                (await this.confirmOnlineStateOrThrow());
              let n = i.requester.publicKey,
                s = await this.client.core.crypto.generateKeyPair(),
                a = lE(n);
              await this.sendError({
                id: t,
                topic: a,
                error: r,
                encodeOpts: {
                  type: 1,
                  receiverPublicKey: n,
                  senderPublicKey: s,
                },
                rpcOpts: px.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(
                  i.requester.metadata,
                  i.transportType
                ),
              }),
                await this.client.auth.requests.delete(t, {
                  message: "rejected",
                  code: 0,
                }),
                await this.deleteProposal(t);
            }),
            pB(this, "formatAuthMessage", (e) => {
              this.isInitialized();
              let { request: t, iss: r } = e;
              return oO(t, r);
            }),
            pB(this, "processRelayMessageCache", () => {
              setTimeout(async () => {
                if (0 !== this.relayMessageCache.length)
                  for (; this.relayMessageCache.length > 0; )
                    try {
                      let e = this.relayMessageCache.shift();
                      e && (await this.onRelayMessage(e));
                    } catch (e) {
                      this.client.logger.error(e);
                    }
              }, 50);
            }),
            pB(this, "cleanupDuplicatePairings", async (e) => {
              if (e.pairingTopic)
                try {
                  let t = this.client.core.pairing.pairings.get(e.pairingTopic),
                    r = this.client.core.pairing.pairings
                      .getAll()
                      .filter((r) => {
                        var i, n;
                        return (
                          (null == (i = r.peerMetadata) ? void 0 : i.url) &&
                          (null == (n = r.peerMetadata) ? void 0 : n.url) ===
                            e.peer.metadata.url &&
                          r.topic &&
                          r.topic !== t.topic
                        );
                      });
                  if (0 === r.length) return;
                  this.client.logger.info(
                    `Cleaning up ${r.length} duplicate pairing(s)`
                  ),
                    await Promise.all(
                      r.map((e) =>
                        this.client.core.pairing.disconnect({ topic: e.topic })
                      )
                    ),
                    this.client.logger.info(
                      "Duplicate pairings clean up finished"
                    );
                } catch (e) {
                  this.client.logger.error(e);
                }
            }),
            pB(this, "deleteSession", async (e) => {
              var t;
              let {
                  topic: r,
                  expirerHasDeleted: i = !1,
                  emitEvent: n = !0,
                  id: s = 0,
                } = e,
                { self: a } = this.client.session.get(r);
              await this.client.core.relayer.unsubscribe(r),
                await this.client.session.delete(r, lQ("USER_DISCONNECTED")),
                this.addToRecentlyDeleted(r, "session"),
                this.client.core.crypto.keychain.has(a.publicKey) &&
                  (await this.client.core.crypto.deleteKeyPair(a.publicKey)),
                this.client.core.crypto.keychain.has(r) &&
                  (await this.client.core.crypto.deleteSymKey(r)),
                i || this.client.core.expirer.del(r),
                this.client.core.storage
                  .removeItem(pv)
                  .catch((e) => this.client.logger.warn(e)),
                this.getPendingSessionRequests().forEach((e) => {
                  e.topic === r &&
                    this.deletePendingSessionRequest(
                      e.id,
                      lQ("USER_DISCONNECTED")
                    );
                }),
                r ===
                  (null == (t = this.sessionRequestQueue.queue[0])
                    ? void 0
                    : t.topic) && (this.sessionRequestQueue.state = p_.idle),
                n &&
                  this.client.events.emit("session_delete", {
                    id: s,
                    topic: r,
                  });
            }),
            pB(this, "deleteProposal", async (e, t) => {
              if (t)
                try {
                  let t = this.client.proposal.get(e),
                    r = this.client.core.eventClient.getEvent({
                      topic: t.pairingTopic,
                    });
                  r?.setError(he.proposal_expired);
                } catch {}
              await Promise.all([
                this.client.proposal.delete(e, lQ("USER_DISCONNECTED")),
                t ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "proposal");
            }),
            pB(this, "deletePendingSessionRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.pendingRequest.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "request"),
                (this.sessionRequestQueue.queue =
                  this.sessionRequestQueue.queue.filter((t) => t.id !== e)),
                r &&
                  ((this.sessionRequestQueue.state = p_.idle),
                  this.client.events.emit("session_request_expire", { id: e }));
            }),
            pB(this, "deletePendingAuthRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.auth.requests.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]);
            }),
            pB(this, "setExpiry", async (e, t) => {
              this.client.session.keys.includes(e) &&
                (this.client.core.expirer.set(e, t),
                await this.client.session.update(e, { expiry: t }));
            }),
            pB(this, "setProposal", async (e, t) => {
              this.client.core.expirer.set(e, sH(px.wc_sessionPropose.req.ttl)),
                await this.client.proposal.set(e, t);
            }),
            pB(this, "setAuthRequest", async (e, t) => {
              let {
                request: r,
                pairingTopic: i,
                transportType: n = dJ.relay,
              } = t;
              this.client.core.expirer.set(e, r.expiryTimestamp),
                await this.client.auth.requests.set(e, {
                  authPayload: r.authPayload,
                  requester: r.requester,
                  expiryTimestamp: r.expiryTimestamp,
                  id: e,
                  pairingTopic: i,
                  verifyContext: r.verifyContext,
                  transportType: n,
                });
            }),
            pB(this, "setPendingSessionRequest", async (e) => {
              let { id: t, topic: r, params: i, verifyContext: n } = e,
                s =
                  i.request.expiryTimestamp || sH(px.wc_sessionRequest.req.ttl);
              this.client.core.expirer.set(t, s),
                await this.client.pendingRequest.set(t, {
                  id: t,
                  topic: r,
                  params: i,
                  verifyContext: n,
                });
            }),
            pB(this, "sendRequest", async (e) => {
              let t,
                i,
                {
                  topic: n,
                  method: s,
                  params: a,
                  expiry: o,
                  relayRpcId: c,
                  clientRpcId: l,
                  throwOnFailedPublish: d,
                  appLink: h,
                  tvf: u,
                  publishOpts: p = {},
                } = e,
                f = db(s, a, l),
                g = !!h;
              try {
                let e = g ? lb : lw;
                t = await this.client.core.crypto.encode(n, f, { encoding: e });
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendRequest() -> core.crypto.encode() for topic ${n} failed`
                  ),
                  e)
                );
              }
              if (pS.includes(s)) {
                let e = lx(JSON.stringify(f)),
                  r = lx(t);
                i = await this.client.core.verify.register({
                  id: r,
                  decryptedId: e,
                });
              }
              let m = pM(pM({}, px[s].req), p);
              if (
                ((m.attestation = i),
                o && (m.ttl = o),
                c && (m.id = c),
                this.client.core.history.set(n, f),
                g)
              ) {
                let e = lD(h, n, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else
                (m.tvf = pL(pM({}, u), { correlationId: f.id })),
                  d
                    ? ((m.internal = pL(pM({}, m.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(n, t, m))
                    : this.client.core.relayer
                        .publish(n, t, m)
                        .catch((e) => this.client.logger.error(e));
              return f.id;
            }),
            pB(this, "sendProposeSession", async (e) => {
              let { proposal: t, publishOpts: r } = e,
                i = db("wc_sessionPropose", t, t.id);
              this.client.core.history.set(t.pairingTopic, i);
              let n = await this.client.core.crypto.encode(t.pairingTopic, i, {
                  encoding: lw,
                }),
                s = lx(JSON.stringify(i)),
                a = lx(n),
                o = await this.client.core.verify.register({
                  id: a,
                  decryptedId: s,
                });
              await this.client.core.relayer.publishCustom({
                payload: { pairingTopic: t.pairingTopic, sessionProposal: n },
                opts: pL(pM({}, r), {
                  publishMethod: "wc_proposeSession",
                  attestation: o,
                }),
              });
            }),
            pB(this, "sendApproveSession", async (e) => {
              let {
                  sessionTopic: t,
                  pairingProposalResponse: r,
                  proposal: i,
                  sessionSettleRequest: n,
                  publishOpts: s,
                } = e,
                a = dv(i.id, r),
                o = await this.client.core.crypto.encode(i.pairingTopic, a, {
                  encoding: lw,
                }),
                c = db("wc_sessionSettle", n, s?.id),
                l = await this.client.core.crypto.encode(t, c, {
                  encoding: lw,
                });
              this.client.core.history.set(t, c),
                await this.client.core.relayer.publishCustom({
                  payload: {
                    sessionTopic: t,
                    pairingTopic: i.pairingTopic,
                    sessionProposalResponse: o,
                    sessionSettlementRequest: l,
                  },
                  opts: pL(pM({}, s), { publishMethod: "wc_approveSession" }),
                });
            }),
            pB(this, "sendResult", async (e) => {
              let t,
                i,
                n,
                {
                  id: s,
                  topic: a,
                  result: o,
                  throwOnFailedPublish: c,
                  encodeOpts: l,
                  appLink: d,
                } = e,
                h = dv(s, o),
                u = d && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = u ? lb : lw;
                t = await this.client.core.crypto.encode(
                  a,
                  h,
                  pL(pM({}, l || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendResult() -> core.crypto.encode() for topic ${a} failed`
                  ),
                  e)
                );
              }
              try {
                let e = (i = await this.client.core.history.get(a, s)).request;
                try {
                  n = this.getTVFParams(s, e.params, o);
                } catch (e) {
                  this.client.logger.warn(
                    `sendResult() -> getTVFParams() failed: ${e?.message}`
                  );
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendResult() -> history.get(${a}, ${s}) failed`
                  ),
                  e)
                );
              }
              if (u) {
                let e = lD(d, a, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = px[i.request.method].res;
                (e.tvf = pL(pM({}, n), { correlationId: s })),
                  c
                    ? ((e.internal = pL(pM({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(a, t, e))
                    : this.client.core.relayer
                        .publish(a, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              await this.client.core.history.resolve(h);
            }),
            pB(this, "sendError", async (e) => {
              let t,
                i,
                {
                  id: n,
                  topic: s,
                  error: a,
                  encodeOpts: o,
                  rpcOpts: c,
                  appLink: l,
                } = e,
                d = dC(n, a),
                h = l && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = h ? lb : lw;
                t = await this.client.core.crypto.encode(
                  s,
                  d,
                  pL(pM({}, o || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendError() -> core.crypto.encode() for topic ${s} failed`
                  ),
                  e)
                );
              }
              try {
                i = await this.client.core.history.get(s, n);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendError() -> history.get(${s}, ${n}) failed`
                  ),
                  e)
                );
              }
              if (h) {
                let e = lD(l, s, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = i.request.method,
                  r = c || px[e].res;
                this.client.core.relayer.publish(s, t, r);
              }
              await this.client.core.history.resolve(d);
            }),
            pB(this, "cleanup", async () => {
              let e = [],
                t = [];
              this.client.session.getAll().forEach((t) => {
                let r = !1;
                sq(t.expiry) && (r = !0),
                  this.client.core.crypto.keychain.has(t.topic) || (r = !0),
                  r && e.push(t.topic);
              }),
                this.client.proposal.getAll().forEach((e) => {
                  sq(e.expiryTimestamp) && t.push(e.id);
                }),
                await Promise.all([
                  ...e.map((e) => this.deleteSession({ topic: e })),
                  ...t.map((e) => this.deleteProposal(e)),
                ]);
            }),
            pB(this, "onProviderMessageEvent", async (e) => {
              !this.initialized || this.relayMessageCache.length > 0
                ? this.relayMessageCache.push(e)
                : await this.onRelayMessage(e);
            }),
            pB(this, "onRelayEventRequest", async (e) => {
              this.requestQueue.queue.push(e),
                await this.processRequestsQueue();
            }),
            pB(this, "processRequestsQueue", async () => {
              if (this.requestQueue.state === p_.active)
                return void this.client.logger.info(
                  "Request queue already active, skipping..."
                );
              for (
                this.client.logger.info(
                  `Request queue starting with ${this.requestQueue.queue.length} requests`
                );
                this.requestQueue.queue.length > 0;

              ) {
                this.requestQueue.state = p_.active;
                let e = this.requestQueue.queue.shift();
                if (e)
                  try {
                    await this.processRequest(e);
                  } catch (e) {
                    this.client.logger.warn(e);
                  }
              }
              this.requestQueue.state = p_.idle;
            }),
            pB(this, "processRequest", async (e) => {
              let {
                  topic: t,
                  payload: r,
                  attestation: i,
                  transportType: n,
                  encryptedId: s,
                } = e,
                a = r.method;
              if (
                !this.shouldIgnorePairingRequest({ topic: t, requestMethod: a })
              )
                switch (a) {
                  case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                    });
                  case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(t, r);
                  case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(t, r);
                  case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(t, r);
                  case "wc_sessionPing":
                    return await this.onSessionPingRequest(t, r);
                  case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(t, r);
                  case "wc_sessionRequest":
                    return await this.onSessionRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                      transportType: n,
                    });
                  case "wc_sessionEvent":
                    return await this.onSessionEventRequest(t, r);
                  case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                      transportType: n,
                    });
                  default:
                    return this.client.logger.info(
                      `Unsupported request method ${a}`
                    );
                }
            }),
            pB(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r, transportType: i } = e,
                n = (await this.client.core.history.get(t, r.id)).request
                  .method;
              switch (n) {
                case "wc_sessionPropose":
                  return this.onSessionProposeResponse(t, r, i);
                case "wc_sessionSettle":
                  return this.onSessionSettleResponse(t, r);
                case "wc_sessionUpdate":
                  return this.onSessionUpdateResponse(t, r);
                case "wc_sessionExtend":
                  return this.onSessionExtendResponse(t, r);
                case "wc_sessionPing":
                  return this.onSessionPingResponse(t, r);
                case "wc_sessionRequest":
                  return this.onSessionRequestResponse(t, r);
                case "wc_sessionAuthenticate":
                  return this.onSessionAuthenticateResponse(t, r);
                default:
                  return this.client.logger.info(
                    `Unsupported response method ${n}`
                  );
              }
            }),
            pB(this, "onRelayEventUnknownPayload", (e) => {
              let { topic: t } = e,
                { message: r } = lX(
                  "MISSING_OR_INVALID",
                  `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`
                );
              throw Error(r);
            }),
            pB(this, "shouldIgnorePairingRequest", (e) => {
              let { topic: t, requestMethod: r } = e,
                i = this.expectedPairingMethodMap.get(t);
              return (
                !(!i || i.includes(r)) &&
                !!(
                  i.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                )
              );
            }),
            pB(this, "onSessionProposeRequest", async (e) => {
              let { topic: t, payload: r, attestation: i, encryptedId: n } = e,
                { params: s, id: a } = r;
              try {
                let e = this.client.core.eventClient.getEvent({ topic: t });
                0 === this.client.events.listenerCount("session_proposal") &&
                  (console.warn("No listener for session_proposal event"),
                  e?.setError(d9.proposal_listener_not_found)),
                  this.isValidConnect(pM({}, r.params));
                let o = s.expiryTimestamp || sH(px.wc_sessionPropose.req.ttl),
                  c = pM(
                    {
                      id: a,
                      pairingTopic: t,
                      expiryTimestamp: o,
                      attestation: i,
                      encryptedId: n,
                    },
                    s
                  );
                await this.setProposal(a, c);
                let l = await this.getVerifyContext({
                  attestationId: i,
                  hash: lx(JSON.stringify(r)),
                  encryptedId: n,
                  metadata: c.proposer.metadata,
                });
                e?.addTrace(d8.emit_session_proposal),
                  this.client.events.emit("session_proposal", {
                    id: a,
                    params: c,
                    verifyContext: l,
                  });
              } catch (e) {
                await this.sendError({
                  id: a,
                  topic: t,
                  error: e,
                  rpcOpts: px.wc_sessionPropose.autoReject,
                }),
                  this.client.logger.error(e);
              }
            }),
            pB(this, "onSessionProposeResponse", async (e, t, r) => {
              let { id: i } = t;
              if (dO(t)) {
                let { result: n } = t;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  result: n,
                });
                let s = this.client.proposal.get(i);
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  proposal: s,
                });
                let a = s.proposer.publicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  selfPublicKey: a,
                });
                let o = n.responderPublicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  peerPublicKey: o,
                });
                let c = await this.client.core.crypto.generateSharedKey(a, o);
                this.pendingSessions.set(i, {
                  sessionTopic: c,
                  pairingTopic: e,
                  proposalId: i,
                  publicKey: a,
                });
                let l = await this.client.core.relayer.subscribe(c, {
                  transportType: r,
                });
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  subscriptionId: l,
                }),
                  await this.client.core.pairing.activate({ topic: e });
              } else if (dP(t)) {
                await this.deleteProposal(i);
                let e = sz("session_connect", i);
                if (0 === this.events.listenerCount(e))
                  throw Error(`emitting ${e} without any listeners, 954`);
                this.events.emit(e, { error: t.error });
              }
            }),
            pB(this, "onSessionSettleRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                this.isValidSessionSettleRequest(i);
                let {
                    relay: r,
                    controller: n,
                    expiry: s,
                    namespaces: a,
                    sessionProperties: o,
                    scopedProperties: c,
                    sessionConfig: l,
                  } = t.params,
                  d = [...this.pendingSessions.values()].find(
                    (t) => t.sessionTopic === e
                  );
                if (!d)
                  return this.client.logger.error(
                    `Pending session not found for topic ${e}`
                  );
                let h = this.client.proposal.get(d.proposalId),
                  u = pL(
                    pM(
                      pM(
                        pM(
                          {
                            topic: e,
                            relay: r,
                            expiry: s,
                            namespaces: a,
                            acknowledged: !0,
                            pairingTopic: d.pairingTopic,
                            requiredNamespaces: h.requiredNamespaces,
                            optionalNamespaces: h.optionalNamespaces,
                            controller: n.publicKey,
                            self: {
                              publicKey: d.publicKey,
                              metadata: this.client.metadata,
                            },
                            peer: {
                              publicKey: n.publicKey,
                              metadata: n.metadata,
                            },
                          },
                          o && { sessionProperties: o }
                        ),
                        c && { scopedProperties: c }
                      ),
                      l && { sessionConfig: l }
                    ),
                    { transportType: dJ.relay }
                  );
                await this.client.session.set(u.topic, u),
                  await this.setExpiry(u.topic, u.expiry),
                  await this.client.core.pairing.updateMetadata({
                    topic: d.pairingTopic,
                    metadata: u.peer.metadata,
                  }),
                  this.client.events.emit("session_connect", { session: u }),
                  this.events.emit(sz("session_connect", d.proposalId), {
                    session: u,
                  }),
                  this.pendingSessions.delete(d.proposalId),
                  this.deleteProposal(d.proposalId, !1),
                  this.cleanupDuplicatePairings(u),
                  await this.sendResult({ id: t.id, topic: e, result: !0 });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            pB(this, "onSessionSettleResponse", async (e, t) => {
              let { id: r } = t;
              dO(t)
                ? (await this.client.session.update(e, { acknowledged: !0 }),
                  this.events.emit(sz("session_approve", r), {}))
                : dP(t) &&
                  (await this.client.session.delete(e, lQ("USER_DISCONNECTED")),
                  this.events.emit(sz("session_approve", r), {
                    error: t.error,
                  }));
            }),
            pB(this, "onSessionUpdateRequest", async (e, t) => {
              let { params: r, id: i } = t;
              try {
                let t = `${e}_session_update`,
                  n = dc.get(t);
                if (n && this.isRequestOutOfSync(n, i)) {
                  this.client.logger.warn(
                    `Discarding out of sync request - ${i}`
                  ),
                    this.sendError({
                      id: i,
                      topic: e,
                      error: lQ("INVALID_UPDATE_REQUEST"),
                    });
                  return;
                }
                this.isValidUpdate(pM({ topic: e }, r));
                try {
                  dc.set(t, i),
                    await this.client.session.update(e, {
                      namespaces: r.namespaces,
                    }),
                    await this.sendResult({ id: i, topic: e, result: !0 });
                } catch (e) {
                  throw (dc.delete(t), e);
                }
                this.client.events.emit("session_update", {
                  id: i,
                  topic: e,
                  params: r,
                });
              } catch (t) {
                await this.sendError({ id: i, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            pB(
              this,
              "isRequestOutOfSync",
              (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)
            ),
            pB(this, "onSessionUpdateResponse", (e, t) => {
              let { id: r } = t,
                i = sz("session_update", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              dO(t)
                ? this.events.emit(sz("session_update", r), {})
                : dP(t) &&
                  this.events.emit(sz("session_update", r), { error: t.error });
            }),
            pB(this, "onSessionExtendRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidExtend({ topic: e }),
                  await this.setExpiry(e, sH(pE)),
                  await this.sendResult({ id: r, topic: e, result: !0 }),
                  this.client.events.emit("session_extend", {
                    id: r,
                    topic: e,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            pB(this, "onSessionExtendResponse", (e, t) => {
              let { id: r } = t,
                i = sz("session_extend", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              dO(t)
                ? this.events.emit(sz("session_extend", r), {})
                : dP(t) &&
                  this.events.emit(sz("session_extend", r), { error: t.error });
            }),
            pB(this, "onSessionPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_ping", { id: r, topic: e });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            pB(this, "onSessionPingResponse", (e, t) => {
              let { id: r } = t,
                i = sz("session_ping", r);
              setTimeout(() => {
                if (0 === this.events.listenerCount(i))
                  throw Error(`emitting ${i} without any listeners 2176`);
                dO(t)
                  ? this.events.emit(sz("session_ping", r), {})
                  : dP(t) &&
                    this.events.emit(sz("session_ping", r), { error: t.error });
              }, 500);
            }),
            pB(this, "onSessionDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e, reason: t.params }),
                  await Promise.all([
                    new Promise((t) => {
                      this.client.core.relayer.once(dZ.publish, async () => {
                        t(await this.deleteSession({ topic: e, id: r }));
                      });
                    }),
                    this.sendResult({ id: r, topic: e, result: !0 }),
                    this.cleanupPendingSentRequestsForTopic({
                      topic: e,
                      error: lQ("USER_DISCONNECTED"),
                    }),
                  ]).catch((e) => this.client.logger.error(e));
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            pB(this, "onSessionRequest", async (e) => {
              var t, r, i;
              let {
                  topic: n,
                  payload: s,
                  attestation: a,
                  encryptedId: o,
                  transportType: c,
                } = e,
                { id: l, params: d } = s;
              try {
                await this.isValidRequest(pM({ topic: n }, d));
                let e = this.client.session.get(n),
                  s = await this.getVerifyContext({
                    attestationId: a,
                    hash: lx(JSON.stringify(db("wc_sessionRequest", d, l))),
                    encryptedId: o,
                    metadata: e.peer.metadata,
                    transportType: c,
                  }),
                  h = { id: l, topic: n, params: d, verifyContext: s };
                await this.setPendingSessionRequest(h),
                  c === dJ.link_mode &&
                    null != (t = e.peer.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      null == (r = e.peer.metadata.redirect)
                        ? void 0
                        : r.universal
                    ),
                  null != (i = this.client.signConfig) && i.disableRequestQueue
                    ? this.emitSessionRequest(h)
                    : (this.addSessionRequestToSessionRequestQueue(h),
                      this.processSessionRequestQueue());
              } catch (e) {
                await this.sendError({ id: l, topic: n, error: e }),
                  this.client.logger.error(e);
              }
            }),
            pB(this, "onSessionRequestResponse", (e, t) => {
              let { id: r } = t,
                i = sz("session_request", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              dO(t)
                ? this.events.emit(sz("session_request", r), {
                    result: t.result,
                  })
                : dP(t) &&
                  this.events.emit(sz("session_request", r), {
                    error: t.error,
                  });
            }),
            pB(this, "onSessionEventRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                let t = `${e}_session_event_${i.event.name}`,
                  n = dc.get(t);
                if (n && this.isRequestOutOfSync(n, r))
                  return void this.client.logger.info(
                    `Discarding out of sync request - ${r}`
                  );
                this.isValidEmit(pM({ topic: e }, i)),
                  this.client.events.emit("session_event", {
                    id: r,
                    topic: e,
                    params: i,
                  }),
                  dc.set(t, r);
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            pB(this, "onSessionAuthenticateResponse", (e, t) => {
              let { id: r } = t;
              this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: e,
                payload: t,
              }),
                dO(t)
                  ? this.events.emit(sz("session_request", r), {
                      result: t.result,
                    })
                  : dP(t) &&
                    this.events.emit(sz("session_request", r), {
                      error: t.error,
                    });
            }),
            pB(this, "onSessionAuthenticateRequest", async (e) => {
              var t;
              let {
                topic: r,
                payload: i,
                attestation: n,
                encryptedId: s,
                transportType: a,
              } = e;
              try {
                let {
                    requester: e,
                    authPayload: o,
                    expiryTimestamp: c,
                  } = i.params,
                  l = await this.getVerifyContext({
                    attestationId: n,
                    hash: lx(JSON.stringify(i)),
                    encryptedId: s,
                    metadata: e.metadata,
                    transportType: a,
                  }),
                  d = {
                    requester: e,
                    pairingTopic: r,
                    id: i.id,
                    authPayload: o,
                    verifyContext: l,
                    expiryTimestamp: c,
                  };
                await this.setAuthRequest(i.id, {
                  request: d,
                  pairingTopic: r,
                  transportType: a,
                }),
                  a === dJ.link_mode &&
                    null != (t = e.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      e.metadata.redirect.universal
                    ),
                  this.client.events.emit("session_authenticate", {
                    topic: r,
                    params: i.params,
                    id: i.id,
                    verifyContext: l,
                  });
              } catch (s) {
                this.client.logger.error(s);
                let e = i.params.requester.publicKey,
                  t = await this.client.core.crypto.generateKeyPair(),
                  n = this.getAppLinkIfEnabled(i.params.requester.metadata, a);
                await this.sendError({
                  id: i.id,
                  topic: r,
                  error: s,
                  encodeOpts: {
                    type: 1,
                    receiverPublicKey: e,
                    senderPublicKey: t,
                  },
                  rpcOpts: px.wc_sessionAuthenticate.autoReject,
                  appLink: n,
                });
              }
            }),
            pB(this, "addSessionRequestToSessionRequestQueue", (e) => {
              this.sessionRequestQueue.queue.push(e);
            }),
            pB(this, "cleanupAfterResponse", (e) => {
              this.deletePendingSessionRequest(e.response.id, {
                message: "fulfilled",
                code: 0,
              }),
                setTimeout(() => {
                  (this.sessionRequestQueue.state = p_.idle),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay));
            }),
            pB(
              this,
              "cleanupPendingSentRequestsForTopic",
              ({ topic: e, error: t }) => {
                let r = this.client.core.history.pending;
                r.length > 0 &&
                  r
                    .filter(
                      (t) =>
                        t.topic === e &&
                        "wc_sessionRequest" === t.request.method
                    )
                    .forEach((e) => {
                      let r = sz("session_request", e.request.id);
                      if (0 === this.events.listenerCount(r))
                        throw Error(`emitting ${r} without any listeners`);
                      this.events.emit(sz("session_request", e.request.id), {
                        error: t,
                      });
                    });
              }
            ),
            pB(this, "processSessionRequestQueue", () => {
              if (this.sessionRequestQueue.state === p_.active)
                return void this.client.logger.info(
                  "session request queue is already active."
                );
              let e = this.sessionRequestQueue.queue[0];
              if (!e)
                return void this.client.logger.info(
                  "session request queue is empty."
                );
              try {
                this.emitSessionRequest(e);
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            pB(this, "emitSessionRequest", (e) => {
              if (this.emittedSessionRequests.has(e.id))
                return void this.client.logger.warn(
                  { id: e.id },
                  `Skipping emitting \`session_request\` event for duplicate request. id: ${e.id}`
                );
              (this.sessionRequestQueue.state = p_.active),
                this.emittedSessionRequests.add(e.id),
                this.client.events.emit("session_request", e);
            }),
            pB(this, "onPairingCreated", (e) => {
              if (
                (e.methods &&
                  this.expectedPairingMethodMap.set(e.topic, e.methods),
                e.active)
              )
                return;
              let t = this.client.proposal
                .getAll()
                .find((t) => t.pairingTopic === e.topic);
              t &&
                this.onSessionProposeRequest({
                  topic: e.topic,
                  payload: db(
                    "wc_sessionPropose",
                    pL(pM({}, t), {
                      requiredNamespaces: t.requiredNamespaces,
                      optionalNamespaces: t.optionalNamespaces,
                      relays: t.relays,
                      proposer: t.proposer,
                      sessionProperties: t.sessionProperties,
                      scopedProperties: t.scopedProperties,
                    }),
                    t.id
                  ),
                  attestation: t.attestation,
                  encryptedId: t.encryptedId,
                });
            }),
            pB(this, "isValidConnect", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `connect() params: ${JSON.stringify(e)}`
                );
                throw Error(t);
              }
              let {
                pairingTopic: t,
                requiredNamespaces: r,
                optionalNamespaces: i,
                sessionProperties: n,
                scopedProperties: s,
                relays: a,
              } = e;
              if (
                (l2(t) || (await this.isValidPairingTopic(t)),
                !(function (e, t) {
                  let r = !1;
                  return (
                    t && !e
                      ? (r = !0)
                      : e &&
                        l0(e) &&
                        e.length &&
                        e.forEach((e) => {
                          r = l7(e);
                        }),
                    r
                  );
                })(a, !0))
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `connect() relays: ${a}`
                );
                throw Error(e);
              }
              if (!l2(r) && 0 !== l1(r)) {
                let e =
                  "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                ["fatal", "error", "silent"].includes(this.client.logger.level)
                  ? console.warn(e)
                  : this.client.logger.warn(e),
                  this.validateNamespaces(r, "requiredNamespaces");
              }
              if (
                (l2(i) ||
                  0 === l1(i) ||
                  this.validateNamespaces(i, "optionalNamespaces"),
                l2(n) || this.validateSessionProps(n, "sessionProperties"),
                !l2(s))
              ) {
                this.validateSessionProps(s, "scopedProperties");
                let e = Object.keys(r || {}).concat(Object.keys(i || {}));
                if (!Object.keys(s).every((t) => e.includes(t.split(":")[0])))
                  throw Error(
                    `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                      s
                    )}, required/optional namespaces: ${JSON.stringify(e)}`
                  );
              }
            }),
            pB(this, "validateNamespaces", (e, t) => {
              let r = (function (e, t, r) {
                let i = null;
                if (e && l1(e)) {
                  let n,
                    s = l8(e, t);
                  s && (i = s);
                  let a =
                    ((n = null),
                    Object.entries(e).forEach(([e, i]) => {
                      var s, a;
                      let o;
                      if (n) return;
                      let c =
                        ((s = sw(e, i)),
                        (a = `${t} ${r}`),
                        (o = null),
                        l0(s) && s.length
                          ? s.forEach((e) => {
                              o ||
                                l4(e) ||
                                (o = lQ(
                                  "UNSUPPORTED_CHAINS",
                                  `${a}, chain ${e} should be a string and conform to "namespace:chainId" format`
                                ));
                            })
                          : l4(e) ||
                            (o = lQ(
                              "UNSUPPORTED_CHAINS",
                              `${a}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
                            )),
                        o);
                      c && (n = c);
                    }),
                    n);
                  a && (i = a);
                } else
                  i = lX(
                    "MISSING_OR_INVALID",
                    `${t}, ${r} should be an object with data`
                  );
                return i;
              })(e, "connect()", t);
              if (r) throw Error(r.message);
            }),
            pB(this, "isValidApprove", async (e) => {
              if (!de(e))
                throw Error(
                  lX("MISSING_OR_INVALID", `approve() params: ${e}`).message
                );
              let {
                id: t,
                namespaces: r,
                relayProtocol: i,
                sessionProperties: n,
                scopedProperties: s,
              } = e;
              this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
              let a = this.client.proposal.get(t),
                o = l9(r, "approve()");
              if (o) throw Error(o.message);
              let c = dr(a.requiredNamespaces, r, "approve()");
              if (c) throw Error(c.message);
              if (!l3(i, !0)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `approve() relayProtocol: ${i}`
                );
                throw Error(e);
              }
              if (
                (l2(n) || this.validateSessionProps(n, "sessionProperties"),
                !l2(s))
              ) {
                this.validateSessionProps(s, "scopedProperties");
                let e = new Set(Object.keys(r));
                if (!Object.keys(s).every((t) => e.has(t.split(":")[0])))
                  throw Error(
                    `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                      s
                    )}, approved namespaces: ${Array.from(e).join(", ")}`
                  );
              }
            }),
            pB(this, "isValidReject", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `reject() params: ${e}`
                );
                throw Error(t);
              }
              let { id: t, reason: r } = e;
              if (
                (this.checkRecentlyDeleted(t),
                await this.isValidProposalId(t),
                !(function (e) {
                  return !(
                    !e ||
                    "object" != typeof e ||
                    !e.code ||
                    !l5(e.code, !1) ||
                    !e.message ||
                    !l3(e.message, !1)
                  );
                })(r))
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `reject() reason: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            pB(this, "isValidSessionSettleRequest", (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `onSessionSettleRequest() params: ${e}`
                );
                throw Error(t);
              }
              let { relay: t, controller: r, namespaces: i, expiry: n } = e;
              if (!l7(t)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  "onSessionSettleRequest() relay protocol should be a string"
                );
                throw Error(e);
              }
              let s = (function (e, t) {
                let r = null;
                return (
                  l3(e?.publicKey, !1) ||
                    (r = lX(
                      "MISSING_OR_INVALID",
                      `${t} controller public key should be a string`
                    )),
                  r
                );
              })(r, "onSessionSettleRequest()");
              if (s) throw Error(s.message);
              let a = l9(i, "onSessionSettleRequest()");
              if (a) throw Error(a.message);
              if (sq(n)) {
                let { message: e } = lX("EXPIRED", "onSessionSettleRequest()");
                throw Error(e);
              }
            }),
            pB(this, "isValidUpdate", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `update() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, namespaces: r } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let i = this.client.session.get(t),
                n = l9(r, "update()");
              if (n) throw Error(n.message);
              let s = dr(i.requiredNamespaces, r, "update()");
              if (s) throw Error(s.message);
            }),
            pB(this, "isValidExtend", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `extend() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
            }),
            pB(this, "isValidRequest", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `request() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, request: r, chainId: i, expiry: n } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let { namespaces: s } = this.client.session.get(t);
              if (!dt(s, i)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `request() chainId: ${i}`
                );
                throw Error(e);
              }
              if (
                !(function (e) {
                  return !(l2(e) || !l3(e.method, !1));
                })(r)
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `request() ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
              if (
                !(function (e, t, r) {
                  return (
                    !!l3(r, !1) &&
                    (function (e, t) {
                      let r = [];
                      return (
                        Object.values(e).forEach((e) => {
                          lz(e.accounts).includes(t) && r.push(...e.methods);
                        }),
                        r
                      );
                    })(e, t).includes(r)
                  );
                })(s, i, r.method)
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `request() method: ${r.method}`
                );
                throw Error(e);
              }
              if (
                n &&
                !(function (e, t) {
                  return l5(e, !1) && e <= t.max && e >= t.min;
                })(n, pA)
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `request() expiry: ${n}. Expiry must be a number (in seconds) between ${pA.min} and ${pA.max}`
                );
                throw Error(e);
              }
            }),
            pB(this, "isValidRespond", async (e) => {
              var t;
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `respond() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, response: i } = e;
              try {
                await this.isValidSessionTopic(r);
              } catch (r) {
                throw (
                  (null != (t = e?.response) &&
                    t.id &&
                    this.cleanupAfterResponse(e),
                  r)
                );
              }
              if (
                !(function (e) {
                  return !(
                    l2(e) ||
                    (l2(e.result) && l2(e.error)) ||
                    !l5(e.id, !1) ||
                    !l3(e.jsonrpc, !1)
                  );
                })(i)
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `respond() response: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
            }),
            pB(this, "isValidPing", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            pB(this, "isValidEmit", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `emit() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, event: r, chainId: i } = e;
              await this.isValidSessionTopic(t);
              let { namespaces: n } = this.client.session.get(t);
              if (!dt(n, i)) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `emit() chainId: ${i}`
                );
                throw Error(e);
              }
              if (
                !(function (e) {
                  return !(l2(e) || !l3(e.name, !1));
                })(r) ||
                !(function (e, t, r) {
                  return (
                    !!l3(r, !1) &&
                    (function (e, t) {
                      let r = [];
                      return (
                        Object.values(e).forEach((e) => {
                          lz(e.accounts).includes(t) && r.push(...e.events);
                        }),
                        r
                      );
                    })(e, t).includes(r)
                  );
                })(n, i, r.name)
              ) {
                let { message: e } = lX(
                  "MISSING_OR_INVALID",
                  `emit() event: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            pB(this, "isValidDisconnect", async (e) => {
              if (!de(e)) {
                let { message: t } = lX(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            pB(this, "isValidAuthenticate", (e) => {
              let { chains: t, uri: r, domain: i, nonce: n } = e;
              if (!Array.isArray(t) || 0 === t.length)
                throw Error("chains is required and must be a non-empty array");
              if (!l3(r, !1)) throw Error("uri is required parameter");
              if (!l3(i, !1)) throw Error("domain is required parameter");
              if (!l3(n, !1)) throw Error("nonce is required parameter");
              if ([...new Set(t.map((e) => sy(e).namespace))].length > 1)
                throw Error(
                  "Multi-namespace requests are not supported. Please request single namespace only."
                );
              let { namespace: s } = sy(t[0]);
              if ("eip155" !== s)
                throw Error(
                  "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
                );
            }),
            pB(this, "getVerifyContext", async (e) => {
              let {
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  metadata: n,
                  transportType: s,
                } = e,
                a = {
                  verified: {
                    verifyUrl: n.verifyUrl || d5,
                    validation: "UNKNOWN",
                    origin: n.url || "",
                  },
                };
              try {
                if (s === dJ.link_mode) {
                  let e = this.getAppLinkIfEnabled(n, s);
                  return (
                    (a.verified.validation =
                      e && new URL(e).origin === new URL(n.url).origin
                        ? "VALID"
                        : "INVALID"),
                    a
                  );
                }
                let e = await this.client.core.verify.resolve({
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  verifyUrl: n.verifyUrl,
                });
                e &&
                  ((a.verified.origin = e.origin),
                  (a.verified.isScam = e.isScam),
                  (a.verified.validation =
                    e.origin === new URL(n.url).origin ? "VALID" : "INVALID"));
              } catch (e) {
                this.client.logger.warn(e);
              }
              return (
                this.client.logger.debug(
                  `Verify context: ${JSON.stringify(a)}`
                ),
                a
              );
            }),
            pB(this, "validateSessionProps", (e, t) => {
              Object.values(e).forEach((r, i) => {
                if (null == r) {
                  let { message: n } = lX(
                    "MISSING_OR_INVALID",
                    `${t} must contain an existing value for each key. Received: ${r} for key ${
                      Object.keys(e)[i]
                    }`
                  );
                  throw Error(n);
                }
              });
            }),
            pB(this, "getPendingAuthRequest", (e) => {
              let t = this.client.auth.requests.get(e);
              return "object" == typeof t ? t : void 0;
            }),
            pB(this, "addToRecentlyDeleted", (e, t) => {
              if (
                (this.recentlyDeletedMap.set(e, t),
                this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
              ) {
                let e = 0,
                  t = this.recentlyDeletedLimit / 2;
                for (let r of this.recentlyDeletedMap.keys()) {
                  if (e++ >= t) break;
                  this.recentlyDeletedMap.delete(r);
                }
              }
            }),
            pB(this, "checkRecentlyDeleted", (e) => {
              let t = this.recentlyDeletedMap.get(e);
              if (t) {
                let { message: r } = lX(
                  "MISSING_OR_INVALID",
                  `Record was recently deleted - ${t}: ${e}`
                );
                throw Error(r);
              }
            }),
            pB(this, "isLinkModeEnabled", (e, t) => {
              var i, n, s, a, o, c, l, d, h;
              return (
                !!e &&
                t === dJ.link_mode &&
                (null ==
                (n = null == (i = this.client.metadata) ? void 0 : i.redirect)
                  ? void 0
                  : n.linkMode) === !0 &&
                (null ==
                (a = null == (s = this.client.metadata) ? void 0 : s.redirect)
                  ? void 0
                  : a.universal) !== void 0 &&
                (null ==
                (c = null == (o = this.client.metadata) ? void 0 : o.redirect)
                  ? void 0
                  : c.universal) !== "" &&
                (null == (l = e?.redirect) ? void 0 : l.universal) !== void 0 &&
                (null == (d = e?.redirect) ? void 0 : d.universal) !== "" &&
                (null == (h = e?.redirect) ? void 0 : h.linkMode) === !0 &&
                this.client.core.linkModeSupportedApps.includes(
                  e.redirect.universal
                ) &&
                "u" > typeof (null == r.g ? void 0 : r.g.Linking)
              );
            }),
            pB(this, "getAppLinkIfEnabled", (e, t) => {
              var r;
              return this.isLinkModeEnabled(e, t)
                ? null == (r = e?.redirect)
                  ? void 0
                  : r.universal
                : void 0;
            }),
            pB(this, "handleLinkModeMessage", ({ url: e }) => {
              if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
              let t = sG(e, "topic") || "",
                r = decodeURIComponent(sG(e, "wc_ev") || ""),
                i = this.client.session.keys.includes(t);
              i &&
                this.client.session.update(t, { transportType: dJ.link_mode }),
                this.client.core.dispatchEnvelope({
                  topic: t,
                  message: r,
                  sessionExists: i,
                });
            }),
            pB(this, "registerLinkModeListeners", async () => {
              var e;
              if (
                sY() ||
                (sT() &&
                  null != (e = this.client.metadata.redirect) &&
                  e.linkMode)
              ) {
                let e = null == r.g ? void 0 : r.g.Linking;
                if ("u" > typeof e) {
                  e.addEventListener(
                    "url",
                    this.handleLinkModeMessage,
                    this.client.name
                  );
                  let t = await e.getInitialURL();
                  t &&
                    setTimeout(() => {
                      this.handleLinkModeMessage({ url: t });
                    }, 50);
                }
              }
            }),
            pB(this, "getTVFParams", (e, t, r) => {
              var i, n, s;
              if (!(null != (i = t.request) && i.method)) return {};
              let a = {
                correlationId: e,
                rpcMethods: [t.request.method],
                chainId: t.chainId,
              };
              try {
                (a.txHashes = this.extractTxHashesFromResult(t.request, r)),
                  (a.contractAddresses = this.isValidContractData(
                    t.request.params
                  )
                    ? [
                        null ==
                        (s = null == (n = t.request.params) ? void 0 : n[0])
                          ? void 0
                          : s.to,
                      ]
                    : []);
              } catch (e) {
                this.client.logger.warn("Error getting TVF params", e);
              }
              return a;
            }),
            pB(this, "isValidContractData", (e) => {
              var t;
              if (!e) return !1;
              try {
                let r = e?.data || (null == (t = e?.[0]) ? void 0 : t.data);
                if (!r.startsWith("0x")) return !1;
                let i = r.slice(2);
                return !!/^[0-9a-fA-F]*$/.test(i) && i.length % 2 == 0;
              } catch {}
              return !1;
            }),
            pB(this, "extractTxHashesFromResult", (e, t) => {
              var r;
              try {
                if (!t) return [];
                let i = e.method,
                  n = pI[i];
                if ("sui_signTransaction" === i)
                  return [
                    (function (e) {
                      let t = new Uint8Array(sm.from(e, "base64")),
                        r = Array.from("TransactionData::").map((e) =>
                          e.charCodeAt(0)
                        ),
                        i = new Uint8Array(r.length + t.length);
                      i.set(r), i.set(t, r.length);
                      let n = ou(i, { dkLen: 32 });
                      return iy.A.encode(n);
                    })(t.transactionBytes),
                  ];
                if ("near_signTransaction" === i) return [oy(t)];
                if ("near_signTransactions" === i) return t.map((e) => oy(e));
                if (
                  "xrpl_signTransactionFor" === i ||
                  "xrpl_signTransaction" === i
                )
                  return [null == (r = t.tx_json) ? void 0 : r.hash];
                if ("polkadot_signTransaction" === i)
                  return [
                    (function (e) {
                      let t = Uint8Array.from(sm.from(e.signature, "hex")),
                        r = (function ({
                          publicKey: e,
                          signature: t,
                          payload: r,
                        }) {
                          var i, n;
                          let s = dl(r.method),
                            a =
                              128 |
                              parseInt(
                                (null == (i = r.version)
                                  ? void 0
                                  : i.toString()) || "4"
                              ),
                            o = (function (e) {
                              let t = iy.A.decode(e)[0];
                              return 42 === t ? 0 : 60 === t ? 2 : 1;
                            })(r.address),
                            c =
                              "00" === r.era ? new Uint8Array([0]) : dl(r.era);
                          if (1 !== c.length && 2 !== c.length)
                            throw Error("Invalid era length");
                          let l = parseInt(r.nonce, 16),
                            d = new Uint8Array([255 & l, (l >> 8) & 255]),
                            h = new Uint8Array([
                              0,
                              ...e,
                              o,
                              ...t,
                              ...c,
                              ...d,
                              ...(function (e) {
                                if (e < BigInt(1) << BigInt(6))
                                  return new Uint8Array([
                                    Number(e << BigInt(2)),
                                  ]);
                                if (e < BigInt(1) << BigInt(14)) {
                                  let t = (e << BigInt(2)) | BigInt(1);
                                  return new Uint8Array([
                                    Number(t & BigInt(255)),
                                    Number((t >> BigInt(8)) & BigInt(255)),
                                  ]);
                                }
                                if (e < BigInt(1) << BigInt(30)) {
                                  let t = (e << BigInt(2)) | BigInt(2);
                                  return new Uint8Array([
                                    Number(t & BigInt(255)),
                                    Number((t >> BigInt(8)) & BigInt(255)),
                                    Number((t >> BigInt(16)) & BigInt(255)),
                                    Number((t >> BigInt(24)) & BigInt(255)),
                                  ]);
                                }
                                throw Error(
                                  "BigInt compact encoding not supported > 2^30"
                                );
                              })(
                                BigInt(
                                  `0x${
                                    (n = r.tip).startsWith("0x")
                                      ? n.slice(2)
                                      : n
                                  }`
                                )
                              ),
                              ...s,
                            ]);
                          return new Uint8Array([
                            ...(function (e) {
                              if (e < 64) return new Uint8Array([e << 2]);
                              if (e < 16384) {
                                let t = (e << 2) | 1;
                                return new Uint8Array([
                                  255 & t,
                                  (t >> 8) & 255,
                                ]);
                              }
                              if (e < 0x40000000) {
                                let t = (e << 2) | 2;
                                return new Uint8Array([
                                  255 & t,
                                  (t >> 8) & 255,
                                  (t >> 16) & 255,
                                  (t >> 24) & 255,
                                ]);
                              }
                              throw Error(
                                "Compact encoding > 2^30 not supported"
                              );
                            })(h.length + 1),
                            a,
                            ...h,
                          ]);
                        })({
                          publicKey: (function (e) {
                            let t = iy.A.decode(e);
                            if (t.length < 33)
                              throw Error("Too short to contain a public key");
                            return t.slice(1, 33);
                          })(e.transaction.address),
                          signature: t,
                          payload: e.transaction,
                        });
                      var i = sm.from(r).toString("hex");
                      let n = dl(i),
                        s = (0, sf.blake2b)(n, void 0, 32);
                      return "0x" + sm.from(s).toString("hex");
                    })({
                      transaction: e.params.transactionPayload,
                      signature: t.signature,
                    }),
                  ];
                if ("algo_signTxn" === i)
                  return l0(t) ? t.map((e) => ow(e)) : [ow(t)];
                if ("cosmos_signDirect" === i)
                  return [
                    (function (e) {
                      let t = sm.from(e.signed.bodyBytes, "base64"),
                        r = sm.from(e.signed.authInfoBytes, "base64"),
                        i = sm.from(e.signature.signature, "base64"),
                        n = [];
                      n.push(sm.from([10])),
                        n.push(ob(t.length)),
                        n.push(t),
                        n.push(sm.from([18])),
                        n.push(ob(r.length)),
                        n.push(r),
                        n.push(sm.from([26])),
                        n.push(ob(i.length)),
                        n.push(i);
                      let s = ot(sm.concat(n));
                      return sm.from(s).toString("hex").toUpperCase();
                    })(t),
                  ];
                if ("string" == typeof t) return [t];
                let s = t[n.key];
                if (l0(s))
                  return "solana_signAllTransactions" === i
                    ? s.map((e) =>
                        (function (e) {
                          let t = atob(e),
                            r = new Uint8Array(t.length);
                          for (let e = 0; e < t.length; e++)
                            r[e] = t.charCodeAt(e);
                          let i = r[0];
                          if (0 === i) throw Error("No signatures found");
                          if (r.length < 1 + 64 * i)
                            throw Error(
                              "Transaction data too short for claimed signature count"
                            );
                          if (r.length < 100)
                            throw Error("Transaction too short");
                          let n = sm.from(e, "base64").slice(1, 65);
                          return iy.A.encode(n);
                        })(e)
                      )
                    : s;
                if ("string" == typeof s) return [s];
              } catch (e) {
                this.client.logger.warn(
                  "Error extracting tx hashes from result",
                  e
                );
              }
              return [];
            });
        }
        async processPendingMessageEvents() {
          try {
            let e = this.client.session.keys,
              t = this.client.core.relayer.messages.getWithoutAck(e);
            for (let [e, r] of Object.entries(t))
              for (let t of r)
                try {
                  await this.onProviderMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                  });
                } catch {
                  this.client.logger.warn(
                    `Error processing pending message event for topic: ${e}, message: ${t}`
                  );
                }
          } catch (e) {
            this.client.logger.warn("processPendingMessageEvents failed", e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = lX("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async confirmOnlineStateOrThrow() {
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(dZ.message, (e) => {
            this.onProviderMessageEvent(e);
          });
        }
        async onRelayMessage(e) {
          let { topic: t, message: r, attestation: i, transportType: n } = e,
            { publicKey: s } = this.client.auth.authKeys.keys.includes(pN)
              ? this.client.auth.authKeys.get(pN)
              : { responseTopic: void 0, publicKey: void 0 };
          try {
            let e = await this.client.core.crypto.decode(t, r, {
              receiverPublicKey: s,
              encoding: n === dJ.link_mode ? lb : lw,
            });
            dN(e)
              ? (this.client.core.history.set(t, e),
                await this.onRelayEventRequest({
                  topic: t,
                  payload: e,
                  attestation: i,
                  transportType: n,
                  encryptedId: lx(r),
                }))
              : dT(e)
              ? (await this.client.core.history.resolve(e),
                await this.onRelayEventResponse({
                  topic: t,
                  payload: e,
                  transportType: n,
                }),
                this.client.core.history.delete(t, e.id))
              : await this.onRelayEventUnknownPayload({
                  topic: t,
                  payload: e,
                  transportType: n,
                }),
              await this.client.core.relayer.messages.ack(t, r);
          } catch (e) {
            this.client.logger.error(e);
          }
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(d3.expired, async (e) => {
            let { topic: t, id: r } = sF(e.target);
            return r && this.client.pendingRequest.keys.includes(r)
              ? await this.deletePendingSessionRequest(r, lX("EXPIRED"), !0)
              : r && this.client.auth.requests.keys.includes(r)
              ? await this.deletePendingAuthRequest(r, lX("EXPIRED"), !0)
              : void (t
                  ? this.client.session.keys.includes(t) &&
                    (await this.deleteSession({
                      topic: t,
                      expirerHasDeleted: !0,
                    }),
                    this.client.events.emit("session_expire", { topic: t }))
                  : r &&
                    (await this.deleteProposal(r, !0),
                    this.client.events.emit("proposal_expire", { id: r })));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(d1.create, (e) =>
            this.onPairingCreated(e)
          ),
            this.client.core.pairing.events.on(d1.delete, (e) => {
              this.addToRecentlyDeleted(e.topic, "pairing");
            });
        }
        isValidPairingTopic(e) {
          if (!l3(e, !1)) {
            let { message: t } = lX(
              "MISSING_OR_INVALID",
              `pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.core.pairing.pairings.keys.includes(e)) {
            let { message: t } = lX(
              "NO_MATCHING_KEY",
              `pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (sq(this.client.core.pairing.pairings.get(e).expiry)) {
            let { message: t } = lX("EXPIRED", `pairing topic: ${e}`);
            throw Error(t);
          }
        }
        async isValidSessionTopic(e) {
          if (!l3(e, !1)) {
            let { message: t } = lX(
              "MISSING_OR_INVALID",
              `session topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (
            (this.checkRecentlyDeleted(e),
            !this.client.session.keys.includes(e))
          ) {
            let { message: t } = lX(
              "NO_MATCHING_KEY",
              `session topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (sq(this.client.session.get(e).expiry)) {
            await this.deleteSession({ topic: e });
            let { message: t } = lX("EXPIRED", `session topic: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.crypto.keychain.has(e)) {
            let { message: t } = lX(
              "MISSING_OR_INVALID",
              `session topic does not exist in keychain: ${e}`
            );
            throw (await this.deleteSession({ topic: e }), Error(t));
          }
        }
        async isValidSessionOrPairingTopic(e) {
          if (
            (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
          )
            await this.isValidSessionTopic(e);
          else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
          else if (l3(e, !1)) {
            let { message: t } = lX(
              "NO_MATCHING_KEY",
              `session or pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          } else {
            let { message: t } = lX(
              "MISSING_OR_INVALID",
              `session or pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
        }
        async isValidProposalId(e) {
          if ("number" != typeof e) {
            let { message: t } = lX(
              "MISSING_OR_INVALID",
              `proposal id should be a number: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.proposal.keys.includes(e)) {
            let { message: t } = lX(
              "NO_MATCHING_KEY",
              `proposal id doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (sq(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            let { message: t } = lX("EXPIRED", `proposal id: ${e}`);
            throw Error(t);
          }
        }
      }
      class pj extends uG {
        constructor(e, t) {
          super(e, t, "proposal", pw), (this.core = e), (this.logger = t);
        }
      }
      class pF extends uG {
        constructor(e, t) {
          super(e, t, "session", pw), (this.core = e), (this.logger = t);
        }
      }
      class pH extends uG {
        constructor(e, t) {
          super(e, t, "request", pw, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      class pq extends uG {
        constructor(e, t) {
          super(e, t, "authKeys", pk, () => pN),
            (this.core = e),
            (this.logger = t);
        }
      }
      class pz extends uG {
        constructor(e, t) {
          super(e, t, "pairingTopics", pk), (this.core = e), (this.logger = t);
        }
      }
      class pV extends uG {
        constructor(e, t) {
          super(e, t, "requests", pk, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      var pZ = Object.defineProperty,
        pK = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? pZ(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class pG {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            pK(this, "authKeys"),
            pK(this, "pairingTopics"),
            pK(this, "requests"),
            (this.authKeys = new pq(this.core, this.logger)),
            (this.pairingTopics = new pz(this.core, this.logger)),
            (this.requests = new pV(this.core, this.logger));
        }
        async init() {
          await this.authKeys.init(),
            await this.pairingTopics.init(),
            await this.requests.init();
        }
      }
      var pJ = Object.defineProperty,
        pY = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? pJ(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class pX extends eu {
        constructor(e) {
          super(e),
            pY(this, "protocol", "wc"),
            pY(this, "version", 2),
            pY(this, "name", pb.name),
            pY(this, "metadata"),
            pY(this, "core"),
            pY(this, "logger"),
            pY(this, "events", new w.EventEmitter()),
            pY(this, "engine"),
            pY(this, "session"),
            pY(this, "proposal"),
            pY(this, "pendingRequest"),
            pY(this, "auth"),
            pY(this, "signConfig"),
            pY(this, "on", (e, t) => this.events.on(e, t)),
            pY(this, "once", (e, t) => this.events.once(e, t)),
            pY(this, "off", (e, t) => this.events.off(e, t)),
            pY(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            pY(this, "removeAllListeners", (e) =>
              this.events.removeAllListeners(e)
            ),
            pY(this, "connect", async (e) => {
              try {
                return await this.engine.connect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "pair", async (e) => {
              try {
                return await this.engine.pair(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "approve", async (e) => {
              try {
                return await this.engine.approve(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "reject", async (e) => {
              try {
                return await this.engine.reject(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "update", async (e) => {
              try {
                return await this.engine.update(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "extend", async (e) => {
              try {
                return await this.engine.extend(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "request", async (e) => {
              try {
                return await this.engine.request(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "respond", async (e) => {
              try {
                return await this.engine.respond(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "ping", async (e) => {
              try {
                return await this.engine.ping(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "emit", async (e) => {
              try {
                return await this.engine.emit(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "disconnect", async (e) => {
              try {
                return await this.engine.disconnect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "find", (e) => {
              try {
                return this.engine.find(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "getPendingSessionRequests", () => {
              try {
                return this.engine.getPendingSessionRequests();
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "authenticate", async (e, t) => {
              try {
                return await this.engine.authenticate(e, t);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "formatAuthMessage", (e) => {
              try {
                return this.engine.formatAuthMessage(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "approveSessionAuthenticate", async (e) => {
              try {
                return await this.engine.approveSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            pY(this, "rejectSessionAuthenticate", async (e) => {
              try {
                return await this.engine.rejectSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            (this.name = e?.name || pb.name),
            (this.metadata = (function (e) {
              var t, r;
              let i = s$();
              try {
                let n, s;
                return (
                  null != e &&
                    e.url &&
                    i.url &&
                    new URL(e.url).host !== new URL(i.url).host &&
                    (console.warn(
                      `The configured WalletConnect 'metadata.url':${e.url} differs from the actual page url:${i.url}. This is probably unintended and can lead to issues.`
                    ),
                    (e.url = i.url)),
                  null != (t = e?.icons) &&
                    t.length &&
                    e.icons.length > 0 &&
                    (e.icons = e.icons.filter((e) => "" !== e)),
                  (n = sI(sI({}, i), e)),
                  (s = {
                    url: e?.url || i.url,
                    name: e?.name || i.name,
                    description: e?.description || i.description,
                    icons:
                      null != (r = e?.icons) && r.length && e.icons.length > 0
                        ? e.icons
                        : i.icons,
                  }),
                  sv(n, sC(s))
                );
              } catch (t) {
                return console.warn("Error populating app metadata", t), e || i;
              }
            })(e?.metadata)),
            (this.signConfig = e?.signConfig);
          let t =
            "u" > typeof e?.logger && "string" != typeof e?.logger
              ? e.logger
              : (0, G.h6)((0, G.iP)({ level: e?.logger || pb.logger }));
          (this.core = e?.core || new pm(e)),
            (this.logger = (0, G.U5)(t, this.name)),
            (this.session = new pF(this.core, this.logger)),
            (this.proposal = new pj(this.core, this.logger)),
            (this.pendingRequest = new pH(this.core, this.logger)),
            (this.engine = new pW(this)),
            (this.auth = new pG(this.core, this.logger));
        }
        static async init(e) {
          let t = new pX(e);
          return await t.initialize(), t;
        }
        get context() {
          return (0, G.oI)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.core.start(),
              await this.session.init(),
              await this.proposal.init(),
              await this.pendingRequest.init(),
              await this.auth.init(),
              await this.engine.init(),
              this.logger.info("SignClient Initialization Success");
          } catch (e) {
            throw (
              (this.logger.info("SignClient Initialization Failure"),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      var pQ = r(37370),
        p0 = r.n(pQ),
        p1 = Object.defineProperty,
        p2 = Object.defineProperties,
        p3 = Object.getOwnPropertyDescriptors,
        p5 = Object.getOwnPropertySymbols,
        p4 = Object.prototype.hasOwnProperty,
        p6 = Object.prototype.propertyIsEnumerable,
        p8 = (e, t, r) =>
          t in e
            ? p1(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        p9 = (e, t) => {
          for (var r in t || (t = {})) p4.call(t, r) && p8(e, r, t[r]);
          if (p5) for (var r of p5(t)) p6.call(t, r) && p8(e, r, t[r]);
          return e;
        },
        p7 = (e, t) => p2(e, p3(t));
      let fe = {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        method: "POST",
      };
      class ft {
        constructor(e, t = !1) {
          if (
            ((this.url = e),
            (this.disableProviderPing = t),
            (this.events = new w.EventEmitter()),
            (this.isAvailable = !1),
            (this.registering = !1),
            !dI(e))
          )
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          (this.url = e), (this.disableProviderPing = t);
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          if (!this.isAvailable) throw Error("Connection already closed");
          this.onClose();
        }
        async send(e) {
          this.isAvailable || (await this.register());
          try {
            let t = (0, W.h)(e),
              r = await (
                await p0()(this.url, p7(p9({}, fe), { body: t }))
              ).json();
            this.onPayload({ data: r });
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        async register(e = this.url) {
          if (!dI(e))
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if (
                      (this.resetMaxListeners(), typeof this.isAvailable > "u")
                    )
                      return t(Error("HTTP connection is missing or invalid"));
                    e();
                  });
              })
            );
          }
          (this.url = e), (this.registering = !0);
          try {
            if (!this.disableProviderPing) {
              let t = (0, W.h)({
                id: 1,
                jsonrpc: "2.0",
                method: "test",
                params: [],
              });
              await p0()(e, p7(p9({}, fe), { body: t }));
            }
            this.onOpen();
          } catch (t) {
            let e = this.parseError(t);
            throw (this.events.emit("register_error", e), this.onClose(), e);
          }
        }
        onOpen() {
          (this.isAvailable = !0),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose() {
          (this.isAvailable = !1),
            (this.registering = !1),
            this.events.emit("close");
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, W.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = dC(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return dg(e, t, "HTTP");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
      }
      var fr = r(81029).Buffer;
      let fi = "error",
        fn = "wc@2:universal_provider:",
        fs = "https://rpc.walletconnect.org/v1/",
        fa = "generic",
        fo = `${fs}bundler`,
        fc = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
      function fl(e) {
        return null == e || ("object" != typeof e && "function" != typeof e);
      }
      function fd(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function fh(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let fu = "[object String]",
        fp = "[object Number]",
        ff = "[object Boolean]",
        fg = "[object Arguments]";
      function fm(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function fy(e, t, r, i = new Map(), n) {
        let s = n?.(e, t, r, i);
        if (null != s) return s;
        if (fl(e)) return e;
        if (i.has(e)) return i.get(e);
        if (Array.isArray(e)) {
          let t = Array(e.length);
          i.set(e, t);
          for (let s = 0; s < e.length; s++) t[s] = fy(e[s], s, r, i, n);
          return (
            Object.hasOwn(e, "index") && (t.index = e.index),
            Object.hasOwn(e, "input") && (t.input = e.input),
            t
          );
        }
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
          let t = new RegExp(e.source, e.flags);
          return (t.lastIndex = e.lastIndex), t;
        }
        if (e instanceof Map) {
          let t = new Map();
          for (let [s, a] of (i.set(e, t), e)) t.set(s, fy(a, s, r, i, n));
          return t;
        }
        if (e instanceof Set) {
          let t = new Set();
          for (let s of (i.set(e, t), e)) t.add(fy(s, void 0, r, i, n));
          return t;
        }
        if ("u" > typeof fr && fr.isBuffer(e)) return e.subarray();
        if (fm(e)) {
          let t = new (Object.getPrototypeOf(e).constructor)(e.length);
          i.set(e, t);
          for (let s = 0; s < e.length; s++) t[s] = fy(e[s], s, r, i, n);
          return t;
        }
        if (
          e instanceof ArrayBuffer ||
          ("u" > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
        )
          return e.slice(0);
        if (e instanceof DataView) {
          let t = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
          return i.set(e, t), fw(t, e, r, i, n), t;
        }
        if ("u" > typeof File && e instanceof File) {
          let t = new File([e], e.name, { type: e.type });
          return i.set(e, t), fw(t, e, r, i, n), t;
        }
        if (e instanceof Blob) {
          let t = new Blob([e], { type: e.type });
          return i.set(e, t), fw(t, e, r, i, n), t;
        }
        if (e instanceof Error) {
          let t = new e.constructor();
          return (
            i.set(e, t),
            (t.message = e.message),
            (t.name = e.name),
            (t.stack = e.stack),
            (t.cause = e.cause),
            fw(t, e, r, i, n),
            t
          );
        }
        if (
          "object" == typeof e &&
          (function (e) {
            switch (fh(e)) {
              case fg:
              case "[object Array]":
              case "[object ArrayBuffer]":
              case "[object DataView]":
              case ff:
              case "[object Date]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Map]":
              case fp:
              case "[object Object]":
              case "[object RegExp]":
              case "[object Set]":
              case fu:
              case "[object Symbol]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return !0;
              default:
                return !1;
            }
          })(e)
        ) {
          let t = Object.create(Object.getPrototypeOf(e));
          return i.set(e, t), fw(t, e, r, i, n), t;
        }
        return e;
      }
      function fw(e, t, r = e, i, n) {
        let s = [...Object.keys(t), ...fd(t)];
        for (let a = 0; a < s.length; a++) {
          let o = s[a],
            c = Object.getOwnPropertyDescriptor(e, o);
          (null == c || c.writable) && (e[o] = fy(t[o], o, r, i, n));
        }
      }
      function fb(e) {
        var t;
        return (
          (t = (t, r, i, n) => {
            let s = void 0;
            if (null != s) return s;
            if ("object" == typeof e)
              switch (Object.prototype.toString.call(e)) {
                case fp:
                case fu:
                case ff: {
                  let t = new e.constructor(e?.valueOf());
                  return fw(t, e), t;
                }
                case fg: {
                  let t = {};
                  return (
                    fw(t, e),
                    (t.length = e.length),
                    (t[Symbol.iterator] = e[Symbol.iterator]),
                    t
                  );
                }
                default:
                  return;
              }
          }),
          fy(e, void 0, e, new Map(), t)
        );
      }
      function fv(e) {
        return (
          null !== e && "object" == typeof e && "[object Arguments]" === fh(e)
        );
      }
      function fC(e) {
        return "object" == typeof e && null !== e;
      }
      function fE() {}
      var fx = Object.defineProperty,
        fA = Object.defineProperties,
        f_ = Object.getOwnPropertyDescriptors,
        fI = Object.getOwnPropertySymbols,
        fS = Object.prototype.hasOwnProperty,
        fk = Object.prototype.propertyIsEnumerable,
        fN = (e, t, r) =>
          t in e
            ? fx(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fT = (e, t) => {
          for (var r in t || (t = {})) fS.call(t, r) && fN(e, r, t[r]);
          if (fI) for (var r of fI(t)) fk.call(t, r) && fN(e, r, t[r]);
          return e;
        },
        fO = (e, t) => fA(e, f_(t));
      function fP(e, t, r) {
        var i;
        let n = sy(e);
        return (
          (null == (i = t.rpcMap) ? void 0 : i[n.reference]) ||
          `${fs}?chainId=${n.namespace}:${n.reference}&projectId=${r}`
        );
      }
      function fR(e) {
        return e.includes(":") ? e.split(":")[1] : e;
      }
      function f$(e) {
        return e.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
      }
      function fD(e) {
        return Object.fromEntries(
          Object.entries(e).filter(([e, t]) => {
            var r, i;
            return (
              (null == (r = t?.chains) ? void 0 : r.length) &&
              (null == (i = t?.chains) ? void 0 : i.length) > 0
            );
          })
        );
      }
      function fU(e = {}, t = {}) {
        return (function (e, ...t) {
          return (function (e, ...t) {
            let r = t.slice(0, -1),
              i = t[t.length - 1],
              n = e;
            for (let e = 0; e < r.length; e++)
              n = (function e(t, r, i, n) {
                if (
                  (fl(t) && (t = Object(t)), null == r || "object" != typeof r)
                )
                  return t;
                if (n.has(r))
                  return (function (e) {
                    if (fl(e)) return e;
                    if (
                      Array.isArray(e) ||
                      fm(e) ||
                      e instanceof ArrayBuffer ||
                      ("u" > typeof SharedArrayBuffer &&
                        e instanceof SharedArrayBuffer)
                    )
                      return e.slice(0);
                    let t = Object.getPrototypeOf(e),
                      r = t.constructor;
                    if (
                      e instanceof Date ||
                      e instanceof Map ||
                      e instanceof Set
                    )
                      return new r(e);
                    if (e instanceof RegExp) {
                      let t = new r(e);
                      return (t.lastIndex = e.lastIndex), t;
                    }
                    if (e instanceof DataView) return new r(e.buffer.slice(0));
                    if (e instanceof Error) {
                      let t = new r(e.message);
                      return (
                        (t.stack = e.stack),
                        (t.name = e.name),
                        (t.cause = e.cause),
                        t
                      );
                    }
                    return "u" > typeof File && e instanceof File
                      ? new r([e], e.name, {
                          type: e.type,
                          lastModified: e.lastModified,
                        })
                      : "object" == typeof e
                      ? Object.assign(Object.create(t), e)
                      : e;
                  })(n.get(r));
                if ((n.set(r, t), Array.isArray(r))) {
                  r = r.slice();
                  for (let e = 0; e < r.length; e++) r[e] = r[e] ?? void 0;
                }
                let s = [...Object.keys(r), ...fd(r)];
                for (let a = 0; a < s.length; a++) {
                  let o = s[a],
                    c = r[o],
                    l = t[o];
                  if (
                    (fv(c) && (c = { ...c }),
                    fv(l) && (l = { ...l }),
                    "u" > typeof fr && fr.isBuffer(c) && (c = fb(c)),
                    Array.isArray(c))
                  )
                    if ("object" == typeof l && null != l) {
                      let e = [],
                        t = Reflect.ownKeys(l);
                      for (let r = 0; r < t.length; r++) {
                        let i = t[r];
                        e[i] = l[i];
                      }
                      l = e;
                    } else l = [];
                  let d = i(l, c, o, t, r, n);
                  null != d
                    ? (t[o] = d)
                    : Array.isArray(c) || (fC(l) && fC(c))
                    ? (t[o] = e(l, c, i, n))
                    : null == l &&
                      (function (e) {
                        if ("object" != typeof e || null == e) return !1;
                        if (null === Object.getPrototypeOf(e)) return !0;
                        if (
                          "[object Object]" !==
                          Object.prototype.toString.call(e)
                        ) {
                          let t = e[Symbol.toStringTag];
                          return (
                            null != t &&
                            !!Object.getOwnPropertyDescriptor(
                              e,
                              Symbol.toStringTag
                            )?.writable &&
                            e.toString() === `[object ${t}]`
                          );
                        }
                        let t = e;
                        for (; null !== Object.getPrototypeOf(t); )
                          t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t;
                      })(c)
                    ? (t[o] = e({}, c, i, n))
                    : null == l && fm(c)
                    ? (t[o] = fb(c))
                    : (void 0 === l || void 0 !== c) && (t[o] = c);
                }
                return t;
              })(n, r[e], i, new Map());
            return n;
          })(e, ...t, fE);
        })(fD(fM(e)), fD(fM(t)));
      }
      function fM(e) {
        var t, r, i, n, s;
        let a = {};
        if (!l1(e)) return a;
        for (let [o, c] of Object.entries(e)) {
          let e = lV(o) ? [o] : c.chains,
            l = c.methods || [],
            d = c.events || [],
            h = c.rpcMap || {},
            u = lZ(o);
          (a[u] = fO(fT(fT({}, a[u]), c), {
            chains: sV(e, null == (t = a[u]) ? void 0 : t.chains),
            methods: sV(l, null == (r = a[u]) ? void 0 : r.methods),
            events: sV(d, null == (i = a[u]) ? void 0 : i.events),
          })),
            (l1(h) || l1((null == (n = a[u]) ? void 0 : n.rpcMap) || {})) &&
              (a[u].rpcMap = fT(
                fT({}, h),
                null == (s = a[u]) ? void 0 : s.rpcMap
              ));
        }
        return a;
      }
      function fL(e) {
        return e.includes(":") ? e.split(":")[2] : e;
      }
      function fB(e) {
        let t = {};
        for (let [r, i] of Object.entries(e)) {
          let e = i.methods || [],
            n = i.events || [],
            s = i.accounts || [],
            a = lV(r) ? [r] : i.chains ? i.chains : f$(i.accounts);
          t[r] = { chains: a, methods: e, events: n, accounts: s };
        }
        return t;
      }
      function fW(e) {
        return "number" == typeof e
          ? e
          : e.includes("0x")
          ? parseInt(e, 16)
          : isNaN(Number((e = e.includes(":") ? e.split(":")[1] : e)))
          ? e
          : Number(e);
      }
      let fj = {},
        fF = (e) => fj[e],
        fH = (e, t) => {
          fj[e] = t;
        };
      var fq = Object.defineProperty,
        fz = Object.getOwnPropertySymbols,
        fV = Object.prototype.hasOwnProperty,
        fZ = Object.prototype.propertyIsEnumerable,
        fK = (e, t, r) =>
          t in e
            ? fq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        fG = (e, t) => {
          for (var r in t || (t = {})) fV.call(t, r) && fK(e, r, t[r]);
          if (fz) for (var r of fz(t)) fZ.call(t, r) && fK(e, r, t[r]);
          return e;
        };
      let fJ = "eip155",
        fY = [
          "atomic",
          "flow-control",
          "paymasterService",
          "sessionKeys",
          "auxiliaryFunds",
        ],
        fX = (e) => (e && e.startsWith("0x") ? BigInt(e).toString(10) : e),
        fQ = (e) =>
          e && e.startsWith("0x") ? e : `0x${BigInt(e).toString(16)}`,
        f0 = (e) =>
          Object.keys(e)
            .filter((e) => fY.includes(e))
            .reduce((t, r) => ((t[r] = e[r]), t), {});
      var f1 = Object.defineProperty,
        f2 = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? f1(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class f3 {
        constructor(e) {
          f2(this, "name", "polkadot"),
            f2(this, "client"),
            f2(this, "httpProviders"),
            f2(this, "events"),
            f2(this, "namespace"),
            f2(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = fR(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var f5 = Object.defineProperty,
        f4 = Object.defineProperties,
        f6 = Object.getOwnPropertyDescriptors,
        f8 = Object.getOwnPropertySymbols,
        f9 = Object.prototype.hasOwnProperty,
        f7 = Object.prototype.propertyIsEnumerable,
        ge = (e, t, r) =>
          t in e
            ? f5(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        gt = (e, t) => {
          for (var r in t || (t = {})) f9.call(t, r) && ge(e, r, t[r]);
          if (f8) for (var r of f8(t)) f7.call(t, r) && ge(e, r, t[r]);
          return e;
        },
        gr = (e, t) => f4(e, f6(t)),
        gi = (e, t, r) => ge(e, "symbol" != typeof t ? t + "" : t, r);
      class gn {
        constructor(e) {
          gi(this, "name", "eip155"),
            gi(this, "client"),
            gi(this, "chainId"),
            gi(this, "namespace"),
            gi(this, "httpProviders"),
            gi(this, "events"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.httpProviders = this.createHttpProviders()),
            (this.chainId = parseInt(this.getDefaultChain()));
        }
        async request(e) {
          switch (e.request.method) {
            case "eth_requestAccounts":
            case "eth_accounts":
              return this.getAccounts();
            case "wallet_switchEthereumChain":
              return await this.handleSwitchChain(e);
            case "eth_chainId":
              return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
              return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
              return await this.getCallStatus(e);
          }
          return this.namespace.methods.includes(e.request.method)
            ? await this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
            (this.chainId = parseInt(e)),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId.toString();
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        createHttpProvider(e, t) {
          let r =
            t ||
            fP(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = parseInt(fR(t));
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        getHttpProvider() {
          let e = this.chainId,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        async handleSwitchChain(e) {
          var t, r;
          let i = e.request.params
              ? null == (t = e.request.params[0])
                ? void 0
                : t.chainId
              : "0x0",
            n = parseInt((i = i.startsWith("0x") ? i : `0x${i}`), 16);
          if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);
          else if (
            this.namespace.methods.includes("wallet_switchEthereumChain")
          )
            await this.client.request({
              topic: e.topic,
              request: { method: e.request.method, params: [{ chainId: i }] },
              chainId: null == (r = this.namespace.chains) ? void 0 : r[0],
            }),
              this.setDefaultChain(`${n}`);
          else
            throw Error(
              `Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
            );
          return null;
        }
        isChainApproved(e) {
          return this.namespace.chains.includes(`${this.name}:${e}`);
        }
        async getCapabilities(e) {
          var t, r, i, n, s;
          let a,
            o =
              null == (r = null == (t = e.request) ? void 0 : t.params)
                ? void 0
                : r[0],
            c =
              (null == (n = null == (i = e.request) ? void 0 : i.params)
                ? void 0
                : n[1]) || [];
          if (!o)
            throw Error(
              "Missing address parameter in `wallet_getCapabilities` request"
            );
          let l = this.client.session.get(e.topic),
            d =
              (null == (s = l?.sessionProperties) ? void 0 : s.capabilities) ||
              {},
            h = `${o}${c.join(",")}`,
            u = d?.[h];
          if (u) return u;
          try {
            a = ((e, t, r) => {
              let { sessionProperties: i = {}, scopedProperties: n = {} } = e,
                s = {};
              if (!l1(n) && !l1(i)) return;
              let a = f0(i);
              for (let e of r) {
                let r = fX(e);
                if (!r) continue;
                s[fQ(r)] = a;
                let i = n?.[`${fJ}:${r}`];
                if (i) {
                  let e = i?.[`${fJ}:${r}:${t}`];
                  s[fQ(r)] = fG(fG({}, s[fQ(r)]), f0(e || i));
                }
              }
              for (let [e, t] of Object.entries(s))
                0 === Object.keys(t).length && delete s[e];
              return Object.keys(s).length > 0 ? s : void 0;
            })(l, o, c);
          } catch (e) {
            console.warn("Failed to extract capabilities from session", e);
          }
          if (a) return a;
          let p = await this.client.request(e);
          try {
            await this.client.session.update(e.topic, {
              sessionProperties: gr(gt({}, l.sessionProperties || {}), {
                capabilities: gr(gt({}, d || {}), { [h]: p }),
              }),
            });
          } catch (e) {
            console.warn("Failed to update session with capabilities", e);
          }
          return p;
        }
        async getCallStatus(e) {
          var t, r;
          let i = this.client.session.get(e.topic),
            n = null == (t = i.sessionProperties) ? void 0 : t.bundler_name;
          if (n) {
            let t = this.getBundlerUrl(e.chainId, n);
            try {
              return await this.getUserOperationReceipt(t, e);
            } catch (e) {
              console.warn("Failed to fetch call status from bundler", e, t);
            }
          }
          let s = null == (r = i.sessionProperties) ? void 0 : r.bundler_url;
          if (s)
            try {
              return await this.getUserOperationReceipt(s, e);
            } catch (e) {
              console.warn(
                "Failed to fetch call status from custom bundler",
                e,
                s
              );
            }
          if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
          throw Error("Fetching call status not approved by the wallet.");
        }
        async getUserOperationReceipt(e, t) {
          var r;
          let i = new URL(e),
            n = await fetch(i, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(
                db("eth_getUserOperationReceipt", [
                  null == (r = t.request.params) ? void 0 : r[0],
                ])
              ),
            });
          if (!n.ok)
            throw Error(`Failed to fetch user operation receipt - ${n.status}`);
          return await n.json();
        }
        getBundlerUrl(e, t) {
          return `${fo}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
        }
      }
      var gs = Object.defineProperty,
        ga = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gs(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class go {
        constructor(e) {
          ga(this, "name", "solana"),
            ga(this, "client"),
            ga(this, "httpProviders"),
            ga(this, "events"),
            ga(this, "namespace"),
            ga(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = fR(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gc = Object.defineProperty,
        gl = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gc(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gd {
        constructor(e) {
          gl(this, "name", "cosmos"),
            gl(this, "client"),
            gl(this, "httpProviders"),
            gl(this, "events"),
            gl(this, "namespace"),
            gl(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              fc.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = fR(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gh = Object.defineProperty,
        gu = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gh(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gp {
        constructor(e) {
          gu(this, "name", "algorand"),
            gu(this, "client"),
            gu(this, "httpProviders"),
            gu(this, "events"),
            gu(this, "namespace"),
            gu(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (!this.httpProviders[e]) {
            let r =
              t ||
              fP(
                `${this.name}:${e}`,
                this.namespace,
                this.client.core.projectId
              );
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          (this.chainId = e),
            this.events.emit(
              fc.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          return typeof r > "u"
            ? void 0
            : new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gf = Object.defineProperty,
        gg = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gf(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gm {
        constructor(e) {
          gg(this, "name", "cip34"),
            gg(this, "client"),
            gg(this, "httpProviders"),
            gg(this, "events"),
            gg(this, "namespace"),
            gg(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              fc.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              let r = this.getCardanoRPCUrl(t),
                i = fR(t);
              e[i] = this.createHttpProvider(i, r);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        getCardanoRPCUrl(e) {
          let t = this.namespace.rpcMap;
          if (t) return t[e];
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || this.getCardanoRPCUrl(e);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gy = Object.defineProperty,
        gw = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gy(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gb {
        constructor(e) {
          gw(this, "name", "elrond"),
            gw(this, "client"),
            gw(this, "httpProviders"),
            gw(this, "events"),
            gw(this, "namespace"),
            gw(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = fR(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gv = Object.defineProperty,
        gC = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gv(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gE {
        constructor(e) {
          gC(this, "name", "multiversx"),
            gC(this, "client"),
            gC(this, "httpProviders"),
            gC(this, "events"),
            gC(this, "namespace"),
            gC(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = fR(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gx = Object.defineProperty,
        gA = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gx(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class g_ {
        constructor(e) {
          gA(this, "name", "near"),
            gA(this, "client"),
            gA(this, "httpProviders"),
            gA(this, "events"),
            gA(this, "namespace"),
            gA(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || fP(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            fc.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace);
          return typeof r > "u"
            ? void 0
            : new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gI = Object.defineProperty,
        gS = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gI(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gk {
        constructor(e) {
          gS(this, "name", "tezos"),
            gS(this, "client"),
            gS(this, "httpProviders"),
            gS(this, "events"),
            gS(this, "namespace"),
            gS(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || fP(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            fc.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              e[t] = this.createHttpProvider(t);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace);
          return typeof r > "u" ? void 0 : new dR(new ft(r));
        }
      }
      var gN = Object.defineProperty,
        gT = (e, t, r) =>
          ((e, t, r) =>
            t in e
              ? gN(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r))(e, "symbol" != typeof t ? t + "" : t, r);
      class gO {
        constructor(e) {
          gT(this, "name", fa),
            gT(this, "client"),
            gT(this, "httpProviders"),
            gT(this, "events"),
            gT(this, "namespace"),
            gT(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = fF("events")),
            (this.client = fF("client")),
            (this.chainId = this.getDefaultChain()),
            (this.name = this.getNamespaceName()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          (this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || [])),
          ]),
            (this.namespace.accounts = [
              ...new Set(
                (this.namespace.accounts || []).concat(e.accounts || [])
              ),
            ]),
            (this.namespace.methods = [
              ...new Set(
                (this.namespace.methods || []).concat(e.methods || [])
              ),
            ]),
            (this.namespace.events = [
              ...new Set((this.namespace.events || []).concat(e.events || [])),
            ]),
            (this.httpProviders = this.createHttpProviders());
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider(e.chainId).request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(fc.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getNamespaceName() {
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return sy(e).namespace;
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          var e, t;
          let r = {};
          return (
            null == (t = null == (e = this.namespace) ? void 0 : e.accounts) ||
              t.forEach((e) => {
                r[sy(e).reference] = this.createHttpProvider(e);
              }),
            r
          );
        }
        getHttpProvider(e) {
          let t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || fP(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new dR(new ft(r, fF("disableProviderPing")));
        }
      }
      var gP = Object.defineProperty,
        gR = Object.defineProperties,
        g$ = Object.getOwnPropertyDescriptors,
        gD = Object.getOwnPropertySymbols,
        gU = Object.prototype.hasOwnProperty,
        gM = Object.prototype.propertyIsEnumerable,
        gL = (e, t, r) =>
          t in e
            ? gP(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        gB = (e, t) => {
          for (var r in t || (t = {})) gU.call(t, r) && gL(e, r, t[r]);
          if (gD) for (var r of gD(t)) gM.call(t, r) && gL(e, r, t[r]);
          return e;
        },
        gW = (e, t) => gR(e, g$(t)),
        gj = (e, t, r) => gL(e, "symbol" != typeof t ? t + "" : t, r);
      class gF {
        constructor(e) {
          gj(this, "client"),
            gj(this, "namespaces"),
            gj(this, "optionalNamespaces"),
            gj(this, "sessionProperties"),
            gj(this, "scopedProperties"),
            gj(this, "events", new (b())()),
            gj(this, "rpcProviders", {}),
            gj(this, "session"),
            gj(this, "providerOpts"),
            gj(this, "logger"),
            gj(this, "uri"),
            gj(this, "disableProviderPing", !1),
            (this.providerOpts = e),
            (this.logger =
              "u" > typeof e?.logger && "string" != typeof e?.logger
                ? e.logger
                : (0, G.h6)((0, G.iP)({ level: e?.logger || fi }))),
            (this.disableProviderPing = e?.disableProviderPing || !1);
        }
        static async init(e) {
          let t = new gF(e);
          return await t.initialize(), t;
        }
        async request(e, t, r) {
          let [i, n] = this.validateChain(t);
          if (!this.session)
            throw Error("Please call connect() before request()");
          return await this.getProvider(i).request({
            request: gB({}, e),
            chainId: `${i}:${n}`,
            topic: this.session.topic,
            expiry: r,
          });
        }
        sendAsync(e, t, r, i) {
          let n = new Date().getTime();
          this.request(e, r, i)
            .then((e) => t(null, dv(n, e)))
            .catch((e) => t(e, void 0));
        }
        async enable() {
          if (!this.client) throw Error("Sign Client not initialized");
          return (
            this.session ||
              (await this.connect({
                namespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties,
                scopedProperties: this.scopedProperties,
              })),
            await this.requestAccounts()
          );
        }
        async disconnect() {
          var e;
          if (!this.session)
            throw Error("Please call connect() before enable()");
          await this.client.disconnect({
            topic: null == (e = this.session) ? void 0 : e.topic,
            reason: lQ("USER_DISCONNECTED"),
          }),
            await this.cleanup();
        }
        async connect(e) {
          if (!this.client) throw Error("Sign Client not initialized");
          if (
            (this.setNamespaces(e),
            this.cleanupPendingPairings(),
            !e.skipPairing)
          )
            return await this.pair(e.pairingTopic);
        }
        async authenticate(e, t) {
          if (!this.client) throw Error("Sign Client not initialized");
          this.setNamespaces(e), await this.cleanupPendingPairings();
          let { uri: r, response: i } = await this.client.authenticate(e, t);
          r && ((this.uri = r), this.events.emit("display_uri", r));
          let n = await i();
          if (((this.session = n.session), this.session)) {
            let e = fB(this.session.namespaces);
            (this.namespaces = fU(this.namespaces, e)),
              await this.persist("namespaces", this.namespaces),
              this.onConnect();
          }
          return n;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        get isWalletConnect() {
          return !0;
        }
        async pair(e) {
          let { uri: t, approval: r } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          });
          t && ((this.uri = t), this.events.emit("display_uri", t));
          let i = await r();
          this.session = i;
          let n = fB(i.namespaces);
          return (
            (this.namespaces = fU(this.namespaces, n)),
            await this.persist("namespaces", this.namespaces),
            await this.persist("optionalNamespaces", this.optionalNamespaces),
            this.onConnect(),
            this.session
          );
        }
        setDefaultChain(e, t) {
          try {
            if (!this.session) return;
            let [r, i] = this.validateChain(e);
            this.getProvider(r).setDefaultChain(i, t);
          } catch (e) {
            if (!/Please call connect/.test(e.message)) throw e;
          }
        }
        async cleanupPendingPairings(e = {}) {
          try {
            this.logger.info("Cleaning up inactive pairings...");
            let t = this.client.pairing.getAll();
            if (!l0(t)) return;
            for (let r of t)
              e.deletePairings
                ? this.client.core.expirer.set(r.topic, 0)
                : await this.client.core.relayer.subscriber.unsubscribe(
                    r.topic
                  );
            this.logger.info(`Inactive pairings cleared: ${t.length}`);
          } catch (e) {
            this.logger.warn("Failed to cleanup pending pairings", e);
          }
        }
        abortPairingAttempt() {
          this.logger.warn(
            "abortPairingAttempt is deprecated. This is now a no-op."
          );
        }
        async checkStorage() {
          (this.namespaces = (await this.getFromStore("namespaces")) || {}),
            (this.optionalNamespaces =
              (await this.getFromStore("optionalNamespaces")) || {}),
            this.session && this.createProviders();
        }
        async initialize() {
          this.logger.trace("Initialized"),
            await this.createClient(),
            await this.checkStorage(),
            this.registerEventListeners();
        }
        async createClient() {
          var e, t;
          if (
            ((this.client =
              this.providerOpts.client ||
              (await pX.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || fi,
                relayUrl:
                  this.providerOpts.relayUrl || "wss://relay.walletconnect.org",
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled,
              }))),
            this.providerOpts.session)
          )
            try {
              this.session = this.client.session.get(
                this.providerOpts.session.topic
              );
            } catch (r) {
              throw (
                (this.logger.error("Failed to get session", r),
                Error(
                  `The provided session: ${
                    null ==
                    (t = null == (e = this.providerOpts) ? void 0 : e.session)
                      ? void 0
                      : t.topic
                  } doesn't exist in the Sign client`
                ))
              );
            }
          else {
            let e = this.client.session.getAll();
            this.session = e[0];
          }
          this.logger.trace("SignClient Initialized");
        }
        createProviders() {
          if (!this.client) throw Error("Sign Client not initialized");
          if (!this.session)
            throw Error(
              "Session not initialized. Please call connect() before enable()"
            );
          let e = [
            ...new Set(Object.keys(this.session.namespaces).map((e) => lZ(e))),
          ];
          fH("client", this.client),
            fH("events", this.events),
            fH("disableProviderPing", this.disableProviderPing),
            e.forEach((e) => {
              if (!this.session) return;
              let t = (function (e, t) {
                let r = Object.keys(t.namespaces).filter((t) => t.includes(e));
                if (!r.length) return [];
                let i = [];
                return (
                  r.forEach((e) => {
                    let r = t.namespaces[e].accounts;
                    i.push(...r);
                  }),
                  i
                );
              })(e, this.session);
              if (t?.length === 0) return;
              let r = f$(t),
                i = gW(
                  gB({}, fU(this.namespaces, this.optionalNamespaces)[e]),
                  { accounts: t, chains: r }
                );
              switch (e) {
                case "eip155":
                  this.rpcProviders[e] = new gn({ namespace: i });
                  break;
                case "algorand":
                  this.rpcProviders[e] = new gp({ namespace: i });
                  break;
                case "solana":
                  this.rpcProviders[e] = new go({ namespace: i });
                  break;
                case "cosmos":
                  this.rpcProviders[e] = new gd({ namespace: i });
                  break;
                case "polkadot":
                  this.rpcProviders[e] = new f3({ namespace: i });
                  break;
                case "cip34":
                  this.rpcProviders[e] = new gm({ namespace: i });
                  break;
                case "elrond":
                  this.rpcProviders[e] = new gb({ namespace: i });
                  break;
                case "multiversx":
                  this.rpcProviders[e] = new gE({ namespace: i });
                  break;
                case "near":
                  this.rpcProviders[e] = new g_({ namespace: i });
                  break;
                case "tezos":
                  this.rpcProviders[e] = new gk({ namespace: i });
                  break;
                default:
                  this.rpcProviders[e] = new gO({ namespace: i });
              }
            });
        }
        registerEventListeners() {
          if (typeof this.client > "u")
            throw Error("Sign Client is not initialized");
          this.client.on("session_ping", (e) => {
            var t;
            let { topic: r } = e;
            r === (null == (t = this.session) ? void 0 : t.topic) &&
              this.events.emit("session_ping", e);
          }),
            this.client.on("session_event", (e) => {
              var t;
              let { params: r, topic: i } = e;
              if (i !== (null == (t = this.session) ? void 0 : t.topic)) return;
              let { event: n } = r;
              if ("accountsChanged" === n.name) {
                let e = n.data;
                e && l0(e) && this.events.emit("accountsChanged", e.map(fL));
              } else if ("chainChanged" === n.name) {
                let e = r.chainId,
                  t = r.event.data,
                  i = lZ(e),
                  n = fW(e) !== fW(t) ? `${i}:${fW(t)}` : e;
                this.onChainChanged(n);
              } else this.events.emit(n.name, n.data);
              this.events.emit("session_event", e);
            }),
            this.client.on("session_update", ({ topic: e, params: t }) => {
              var r, i;
              if (e !== (null == (r = this.session) ? void 0 : r.topic)) return;
              let { namespaces: n } = t,
                s = null == (i = this.client) ? void 0 : i.session.get(e);
              (this.session = gW(gB({}, s), { namespaces: n })),
                this.onSessionUpdate(),
                this.events.emit("session_update", { topic: e, params: t });
            }),
            this.client.on("session_delete", async (e) => {
              var t;
              e.topic === (null == (t = this.session) ? void 0 : t.topic) &&
                (await this.cleanup(),
                this.events.emit("session_delete", e),
                this.events.emit(
                  "disconnect",
                  gW(gB({}, lQ("USER_DISCONNECTED")), { data: e.topic })
                ));
            }),
            this.on(fc.DEFAULT_CHAIN_CHANGED, (e) => {
              this.onChainChanged(e, !0);
            });
        }
        getProvider(e) {
          return this.rpcProviders[e] || this.rpcProviders[fa];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((e) => {
            var t;
            this.getProvider(e).updateNamespace(
              null == (t = this.session) ? void 0 : t.namespaces[e]
            );
          });
        }
        setNamespaces(e) {
          let {
            namespaces: t = {},
            optionalNamespaces: r = {},
            sessionProperties: i,
            scopedProperties: n,
          } = e;
          (this.optionalNamespaces = fU(t, r)),
            (this.sessionProperties = i),
            (this.scopedProperties = n);
        }
        validateChain(e) {
          let [t, r] = e?.split(":") || ["", ""];
          if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [t, r];
          if (
            t &&
            !Object.keys(this.namespaces || {})
              .map((e) => lZ(e))
              .includes(t)
          )
            throw Error(
              `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
            );
          if (t && r) return [t, r];
          let i = lZ(Object.keys(this.namespaces)[0]),
            n = this.rpcProviders[i].getDefaultChain();
          return [i, n];
        }
        async requestAccounts() {
          let [e] = this.validateChain();
          return await this.getProvider(e).requestAccounts();
        }
        async onChainChanged(e, t = !1) {
          if (!this.namespaces) return;
          let [r, i] = this.validateChain(e);
          if (!i) return;
          this.updateNamespaceChain(r, i);
          let n = this.getProvider(r).getDefaultChain();
          t
            ? (this.events.emit("chainChanged", i),
              this.emitAccountsChangedOnChainChange({
                namespace: r,
                previousChainId: n,
                newChainId: e,
              }))
            : this.getProvider(r).setDefaultChain(i),
            await this.persist("namespaces", this.namespaces);
        }
        emitAccountsChangedOnChainChange({
          namespace: e,
          previousChainId: t,
          newChainId: r,
        }) {
          var i, n;
          try {
            if (t === r) return;
            let s =
              null ==
              (n = null == (i = this.session) ? void 0 : i.namespaces[e])
                ? void 0
                : n.accounts;
            if (!s) return;
            let a = s.filter((e) => e.includes(`${r}:`)).map(fL);
            if (!l0(a)) return;
            this.events.emit("accountsChanged", a);
          } catch (e) {
            this.logger.warn(
              "Failed to emit accountsChanged on chain change",
              e
            );
          }
        }
        updateNamespaceChain(e, t) {
          if (!this.namespaces) return;
          let r = this.namespaces[e] ? e : `${e}:${t}`;
          this.namespaces[r]
            ? this.namespaces[r] && (this.namespaces[r].defaultChain = t)
            : (this.namespaces[r] = {
                chains: [],
                methods: [],
                events: [],
                defaultChain: t,
              });
        }
        onConnect() {
          this.createProviders(),
            this.events.emit("connect", { session: this.session });
        }
        async cleanup() {
          (this.namespaces = void 0),
            (this.optionalNamespaces = void 0),
            (this.sessionProperties = void 0),
            await this.deleteFromStore("namespaces"),
            await this.deleteFromStore("optionalNamespaces"),
            await this.deleteFromStore("sessionProperties"),
            (this.session = void 0),
            this.cleanupPendingPairings({ deletePairings: !0 }),
            await this.cleanupStorage();
        }
        async persist(e, t) {
          var r;
          let i = (null == (r = this.session) ? void 0 : r.topic) || "";
          await this.client.core.storage.setItem(`${fn}/${e}${i}`, t);
        }
        async getFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          return await this.client.core.storage.getItem(`${fn}/${e}${r}`);
        }
        async deleteFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          await this.client.core.storage.removeItem(`${fn}/${e}${r}`);
        }
        async cleanupStorage() {
          var e;
          try {
            if ((null == (e = this.client) ? void 0 : e.session.length) > 0)
              return;
            for (let e of await this.client.core.storage.getKeys())
              e.startsWith(fn) &&
                (await this.client.core.storage.removeItem(e));
          } catch (e) {
            this.logger.warn("Failed to cleanup storage", e);
          }
        }
      }
    },
    59350: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (e, t, r) =>
        JSON.stringify(
          e,
          (e, r) => {
            let i = "bigint" == typeof r ? r.toString() : r;
            return "function" == typeof t ? t(e, i) : i;
          },
          r
        );
    },
    60587: (e, t, r) => {
      "use strict";
      function i(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      r.d(t, { q: () => i });
    },
    60869: (e, t, r) => {
      "use strict";
      r.d(t, { sc: () => d });
      var i = r(890);
      class n extends i.Vw {
        constructor(e, t, r, n) {
          super(),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = n),
            (this.buffer = new Uint8Array(e)),
            (this.view = (0, i.O8)(this.buffer));
        }
        update(e) {
          (0, i.CC)(this), (e = (0, i.ZJ)(e)), (0, i.DO)(e);
          let { view: t, buffer: r, blockLen: n } = this,
            s = e.length;
          for (let a = 0; a < s; ) {
            let o = Math.min(n - this.pos, s - a);
            if (o === n) {
              let t = (0, i.O8)(e);
              for (; n <= s - a; a += n) this.process(t, a);
              continue;
            }
            r.set(e.subarray(a, a + o), this.pos),
              (this.pos += o),
              (a += o),
              this.pos === n && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          (0, i.CC)(this), (0, i.Ht)(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: n, isLE: s } = this,
            { pos: a } = this;
          (t[a++] = 128),
            (0, i.uH)(this.buffer.subarray(a)),
            this.padOffset > n - a && (this.process(r, 0), (a = 0));
          for (let e = a; e < n; e++) t[e] = 0;
          !(function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(0xffffffff),
              a = Number((r >> n) & s),
              o = Number(r & s),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, n - 8, BigInt(8 * this.length), s),
            this.process(r, 0);
          let o = (0, i.O8)(e),
            c = this.outputLen;
          if (c % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let l = c / 4,
            d = this.get();
          if (l > d.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < l; e++) o.setUint32(4 * e, d[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.destroyed = s),
            (e.finished = n),
            (e.length = i),
            (e.pos = a),
            i % t && e.buffer.set(r),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
      }
      let s = Uint32Array.from([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c,
        0x1f83d9ab, 0x5be0cd19,
      ]);
      var a = r(20413);
      let o = Uint32Array.from([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        c = new Uint32Array(64);
      class l extends n {
        constructor(e = 32) {
          super(64, e, 8, !1),
            (this.A = 0 | s[0]),
            (this.B = 0 | s[1]),
            (this.C = 0 | s[2]),
            (this.D = 0 | s[3]),
            (this.E = 0 | s[4]),
            (this.F = 0 | s[5]),
            (this.G = 0 | s[6]),
            (this.H = 0 | s[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: n, F: s, G: a, H: o } = this;
          return [e, t, r, i, n, s, a, o];
        }
        set(e, t, r, i, n, s, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | n),
            (this.F = 0 | s),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = c[e - 15],
              r = c[e - 2],
              n = (0, i.Ow)(t, 7) ^ (0, i.Ow)(t, 18) ^ (t >>> 3),
              s = (0, i.Ow)(r, 17) ^ (0, i.Ow)(r, 19) ^ (r >>> 10);
            c[e] = (s + c[e - 7] + n + c[e - 16]) | 0;
          }
          let { A: r, B: n, C: s, D: a, E: l, F: d, G: h, H: u } = this;
          for (let e = 0; e < 64; e++) {
            var p, f, g, m;
            let t =
                (u +
                  ((0, i.Ow)(l, 6) ^ (0, i.Ow)(l, 11) ^ (0, i.Ow)(l, 25)) +
                  (((p = l) & d) ^ (~p & h)) +
                  o[e] +
                  c[e]) |
                0,
              y =
                (((0, i.Ow)(r, 2) ^ (0, i.Ow)(r, 13) ^ (0, i.Ow)(r, 22)) +
                  (((f = r) & (g = n)) ^ (f & (m = s)) ^ (g & m))) |
                0;
            (u = h),
              (h = d),
              (d = l),
              (l = (a + t) | 0),
              (a = s),
              (s = n),
              (n = r),
              (r = (t + y) | 0);
          }
          (r = (r + this.A) | 0),
            (n = (n + this.B) | 0),
            (s = (s + this.C) | 0),
            (a = (a + this.D) | 0),
            (l = (l + this.E) | 0),
            (d = (d + this.F) | 0),
            (h = (h + this.G) | 0),
            (u = (u + this.H) | 0),
            this.set(r, n, s, a, l, d, h, u);
        }
        roundClean() {
          (0, i.uH)(c);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, i.uH)(this.buffer);
        }
      }
      a.lD(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((e) => BigInt(e))
      );
      let d = (0, i.qj)(() => new l());
    },
    61896: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(4959),
        a = r(67869),
        o = r(81701),
        c = r(36211);
      let l = (0, i.AH)`
  :host {
    width: 100%;
    display: block;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.text = ""),
            (this.open = s.I.state.open),
            this.unsubscribe.push(
              a.I.subscribeKey("view", () => {
                s.I.hide();
              }),
              o.W.subscribeKey("open", (e) => {
                e || s.I.hide();
              }),
              s.I.subscribeKey("open", (e) => {
                this.open = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e()), s.I.hide();
        }
        render() {
          return (0, i.qy)`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
        }
        renderChildren() {
          return (0, i.qy)`<slot></slot> `;
        }
        onMouseEnter() {
          let e = this.getBoundingClientRect();
          if (!this.open) {
            let t = document.querySelector("w3m-modal"),
              r = {
                width: e.width,
                height: e.height,
                left: e.left,
                top: e.top,
              };
            if (t) {
              let i = t.getBoundingClientRect();
              (r.left = e.left - (window.innerWidth - i.width) / 2),
                (r.top = e.top - (window.innerHeight - i.height) / 2);
            }
            s.I.showTooltip({
              message: this.text,
              triggerRect: r,
              variant: "shade",
            });
          }
        }
        onMouseLeave(e) {
          this.contains(e.relatedTarget) || s.I.hide();
        }
      };
      (h.styles = [l]),
        d([(0, n.MZ)()], h.prototype, "text", void 0),
        d([(0, n.wk)()], h.prototype, "open", void 0),
        (h = d([(0, c.EM)("w3m-tooltip-trigger")], h));
    },
    61936: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => s, R: () => a });
      var i = r(50707),
        n = r(15885);
      function s(e) {
        let t = (e.transactions ?? []).map((e) =>
          "string" == typeof e ? e : (0, n.uP)(e)
        );
        return {
          ...e,
          baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
          blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
          difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
          excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
          gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
          gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
          hash: e.hash ? e.hash : null,
          logsBloom: e.logsBloom ? e.logsBloom : null,
          nonce: e.nonce ? e.nonce : null,
          number: e.number ? BigInt(e.number) : null,
          size: e.size ? BigInt(e.size) : void 0,
          timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
          transactions: t,
          totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null,
        };
      }
      let a = (0, i.q)("block", s);
    },
    62023: (e, t, r) => {
      "use strict";
      r.d(t, { eL: () => i, pj: () => s, sz: () => n });
      let i = { gwei: 9, wei: 18 },
        n = { ether: -9, wei: 9 },
        s = { ether: -18, gwei: -9 };
    },
    62497: (e) => {
      "use strict";
      e.exports = function (e) {
        for (var t = [], r = e.length, i = 0; i < r; i++) {
          var n = e.charCodeAt(i);
          if (n >= 55296 && n <= 56319 && r > i + 1) {
            var s = e.charCodeAt(i + 1);
            s >= 56320 &&
              s <= 57343 &&
              ((n = (n - 55296) * 1024 + s - 56320 + 65536), (i += 1));
          }
          if (n < 128) {
            t.push(n);
            continue;
          }
          if (n < 2048) {
            t.push((n >> 6) | 192), t.push((63 & n) | 128);
            continue;
          }
          if (n < 55296 || (n >= 57344 && n < 65536)) {
            t.push((n >> 12) | 224),
              t.push(((n >> 6) & 63) | 128),
              t.push((63 & n) | 128);
            continue;
          }
          if (n >= 65536 && n <= 1114111) {
            t.push((n >> 18) | 240),
              t.push(((n >> 12) & 63) | 128),
              t.push(((n >> 6) & 63) | 128),
              t.push((63 & n) | 128);
            continue;
          }
          t.push(239, 191, 189);
        }
        return new Uint8Array(t).buffer;
      };
    },
    62546: (e) => {
      function t(e) {
        if (!e || e < 1)
          throw Error("BitMatrix size must be defined and greater than 0");
        (this.size = e),
          (this.data = new Uint8Array(e * e)),
          (this.reservedBit = new Uint8Array(e * e));
      }
      (t.prototype.set = function (e, t, r, i) {
        let n = e * this.size + t;
        (this.data[n] = r), i && (this.reservedBit[n] = !0);
      }),
        (t.prototype.get = function (e, t) {
          return this.data[e * this.size + t];
        }),
        (t.prototype.xor = function (e, t, r) {
          this.data[e * this.size + t] ^= r;
        }),
        (t.prototype.isReserved = function (e, t) {
          return this.reservedBit[e * this.size + t];
        }),
        (e.exports = t);
    },
    62609: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => f });
      var i = r(1220),
        n = r(98866);
      let s = {
        convertEVMChainIdToCoinType(e) {
          if (e >= 0x80000000) throw Error("Invalid chainId");
          return (0x80000000 | e) >>> 0;
        },
      };
      var a = r(58653),
        o = r(36964),
        c = r(44826),
        l = r(93481),
        d = r(97418),
        h = r(10899),
        u = r(67869);
      let p = (0, i.BX)({ suggestions: [], loading: !1 }),
        f = (0, o.X)({
          state: p,
          subscribe: (e) => (0, i.B1)(p, () => e(p)),
          subscribeKey: (e, t) => (0, n.u$)(p, e, t),
          async resolveName(e) {
            try {
              return await c.T.lookupEnsName(e);
            } catch (e) {
              throw Error(
                e?.reasons?.[0]?.description || "Error resolving name"
              );
            }
          },
          async isNameRegistered(e) {
            try {
              return await c.T.lookupEnsName(e), !0;
            } catch {
              return !1;
            }
          },
          async getSuggestions(e) {
            try {
              return (
                (p.loading = !0),
                (p.suggestions = []),
                (p.suggestions =
                  (await c.T.getEnsNameSuggestions(e)).suggestions || []),
                p.suggestions
              );
            } catch (e) {
              throw Error(
                f.parseEnsApiError(e, "Error fetching name suggestions")
              );
            } finally {
              p.loading = !1;
            }
          },
          async getNamesForAddress(e) {
            try {
              if (!l.W.state.activeCaipNetwork) return [];
              let t = a.i.getEnsFromCacheForAddress(e);
              if (t) return t;
              let r = await c.T.reverseLookupEnsName({ address: e });
              return (
                a.i.updateEnsCache({
                  address: e,
                  ens: r,
                  timestamp: Date.now(),
                }),
                r
              );
            } catch (e) {
              throw Error(
                f.parseEnsApiError(e, "Error fetching names for address")
              );
            }
          },
          async registerName(e) {
            let t = l.W.state.activeCaipNetwork,
              r = l.W.getAccountData(t?.chainNamespace)?.address,
              i = h.a.getAuthConnector();
            if (!t) throw Error("Network not found");
            if (!r || !i) throw Error("Address or auth connector not found");
            p.loading = !0;
            try {
              let i = JSON.stringify({
                name: e,
                attributes: {},
                timestamp: Math.floor(Date.now() / 1e3),
              });
              u.I.pushTransactionStack({
                onCancel() {
                  u.I.replace("RegisterAccountName");
                },
              });
              let n = await d.x.signMessage(i);
              p.loading = !1;
              let o = t.id;
              if (!o) throw Error("Network not found");
              let h = s.convertEVMChainIdToCoinType(Number(o));
              await c.T.registerEnsName({
                coinType: h,
                address: r,
                signature: n,
                message: i,
              }),
                l.W.setAccountProp("profileName", e, t.chainNamespace),
                a.i.updateEnsCache({
                  address: r,
                  ens: [
                    {
                      name: e,
                      registered_at: new Date().toISOString(),
                      updated_at: void 0,
                      addresses: {},
                      attributes: [],
                    },
                  ],
                  timestamp: Date.now(),
                }),
                u.I.replace("RegisterAccountNameSuccess");
            } catch (r) {
              let t = f.parseEnsApiError(r, `Error registering name ${e}`);
              throw (u.I.replace("RegisterAccountName"), Error(t));
            } finally {
              p.loading = !1;
            }
          },
          validateName: (e) => /^[a-zA-Z0-9-]{4,}$/u.test(e),
          parseEnsApiError: (e, t) => e?.reasons?.[0]?.description || t,
        });
    },
    63621: (e, t, r) => {
      "use strict";
      r.d(t, { aG: () => m });
      var i = r(1220),
        n = r(98866),
        s = r(45553),
        a = r(28977),
        o = r(36964),
        c = r(72880),
        l = r(44826),
        d = r(93481),
        h = r(55480);
      let u = {
          id: "2b92315d-eab7-5bef-84fa-089a131333f5",
          name: "USD Coin",
          symbol: "USDC",
          networks: [
            {
              name: "ethereum-mainnet",
              display_name: "Ethereum",
              chain_id: "1",
              contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
            },
            {
              name: "polygon-mainnet",
              display_name: "Polygon",
              chain_id: "137",
              contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
            },
          ],
        },
        p = {
          id: "USD",
          payment_method_limits: [
            { id: "card", min: "10.00", max: "7500.00" },
            { id: "ach_bank_account", min: "10.00", max: "25000.00" },
          ],
        },
        f = {
          providers: a.tM,
          selectedProvider: null,
          error: null,
          purchaseCurrency: u,
          paymentCurrency: p,
          purchaseCurrencies: [u],
          paymentCurrencies: [],
          quotesLoading: !1,
        },
        g = (0, i.BX)(f),
        m = (0, o.X)({
          state: g,
          subscribe: (e) => (0, i.B1)(g, () => e(g)),
          subscribeKey: (e, t) => (0, n.u$)(g, e, t),
          setSelectedProvider(e) {
            if (e && "meld" === e.name) {
              let t = d.W.state.activeChain,
                r = t === s.o.CHAIN.SOLANA ? "SOL" : "USDC",
                i = t
                  ? d.W.state.chains.get(t)?.accountState?.address ?? ""
                  : "",
                n = new URL(e.url);
              n.searchParams.append("publicKey", a.Db),
                n.searchParams.append("destinationCurrencyCode", r),
                n.searchParams.append("walletAddress", i),
                n.searchParams.append(
                  "externalCustomerId",
                  h.H.state.projectId
                ),
                (g.selectedProvider = { ...e, url: n.toString() });
            } else g.selectedProvider = e;
          },
          setOnrampProviders(e) {
            Array.isArray(e) && e.every((e) => "string" == typeof e)
              ? (g.providers = a.tM.filter((t) => e.includes(t.name)))
              : (g.providers = []);
          },
          setPurchaseCurrency(e) {
            g.purchaseCurrency = e;
          },
          setPaymentCurrency(e) {
            g.paymentCurrency = e;
          },
          setPurchaseAmount(e) {
            m.state.purchaseAmount = e;
          },
          setPaymentAmount(e) {
            m.state.paymentAmount = e;
          },
          async getAvailableCurrencies() {
            let e = await l.T.getOnrampOptions();
            (g.purchaseCurrencies = e.purchaseCurrencies),
              (g.paymentCurrencies = e.paymentCurrencies),
              (g.paymentCurrency = e.paymentCurrencies[0] || p),
              (g.purchaseCurrency = e.purchaseCurrencies[0] || u),
              await c.N.fetchCurrencyImages(
                e.paymentCurrencies.map((e) => e.id)
              ),
              await c.N.fetchTokenImages(
                e.purchaseCurrencies.map((e) => e.symbol)
              );
          },
          async getQuote() {
            g.quotesLoading = !0;
            try {
              let e = await l.T.getOnrampQuote({
                purchaseCurrency: g.purchaseCurrency,
                paymentCurrency: g.paymentCurrency,
                amount: g.paymentAmount?.toString() || "0",
                network: g.purchaseCurrency?.symbol,
              });
              return (
                (g.quotesLoading = !1),
                (g.purchaseAmount = Number(e?.purchaseAmount.amount)),
                e
              );
            } catch (e) {
              return (g.error = e.message), (g.quotesLoading = !1), null;
            } finally {
              g.quotesLoading = !1;
            }
          },
          resetState() {
            (g.selectedProvider = null),
              (g.error = null),
              (g.purchaseCurrency = u),
              (g.paymentCurrency = p),
              (g.purchaseCurrencies = [u]),
              (g.paymentCurrencies = []),
              (g.paymentAmount = void 0),
              (g.purchaseAmount = void 0),
              (g.quotesLoading = !1);
          },
        });
    },
    64501: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(12182);
      r(99691), r(45166), r(24772), r(38534);
      var a = r(71084),
        o = r(47327),
        c = r(20296);
      let l = (0, c.AH)`
  :host {
    width: 100%;
  }

  button {
    padding: ${({ spacing: e }) => e[3]};
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: ${({ borderRadius: e }) => e[4]};
    background-color: transparent;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    }
  }

  button:focus-visible:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    box-shadow: 0 0 0 4px ${({ tokens: e }) => e.core.foregroundAccent040};
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-image,
  wui-icon {
    width: ${({ spacing: e }) => e[10]};
    height: ${({ spacing: e }) => e[10]};
  }

  wui-image {
    border-radius: ${({ borderRadius: e }) => e[16]};
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.tokenName = ""),
            (this.tokenImageUrl = ""),
            (this.tokenValue = 0),
            (this.tokenAmount = "0.0"),
            (this.tokenCurrency = ""),
            (this.clickable = !1);
        }
        render() {
          return (0, i.qy)`
      <button data-clickable=${String(this.clickable)}>
        <wui-flex gap="2" alignItems="center">
          ${this.visualTemplate()}
          <wui-flex flexDirection="column" justifyContent="space-between" gap="1">
            <wui-text variant="md-regular" color="primary">${
              this.tokenName
            }</wui-text>
            <wui-text variant="sm-regular-mono" color="secondary">
              ${s.S.formatNumberToLocalString(this.tokenAmount, 4)} ${
            this.tokenCurrency
          }
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-flex
          flexDirection="column"
          justifyContent="space-between"
          gap="1"
          alignItems="flex-end"
        >
          <wui-text variant="md-regular-mono" color="primary"
            >$${this.tokenValue.toFixed(2)}</wui-text
          >
          <wui-text variant="sm-regular-mono" color="secondary">
            ${s.S.formatNumberToLocalString(this.tokenAmount, 4)}
          </wui-text>
        </wui-flex>
      </button>
    `;
        }
        visualTemplate() {
          return this.tokenName && this.tokenImageUrl
            ? (0,
              i.qy)`<wui-image alt=${this.tokenName} src=${this.tokenImageUrl}></wui-image>`
            : (0,
              i.qy)`<wui-icon name="coinPlaceholder" color="default"></wui-icon>`;
        }
      };
      (h.styles = [a.W5, a.fD, l]),
        d([(0, n.MZ)()], h.prototype, "tokenName", void 0),
        d([(0, n.MZ)()], h.prototype, "tokenImageUrl", void 0),
        d([(0, n.MZ)({ type: Number })], h.prototype, "tokenValue", void 0),
        d([(0, n.MZ)()], h.prototype, "tokenAmount", void 0),
        d([(0, n.MZ)()], h.prototype, "tokenCurrency", void 0),
        d([(0, n.MZ)({ type: Boolean })], h.prototype, "clickable", void 0),
        (h = d([(0, o.E)("wui-list-token")], h));
    },
    64663: (e, t, r) => {
      "use strict";
      function i() {
        return (
          (null === r.g || void 0 === r.g ? void 0 : r.g.crypto) ||
          (null === r.g || void 0 === r.g ? void 0 : r.g.msCrypto) ||
          {}
        );
      }
      function n() {
        let e = i();
        return e.subtle || e.webkitSubtle;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowserCryptoAvailable =
          t.getSubtleCrypto =
          t.getBrowerCrypto =
            void 0),
        (t.getBrowerCrypto = i),
        (t.getSubtleCrypto = n),
        (t.isBrowserCryptoAvailable = function () {
          return !!i() && !!n();
        });
    },
    64731: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(71084),
        a = r(47327),
        o = r(20296);
      let c = (0, o.AH)`
  :host {
    display: block;
    width: 100px;
    height: 100px;
  }

  svg {
    width: 100px;
    height: 100px;
  }

  rect {
    fill: none;
    stroke: ${(e) => e.colors.accent100};
    stroke-width: 3px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
      var l = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let d = class extends i.WF {
        constructor() {
          super(...arguments), (this.radius = 36);
        }
        render() {
          return this.svgLoaderTemplate();
        }
        svgLoaderTemplate() {
          let e = this.radius > 50 ? 50 : this.radius,
            t = 36 - e;
          return (0, i.qy)`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${e}
          stroke-dasharray="${116 + t} ${245 + t}"
          stroke-dashoffset=${360 + 1.75 * t}
        />
      </svg>
    `;
        }
      };
      (d.styles = [s.W5, c]),
        l([(0, n.MZ)({ type: Number })], d.prototype, "radius", void 0),
        (d = l([(0, a.E)("wui-loading-thumbnail")], d));
    },
    65103: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => i });
      let i = {
        validateCaipAddress(e) {
          if (e.split(":")?.length !== 3) throw Error("Invalid CAIP Address");
          return e;
        },
        parseCaipAddress(e) {
          let t = e.split(":");
          if (3 !== t.length) throw Error(`Invalid CAIP-10 address: ${e}`);
          let [r, i, n] = t;
          if (!r || !i || !n) throw Error(`Invalid CAIP-10 address: ${e}`);
          return { chainNamespace: r, chainId: i, address: n };
        },
        parseCaipNetworkId(e) {
          let t = e.split(":");
          if (2 !== t.length) throw Error(`Invalid CAIP-2 network id: ${e}`);
          let [r, i] = t;
          if (!r || !i) throw Error(`Invalid CAIP-2 network id: ${e}`);
          return { chainNamespace: r, chainId: i };
        },
      };
    },
    65110: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => h });
      var i = r(83138),
        n = r(98410),
        s = r(67869),
        a = r(70417),
        o = r(36211);
      r(65685), r(25784);
      var c = r(21471);
      let l = (0, o.AH)`
  :host {
    display: block;
  }

  div.container {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    height: auto;
    display: block;
  }

  div.container[status='hide'] {
    animation: fade-out;
    animation-duration: var(--apkt-duration-dynamic);
    animation-timing-function: ${({ easings: e }) => e["ease-out-power-2"]};
    animation-fill-mode: both;
    animation-delay: 0s;
  }

  div.container[status='show'] {
    animation: fade-in;
    animation-duration: var(--apkt-duration-dynamic);
    animation-timing-function: ${({ easings: e }) => e["ease-out-power-2"]};
    animation-fill-mode: both;
    animation-delay: var(--apkt-duration-dynamic);
  }

  @keyframes fade-in {
    from {
      opacity: 0;
      filter: blur(6px);
    }
    to {
      opacity: 1;
      filter: blur(0px);
    }
  }

  @keyframes fade-out {
    from {
      opacity: 1;
      filter: blur(0px);
    }
    to {
      opacity: 0;
      filter: blur(6px);
    }
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.resizeObserver = void 0),
            (this.unsubscribe = []),
            (this.status = "hide"),
            (this.view = s.I.state.view);
        }
        firstUpdated() {
          (this.status = c.y.hasFooter() ? "show" : "hide"),
            this.unsubscribe.push(
              s.I.subscribeKey("view", (e) => {
                (this.view = e),
                  (this.status = c.y.hasFooter() ? "show" : "hide"),
                  "hide" === this.status &&
                    document.documentElement.style.setProperty(
                      "--apkt-footer-height",
                      "0px"
                    );
              })
            ),
            (this.resizeObserver = new ResizeObserver((e) => {
              for (let t of e)
                if (t.target === this.getWrapper()) {
                  let e = `${t.contentRect.height}px`;
                  document.documentElement.style.setProperty(
                    "--apkt-footer-height",
                    e
                  );
                }
            })),
            this.resizeObserver.observe(this.getWrapper());
        }
        render() {
          return (0, i.qy)`
      <div class="container" status=${
        this.status
      }>${this.templatePageContainer()}</div>
    `;
        }
        templatePageContainer() {
          return c.y.hasFooter() ? (0, i.qy)` ${this.templateFooter()}` : null;
        }
        templateFooter() {
          switch (this.view) {
            case "Networks":
              return this.templateNetworksFooter();
            case "Connect":
            case "ConnectWallets":
            case "OnRampFiatSelect":
            case "OnRampTokenSelect":
              return (0, i.qy)`<w3m-legal-footer></w3m-legal-footer>`;
            case "OnRampProviders":
              return (0,
              i.qy)`<w3m-onramp-providers-footer></w3m-onramp-providers-footer>`;
            default:
              return null;
          }
        }
        templateNetworksFooter() {
          return (0, i.qy)` <wui-flex
      class="footer-in"
      padding="3"
      flexDirection="column"
      gap="3"
      alignItems="center"
    >
      <wui-text variant="md-regular" color="secondary" align="center">
        Your connected wallet may not support some of the networks available for this dApp
      </wui-text>
      <wui-link @click=${this.onNetworkHelp.bind(this)}>
        <wui-icon size="sm" color="accent-primary" slot="iconLeft" name="helpCircle"></wui-icon>
        What is a network
      </wui-link>
    </wui-flex>`;
        }
        onNetworkHelp() {
          a.E.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" }),
            s.I.push("WhatIsANetwork");
        }
        getWrapper() {
          return this.shadowRoot?.querySelector("div.container");
        }
      };
      (h.styles = [l]),
        d([(0, n.wk)()], h.prototype, "status", void 0),
        d([(0, n.wk)()], h.prototype, "view", void 0),
        (h = d([(0, o.EM)("w3m-footer")], h));
    },
    65374: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => c });
      var i = r(1220),
        n = r(98866),
        s = r(12319);
      let a = Object.freeze({
          message: "",
          variant: "success",
          svg: void 0,
          open: !1,
          autoClose: !0,
        }),
        o = (0, i.BX)({ ...a }),
        c = {
          state: o,
          subscribeKey: (e, t) => (0, n.u$)(o, e, t),
          showLoading(e, t = {}) {
            this._showMessage({ message: e, variant: "loading", ...t });
          },
          showSuccess(e) {
            this._showMessage({ message: e, variant: "success" });
          },
          showSvg(e, t) {
            this._showMessage({ message: e, svg: t });
          },
          showError(e) {
            let t = s.w.parseError(e);
            this._showMessage({ message: t, variant: "error" });
          },
          hide() {
            (o.message = a.message),
              (o.variant = a.variant),
              (o.svg = a.svg),
              (o.open = a.open),
              (o.autoClose = a.autoClose);
          },
          _showMessage({
            message: e,
            svg: t,
            variant: r = "success",
            autoClose: i = a.autoClose,
          }) {
            o.open
              ? ((o.open = !1),
                setTimeout(() => {
                  (o.message = e),
                    (o.variant = r),
                    (o.svg = t),
                    (o.open = !0),
                    (o.autoClose = i);
                }, 150))
              : ((o.message = e),
                (o.variant = r),
                (o.svg = t),
                (o.open = !0),
                (o.autoClose = i));
          },
        };
    },
    65685: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(55480),
        a = r(36211);
      r(40575), r(41163), r(55877);
      let o = (0, a.AH)`
  :host wui-ux-by-reown {
    padding-top: 0;
  }

  :host wui-ux-by-reown.branding-only {
    padding-top: ${({ spacing: e }) => e["3"]};
  }

  a {
    text-decoration: none;
    color: ${({ tokens: e }) => e.core.textAccentPrimary};
    font-weight: 500;
  }
`;
      var c = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let l = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.remoteFeatures = s.H.state.remoteFeatures),
            this.unsubscribe.push(
              s.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = s.H.state,
            r = s.H.state.features?.legalCheckbox;
          return (e || t) && !r
            ? (0, i.qy)`
      <wui-flex flexDirection="column">
        <wui-flex .padding=${["4", "3", "3", "3"]} justifyContent="center">
          <wui-text color="secondary" variant="md-regular" align="center">
            By connecting your wallet, you agree to our <br />
            ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
          </wui-text>
        </wui-flex>
        ${this.reownBrandingTemplate()}
      </wui-flex>
    `
            : (0, i.qy)`
        <wui-flex flexDirection="column"> ${this.reownBrandingTemplate(
          !0
        )} </wui-flex>
      `;
        }
        andTemplate() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = s.H.state;
          return e && t ? "and" : "";
        }
        termsTemplate() {
          let { termsConditionsUrl: e } = s.H.state;
          return e
            ? (0, i.qy)`<a href=${e} target="_blank" rel="noopener noreferrer"
      >Terms of Service</a
    >`
            : null;
        }
        privacyTemplate() {
          let { privacyPolicyUrl: e } = s.H.state;
          return e
            ? (0, i.qy)`<a href=${e} target="_blank" rel="noopener noreferrer"
      >Privacy Policy</a
    >`
            : null;
        }
        reownBrandingTemplate(e = !1) {
          return this.remoteFeatures?.reownBranding
            ? e
              ? (0,
                i.qy)`<wui-ux-by-reown class="branding-only"></wui-ux-by-reown>`
              : (0, i.qy)`<wui-ux-by-reown></wui-ux-by-reown>`
            : null;
        }
      };
      (l.styles = [o]),
        c([(0, n.wk)()], l.prototype, "remoteFeatures", void 0),
        (l = c([(0, a.EM)("w3m-legal-footer")], l));
    },
    65727: (e, t, r) => {
      "use strict";
      let i = r(88759);
      e.exports = s;
      let n =
        (function () {
          function e(e) {
            return void 0 !== e && e;
          }
          try {
            if ("undefined" != typeof globalThis) return globalThis;
            return (
              Object.defineProperty(Object.prototype, "globalThis", {
                get: function () {
                  return (
                    delete Object.prototype.globalThis, (this.globalThis = this)
                  );
                },
                configurable: !0,
              }),
              globalThis
            );
          } catch (t) {
            return e(self) || e(window) || e(this) || {};
          }
        })().console || {};
      function s(e) {
        var t, r;
        (e = e || {}).browser = e.browser || {};
        let i = e.browser.transmit;
        if (i && "function" != typeof i.send)
          throw Error("pino: transmit option must have a send function");
        let d = e.browser.write || n;
        e.browser.write && (e.browser.asObject = !0);
        let h = e.serializers || {},
          g =
            ((t = e.browser.serialize),
            Array.isArray(t)
              ? t.filter(function (e) {
                  return "!stdSerializers.err" !== e;
                })
              : !0 === t && Object.keys(h)),
          m = e.browser.serialize;
        Array.isArray(e.browser.serialize) &&
          e.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
          (m = !1),
          "function" == typeof d &&
            (d.error = d.fatal = d.warn = d.info = d.debug = d.trace = d),
          !1 === e.enabled && (e.level = "silent");
        let y = e.level || "info",
          w = Object.create(d);
        w.log || (w.log = u),
          Object.defineProperty(w, "levelVal", {
            get: function () {
              return "silent" === this.level
                ? 1 / 0
                : this.levels.values[this.level];
            },
          }),
          Object.defineProperty(w, "level", {
            get: function () {
              return this._level;
            },
            set: function (e) {
              if ("silent" !== e && !this.levels.values[e])
                throw Error("unknown level " + e);
              (this._level = e),
                a(b, w, "error", "log"),
                a(b, w, "fatal", "error"),
                a(b, w, "warn", "error"),
                a(b, w, "info", "log"),
                a(b, w, "debug", "log"),
                a(b, w, "trace", "log");
            },
          });
        let b = {
          transmit: i,
          serialize: g,
          asObject: e.browser.asObject,
          levels: ["error", "fatal", "warn", "info", "debug", "trace"],
          timestamp:
            "function" == typeof (r = e).timestamp
              ? r.timestamp
              : !1 === r.timestamp
              ? p
              : f,
        };
        return (
          (w.levels = s.levels),
          (w.level = y),
          (w.setMaxListeners =
            w.getMaxListeners =
            w.emit =
            w.addListener =
            w.on =
            w.prependListener =
            w.once =
            w.prependOnceListener =
            w.removeListener =
            w.removeAllListeners =
            w.listeners =
            w.listenerCount =
            w.eventNames =
            w.write =
            w.flush =
              u),
          (w.serializers = h),
          (w._serialize = g),
          (w._stdErrSerialize = m),
          (w.child = function (t, r) {
            if (!t) throw Error("missing bindings for child Pino");
            (r = r || {}),
              g && t.serializers && (r.serializers = t.serializers);
            let n = r.serializers;
            if (g && n) {
              var s = Object.assign({}, h, n),
                a = !0 === e.browser.serialize ? Object.keys(s) : g;
              delete t.serializers, o([t], a, s, this._stdErrSerialize);
            }
            function d(e) {
              (this._childLevel = (0 | e._childLevel) + 1),
                (this.error = c(e, t, "error")),
                (this.fatal = c(e, t, "fatal")),
                (this.warn = c(e, t, "warn")),
                (this.info = c(e, t, "info")),
                (this.debug = c(e, t, "debug")),
                (this.trace = c(e, t, "trace")),
                s && ((this.serializers = s), (this._serialize = a)),
                i && (this._logEvent = l([].concat(e._logEvent.bindings, t)));
            }
            return (d.prototype = this), new d(this);
          }),
          i && (w._logEvent = l()),
          w
        );
      }
      function a(e, t, r, a) {
        let c = Object.getPrototypeOf(t);
        (t[r] =
          t.levelVal > t.levels.values[r]
            ? u
            : c[r]
            ? c[r]
            : n[r] || n[a] || u),
          (function (e, t, r) {
            if (e.transmit || t[r] !== u) {
              var a;
              t[r] =
                ((a = t[r]),
                function () {
                  let c = e.timestamp(),
                    d = Array(arguments.length),
                    h =
                      Object.getPrototypeOf && Object.getPrototypeOf(this) === n
                        ? n
                        : this;
                  for (var u = 0; u < d.length; u++) d[u] = arguments[u];
                  if (
                    (e.serialize &&
                      !e.asObject &&
                      o(
                        d,
                        this._serialize,
                        this.serializers,
                        this._stdErrSerialize
                      ),
                    e.asObject
                      ? a.call(
                          h,
                          (function (e, t, r, n) {
                            e._serialize &&
                              o(
                                r,
                                e._serialize,
                                e.serializers,
                                e._stdErrSerialize
                              );
                            let a = r.slice(),
                              c = a[0],
                              l = {};
                            n && (l.time = n), (l.level = s.levels.values[t]);
                            let d = (0 | e._childLevel) + 1;
                            if (
                              (d < 1 && (d = 1),
                              null !== c && "object" == typeof c)
                            ) {
                              for (; d-- && "object" == typeof a[0]; )
                                Object.assign(l, a.shift());
                              c = a.length ? i(a.shift(), a) : void 0;
                            } else
                              "string" == typeof c && (c = i(a.shift(), a));
                            return void 0 !== c && (l.msg = c), l;
                          })(this, r, d, c)
                        )
                      : a.apply(h, d),
                    e.transmit)
                  ) {
                    let i = e.transmit.level || t.level,
                      n = s.levels.values[i],
                      a = s.levels.values[r];
                    if (a < n) return;
                    !(function (e, t, r) {
                      let i = t.send,
                        n = t.ts,
                        s = t.methodLevel,
                        a = t.methodValue,
                        c = t.val,
                        d = e._logEvent.bindings;
                      o(
                        r,
                        e._serialize || Object.keys(e.serializers),
                        e.serializers,
                        void 0 === e._stdErrSerialize || e._stdErrSerialize
                      ),
                        (e._logEvent.ts = n),
                        (e._logEvent.messages = r.filter(function (e) {
                          return -1 === d.indexOf(e);
                        })),
                        (e._logEvent.level.label = s),
                        (e._logEvent.level.value = a),
                        i(s, e._logEvent, c),
                        (e._logEvent = l(d));
                    })(
                      this,
                      {
                        ts: c,
                        methodLevel: r,
                        methodValue: a,
                        transmitLevel: i,
                        transmitValue:
                          s.levels.values[e.transmit.level || t.level],
                        send: e.transmit.send,
                        val: t.levelVal,
                      },
                      d
                    );
                  }
                });
            }
          })(e, t, r);
      }
      function o(e, t, r, i) {
        for (let n in e)
          if (i && e[n] instanceof Error) e[n] = s.stdSerializers.err(e[n]);
          else if ("object" == typeof e[n] && !Array.isArray(e[n]))
            for (let i in e[n])
              t && t.indexOf(i) > -1 && i in r && (e[n][i] = r[i](e[n][i]));
      }
      function c(e, t, r) {
        return function () {
          let i = Array(1 + arguments.length);
          i[0] = t;
          for (var n = 1; n < i.length; n++) i[n] = arguments[n - 1];
          return e[r].apply(this, i);
        };
      }
      function l(e) {
        return {
          ts: 0,
          messages: [],
          bindings: e || [],
          level: { label: "", value: 0 },
        };
      }
      function d() {
        return {};
      }
      function h(e) {
        return e;
      }
      function u() {}
      function p() {
        return !1;
      }
      function f() {
        return Date.now();
      }
      (s.levels = {
        values: {
          fatal: 60,
          error: 50,
          warn: 40,
          info: 30,
          debug: 20,
          trace: 10,
        },
        labels: {
          10: "trace",
          20: "debug",
          30: "info",
          40: "warn",
          50: "error",
          60: "fatal",
        },
      }),
        (s.stdSerializers = {
          mapHttpRequest: d,
          mapHttpResponse: d,
          wrapRequestSerializer: h,
          wrapResponseSerializer: h,
          wrapErrorSerializer: h,
          req: d,
          res: d,
          err: function (e) {
            let t = {
              type: e.constructor.name,
              msg: e.message,
              stack: e.stack,
            };
            for (let r in e) void 0 === t[r] && (t[r] = e[r]);
            return t;
          },
        }),
        (s.stdTimeFunctions = Object.assign(
          {},
          {
            nullTime: p,
            epochTime: f,
            unixTime: function () {
              return Math.round(Date.now() / 1e3);
            },
            isoTime: function () {
              return new Date(Date.now()).toISOString();
            },
          }
        ));
    },
    66575: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => s });
      var i = r(98502);
      let n = {
        attribute: !0,
        type: String,
        converter: i.W3,
        reflect: !1,
        hasChanged: i.Ec,
      };
      function s(e) {
        return (t, r) =>
          "object" == typeof r
            ? ((e = n, t, r) => {
                let { kind: i, metadata: s } = r,
                  a = globalThis.litPropertyMetadata.get(s);
                if (
                  (void 0 === a &&
                    globalThis.litPropertyMetadata.set(s, (a = new Map())),
                  "setter" === i && ((e = Object.create(e)).wrapped = !0),
                  a.set(r.name, e),
                  "accessor" === i)
                ) {
                  let { name: i } = r;
                  return {
                    set(r) {
                      let n = t.get.call(this);
                      t.set.call(this, r), this.requestUpdate(i, n, e);
                    },
                    init(t) {
                      return void 0 !== t && this.C(i, void 0, e, t), t;
                    },
                  };
                }
                if ("setter" === i) {
                  let { name: i } = r;
                  return function (r) {
                    let n = this[i];
                    t.call(this, r), this.requestUpdate(i, n, e);
                  };
                }
                throw Error("Unsupported decorator location: " + i);
              })(e, t, r)
            : ((e, t, r) => {
                let i = t.hasOwnProperty(r);
                return (
                  t.constructor.createProperty(r, e),
                  i ? Object.getOwnPropertyDescriptor(t, r) : void 0
                );
              })(e, t, r);
      }
    },
    66969: (e, t, r) => {
      "use strict";
      r.d(t, { Fl: () => s, NV: () => a, ii: () => n });
      var i = r(13933);
      class n extends i.C {
        constructor({ offset: e, position: t, size: r }) {
          super(
            `Slice ${
              "start" === t ? "starting" : "ending"
            } at offset "${e}" is out-of-bounds (size: ${r}).`,
            { name: "SliceOffsetOutOfBoundsError" }
          );
        }
      }
      class s extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      class a extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} is expected to be ${t} ${r} long, but is ${e} ${r} long.`,
            { name: "InvalidBytesLengthError" }
          );
        }
      }
    },
    67243: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => m }), r(59335);
      var i = r(45553),
        n = r(73537),
        s = r(93481),
        a = r(97418),
        o = r(10899),
        c = r(70417),
        l = r(81701),
        d = r(55480),
        h = r(67869),
        u = r(65374),
        p = r(71305),
        f = r(12319);
      let g = null,
        m = {
          getSIWX: () => d.H.state.siwx,
          async initializeIfEnabled(e = s.W.getActiveCaipAddress()) {
            let t = d.H.state.siwx;
            if (!(t && e)) return;
            let [r, i, n] = e.split(":");
            if (s.W.checkIfSupportedNetwork(r, `${r}:${i}`))
              try {
                if (d.H.state.remoteFeatures?.emailCapture) {
                  let e = s.W.getAccountData(r)?.user;
                  await l.W.open({
                    view: "DataCapture",
                    data: { email: e?.email ?? void 0 },
                  });
                  return;
                }
                if (
                  (g && (await g), (await t.getSessions(`${r}:${i}`, n)).length)
                )
                  return;
                await l.W.open({ view: "SIWXSignMessage" });
              } catch (e) {
                console.error("SIWXUtil:initializeIfEnabled", e),
                  c.E.sendEvent({
                    type: "track",
                    event: "SIWX_AUTH_ERROR",
                    properties: this.getSIWXEventProperties(e),
                  }),
                  await a.x._getClient()?.disconnect().catch(console.error),
                  h.I.reset("Connect"),
                  u.P.showError(
                    "A problem occurred while trying initialize authentication"
                  );
              }
          },
          async requestSignMessage() {
            let e = d.H.state.siwx,
              t = f.w.getPlainAddress(s.W.getActiveCaipAddress()),
              r = (0, p.kg)(),
              n = a.x._getClient();
            if (!e) throw Error("SIWX is not enabled");
            if (!t) throw Error("No ActiveCaipAddress found");
            if (!r) throw Error("No ActiveCaipNetwork or client found");
            if (!n) throw Error("No ConnectionController client found");
            try {
              let a = await e.createMessage({
                  chainId: r.caipNetworkId,
                  accountAddress: t,
                }),
                d = a.toString();
              o.a.getConnectorId(r.chainNamespace) === i.o.CONNECTOR_ID.AUTH &&
                h.I.pushTransactionStack({});
              let u = await n.signMessage(d);
              await e.addSession({ data: a, message: d, signature: u }),
                s.W.setLastConnectedSIWECaipNetwork(r),
                l.W.close(),
                c.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_SUCCESS",
                  properties: this.getSIWXEventProperties(),
                });
            } catch (e) {
              (l.W.state.open && "ApproveTransaction" !== h.I.state.view) ||
                (await l.W.open({ view: "SIWXSignMessage" })),
                u.P.showError("Error signing message"),
                c.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: this.getSIWXEventProperties(e),
                }),
                console.error("SWIXUtil:requestSignMessage", e);
            }
          },
          async cancelSignMessage() {
            try {
              let e = this.getSIWX();
              if (e?.getRequired?.()) {
                let t = s.W.getLastConnectedSIWECaipNetwork();
                if (t) {
                  let r = await e?.getSessions(
                    t?.caipNetworkId,
                    f.w.getPlainAddress(s.W.getActiveCaipAddress()) || ""
                  );
                  r && r.length > 0
                    ? await s.W.switchActiveNetwork(t)
                    : await a.x.disconnect();
                } else await a.x.disconnect();
              } else l.W.close();
              l.W.close(),
                c.E.sendEvent({
                  event: "CLICK_CANCEL_SIWX",
                  type: "track",
                  properties: this.getSIWXEventProperties(),
                });
            } catch (e) {
              console.error("SIWXUtil:cancelSignMessage", e);
            }
          },
          async getAllSessions() {
            let e = this.getSIWX(),
              t = s.W.getAllRequestedCaipNetworks(),
              r = [];
            return (
              await Promise.all(
                t.map(async (t) => {
                  let i = await e?.getSessions(
                    t.caipNetworkId,
                    f.w.getPlainAddress(s.W.getActiveCaipAddress()) || ""
                  );
                  i && r.push(...i);
                })
              ),
              r
            );
          },
          async getSessions(e) {
            let t = d.H.state.siwx,
              r = e?.address;
            if (!r) {
              let e = s.W.getActiveCaipAddress();
              r = f.w.getPlainAddress(e);
            }
            let i = e?.caipNetworkId;
            if (!i) {
              let e = s.W.getActiveCaipNetwork();
              i = e?.caipNetworkId;
            }
            return t && r && i ? t.getSessions(i, r) : [];
          },
          async isSIWXCloseDisabled() {
            let e = this.getSIWX();
            if (e) {
              let t = "ApproveTransaction" === h.I.state.view,
                r = "SIWXSignMessage" === h.I.state.view;
              if (t || r)
                return (
                  e.getRequired?.() && 0 === (await this.getSessions()).length
                );
            }
            return !1;
          },
          async authConnectorAuthenticate({
            authConnector: e,
            chainId: t,
            socialUri: r,
            preferredAccountType: n,
            chainNamespace: a,
          }) {
            let o = m.getSIWX(),
              c = (0, p.kg)();
            if (
              !o ||
              !a.includes(i.o.CHAIN.EVM) ||
              d.H.state.remoteFeatures?.emailCapture
            ) {
              let i = await e.connect({
                chainId: t,
                socialUri: r,
                preferredAccountType: n,
              });
              return {
                address: i.address,
                chainId: i.chainId,
                accounts: i.accounts,
              };
            }
            let l = `${a}:${t}`,
              h = await o.createMessage({
                chainId: l,
                accountAddress: "<<AccountAddress>>",
              }),
              u = {
                accountAddress: h.accountAddress,
                chainId: h.chainId,
                domain: h.domain,
                uri: h.uri,
                version: h.version,
                nonce: h.nonce,
                notBefore: h.notBefore,
                statement: h.statement,
                resources: h.resources,
                requestId: h.requestId,
                issuedAt: h.issuedAt,
                expirationTime: h.expirationTime,
                serializedMessage: h.toString(),
              },
              f = await e.connect({
                chainId: t,
                socialUri: r,
                siwxMessage: u,
                preferredAccountType: n,
              });
            if (
              ((u.accountAddress = f.address),
              (u.serializedMessage = f.message || ""),
              f.signature && f.message)
            ) {
              let e = m.addEmbeddedWalletSession(u, f.message, f.signature);
              await e;
            }
            return (
              s.W.setLastConnectedSIWECaipNetwork(c),
              { address: f.address, chainId: f.chainId, accounts: f.accounts }
            );
          },
          async addEmbeddedWalletSession(e, t, r) {
            if (g) return g;
            let i = m.getSIWX();
            return i
              ? (g = i
                  .addSession({ data: e, message: t, signature: r })
                  .finally(() => {
                    g = null;
                  }))
              : Promise.resolve();
          },
          async universalProviderAuthenticate({
            universalProvider: e,
            chains: t,
            methods: r,
          }) {
            let i = m.getSIWX(),
              n = (0, p.kg)(),
              a = new Set(t.map((e) => e.split(":")[0]));
            if (!i || 1 !== a.size || !a.has("eip155")) return !1;
            let o = await i.createMessage({
                chainId: (0, p.kg)()?.caipNetworkId || "",
                accountAddress: "",
              }),
              l = await e.authenticate({
                nonce: o.nonce,
                domain: o.domain,
                uri: o.uri,
                exp: o.expirationTime,
                iat: o.issuedAt,
                nbf: o.notBefore,
                requestId: o.requestId,
                version: o.version,
                resources: o.resources,
                statement: o.statement,
                chainId: o.chainId,
                methods: r,
                chains: [o.chainId, ...t.filter((e) => e !== o.chainId)],
              });
            u.P.showLoading("Authenticating...", { autoClose: !1 });
            let d = {
              ...l.session.peer.metadata,
              name: l.session.peer.metadata.name,
              icon: l.session.peer.metadata.icons?.[0],
              type: "WALLET_CONNECT",
            };
            if (
              (s.W.setAccountProp("connectedWalletInfo", d, Array.from(a)[0]),
              l?.auths?.length)
            ) {
              let t = l.auths.map((t) => {
                let r = e.client.formatAuthMessage({
                  request: t.p,
                  iss: t.p.iss,
                });
                return {
                  data: {
                    ...t.p,
                    accountAddress: t.p.iss.split(":").slice(-1).join(""),
                    chainId: t.p.iss.split(":").slice(2, 4).join(":"),
                    uri: t.p.aud,
                    version: t.p.version || o.version,
                    expirationTime: t.p.exp,
                    issuedAt: t.p.iat,
                    notBefore: t.p.nbf,
                  },
                  message: r,
                  signature: t.s.s,
                  cacao: t,
                };
              });
              try {
                await i.setSessions(t),
                  n && s.W.setLastConnectedSIWECaipNetwork(n),
                  c.E.sendEvent({
                    type: "track",
                    event: "SIWX_AUTH_SUCCESS",
                    properties: m.getSIWXEventProperties(),
                  });
              } catch (t) {
                throw (
                  (console.error(
                    "SIWX:universalProviderAuth - failed to set sessions",
                    t
                  ),
                  c.E.sendEvent({
                    type: "track",
                    event: "SIWX_AUTH_ERROR",
                    properties: m.getSIWXEventProperties(t),
                  }),
                  await e.disconnect().catch(console.error),
                  t)
                );
              } finally {
                u.P.hide();
              }
            }
            return !0;
          },
          getSIWXEventProperties(e) {
            let t = s.W.state.activeChain;
            if (!t)
              throw Error(
                "SIWXUtil:getSIWXEventProperties - namespace is required"
              );
            return {
              network: s.W.state.activeCaipNetwork?.caipNetworkId || "",
              isSmartAccount: (0, p.lj)(t) === n.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
              message: e ? f.w.parseError(e) : void 0,
            };
          },
          async clearSessions() {
            let e = this.getSIWX();
            e && (await e.setSessions([]));
          },
        };
    },
    67550: (e, t, r) => {
      "use strict";
      r.d(t, { u: () => s });
      var i = r(98722);
      let n = new Map();
      function s({ fn: e, id: t, shouldSplitBatch: r, wait: s = 0, sort: a }) {
        let o = async () => {
            let t = l();
            c();
            let r = t.map(({ args: e }) => e);
            0 !== r.length &&
              e(r)
                .then((e) => {
                  a && Array.isArray(e) && e.sort(a);
                  for (let r = 0; r < t.length; r++) {
                    let { resolve: i } = t[r];
                    i?.([e[r], e]);
                  }
                })
                .catch((e) => {
                  for (let r = 0; r < t.length; r++) {
                    let { reject: i } = t[r];
                    i?.(e);
                  }
                });
          },
          c = () => n.delete(t),
          l = () => n.get(t) || [],
          d = (e) => n.set(t, [...l(), e]);
        return {
          flush: c,
          async schedule(e) {
            let { promise: t, resolve: n, reject: a } = (0, i.Y)();
            return (
              (r?.([...l().map(({ args: e }) => e), e]) && o(), l().length > 0)
                ? d({ args: e, resolve: n, reject: a })
                : (d({ args: e, resolve: n, reject: a }), setTimeout(o, s)),
              t
            );
          },
        };
      }
    },
    67869: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => h });
      var i = r(1220),
        n = r(98866),
        s = r(36964),
        a = r(93481),
        o = r(10899),
        c = r(81701),
        l = r(55480);
      let d = (0, i.BX)({
          view: "Connect",
          history: ["Connect"],
          transactionStack: [],
        }),
        h = (0, s.X)({
          state: d,
          subscribeKey: (e, t) => (0, n.u$)(d, e, t),
          pushTransactionStack(e) {
            d.transactionStack.push(e);
          },
          popTransactionStack(e) {
            let t = d.transactionStack.pop();
            if (!t) return;
            let { onSuccess: r, onError: i, onCancel: n } = t;
            switch (e) {
              case "success":
                r?.();
                break;
              case "error":
                i?.(), h.goBack();
                break;
              case "cancel":
                n?.(), h.goBack();
            }
          },
          push(e, t) {
            e !== d.view && ((d.view = e), d.history.push(e), (d.data = t));
          },
          reset(e, t) {
            (d.view = e), (d.history = [e]), (d.data = t);
          },
          replace(e, t) {
            d.history.at(-1) !== e &&
              ((d.view = e),
              (d.history[d.history.length - 1] = e),
              (d.data = t));
          },
          goBack() {
            let e = a.W.state.activeCaipAddress,
              t = "ConnectingFarcaster" === h.state.view,
              r = !e && t;
            if (d.history.length > 1) {
              d.history.pop();
              let [t] = d.history.slice(-1);
              t && (e && "Connect" === t ? (d.view = "Account") : (d.view = t));
            } else c.W.close();
            d.data?.wallet && (d.data.wallet = void 0),
              d.data?.redirectView && (d.data.redirectView = void 0),
              setTimeout(() => {
                if (r) {
                  a.W.setAccountProp(
                    "farcasterUrl",
                    void 0,
                    a.W.state.activeChain
                  );
                  let e = o.a.getAuthConnector();
                  e?.provider?.reload();
                  let t = (0, i.P9)(l.H.state);
                  e?.provider?.syncDappData?.({
                    metadata: t.metadata,
                    sdkVersion: t.sdkVersion,
                    projectId: t.projectId,
                    sdkType: t.sdkType,
                  });
                }
              }, 100);
          },
          goBackToIndex(e) {
            if (d.history.length > 1) {
              d.history = d.history.slice(0, e + 1);
              let [t] = d.history.slice(-1);
              t && (d.view = t);
            }
          },
          goBackOrCloseModal() {
            h.state.history.length > 1 ? h.goBack() : c.W.close();
          },
        });
    },
    69435: (e, t, r) => {
      let i = r(46342),
        n = r(81010),
        s = r(24967),
        a = r(89158),
        o = r(29762),
        c = i.getBCHDigit(7973);
      function l(e, t) {
        return a.getCharCountIndicator(e, t) + 4;
      }
      (t.from = function (e, t) {
        return o.isValid(e) ? parseInt(e, 10) : t;
      }),
        (t.getCapacity = function (e, t, r) {
          if (!o.isValid(e)) throw Error("Invalid QR Code version");
          void 0 === r && (r = a.BYTE);
          let s =
            (i.getSymbolTotalCodewords(e) - n.getTotalCodewordsCount(e, t)) * 8;
          if (r === a.MIXED) return s;
          let c = s - l(r, e);
          switch (r) {
            case a.NUMERIC:
              return Math.floor((c / 10) * 3);
            case a.ALPHANUMERIC:
              return Math.floor((c / 11) * 2);
            case a.KANJI:
              return Math.floor(c / 13);
            case a.BYTE:
            default:
              return Math.floor(c / 8);
          }
        }),
        (t.getBestVersionForData = function (e, r) {
          let i,
            n = s.from(r, s.M);
          if (Array.isArray(e)) {
            if (e.length > 1) {
              for (let r = 1; r <= 40; r++)
                if (
                  (function (e, t) {
                    let r = 0;
                    return (
                      e.forEach(function (e) {
                        let i = l(e.mode, t);
                        r += i + e.getBitsLength();
                      }),
                      r
                    );
                  })(e, r) <= t.getCapacity(r, n, a.MIXED)
                )
                  return r;
              return;
            }
            if (0 === e.length) return 1;
            i = e[0];
          } else i = e;
          return (function (e, r, i) {
            for (let n = 1; n <= 40; n++)
              if (r <= t.getCapacity(n, i, e)) return n;
          })(i.mode, i.getLength(), n);
        }),
        (t.getEncodedBits = function (e) {
          if (!o.isValid(e) || e < 7) throw Error("Invalid QR Code version");
          let t = e << 12;
          for (; i.getBCHDigit(t) - c >= 0; )
            t ^= 7973 << (i.getBCHDigit(t) - c);
          return (e << 12) | t;
        });
    },
    70371: (e, t, r) => {
      let i = r(89158),
        n = r(54415),
        s = r(31937),
        a = r(44006),
        o = r(73987),
        c = r(53896),
        l = r(46342),
        d = r(88072);
      function h(e) {
        return unescape(encodeURIComponent(e)).length;
      }
      function u(e, t, r) {
        let i,
          n = [];
        for (; null !== (i = e.exec(r)); )
          n.push({ data: i[0], index: i.index, mode: t, length: i[0].length });
        return n;
      }
      function p(e) {
        let t,
          r,
          n = u(c.NUMERIC, i.NUMERIC, e),
          s = u(c.ALPHANUMERIC, i.ALPHANUMERIC, e);
        return (
          l.isKanjiModeEnabled()
            ? ((t = u(c.BYTE, i.BYTE, e)), (r = u(c.KANJI, i.KANJI, e)))
            : ((t = u(c.BYTE_KANJI, i.BYTE, e)), (r = [])),
          n
            .concat(s, t, r)
            .sort(function (e, t) {
              return e.index - t.index;
            })
            .map(function (e) {
              return { data: e.data, mode: e.mode, length: e.length };
            })
        );
      }
      function f(e, t) {
        switch (t) {
          case i.NUMERIC:
            return n.getBitsLength(e);
          case i.ALPHANUMERIC:
            return s.getBitsLength(e);
          case i.KANJI:
            return o.getBitsLength(e);
          case i.BYTE:
            return a.getBitsLength(e);
        }
      }
      function g(e, t) {
        let r,
          c = i.getBestModeForData(e);
        if ((r = i.from(t, c)) !== i.BYTE && r.bit < c.bit)
          throw Error(
            '"' +
              e +
              '" cannot be encoded with mode ' +
              i.toString(r) +
              ".\n Suggested mode is: " +
              i.toString(c)
          );
        switch ((r === i.KANJI && !l.isKanjiModeEnabled() && (r = i.BYTE), r)) {
          case i.NUMERIC:
            return new n(e);
          case i.ALPHANUMERIC:
            return new s(e);
          case i.KANJI:
            return new o(e);
          case i.BYTE:
            return new a(e);
        }
      }
      (t.fromArray = function (e) {
        return e.reduce(function (e, t) {
          return (
            "string" == typeof t
              ? e.push(g(t, null))
              : t.data && e.push(g(t.data, t.mode)),
            e
          );
        }, []);
      }),
        (t.fromString = function (e, r) {
          let n = (function (e, t) {
              let r = {},
                n = { start: {} },
                s = ["start"];
              for (let a = 0; a < e.length; a++) {
                let o = e[a],
                  c = [];
                for (let e = 0; e < o.length; e++) {
                  let l = o[e],
                    d = "" + a + e;
                  c.push(d), (r[d] = { node: l, lastCount: 0 }), (n[d] = {});
                  for (let e = 0; e < s.length; e++) {
                    let a = s[e];
                    r[a] && r[a].node.mode === l.mode
                      ? ((n[a][d] =
                          f(r[a].lastCount + l.length, l.mode) -
                          f(r[a].lastCount, l.mode)),
                        (r[a].lastCount += l.length))
                      : (r[a] && (r[a].lastCount = l.length),
                        (n[a][d] =
                          f(l.length, l.mode) +
                          4 +
                          i.getCharCountIndicator(l.mode, t)));
                  }
                }
                s = c;
              }
              for (let e = 0; e < s.length; e++) n[s[e]].end = 0;
              return { map: n, table: r };
            })(
              (function (e) {
                let t = [];
                for (let r = 0; r < e.length; r++) {
                  let n = e[r];
                  switch (n.mode) {
                    case i.NUMERIC:
                      t.push([
                        n,
                        {
                          data: n.data,
                          mode: i.ALPHANUMERIC,
                          length: n.length,
                        },
                        { data: n.data, mode: i.BYTE, length: n.length },
                      ]);
                      break;
                    case i.ALPHANUMERIC:
                      t.push([
                        n,
                        { data: n.data, mode: i.BYTE, length: n.length },
                      ]);
                      break;
                    case i.KANJI:
                      t.push([
                        n,
                        { data: n.data, mode: i.BYTE, length: h(n.data) },
                      ]);
                      break;
                    case i.BYTE:
                      t.push([
                        { data: n.data, mode: i.BYTE, length: h(n.data) },
                      ]);
                  }
                }
                return t;
              })(p(e, l.isKanjiModeEnabled())),
              r
            ),
            s = d.find_path(n.map, "start", "end"),
            a = [];
          for (let e = 1; e < s.length - 1; e++) a.push(n.table[s[e]].node);
          return t.fromArray(
            a.reduce(function (e, t) {
              let r = e.length - 1 >= 0 ? e[e.length - 1] : null;
              return (
                r && r.mode === t.mode
                  ? (e[e.length - 1].data += t.data)
                  : e.push(t),
                e
              );
            }, [])
          );
        }),
        (t.rawSplit = function (e) {
          return t.fromArray(p(e, l.isKanjiModeEnabled()));
        });
    },
    70417: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => u });
      var i = r(1220),
        n = r(12319),
        s = r(32464),
        a = r(93481),
        o = r(55480);
      let c = n.w.getAnalyticsUrl(),
        l = new s.Z({ baseUrl: c, clientId: null }),
        d = ["MODAL_CREATED"],
        h = (0, i.BX)({
          timestamp: Date.now(),
          reportedErrors: {},
          data: { type: "track", event: "MODAL_CREATED" },
          pendingEvents: [],
          subscribedToVisibilityChange: !1,
        }),
        u = {
          state: h,
          subscribe: (e) => (0, i.B1)(h, () => e(h)),
          getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = o.H.state;
            return { projectId: e, st: t, sv: r || "html-wagmi-4.2.2" };
          },
          _setPendingEvent(e) {
            try {
              let t = a.W.getAccountData()?.address;
              if (
                ("address" in e.data && e.data.address && (t = e.data.address),
                d.includes(e.data.event) || "undefined" == typeof window)
              )
                return;
              let r = a.W.getActiveCaipNetwork()?.caipNetworkId;
              this.state.pendingEvents.push({
                eventId: n.w.getUUID(),
                url: window.location.href,
                domain: window.location.hostname,
                timestamp: e.timestamp,
                props: {
                  ...e.data,
                  address: t,
                  properties: {
                    ...("properties" in e.data ? e.data.properties : {}),
                    caipNetworkId: r,
                  },
                },
              }),
                (h.reportedErrors.FORBIDDEN = !1),
                JSON.stringify(h.pendingEvents).length / 1024 > 45 &&
                  u._submitPendingEvents();
            } catch (e) {
              console.warn("_setPendingEvent", e);
            }
          },
          sendEvent(e) {
            (h.timestamp = Date.now()),
              (h.data = e),
              (o.H.state.features?.analytics ||
                [
                  "INITIALIZE",
                  "CONNECT_SUCCESS",
                  "SOCIAL_LOGIN_SUCCESS",
                ].includes(e.event)) &&
                u._setPendingEvent(h),
              this._subscribeToVisibilityChange();
          },
          _submitPendingEvents() {
            if (0 !== h.pendingEvents.length)
              try {
                l.sendBeacon({
                  path: "/batch",
                  params: u.getSdkProperties(),
                  body: h.pendingEvents,
                }),
                  (h.reportedErrors.FORBIDDEN = !1),
                  (h.pendingEvents = []);
              } catch (e) {
                h.reportedErrors.FORBIDDEN = !0;
              }
          },
          _subscribeToVisibilityChange() {
            h.subscribedToVisibilityChange ||
              ("undefined" != typeof document &&
                ((h.subscribedToVisibilityChange = !0),
                document?.addEventListener?.("visibilitychange", () => {
                  "hidden" === document.visibilityState &&
                    u._submitPendingEvents();
                })));
          },
        };
    },
    71018: (e, t, r) => {
      "use strict";
      r.d(t, {
        D5: () => _,
        U5: () => A,
        h6: () => n.a,
        iP: () => E,
        oI: () => x,
      });
      var i = r(65727),
        n = r.n(i),
        s = r(25042);
      let a = { level: "info" },
        o = "custom_context";
      class c {
        constructor(e) {
          (this.nodeValue = e),
            (this.sizeInBytes = new TextEncoder().encode(
              this.nodeValue
            ).length),
            (this.next = null);
        }
        get value() {
          return this.nodeValue;
        }
        get size() {
          return this.sizeInBytes;
        }
      }
      class l {
        constructor(e) {
          (this.head = null),
            (this.tail = null),
            (this.lengthInNodes = 0),
            (this.maxSizeInBytes = e),
            (this.sizeInBytes = 0);
        }
        append(e) {
          let t = new c(e);
          if (t.size > this.maxSizeInBytes)
            throw Error(
              `[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`
            );
          for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
          this.head ? this.tail && (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            this.lengthInNodes++,
            (this.sizeInBytes += t.size);
        }
        shift() {
          if (!this.head) return;
          let e = this.head;
          (this.head = this.head.next),
            this.head || (this.tail = null),
            this.lengthInNodes--,
            (this.sizeInBytes -= e.size);
        }
        toArray() {
          let e = [],
            t = this.head;
          for (; null !== t; ) e.push(t.value), (t = t.next);
          return e;
        }
        get length() {
          return this.lengthInNodes;
        }
        get size() {
          return this.sizeInBytes;
        }
        toOrderedArray() {
          return Array.from(this);
        }
        [Symbol.iterator]() {
          let e = this.head;
          return {
            next: () => {
              if (!e) return { done: !0, value: null };
              let t = e.value;
              return (e = e.next), { done: !1, value: t };
            },
          };
        }
      }
      class d {
        constructor(e, t = 1024e3) {
          (this.level = e ?? "error"),
            (this.levelValue = i.levels.values[this.level]),
            (this.MAX_LOG_SIZE_IN_BYTES = t),
            (this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES));
        }
        forwardToConsole(e, t) {
          t === i.levels.values.error
            ? console.error(e)
            : t === i.levels.values.warn
            ? console.warn(e)
            : t === i.levels.values.debug
            ? console.debug(e)
            : t === i.levels.values.trace
            ? console.trace(e)
            : console.log(e);
        }
        appendToLogs(e) {
          this.logs.append(
            (0, s.h)({ timestamp: new Date().toISOString(), log: e })
          );
          let t = "string" == typeof e ? JSON.parse(e).level : e.level;
          t >= this.levelValue && this.forwardToConsole(e, t);
        }
        getLogs() {
          return this.logs;
        }
        clearLogs() {
          this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES);
        }
        getLogArray() {
          return Array.from(this.logs);
        }
        logsToBlob(e) {
          let t = this.getLogArray();
          return (
            t.push((0, s.h)({ extraMetadata: e })),
            new Blob(t, { type: "application/json" })
          );
        }
      }
      class h {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new d(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
        downloadLogsBlobInBrowser(e) {
          let t = URL.createObjectURL(this.logsToBlob(e)),
            r = document.createElement("a");
          (r.href = t),
            (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
            document.body.appendChild(r),
            r.click(),
            document.body.removeChild(r),
            URL.revokeObjectURL(t);
        }
      }
      class u {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new d(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
      }
      var p = Object.defineProperty,
        f = Object.defineProperties,
        g = Object.getOwnPropertyDescriptors,
        m = Object.getOwnPropertySymbols,
        y = Object.prototype.hasOwnProperty,
        w = Object.prototype.propertyIsEnumerable,
        b = (e, t, r) =>
          t in e
            ? p(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        v = (e, t) => {
          for (var r in t || (t = {})) y.call(t, r) && b(e, r, t[r]);
          if (m) for (var r of m(t)) w.call(t, r) && b(e, r, t[r]);
          return e;
        },
        C = (e, t) => f(e, g(t));
      function E(e) {
        return C(v({}, e), { level: e?.level || a.level });
      }
      function x(e, t = o) {
        return typeof e.bindings > "u"
          ? (function (e, t = o) {
              return e[t] || "";
            })(e, t)
          : e.bindings().context || "";
      }
      function A(e, t, r = o) {
        let i = (function (e, t, r = o) {
          let i = x(e, r);
          return i.trim() ? `${i}/${t}` : t;
        })(e, t, r);
        return (function (e, t, r = o) {
          return (e[r] = t), e;
        })(e.child({ context: i }), i, r);
      }
      function _(e) {
        return "u" > typeof e.loggerOverride &&
          "string" != typeof e.loggerOverride
          ? { logger: e.loggerOverride, chunkLoggerController: null }
          : "u" > typeof window
          ? (function (e) {
              var t, r;
              let i = new h(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: n()(
                  C(v({}, e.opts), {
                    level: "trace",
                    browser: C(
                      v({}, null == (r = e.opts) ? void 0 : r.browser),
                      { write: (e) => i.write(e) }
                    ),
                  })
                ),
                chunkLoggerController: i,
              };
            })(e)
          : (function (e) {
              var t;
              let r = new u(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: n()(C(v({}, e.opts), { level: "trace" }), r),
                chunkLoggerController: r,
              };
            })(e);
      }
    },
    71084: (e, t, r) => {
      "use strict";
      let i, n, s, a, o;
      r.d(t, {
        JX: () => p,
        RF: () => u,
        W5: () => m,
        ds: () => f,
        fD: () => y,
      });
      var c = r(83138),
        l = r(20296);
      let d = {
        "KHTeka-500-woff2": "https://fonts.reown.com/KHTeka-Medium.woff2",
        "KHTeka-400-woff2": "https://fonts.reown.com/KHTeka-Regular.woff2",
        "KHTeka-300-woff2": "https://fonts.reown.com/KHTeka-Light.woff2",
        "KHTekaMono-400-woff2":
          "https://fonts.reown.com/KHTekaMono-Regular.woff2",
        "KHTeka-500-woff": "https://fonts.reown.com/KHTeka-Light.woff",
        "KHTeka-400-woff": "https://fonts.reown.com/KHTeka-Regular.woff",
        "KHTeka-300-woff": "https://fonts.reown.com/KHTeka-Light.woff",
        "KHTekaMono-400-woff":
          "https://fonts.reown.com/KHTekaMono-Regular.woff",
      };
      function h(e, t = "dark") {
        i && document.head.removeChild(i),
          ((i = document.createElement("style")).textContent =
            l.CV.createRootStyles(t, e)),
          document.head.appendChild(i);
      }
      function u(e, t = "dark") {
        if (
          ((o = e),
          (n = document.createElement("style")),
          (s = document.createElement("style")),
          (a = document.createElement("style")),
          (n.textContent = g(e).core.cssText),
          (s.textContent = g(e).dark.cssText),
          (a.textContent = g(e).light.cssText),
          document.head.appendChild(n),
          document.head.appendChild(s),
          document.head.appendChild(a),
          h(e, t),
          p(t),
          !e?.["--w3m-font-family"])
        )
          for (let [e, t] of Object.entries(d)) {
            let r = document.createElement("link");
            (r.rel = "preload"),
              (r.href = t),
              (r.as = "font"),
              (r.type = e.includes("woff2") ? "font/woff2" : "font/woff"),
              (r.crossOrigin = "anonymous"),
              document.head.appendChild(r);
          }
        p(t);
      }
      function p(e = "dark") {
        s &&
          a &&
          i &&
          ("light" === e
            ? (h(o, e), s.removeAttribute("media"), (a.media = "enabled"))
            : (h(o, e), a.removeAttribute("media"), (s.media = "enabled")));
      }
      function f(e) {
        if (
          ((o = e),
          n &&
            s &&
            a &&
            ((n.textContent = g(e).core.cssText),
            (s.textContent = g(e).dark.cssText),
            (a.textContent = g(e).light.cssText),
            e?.["--w3m-font-family"]))
        ) {
          let t = e["--w3m-font-family"];
          (n.textContent = n.textContent?.replace(
            "font-family: KHTeka",
            `font-family: ${t}`
          )),
            (s.textContent = s.textContent?.replace(
              "font-family: KHTeka",
              `font-family: ${t}`
            )),
            (a.textContent = a.textContent?.replace(
              "font-family: KHTeka",
              `font-family: ${t}`
            ));
        }
        i && h(e, a?.media === "enabled" ? "light" : "dark");
      }
      function g(e) {
        let t = !!e?.["--w3m-font-family"];
        return {
          core: (0, c.AH)`
      ${
        t
          ? (0, c.AH)``
          : (0, c.AH)`
            @font-face {
              font-family: 'KHTeka';
              src:
                url(${(0, c.iz)(d["KHTeka-400-woff2"])}) format('woff2'),
                url(${(0, c.iz)(d["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
              font-display: swap;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${(0, c.iz)(d["KHTeka-300-woff2"])}) format('woff2'),
                url(${(0, c.iz)(d["KHTeka-300-woff"])}) format('woff');
              font-weight: 300;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTekaMono';
              src:
                url(${(0, c.iz)(d["KHTekaMono-400-woff2"])}) format('woff2'),
                url(${(0, c.iz)(d["KHTekaMono-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${(0, c.iz)(d["KHTeka-400-woff2"])}) format('woff2'),
                url(${(0, c.iz)(d["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }
          `
      }

      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --apkt-modal-width: 370px;

        --apkt-visual-size-inherit: inherit;
        --apkt-visual-size-sm: 40px;
        --apkt-visual-size-md: 55px;
        --apkt-visual-size-lg: 80px;

        --apkt-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --apkt-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --apkt-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --apkt-width-network-sm: 36px;
        --apkt-width-network-md: 48px;
        --apkt-width-network-lg: 86px;

        --apkt-duration-dynamic: 0ms;
        --apkt-height-network-sm: 40px;
        --apkt-height-network-md: 54px;
        --apkt-height-network-lg: 96px;
      }
    `,
          dark: (0, c.AH)`
      :root {
      }
    `,
          light: (0, c.AH)`
      :root {
      }
    `,
        };
      }
      let m = (0, c.AH)`
  div,
  span,
  iframe,
  a,
  img,
  form,
  button,
  label,
  *::after,
  *::before {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    backface-visibility: hidden;
  }

  :host {
    font-family: var(--apkt-fontFamily-regular);
  }
`,
        y = (0, c.AH)`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;

    will-change: background-color, color, border, box-shadow, width, height, transform, opacity;
    outline: none;
    border: none;
    text-decoration: none;
    transition:
      background-color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      box-shadow var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      width var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      height var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      transform var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      opacity var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      scale var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border-radius var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2);
    will-change:
      background-color, color, border, box-shadow, width, height, transform, opacity, scale,
      border-radius;
  }

  a:active:not([disabled]),
  button:active:not([disabled]) {
    scale: 0.975;
    transform-origin: center;
  }

  button:disabled {
    cursor: default;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
    },
    71305: (e, t, r) => {
      "use strict";
      r.d(t, { K1: () => s, kg: () => o, lj: () => a });
      var i = r(93481),
        n = r(28977);
      function s() {
        let e = i.W.state.activeCaipNetwork?.chainNamespace || "eip155",
          t = i.W.state.activeCaipNetwork?.id || 1,
          r = n.oU.NATIVE_TOKEN_ADDRESS[e];
        return `${e}:${t}:${r}`;
      }
      function a(e) {
        return i.W.getAccountData(e)?.preferredAccountType;
      }
      function o(e) {
        return e
          ? i.W.state.chains.get(e)?.networkState?.caipNetwork
          : i.W.state.activeCaipNetwork;
      }
    },
    72289: (e, t, r) => {
      "use strict";
      r.d(t, { v: () => s });
      var i = r(55480),
        n = r(3375);
      class s {
        constructor() {}
        static getInstance({
          projectId: e,
          chainId: t,
          enableLogger: r,
          onTimeout: a,
          abortController: o,
          getActiveCaipNetwork: c,
          getCaipNetworks: l,
        }) {
          return (
            s.instance ||
              (s.instance = new n.Y({
                projectId: e,
                chainId: t,
                enableLogger: r,
                onTimeout: a,
                abortController: o,
                getActiveCaipNetwork: c,
                getCaipNetworks: l,
                enableCloudAuthAccount:
                  !!i.H.state.remoteFeatures?.emailCapture,
              })),
            s.instance
          );
        }
      }
    },
    72427: (e, t, r) => {
      "use strict";
      r.d(t, { db: () => s, eV: () => n });
      var i = r(66969);
      function n(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? s(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new i.Fl({
                  size: e.length,
                  targetSize: r,
                  type: "bytes",
                });
              let n = new Uint8Array(r);
              for (let i = 0; i < r; i++) {
                let s = "right" === t;
                n[s ? i : r - i - 1] = e[s ? i : e.length - i - 1];
              }
              return n;
            })(e, { dir: t, size: r });
      }
      function s(e, { dir: t, size: r = 32 } = {}) {
        if (null === r) return e;
        let n = e.replace("0x", "");
        if (n.length > 2 * r)
          throw new i.Fl({
            size: Math.ceil(n.length / 2),
            targetSize: r,
            type: "hex",
          });
        return `0x${n["right" === t ? "padEnd" : "padStart"](2 * r, "0")}`;
      }
    },
    72557: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => i });
      let i = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
        DEFAULT_ALLOWED_ANCESTORS: [
          "http://localhost:*",
          "https://localhost:*",
          "http://127.0.0.1:*",
          "https://127.0.0.1:*",
          "https://*.pages.dev",
          "https://*.vercel.app",
          "https://*.ngrok-free.app",
          "https://secure-mobile.walletconnect.com",
          "https://secure-mobile.walletconnect.org",
        ],
      };
    },
    72880: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => b });
      var i = r(1220),
        n = r(98866),
        s = r(45553),
        a = r(14744),
        o = r(12319),
        c = r(32464),
        l = r(19831),
        d = r(58653),
        h = r(29936),
        u = r(93481),
        p = r(10899),
        f = r(70417),
        g = r(55480);
      let m = o.w.getApiUrl(),
        y = new c.Z({ baseUrl: m, clientId: null }),
        w = (0, i.BX)({
          promises: {},
          page: 1,
          count: 0,
          featured: [],
          allFeatured: [],
          recommended: [],
          allRecommended: [],
          wallets: [],
          filteredWallets: [],
          search: [],
          isAnalyticsEnabled: !1,
          excludedWallets: [],
          isFetchingRecommendedWallets: !1,
          explorerWallets: [],
          explorerFilteredWallets: [],
        }),
        b = {
          state: w,
          subscribeKey: (e, t) => (0, n.u$)(w, e, t),
          _getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = g.H.state;
            return {
              projectId: e,
              st: t || "appkit",
              sv: r || "html-wagmi-4.2.2",
            };
          },
          _filterOutExtensions: (e) =>
            g.H.state.isUniversalProvider
              ? e.filter(
                  (e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)
                )
              : e,
          async _fetchWalletImage(e) {
            let t = `${y.baseUrl}/getWalletImage/${e}`,
              r = await y.getBlob({ path: t, params: b._getSdkProperties() });
            h.j.setWalletImage(e, URL.createObjectURL(r));
          },
          async _fetchNetworkImage(e) {
            let t = `${y.baseUrl}/public/getAssetImage/${e}`,
              r = await y.getBlob({ path: t, params: b._getSdkProperties() });
            h.j.setNetworkImage(e, URL.createObjectURL(r));
          },
          async _fetchConnectorImage(e) {
            let t = `${y.baseUrl}/public/getAssetImage/${e}`,
              r = await y.getBlob({ path: t, params: b._getSdkProperties() });
            h.j.setConnectorImage(e, URL.createObjectURL(r));
          },
          async _fetchCurrencyImage(e) {
            let t = `${y.baseUrl}/public/getCurrencyImage/${e}`,
              r = await y.getBlob({ path: t, params: b._getSdkProperties() });
            h.j.setCurrencyImage(e, URL.createObjectURL(r));
          },
          async _fetchTokenImage(e) {
            let t = `${y.baseUrl}/public/getTokenImage/${e}`,
              r = await y.getBlob({ path: t, params: b._getSdkProperties() });
            h.j.setTokenImage(e, URL.createObjectURL(r));
          },
          _filterWalletsByPlatform(e) {
            let t = e.length,
              r = o.w.isMobile()
                ? e?.filter(
                    (e) =>
                      !!e.mobile_link ||
                      !!e.webapp_link ||
                      Object.values(l.O)
                        .map((e) => e.id)
                        .includes(e.id)
                  )
                : e,
              i = t - r.length;
            return { filteredWallets: r, mobileFilteredOutWalletsLength: i };
          },
          fetchProjectConfig: async () =>
            (
              await y.get({
                path: "/appkit/v1/config",
                params: b._getSdkProperties(),
              })
            ).features,
          async fetchAllowedOrigins() {
            try {
              let { allowedOrigins: e } = await y.get({
                path: "/projects/v1/origins",
                params: b._getSdkProperties(),
              });
              return e;
            } catch (e) {
              if (e instanceof Error && e.cause instanceof Response) {
                let t = e.cause.status;
                if (t === s.o.HTTP_STATUS_CODES.TOO_MANY_REQUESTS)
                  throw Error("RATE_LIMITED", { cause: e });
                if (t >= s.o.HTTP_STATUS_CODES.SERVER_ERROR && t < 600)
                  throw Error("SERVER_ERROR", { cause: e });
              }
              return [];
            }
          },
          async fetchNetworkImages() {
            let e = u.W.getAllRequestedCaipNetworks(),
              t = e
                ?.map(({ assets: e }) => e?.imageId)
                .filter(Boolean)
                .filter((e) => !a.$.getNetworkImageById(e));
            t &&
              (await Promise.allSettled(t.map((e) => b._fetchNetworkImage(e))));
          },
          async fetchConnectorImages() {
            let { connectors: e } = p.a.state,
              t = e.map(({ imageId: e }) => e).filter(Boolean);
            await Promise.allSettled(t.map((e) => b._fetchConnectorImage(e)));
          },
          async fetchCurrencyImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchCurrencyImage(e)));
          },
          async fetchTokenImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchTokenImage(e)));
          },
          async fetchWallets(e) {
            let t = e.exclude ?? [];
            b._getSdkProperties().sv.startsWith("html-core-") &&
              t.push(...Object.values(l.O).map((e) => e.id));
            let r = await y.get({
                path: "/getWallets",
                params: {
                  ...b._getSdkProperties(),
                  ...e,
                  page: String(e.page),
                  entries: String(e.entries),
                  include: e.include?.join(","),
                  exclude: t.join(","),
                },
              }),
              { filteredWallets: i, mobileFilteredOutWalletsLength: n } =
                b._filterWalletsByPlatform(r?.data);
            return {
              data: i || [],
              count: r?.count,
              mobileFilteredOutWalletsLength: n,
            };
          },
          async prefetchWalletRanks() {
            let e = p.a.state.connectors;
            if (!e?.length) return;
            let t = { page: 1, entries: 20, badge: "certified" };
            if (
              ((t.names = e.map((e) => e.name).join(",")),
              u.W.state.activeChain === s.o.CHAIN.EVM)
            ) {
              let r = [
                ...e.flatMap(
                  (e) => e.connectors?.map((e) => e.info?.rdns) || []
                ),
                ...e.map((e) => e.info?.rdns),
              ].filter((e) => "string" == typeof e && e.length > 0);
              r.length && (t.rdns = r.join(","));
            }
            let { data: r } = await b.fetchWallets(t);
            w.explorerWallets = r;
            let i = u.W.getRequestedCaipNetworkIds().join(",");
            w.explorerFilteredWallets = r.filter((e) =>
              e.chains?.some((e) => i.includes(e))
            );
          },
          async fetchFeaturedWallets() {
            let { featuredWalletIds: e } = g.H.state;
            if (e?.length) {
              let t = {
                  ...b._getSdkProperties(),
                  page: 1,
                  entries: e?.length ?? 4,
                  include: e,
                },
                { data: r } = await b.fetchWallets(t),
                i = [...r].sort((t, r) => e.indexOf(t.id) - e.indexOf(r.id)),
                n = i.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(n.map((e) => b._fetchWalletImage(e))),
                (w.featured = i),
                (w.allFeatured = i);
            }
          },
          async fetchRecommendedWallets() {
            try {
              w.isFetchingRecommendedWallets = !0;
              let {
                  includeWalletIds: e,
                  excludeWalletIds: t,
                  featuredWalletIds: r,
                } = g.H.state,
                i = [...(t ?? []), ...(r ?? [])].filter(Boolean),
                n = u.W.getRequestedCaipNetworkIds().join(","),
                { data: s, count: a } = await b.fetchWallets({
                  page: 1,
                  entries: 4,
                  include: e,
                  exclude: i,
                  chains: n,
                }),
                o = d.i.getRecentWallets(),
                c = s.map((e) => e.image_id).filter(Boolean),
                l = o.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(
                [...c, ...l].map((e) => b._fetchWalletImage(e))
              ),
                (w.recommended = s),
                (w.allRecommended = s),
                (w.count = a ?? 0);
            } catch {
            } finally {
              w.isFetchingRecommendedWallets = !1;
            }
          },
          async fetchWalletsByPage({ page: e }) {
            let {
                includeWalletIds: t,
                excludeWalletIds: r,
                featuredWalletIds: i,
              } = g.H.state,
              n = u.W.getRequestedCaipNetworkIds().join(","),
              s = [
                ...w.recommended.map(({ id: e }) => e),
                ...(r ?? []),
                ...(i ?? []),
              ].filter(Boolean),
              {
                data: a,
                count: c,
                mobileFilteredOutWalletsLength: l,
              } = await b.fetchWallets({
                page: e,
                entries: 40,
                include: t,
                exclude: s,
                chains: n,
              });
            w.mobileFilteredOutWalletsLength =
              l + (w.mobileFilteredOutWalletsLength ?? 0);
            let d = a
              .slice(0, 20)
              .map((e) => e.image_id)
              .filter(Boolean);
            await Promise.allSettled(d.map((e) => b._fetchWalletImage(e))),
              (w.wallets = o.w
                .uniqueBy([...w.wallets, ...b._filterOutExtensions(a)], "id")
                .filter((e) => e.chains?.some((e) => n.includes(e)))),
              (w.count = c > w.count ? c : w.count),
              (w.page = e);
          },
          async initializeExcludedWallets({ ids: e }) {
            let t = { page: 1, entries: e.length, include: e },
              { data: r } = await b.fetchWallets(t);
            r &&
              r.forEach((e) => {
                w.excludedWallets.push({ rdns: e.rdns, name: e.name });
              });
          },
          async searchWallet({ search: e, badge: t }) {
            let { includeWalletIds: r, excludeWalletIds: i } = g.H.state,
              n = u.W.getRequestedCaipNetworkIds().join(",");
            w.search = [];
            let s = {
                page: 1,
                entries: 100,
                search: e?.trim(),
                badge_type: t,
                include: r,
                exclude: i,
                chains: n,
              },
              { data: a } = await b.fetchWallets(s);
            f.E.sendEvent({
              type: "track",
              event: "SEARCH_WALLET",
              properties: { badge: t ?? "", search: e ?? "" },
            });
            let c = a.map((e) => e.image_id).filter(Boolean);
            await Promise.allSettled([
              ...c.map((e) => b._fetchWalletImage(e)),
              o.w.wait(300),
            ]),
              (w.search = b._filterOutExtensions(a));
          },
          initPromise(e, t) {
            let r = w.promises[e];
            return r || (w.promises[e] = t());
          },
          prefetch: ({
            fetchConnectorImages: e = !0,
            fetchFeaturedWallets: t = !0,
            fetchRecommendedWallets: r = !0,
            fetchNetworkImages: i = !0,
            fetchWalletRanks: n = !0,
          } = {}) =>
            Promise.allSettled(
              [
                e && b.initPromise("connectorImages", b.fetchConnectorImages),
                t && b.initPromise("featuredWallets", b.fetchFeaturedWallets),
                r &&
                  b.initPromise(
                    "recommendedWallets",
                    b.fetchRecommendedWallets
                  ),
                i && b.initPromise("networkImages", b.fetchNetworkImages),
                n && b.initPromise("walletRanks", b.prefetchWalletRanks),
              ].filter(Boolean)
            ),
          prefetchAnalyticsConfig() {
            g.H.state.features?.analytics && b.fetchAnalyticsConfig();
          },
          async fetchAnalyticsConfig() {
            try {
              let { isAnalyticsEnabled: e } = await y.get({
                path: "/getAnalyticsConfig",
                params: b._getSdkProperties(),
              });
              g.H.setFeatures({ analytics: e });
            } catch (e) {
              g.H.setFeatures({ analytics: !1 });
            }
          },
          filterByNamespaces(e) {
            if (!e?.length) {
              (w.featured = w.allFeatured), (w.recommended = w.allRecommended);
              return;
            }
            let t = u.W.getRequestedCaipNetworkIds().join(",");
            (w.featured = w.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (w.recommended = w.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              )),
              (w.filteredWallets = w.wallets.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
          clearFilterByNamespaces() {
            w.filteredWallets = [];
          },
          setFilterByNamespace(e) {
            if (!e) {
              (w.featured = w.allFeatured), (w.recommended = w.allRecommended);
              return;
            }
            let t = u.W.getRequestedCaipNetworkIds().join(",");
            (w.featured = w.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (w.recommended = w.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              )),
              (w.filteredWallets = w.wallets.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
        };
    },
    73022: (e, t, r) => {
      "use strict";
      r.d(t, {
        Ai: () => u,
        Hq: () => h,
        JR: () => f,
        OC: () => p,
        tz: () => d,
      });
      let i = Symbol(),
        n = Symbol(),
        s = Object.getPrototypeOf,
        a = new WeakMap(),
        o = (e) =>
          e &&
          (a.has(e)
            ? a.get(e)
            : s(e) === Object.prototype || s(e) === Array.prototype),
        c = (e) => "object" == typeof e && null !== e,
        l = (e) => e[n] || e,
        d = (e, t, r, a) => {
          if (!o(e)) return e;
          let c = a && a.get(e);
          if (!c) {
            let t = l(e);
            (c = Object.values(Object.getOwnPropertyDescriptors(t)).some(
              (e) => !e.configurable && !e.writable
            )
              ? [
                  t,
                  ((e) => {
                    if (Array.isArray(e)) return Array.from(e);
                    let t = Object.getOwnPropertyDescriptors(e);
                    return (
                      Object.values(t).forEach((e) => {
                        e.configurable = !0;
                      }),
                      Object.create(s(e), t)
                    );
                  })(t),
                ]
              : [t]),
              null == a || a.set(e, c);
          }
          let [h, u] = c,
            p = r && r.get(h);
          return (
            (!p || !!u !== p[1].f) &&
              (((p = ((e, t) => {
                let r = { f: t },
                  s = !1,
                  a = (t, i) => {
                    if (!s) {
                      let n = r.a.get(e);
                      if ((n || ((n = {}), r.a.set(e, n)), "w" === t)) n.w = !0;
                      else {
                        let e = n[t];
                        e || ((e = new Set()), (n[t] = e)), e.add(i);
                      }
                    }
                  },
                  o = {
                    get: (t, i) =>
                      i === n
                        ? e
                        : (a("k", i), d(Reflect.get(t, i), r.a, r.c, r.t)),
                    has: (t, n) =>
                      n === i
                        ? ((s = !0), r.a.delete(e), !0)
                        : (a("h", n), Reflect.has(t, n)),
                    getOwnPropertyDescriptor: (e, t) => (
                      a("o", t), Reflect.getOwnPropertyDescriptor(e, t)
                    ),
                    ownKeys: (e) => (a("w"), Reflect.ownKeys(e)),
                  };
                return t && (o.set = o.deleteProperty = () => !1), [o, r];
              })(h, !!u))[1].p = new Proxy(u || h, p[0])),
              r && r.set(h, p)),
            (p[1].a = t),
            (p[1].c = r),
            (p[1].t = a),
            p[1].p
          );
        },
        h = (e, t, r, i, n = Object.is) => {
          if (n(e, t)) return !1;
          if (!c(e) || !c(t)) return !0;
          let s = r.get(l(e));
          if (!s) return !0;
          if (i) {
            if (i.get(e) === t) return !1;
            i.set(e, t);
          }
          let a = null;
          for (let r of s.h || [])
            if ((a = Reflect.has(e, r) !== Reflect.has(t, r))) return a;
          if (!0 === s.w) {
            if (
              (a = ((e, t) => {
                let r = Reflect.ownKeys(e),
                  i = Reflect.ownKeys(t);
                return r.length !== i.length || r.some((e, t) => e !== i[t]);
              })(e, t))
            )
              return a;
          } else
            for (let r of s.o || []) {
              let i = !!Reflect.getOwnPropertyDescriptor(e, r);
              if ((a = !!Reflect.getOwnPropertyDescriptor(t, r) !== i))
                return a;
            }
          for (let o of s.k || []) if ((a = h(e[o], t[o], r, i, n))) return a;
          if (null === a) throw Error("invalid used");
          return a;
        },
        u = (e) => (o(e) && e[n]) || null,
        p = (e, t = !0) => {
          a.set(e, t);
        },
        f = (e, t, r) => {
          let i = [],
            n = new WeakSet(),
            s = (e, a) => {
              var o, d, h;
              if (n.has(e)) return;
              c(e) && n.add(e);
              let u = c(e) && t.get(l(e));
              if (u) {
                if (
                  (null == (o = u.h) ||
                    o.forEach((e) => {
                      let t = `:has(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    }),
                  !0 === u.w)
                ) {
                  let e = ":ownKeys";
                  i.push(a ? [...a, e] : [e]);
                } else
                  null == (d = u.o) ||
                    d.forEach((e) => {
                      let t = `:hasOwn(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    });
                null == (h = u.k) ||
                  h.forEach((t) => {
                    (!r ||
                      "value" in
                        (Object.getOwnPropertyDescriptor(e, t) || {})) &&
                      s(e[t], a ? [...a, t] : [t]);
                  });
              } else a && i.push(a);
            };
          return s(e), i;
        };
    },
    73168: (e, t, r) => {
      "use strict";
      r.d(t, {
        CL: () => c,
        D5: () => d,
        Di: () => u,
        G1: () => T,
        Gi: () => l,
        L5: () => _,
        MI: () => P,
        RV: () => E,
        Sf: () => C,
        WT: () => I,
        XU: () => o,
        YW: () => g,
        ab: () => m,
        bq: () => h,
        cg: () => k,
        ch: () => A,
        hA: () => p,
        hl: () => S,
        jz: () => O,
        qZ: () => f,
        s0: () => y,
        sV: () => v,
        uL: () => N,
        vx: () => b,
        xQ: () => w,
        xq: () => x,
      });
      var i = r(13933),
        n = r(4058);
      class s extends i.C {
        constructor(
          e,
          { code: t, docsPath: r, metaMessages: i, name: s, shortMessage: a }
        ) {
          super(a, {
            cause: e,
            docsPath: r,
            metaMessages: i || e?.metaMessages,
            name: s || "RpcError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = s || e.name),
            (this.code = e instanceof n.J8 ? e.code : t ?? -1);
        }
      }
      class a extends s {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class o extends s {
        constructor(e) {
          super(e, {
            code: o.code,
            name: "ParseRpcError",
            shortMessage:
              "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
          });
        }
      }
      Object.defineProperty(o, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class c extends s {
        constructor(e) {
          super(e, {
            code: c.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object.",
          });
        }
      }
      Object.defineProperty(c, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class l extends s {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: l.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${
              t ? ` "${t}"` : ""
            } does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(l, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class d extends s {
        constructor(e) {
          super(e, {
            code: d.code,
            name: "InvalidParamsRpcError",
            shortMessage:
              "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(d, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class h extends s {
        constructor(e) {
          super(e, {
            code: h.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received.",
          });
        }
      }
      Object.defineProperty(h, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class u extends s {
        constructor(e) {
          super(e, {
            code: u.code,
            name: "InvalidInputRpcError",
            shortMessage:
              "Missing or invalid parameters.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(u, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class p extends s {
        constructor(e) {
          super(e, {
            code: p.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ResourceNotFoundRpcError",
            });
        }
      }
      Object.defineProperty(p, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class f extends s {
        constructor(e) {
          super(e, {
            code: f.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available.",
          });
        }
      }
      Object.defineProperty(f, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class g extends s {
        constructor(e) {
          super(e, {
            code: g.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed.",
          });
        }
      }
      Object.defineProperty(g, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class m extends s {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: m.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`,
          });
        }
      }
      Object.defineProperty(m, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class y extends s {
        constructor(e) {
          super(e, {
            code: y.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit.",
          });
        }
      }
      Object.defineProperty(y, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class w extends s {
        constructor(e) {
          super(e, {
            code: w.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported.",
          });
        }
      }
      Object.defineProperty(w, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class b extends a {
        constructor(e) {
          super(e, {
            code: b.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request.",
          });
        }
      }
      Object.defineProperty(b, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class v extends a {
        constructor(e) {
          super(e, {
            code: v.code,
            name: "UnauthorizedProviderError",
            shortMessage:
              "The requested method and/or account has not been authorized by the user.",
          });
        }
      }
      Object.defineProperty(v, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class C extends a {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: C.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${
              t ? ` " ${t}"` : ""
            }.`,
          });
        }
      }
      Object.defineProperty(C, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class E extends a {
        constructor(e) {
          super(e, {
            code: E.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains.",
          });
        }
      }
      Object.defineProperty(E, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class x extends a {
        constructor(e) {
          super(e, {
            code: x.code,
            name: "ChainDisconnectedError",
            shortMessage:
              "The Provider is not connected to the requested chain.",
          });
        }
      }
      Object.defineProperty(x, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class A extends a {
        constructor(e) {
          super(e, {
            code: A.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain.",
          });
        }
      }
      Object.defineProperty(A, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class _ extends a {
        constructor(e) {
          super(e, {
            code: _.code,
            name: "UnsupportedNonOptionalCapabilityError",
            shortMessage:
              "This Wallet does not support a capability that was not marked as optional.",
          });
        }
      }
      Object.defineProperty(_, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5700,
      });
      class I extends a {
        constructor(e) {
          super(e, {
            code: I.code,
            name: "UnsupportedChainIdError",
            shortMessage:
              "This Wallet does not support the requested chain ID.",
          });
        }
      }
      Object.defineProperty(I, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5710,
      });
      class S extends a {
        constructor(e) {
          super(e, {
            code: S.code,
            name: "DuplicateIdError",
            shortMessage: "There is already a bundle submitted with this ID.",
          });
        }
      }
      Object.defineProperty(S, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5720,
      });
      class k extends a {
        constructor(e) {
          super(e, {
            code: k.code,
            name: "UnknownBundleIdError",
            shortMessage: "This bundle id is unknown / has not been submitted",
          });
        }
      }
      Object.defineProperty(k, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5730,
      });
      class N extends a {
        constructor(e) {
          super(e, {
            code: N.code,
            name: "BundleTooLargeError",
            shortMessage:
              "The call bundle is too large for the Wallet to process.",
          });
        }
      }
      Object.defineProperty(N, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5740,
      });
      class T extends a {
        constructor(e) {
          super(e, {
            code: T.code,
            name: "AtomicReadyWalletRejectedUpgradeError",
            shortMessage:
              "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.",
          });
        }
      }
      Object.defineProperty(T, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5750,
      });
      class O extends a {
        constructor(e) {
          super(e, {
            code: O.code,
            name: "AtomicityNotSupportedError",
            shortMessage:
              "The wallet does not support atomic execution but the request requires it.",
          });
        }
      }
      Object.defineProperty(O, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 5760,
      });
      class P extends s {
        constructor(e) {
          super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred.",
          });
        }
      }
    },
    73537: (e, t, r) => {
      "use strict";
      r.d(t, {
        OH: () => s,
        Vl: () => c,
        gS: () => a,
        hy: () => n,
        s1: () => o,
      });
      var i = r(95704);
      let n =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL
            : void 0) || "https://secure.walletconnect.org/sdk",
        s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
            : void 0) || "error",
        a =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
            : void 0) || "4",
        o = {
          APP_EVENT_KEY: "@w3m-app/",
          FRAME_EVENT_KEY: "@w3m-frame/",
          RPC_METHOD_KEY: "RPC_",
          STORAGE_KEY: "@appkit-wallet/",
          SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
          EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
          LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
          LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
          EMAIL: "EMAIL",
          PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
          SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
          SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
          SOCIAL_USERNAME: "SOCIAL_USERNAME",
          APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
          APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
          APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
          APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
          APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
          APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
          APP_GET_USER: "@w3m-app/GET_USER",
          APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
          APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
          APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
          APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
          APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
          APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
          APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
          APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
          APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
          APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
          APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
            "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
          APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
          APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
          APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
          APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
          APP_RELOAD: "@w3m-app/RELOAD",
          APP_RPC_ABORT: "@w3m-app/RPC_ABORT",
          FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
          FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
          FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
          FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
          FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
          FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
          FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
          FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
          FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
          FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
          FRAME_CONNECT_FARCASTER_SUCCESS:
            "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
          FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
          FRAME_GET_FARCASTER_URI_SUCCESS:
            "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
          FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
          FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
          FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
          FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
          FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
          FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
          FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
          FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
          FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
          FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
          FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
          FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
          FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
          FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
          FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
          FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
          FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
          FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
          FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
          FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
          FRAME_INIT_SMART_ACCOUNT_SUCCESS:
            "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
          FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
          FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
          FRAME_SET_PREFERRED_ACCOUNT_ERROR:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
          FRAME_READY: "@w3m-frame/READY",
          FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
          FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
          FRAME_RPC_ABORT_SUCCESS: "@w3m-frame/RPC_ABORT_SUCCESS",
          FRAME_RPC_ABORT_ERROR: "@w3m-frame/RPC_ABORT_ERROR",
          RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
          RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
          RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
        },
        c = {
          SAFE_RPC_METHODS: [
            "eth_accounts",
            "eth_blockNumber",
            "eth_call",
            "eth_chainId",
            "eth_estimateGas",
            "eth_feeHistory",
            "eth_gasPrice",
            "eth_getAccount",
            "eth_getBalance",
            "eth_getBlockByHash",
            "eth_getBlockByNumber",
            "eth_getBlockReceipts",
            "eth_getBlockTransactionCountByHash",
            "eth_getBlockTransactionCountByNumber",
            "eth_getCode",
            "eth_getFilterChanges",
            "eth_getFilterLogs",
            "eth_getLogs",
            "eth_getProof",
            "eth_getStorageAt",
            "eth_getTransactionByBlockHashAndIndex",
            "eth_getTransactionByBlockNumberAndIndex",
            "eth_getTransactionByHash",
            "eth_getTransactionCount",
            "eth_getTransactionReceipt",
            "eth_getUncleCountByBlockHash",
            "eth_getUncleCountByBlockNumber",
            "eth_maxPriorityFeePerGas",
            "eth_newBlockFilter",
            "eth_newFilter",
            "eth_newPendingTransactionFilter",
            "eth_sendRawTransaction",
            "eth_syncing",
            "eth_uninstallFilter",
            "wallet_getCapabilities",
            "wallet_getCallsStatus",
            "eth_getUserOperationReceipt",
            "eth_estimateUserOperationGas",
            "eth_getUserOperationByHash",
            "eth_supportedEntryPoints",
            "wallet_getAssets",
          ],
          NOT_SAFE_RPC_METHODS: [
            "personal_sign",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "solana_signMessage",
            "solana_signTransaction",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
            "wallet_sendCalls",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "eth_sendUserOperation",
          ],
          GET_CHAIN_ID: "eth_chainId",
          RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
          RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
          ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
        };
    },
    73987: (e, t, r) => {
      let i = r(89158),
        n = r(46342);
      function s(e) {
        (this.mode = i.KANJI), (this.data = e);
      }
      (s.getBitsLength = function (e) {
        return 13 * e;
      }),
        (s.prototype.getLength = function () {
          return this.data.length;
        }),
        (s.prototype.getBitsLength = function () {
          return s.getBitsLength(this.data.length);
        }),
        (s.prototype.write = function (e) {
          let t;
          for (t = 0; t < this.data.length; t++) {
            let r = n.toSJIS(this.data[t]);
            if (r >= 33088 && r <= 40956) r -= 33088;
            else if (r >= 57408 && r <= 60351) r -= 49472;
            else
              throw Error(
                "Invalid SJIS character: " +
                  this.data[t] +
                  "\nMake sure your charset is UTF-8"
              );
            (r = ((r >>> 8) & 255) * 192 + (255 & r)), e.put(r, 13);
          }
        }),
        (e.exports = s);
    },
    74678: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => i });
      let i = { URLS: { FAQ: "https://walletconnect.com/faq" } };
    },
    75484: (e, t, r) => {
      "use strict";
      r(21129);
    },
    75578: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => s });
      var i = r(45553),
        n = r(8567);
      let s = {
        ConnectorExplorerIds: {
          [i.o.CONNECTOR_ID.COINBASE]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.SAFE]:
            "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [i.o.CONNECTOR_ID.LEDGER]:
            "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
          [i.o.CONNECTOR_ID.OKX]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
          [n.o.METMASK_CONNECTOR_NAME]:
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
          [n.o.TRUST_CONNECTOR_NAME]:
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
          [n.o.SOLFLARE_CONNECTOR_NAME]:
            "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
          [n.o.PHANTOM_CONNECTOR_NAME]:
            "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
          [n.o.COIN98_CONNECTOR_NAME]:
            "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
          [n.o.MAGIC_EDEN_CONNECTOR_NAME]:
            "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
          [n.o.BACKPACK_CONNECTOR_NAME]:
            "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
          [n.o.BITGET_CONNECTOR_NAME]:
            "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
          [n.o.FRONTIER_CONNECTOR_NAME]:
            "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
          [n.o.XVERSE_CONNECTOR_NAME]:
            "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
          [n.o.LEATHER_CONNECTOR_NAME]:
            "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
          [n.o.OKX_CONNECTOR_NAME]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
        },
        NetworkImageIds: {
          1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
          295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
          0xaa36a7: "e909ea0a-f92a-4512-c8fc-748044ea6800",
          84532: "a18a7ecd-e307-4360-4746-283182228e00",
          1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
          130: "2257980a-3463-48c6-cbac-a42d2a956e00",
          10143: "0a728e83-bacb-46db-7844-948f05434900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          0x4e454152: "3ff73439-a619-4894-9262-4470c773a100",
          2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
          2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
          "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1:
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "000000000019d6689c085ae165831e93":
            "0b4838db-0161-4ffe-022d-532bf03dba00",
          "000000000933ea01ad0ee984209779ba":
            "39354064-d79b-420b-065d-f980c4b78200",
          "00000008819873e925422c1ff0f99f7c":
            "b3406e4a-bbfc-44fb-e3a6-89673c78b700",
        },
        ConnectorImageIds: {
          [i.o.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [i.o.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]:
            "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [i.o.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
        },
        ConnectorNamesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "Browser Wallet",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
          [i.o.CONNECTOR_ID.COINBASE]: "Coinbase",
          [i.o.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
          [i.o.CONNECTOR_ID.LEDGER]: "Ledger",
          [i.o.CONNECTOR_ID.SAFE]: "Safe",
        },
        ConnectorTypesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "INJECTED",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
          [i.o.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
          [i.o.CONNECTOR_ID.AUTH]: "AUTH",
          [n.o.CONNECTOR_TYPE_AUTH]: "AUTH",
        },
        WalletConnectRpcChainIds: [
          1, 5, 0xaa36a7, 10, 420, 42161, 421613, 137, 80001, 42220, 0x4e454152,
          0x4e454153, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
          280,
        ],
      };
    },
    75751: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => a });
      var i = r(1220),
        n = r(98866);
      let s = (0, i.BX)({ isLegalCheckboxChecked: !1 }),
        a = {
          state: s,
          subscribe: (e) => (0, i.B1)(s, () => e(s)),
          subscribeKey: (e, t) => (0, n.u$)(s, e, t),
          setIsLegalCheckboxChecked(e) {
            s.isLegalCheckboxChecked = e;
          },
        };
    },
    76115: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => n });
      var i = r(13933);
      class n extends i.C {
        constructor({ address: e }) {
          super(`Address "${e}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart.",
            ],
            name: "InvalidAddressError",
          });
        }
      }
    },
    76190: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n, P: () => s });
      var i = r(45553);
      let n = {
          caipNetworkIdToNumber: (e) => (e ? Number(e.split(":")[1]) : void 0),
          parseEvmChainId(e) {
            return "string" == typeof e ? this.caipNetworkIdToNumber(e) : e;
          },
          getNetworksByNamespace: (e, t) =>
            e?.filter((e) => e.chainNamespace === t) || [],
          getFirstNetworkByNamespace(e, t) {
            return this.getNetworksByNamespace(e, t)[0];
          },
          getNetworkNameByCaipNetworkId(e, t) {
            if (!t) return;
            let r = e.find((e) => e.caipNetworkId === t);
            if (r) return r.name;
            let [n] = t.split(":");
            return i.o.CHAIN_NAME_MAP?.[n] || void 0;
          },
        },
        s = [
          "eip155",
          "solana",
          "polkadot",
          "bip122",
          "cosmos",
          "sui",
          "stacks",
        ];
    },
    76275: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410);
      let s = (0,
        i.JW)`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="64" fill="#F7931A"/>
  <g clip-path="url(#clip0_1045_17)">
    <path d="M63.0394 39.7409C58.7654 56.8839 41.4024 67.3169 24.2574 63.0419C7.11937 58.7679 -3.31363 41.4039 0.962367 24.2619C5.23437 7.11686 22.5974 -3.31714 39.7374 0.956863C56.8814 5.23086 67.3134 22.5969 63.0394 39.7409Z" fill="#F7931A"/>
    <path d="M46.1092 27.4409C46.7462 23.1829 43.5042 20.8939 39.0712 19.3669L40.5092 13.5989L36.9982 12.7239L35.5982 18.3399C34.6752 18.1099 33.7272 17.8929 32.7852 17.6779L34.1952 12.0249L30.6862 11.1499L29.2472 16.9159C28.4832 16.7419 27.7332 16.5699 27.0052 16.3889L27.0092 16.3709L22.1672 15.1619L21.2332 18.9119C21.2332 18.9119 23.8382 19.5089 23.7832 19.5459C25.2052 19.9009 25.4622 20.8419 25.4192 21.5879L23.7812 28.1589C23.8792 28.1839 24.0062 28.2199 24.1462 28.2759C24.0292 28.2469 23.9042 28.2149 23.7752 28.1839L21.4792 37.3889C21.3052 37.8209 20.8642 38.4689 19.8702 38.2229C19.9052 38.2739 17.3182 37.5859 17.3182 37.5859L15.5752 41.6049L20.1442 42.7439C20.9942 42.9569 21.8272 43.1799 22.6472 43.3899L21.1942 49.2239L24.7012 50.0989L26.1402 44.3269C27.0982 44.5869 28.0282 44.8269 28.9382 45.0529L27.5042 50.7979L31.0152 51.6729L32.4682 45.8499C38.4552 46.9829 42.9572 46.5259 44.8522 41.1109C46.3792 36.7509 44.7762 34.2359 41.6262 32.5959C43.9202 32.0669 45.6482 30.5579 46.1092 27.4409ZM38.0872 38.6899C37.0022 43.0499 29.6612 40.6929 27.2812 40.1019L29.2092 32.3729C31.5892 32.9669 39.2212 34.1429 38.0872 38.6899ZM39.1732 27.3779C38.1832 31.3439 32.0732 29.3289 30.0912 28.8349L31.8392 21.8249C33.8212 22.3189 40.2042 23.2409 39.1732 27.3779Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_1045_17">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`,
        a = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `,
        o = (0, i.JW)`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `,
        c = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`,
        l = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `,
        d = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `,
        h = (0,
        i.JW)`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="64" rx="30" fill="#1DC956"/>
  <rect x="0.5" y="0.5" width="63" height="63" rx="29.5" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M32.4053 19.8031C35.3901 19.8031 38.0431 20.8349 40.1619 22.8247L45.9656 17.0211C42.4465 13.7416 37.8773 11.7333 32.4053 11.7333C24.4829 11.7333 17.6475 16.2841 14.3127 22.9168L21.056 28.1493C22.6589 23.359 27.136 19.8031 32.4053 19.8031Z" fill="#1DC956" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M32.4053 52.2667C37.8773 52.2667 42.465 50.4611 45.8182 47.3658L39.2407 42.2623C37.4351 43.4783 35.1321 44.2153 32.4053 44.2153C27.136 44.2153 22.6589 40.6594 21.056 35.8691L14.3127 41.1016C17.6475 47.7159 24.4829 52.2667 32.4053 52.2667Z" fill="#2BEE6C"/>
  <path d="M21.056 35.8507L19.5636 36.993L14.3127 41.0832M39.2407 42.2623L45.8182 47.3658C42.465 50.4611 37.8773 52.2667 32.4053 52.2667C24.4829 52.2667 17.6475 47.7159 14.3127 41.1016L21.056 35.8691C22.6589 40.6594 27.136 44.2153 32.4053 44.2153C35.1321 44.2153 37.4351 43.4783 39.2407 42.2623Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M51.8613 32.4606C51.8613 31.0235 51.7323 29.6417 51.4928 28.3151H32.4053V36.1638H43.3124C42.8334 38.688 41.3963 40.8252 39.2407 42.2623L45.8181 47.3658C49.6503 43.8283 51.8613 38.6327 51.8613 32.4606Z" fill="#1FAD7E" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" fill="#86F999"/>
  <path d="M21.056 35.8691L14.3127 41.1016M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
</svg>
`,
        u = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
        p = (0,
        i.JW)`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31636)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58318 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58318 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9269C60.4784 58.4159 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4159 2.1019 55.9269C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#794CFF"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M40 39.4595C44.7824 36.693 48 31.5222 48 25.6C48 16.7634 40.8366 9.59998 32 9.59998C23.1634 9.59998 16 16.7634 16 25.6C16 31.5222 19.2176 36.693 24 39.4595V45.8144H40V39.4595Z" fill="#906EF7"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#906EF7"/>
    <path d="M24 45.8144V39.4595C19.2176 36.693 16 31.5222 16 25.6C16 16.7634 23.1634 9.59998 32 9.59998C40.8366 9.59998 48 16.7634 48 25.6C48 31.5222 44.7824 36.693 40 39.4595V45.8144M24 45.8144H40M24 45.8144V49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#643CDD" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M29.6735 26.9101V29.1109H34.0753V26.9101C34.0753 25.6945 35.0607 24.7092 36.2762 24.7092C37.4917 24.7092 38.4771 25.6945 38.4771 26.9101C38.4771 28.1256 37.4917 29.1109 36.2762 29.1109H34.0753H29.6735H27.4726C26.2571 29.1109 25.2717 28.1256 25.2717 26.9101C25.2717 25.6945 26.2571 24.7092 27.4726 24.7092C28.6881 24.7092 29.6735 25.6945 29.6735 26.9101Z" fill="#906EF7"/>
    <path d="M29.6735 45.3183V26.9101C29.6735 25.6945 28.6881 24.7092 27.4726 24.7092V24.7092C26.2571 24.7092 25.2717 25.6945 25.2717 26.9101V26.9101C25.2717 28.1256 26.2571 29.1109 27.4726 29.1109H36.2762C37.4917 29.1109 38.4771 28.1256 38.4771 26.9101V26.9101C38.4771 25.6945 37.4917 24.7092 36.2762 24.7092V24.7092C35.0607 24.7092 34.0753 25.6945 34.0753 26.9101V45.3183" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31636">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`,
        f = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
        g = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `,
        m = (0,
        i.JW)`<svg width="40" height="42" viewBox="0 0 40 42" fill="none">
<path opacity="0.7" d="M19.9526 41.9076L7.3877 34.655V26.1226L19.9526 33.3751V41.9076Z" fill="url(#paint0_linear_2113_32117)"/>
<path opacity="0.7" d="M19.9521 41.9076L32.5171 34.655V26.1226L19.9521 33.3751V41.9076Z" fill="url(#paint1_linear_2113_32117)"/>
<path opacity="0.7" d="M39.9095 7.34521V21.8562L32.5166 26.1225V11.6114L39.9095 7.34521Z" fill="url(#paint2_linear_2113_32117)"/>
<path d="M39.9099 7.34536L27.345 0.0927734L19.9521 4.359L32.5171 11.6116L39.9099 7.34536Z" fill="url(#paint3_linear_2113_32117)"/>
<path d="M0 7.34536L12.5649 0.0927734L19.9519 4.359L7.387 11.6116L0 7.34536Z" fill="#F969D3"/>
<path opacity="0.7" d="M0 7.34521V21.8562L7.387 26.1225V11.6114L0 7.34521Z" fill="url(#paint4_linear_2113_32117)"/>
<defs>
<linearGradient id="paint0_linear_2113_32117" x1="18.6099" y1="41.8335" x2="7.73529" y2="8.31842" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
<linearGradient id="paint1_linear_2113_32117" x1="26.2346" y1="26.1226" x2="26.2346" y2="41.9076" gradientUnits="userSpaceOnUse">
<stop stop-color="#719DED"/>
<stop offset="1" stop-color="#2545BE"/>
</linearGradient>
<linearGradient id="paint2_linear_2113_32117" x1="36.213" y1="7.34521" x2="36.213" y2="26.1225" gradientUnits="userSpaceOnUse">
<stop stop-color="#93EBFF"/>
<stop offset="1" stop-color="#197DDB"/>
</linearGradient>
<linearGradient id="paint3_linear_2113_32117" x1="29.931" y1="0.0927734" x2="38.2156" y2="14.8448" gradientUnits="userSpaceOnUse">
<stop stop-color="#F969D3"/>
<stop offset="1" stop-color="#4F51C0"/>
</linearGradient>
<linearGradient id="paint4_linear_2113_32117" x1="18.1251" y1="44.2539" x2="-7.06792" y2="15.2763" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
</defs>
</svg>`,
        y = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`,
        w = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `,
        b = (0, i.JW)`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
        v = (0,
        i.JW)`<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`,
        C = (0,
        i.JW)`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31635)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58317 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58317 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9268C60.4784 58.4158 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4158 2.1019 55.9268C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#EB8B47"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M28.1042 49.2329L13.1024 51.2077L15.0772 36.2059L37.1015 14.1815C39.2441 12.039 40.3154 10.9677 41.5718 10.624C42.4205 10.3918 43.3159 10.3918 44.1645 10.624C45.421 10.9677 46.4922 12.039 48.6348 14.1815L50.1286 15.6753C52.2711 17.8179 53.3424 18.8891 53.6861 20.1456C53.9183 20.9942 53.9183 21.8896 53.6861 22.7383C53.3424 23.9947 52.2711 25.066 50.1286 27.2086L28.1042 49.2329Z" fill="#FF974C" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M38.5962 20.5376L22.4199 36.7139" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M43.7727 25.714L27.5964 41.8903" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M22.3703 36.7635C19.3258 39.808 16.0198 36.6395 16.2616 35.0324" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5466 41.9399C24.5034 44.9831 28.155 48.7098 29.2738 48.0475" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5468 41.9398C23.428 46.0586 18.2516 40.8822 22.3704 36.7634" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M15.8191 50.5214C15.4711 49.5823 14.728 48.8392 13.7889 48.4912" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M49.2862 29.5805L34.7275 15.0219" stroke="#E4E7E7" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31635">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`,
        E = (0, i.JW)`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `,
        x = (0, i.JW)`<svg fill="none" viewBox="0 0 80 80">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M40 80a40 40 0 1 0 0-80 40 40 0 0 0 0 80Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M79.5 40a39.5 39.5 0 1 1-79 0 39.5 39.5 0 0 1 79 0Z"
    />
    <path
      fill="#fff"
      d="m62.62 51.54-7.54 7.91a1.75 1.75 0 0 1-1.29.55H18.02a.9.9 0 0 1-.8-.52.84.84 0 0 1 .16-.92l7.55-7.92a1.75 1.75 0 0 1 1.28-.55h35.77a.87.87 0 0 1 .8.52.84.84 0 0 1-.16.93Zm-7.54-15.95a1.75 1.75 0 0 0-1.29-.54H18.02a.89.89 0 0 0-.8.51.84.84 0 0 0 .16.93l7.55 7.92a1.75 1.75 0 0 0 1.28.54h35.77a.89.89 0 0 0 .8-.51.84.84 0 0 0-.16-.93l-7.54-7.92ZM18.02 29.9h35.77a1.79 1.79 0 0 0 1.29-.54l7.54-7.92a.85.85 0 0 0 .16-.93.87.87 0 0 0-.8-.51H26.21a1.79 1.79 0 0 0-1.28.54l-7.55 7.92a.85.85 0 0 0-.16.93.89.89 0 0 0 .8.52Z"
    />
  </g>
  <defs>
    <linearGradient id="b" x1="6.75" x2="80.68" y1="81.91" y2="7.37" gradientUnits="userSpaceOnUse">
      <stop offset=".08" stop-color="#9945FF" />
      <stop offset=".3" stop-color="#8752F3" />
      <stop offset=".5" stop-color="#5497D5" />
      <stop offset=".6" stop-color="#43B4CA" />
      <stop offset=".72" stop-color="#28E0B9" />
      <stop offset=".97" stop-color="#19FB9B" />
    </linearGradient>
    <clipPath id="a"><path fill="#fff" d="M0 0h80v80H0z" /></clipPath>
  </defs>
</svg> `,
        A = (0, i.JW)`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
      var _ = r(71084),
        I = r(47327);
      let S = (0, i.AH)`
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;
      var k = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let N = {
          browser: a,
          dao: o,
          defi: c,
          defiAlt: l,
          eth: d,
          layers: u,
          lock: f,
          login: g,
          network: y,
          nft: w,
          noun: b,
          profile: E,
          system: A,
          meld: m,
          onrampCard: v,
          google: h,
          pencil: C,
          lightbulb: p,
          solana: x,
          bitcoin: s,
        },
        T = class extends i.WF {
          constructor() {
            super(...arguments), (this.name = "browser"), (this.size = "md");
          }
          render() {
            return (
              (this.style.cssText = `
       --local-size: var(--apkt-visual-size-${this.size});
   `),
              (0, i.qy)`${N[this.name]}`
            );
          }
        };
      (T.styles = [_.W5, S]),
        k([(0, n.MZ)()], T.prototype, "name", void 0),
        k([(0, n.MZ)()], T.prototype, "size", void 0),
        (T = k([(0, I.E)("wui-visual")], T));
    },
    77237: (e, t, r) => {
      "use strict";
      r(99691);
    },
    77608: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => d, o: () => l });
      var i = r(76115),
        n = r(55563),
        s = r(80329),
        a = r(20390),
        o = r(24784);
      let c = new a.A(8192);
      function l(e, t) {
        if (c.has(`${e}.${t}`)) return c.get(`${e}.${t}`);
        let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
          i = (0, s.S)((0, n.Af)(r), "bytes"),
          a = (t ? r.substring(`${t}0x`.length) : r).split("");
        for (let e = 0; e < 40; e += 2)
          i[e >> 1] >> 4 >= 8 && a[e] && (a[e] = a[e].toUpperCase()),
            (15 & i[e >> 1]) >= 8 &&
              a[e + 1] &&
              (a[e + 1] = a[e + 1].toUpperCase());
        let o = `0x${a.join("")}`;
        return c.set(`${e}.${t}`, o), o;
      }
      function d(e, t) {
        if (!(0, o.P)(e, { strict: !1 })) throw new i.M({ address: e });
        return l(e, t);
      }
    },
    78140: (e, t, r) => {
      "use strict";
      async function i(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      r.d(t, { u: () => i });
    },
    78790: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964);
      r(99691), r(24772), r(84042);
      var a = r(71084),
        o = r(47327);
      r(18294);
      var c = r(20296);
      let l = (0, c.AH)`
  :host {
    position: relative;
    border-radius: ${({ borderRadius: e }) => e[2]};
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: ${({ tokens: e }) => e.theme.foregroundPrimary};
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    column-gap: ${({ spacing: e }) => e[1]};
    padding: ${({ spacing: e }) => e[1]};
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: 2px;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments), (this.walletImages = []);
        }
        render() {
          let e = this.walletImages.length < 4;
          return (0, i.qy)`${this.walletImages.slice(0, 4).map(
            ({ src: e, walletName: t }) => (0, i.qy)`
          <wui-wallet-image
            size="sm"
            imageSrc=${e}
            name=${(0, s.J)(t)}
          ></wui-wallet-image>
        `
          )}
    ${
      e
        ? [...Array(4 - this.walletImages.length)].map(
            () =>
              (0,
              i.qy)` <wui-wallet-image size="sm" name=""></wui-wallet-image>`
          )
        : null
    } `;
        }
      };
      (h.styles = [a.W5, l]),
        d([(0, n.MZ)({ type: Array })], h.prototype, "walletImages", void 0),
        (h = d([(0, o.E)("wui-all-wallets-image")], h)),
        r(50505);
      let u = (0, c.AH)`
  :host {
    width: 100%;
  }

  button {
    column-gap: ${({ spacing: e }) => e[2]};
    padding: ${({ spacing: e }) => e[3]};
    width: 100%;
    background-color: transparent;
    border-radius: ${({ borderRadius: e }) => e[4]};
    color: ${({ tokens: e }) => e.theme.textPrimary};
  }

  button > wui-wallet-image {
    background: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:hover:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  button[data-all-wallets='true'] {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  button[data-all-wallets='true']:hover:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  button:focus-visible:enabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    box-shadow: 0 0 0 4px ${({ tokens: e }) => e.core.foregroundAccent020};
  }

  button:disabled {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:disabled > wui-tag {
    background-color: ${({ tokens: e }) => e.core.glass010};
    color: ${({ tokens: e }) => e.theme.foregroundTertiary};
  }
`;
      var p = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let f = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.walletImages = []),
            (this.imageSrc = ""),
            (this.name = ""),
            (this.size = "md"),
            (this.tabIdx = void 0),
            (this.disabled = !1),
            (this.showAllWallets = !1),
            (this.loading = !1),
            (this.loadingSpinnerColor = "accent-100");
        }
        render() {
          return (
            (this.dataset.size = this.size),
            (0, i.qy)`
      <button
        ?disabled=${this.disabled}
        data-all-wallets=${this.showAllWallets}
        tabindex=${(0, s.J)(this.tabIdx)}
      >
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="lg-regular" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `
          );
        }
        templateAllWallets() {
          return this.showAllWallets && this.imageSrc
            ? (0,
              i.qy)` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `
            : this.showAllWallets && this.walletIcon
            ? (0,
              i.qy)` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `
            : null;
        }
        templateWalletImage() {
          return !this.showAllWallets && this.imageSrc
            ? (0, i.qy)`<wui-wallet-image
        size=${(0, s.J)("sm" === this.size ? "sm" : "md")}
        imageSrc=${this.imageSrc}
        name=${this.name}
      ></wui-wallet-image>`
            : this.showAllWallets || this.imageSrc
            ? null
            : (0,
              i.qy)`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
        }
        templateStatus() {
          return this.loading
            ? (0,
              i.qy)`<wui-loading-spinner size="lg" color="accent-primary"></wui-loading-spinner>`
            : this.tagLabel && this.tagVariant
            ? (0,
              i.qy)`<wui-tag size="sm" variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`
            : null;
        }
      };
      (f.styles = [a.W5, a.fD, u]),
        p([(0, n.MZ)({ type: Array })], f.prototype, "walletImages", void 0),
        p([(0, n.MZ)()], f.prototype, "imageSrc", void 0),
        p([(0, n.MZ)()], f.prototype, "name", void 0),
        p([(0, n.MZ)()], f.prototype, "size", void 0),
        p([(0, n.MZ)()], f.prototype, "tagLabel", void 0),
        p([(0, n.MZ)()], f.prototype, "tagVariant", void 0),
        p([(0, n.MZ)()], f.prototype, "walletIcon", void 0),
        p([(0, n.MZ)()], f.prototype, "tabIdx", void 0),
        p([(0, n.MZ)({ type: Boolean })], f.prototype, "disabled", void 0),
        p(
          [(0, n.MZ)({ type: Boolean })],
          f.prototype,
          "showAllWallets",
          void 0
        ),
        p([(0, n.MZ)({ type: Boolean })], f.prototype, "loading", void 0),
        p(
          [(0, n.MZ)({ type: String })],
          f.prototype,
          "loadingSpinnerColor",
          void 0
        ),
        (f = p([(0, o.E)("wui-list-wallet")], f));
    },
    78964: (e, t, r) => {
      "use strict";
      r.d(t, { J: () => n });
      var i = r(52321);
      let n = (e) => e ?? i.s6;
    },
    79355: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => c });
      var i = r(45553),
        n = r(93481),
        s = r(10899),
        a = r(58653),
        o = r(8567);
      let c = {
        getCaipTokens(e) {
          if (!e) return;
          let t = {};
          return (
            Object.entries(e).forEach(([e, r]) => {
              t[`${o.o.EIP155}:${e}`] = r;
            }),
            t
          );
        },
        isLowerCaseMatch: (e, t) => e?.toLowerCase() === t?.toLowerCase(),
        getActiveNamespaceConnectedToAuth() {
          let e = n.W.state.activeChain;
          return i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
            (t) => s.a.getConnectorId(t) === i.o.CONNECTOR_ID.AUTH && t === e
          );
        },
        withRetry({ conditionFn: e, intervalMs: t, maxRetries: r }) {
          let i = 0;
          return new Promise((n) => {
            async function s() {
              return ((i += 1), await e())
                ? n(!0)
                : i >= r
                ? n(!1)
                : (setTimeout(s, t), null);
            }
            s();
          });
        },
        userChainIdToChainNamespace(e) {
          if ("number" == typeof e) return i.o.CHAIN.EVM;
          let [t] = e.split(":");
          return t;
        },
        getOtherAuthNamespaces: (e) =>
          e ? i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.filter((t) => t !== e) : [],
        getConnectorStorageInfo(e, t) {
          let r = a.i.getConnections()[t] ?? [];
          return {
            hasDisconnected: a.i.isConnectorDisconnected(e, t),
            hasConnected: r.some((t) => c.isLowerCaseMatch(t.connectorId, e)),
          };
        },
      };
    },
    79530: (e, t, r) => {
      "use strict";
      r.d(t, { RQ: () => i, vx: () => s });
      let i = {
        RPC_ERROR_CODE: { USER_REJECTED_REQUEST: 4001 },
        PROVIDER_RPC_ERROR_NAME: {
          PROVIDER_RPC: "ProviderRpcError",
          USER_REJECTED_REQUEST: "UserRejectedRequestError",
        },
        isRpcProviderError(e) {
          try {
            if ("object" == typeof e && null !== e) {
              let t = "string" == typeof e.message,
                r = "number" == typeof e.code;
              return t && r;
            }
            return !1;
          } catch {
            return !1;
          }
        },
        isUserRejectedMessage: (e) =>
          e.toLowerCase().includes("user rejected") ||
          e.toLowerCase().includes("user cancelled") ||
          e.toLowerCase().includes("user canceled"),
        isUserRejectedRequestError: (e) =>
          i.isRpcProviderError(e)
            ? e.code === i.RPC_ERROR_CODE.USER_REJECTED_REQUEST ||
              i.isUserRejectedMessage(e.message)
            : e instanceof Error && i.isUserRejectedMessage(e.message),
      };
      class n extends Error {
        constructor(e, t) {
          super(t.message, { cause: e }),
            (this.name = i.PROVIDER_RPC_ERROR_NAME.PROVIDER_RPC),
            (this.code = t.code);
        }
      }
      class s extends n {
        constructor(e) {
          super(e, {
            code: i.RPC_ERROR_CODE.USER_REJECTED_REQUEST,
            message: "User rejected the request",
          }),
            (this.name = i.PROVIDER_RPC_ERROR_NAME.USER_REJECTED_REQUEST);
        }
      }
    },
    80329: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => o });
      var i = r(26368),
        n = r(60587),
        s = r(55563),
        a = r(34561);
      function o(e, t) {
        let r = (0, i.lY)((0, n.q)(e, { strict: !1 }) ? (0, s.ZJ)(e) : e);
        return "bytes" === (t || "hex") ? r : (0, a.nj)(r);
      }
    },
    80361: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_YEAR =
          t.FOUR_WEEKS =
          t.THREE_WEEKS =
          t.TWO_WEEKS =
          t.ONE_WEEK =
          t.THIRTY_DAYS =
          t.SEVEN_DAYS =
          t.FIVE_DAYS =
          t.THREE_DAYS =
          t.ONE_DAY =
          t.TWENTY_FOUR_HOURS =
          t.TWELVE_HOURS =
          t.SIX_HOURS =
          t.THREE_HOURS =
          t.ONE_HOUR =
          t.SIXTY_MINUTES =
          t.THIRTY_MINUTES =
          t.TEN_MINUTES =
          t.FIVE_MINUTES =
          t.ONE_MINUTE =
          t.SIXTY_SECONDS =
          t.THIRTY_SECONDS =
          t.TEN_SECONDS =
          t.FIVE_SECONDS =
          t.ONE_SECOND =
            void 0),
        (t.ONE_SECOND = 1),
        (t.FIVE_SECONDS = 5),
        (t.TEN_SECONDS = 10),
        (t.THIRTY_SECONDS = 30),
        (t.SIXTY_SECONDS = 60),
        (t.ONE_MINUTE = t.SIXTY_SECONDS),
        (t.FIVE_MINUTES = 5 * t.ONE_MINUTE),
        (t.TEN_MINUTES = 10 * t.ONE_MINUTE),
        (t.THIRTY_MINUTES = 30 * t.ONE_MINUTE),
        (t.SIXTY_MINUTES = 60 * t.ONE_MINUTE),
        (t.ONE_HOUR = t.SIXTY_MINUTES),
        (t.THREE_HOURS = 3 * t.ONE_HOUR),
        (t.SIX_HOURS = 6 * t.ONE_HOUR),
        (t.TWELVE_HOURS = 12 * t.ONE_HOUR),
        (t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR),
        (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
        (t.THREE_DAYS = 3 * t.ONE_DAY),
        (t.FIVE_DAYS = 5 * t.ONE_DAY),
        (t.SEVEN_DAYS = 7 * t.ONE_DAY),
        (t.THIRTY_DAYS = 30 * t.ONE_DAY),
        (t.ONE_WEEK = t.SEVEN_DAYS),
        (t.TWO_WEEKS = 2 * t.ONE_WEEK),
        (t.THREE_WEEKS = 3 * t.ONE_WEEK),
        (t.FOUR_WEEKS = 4 * t.ONE_WEEK),
        (t.ONE_YEAR = 365 * t.ONE_DAY);
    },
    81010: (e, t, r) => {
      let i = r(24967),
        n = [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4,
          4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8,
          10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6,
          11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23,
          25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12,
          23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29,
          40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51,
          60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74,
          24, 47, 65, 77, 25, 49, 68, 81,
        ],
        s = [
          7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48,
          72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110,
          160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308,
          104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280,
          408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650,
          224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504,
          750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952,
          1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140,
          1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350,
          1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590,
          1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860,
          2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
        ];
      (t.getBlocksCount = function (e, t) {
        switch (t) {
          case i.L:
            return n[(e - 1) * 4 + 0];
          case i.M:
            return n[(e - 1) * 4 + 1];
          case i.Q:
            return n[(e - 1) * 4 + 2];
          case i.H:
            return n[(e - 1) * 4 + 3];
          default:
            return;
        }
      }),
        (t.getTotalCodewordsCount = function (e, t) {
          switch (t) {
            case i.L:
              return s[(e - 1) * 4 + 0];
            case i.M:
              return s[(e - 1) * 4 + 1];
            case i.Q:
              return s[(e - 1) * 4 + 2];
            case i.H:
              return s[(e - 1) * 4 + 3];
            default:
              return;
          }
        });
    },
    81029: (e, t, r) => {
      "use strict";
      let i = r(51746),
        n = r(55459),
        s =
          "function" == typeof Symbol && "function" == typeof Symbol.for
            ? Symbol.for("nodejs.util.inspect.custom")
            : null;
      function a(e) {
        if (e > 0x7fffffff)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
        let t = new Uint8Array(e);
        return Object.setPrototypeOf(t, o.prototype), t;
      }
      function o(e, t, r) {
        if ("number" == typeof e) {
          if ("string" == typeof t)
            throw TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return d(e);
        }
        return c(e, t, r);
      }
      function c(e, t, r) {
        if ("string" == typeof e) {
          var i = e,
            n = t;
          if (
            (("string" != typeof n || "" === n) && (n = "utf8"),
            !o.isEncoding(n))
          )
            throw TypeError("Unknown encoding: " + n);
          let r = 0 | f(i, n),
            s = a(r),
            c = s.write(i, n);
          return c !== r && (s = s.slice(0, c)), s;
        }
        if (ArrayBuffer.isView(e)) {
          var s = e;
          if (M(s, Uint8Array)) {
            let e = new Uint8Array(s);
            return u(e.buffer, e.byteOffset, e.byteLength);
          }
          return h(s);
        }
        if (null == e)
          throw TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof e
          );
        if (
          M(e, ArrayBuffer) ||
          (e && M(e.buffer, ArrayBuffer)) ||
          ("undefined" != typeof SharedArrayBuffer &&
            (M(e, SharedArrayBuffer) || (e && M(e.buffer, SharedArrayBuffer))))
        )
          return u(e, t, r);
        if ("number" == typeof e)
          throw TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        let c = e.valueOf && e.valueOf();
        if (null != c && c !== e) return o.from(c, t, r);
        let l = (function (e) {
          if (o.isBuffer(e)) {
            let t = 0 | p(e.length),
              r = a(t);
            return 0 === r.length || e.copy(r, 0, 0, t), r;
          }
          return void 0 !== e.length
            ? "number" != typeof e.length ||
              (function (e) {
                return e != e;
              })(e.length)
              ? a(0)
              : h(e)
            : "Buffer" === e.type && Array.isArray(e.data)
            ? h(e.data)
            : void 0;
        })(e);
        if (l) return l;
        if (
          "undefined" != typeof Symbol &&
          null != Symbol.toPrimitive &&
          "function" == typeof e[Symbol.toPrimitive]
        )
          return o.from(e[Symbol.toPrimitive]("string"), t, r);
        throw TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof e
        );
      }
      function l(e) {
        if ("number" != typeof e)
          throw TypeError('"size" argument must be of type number');
        if (e < 0)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
      }
      function d(e) {
        return l(e), a(e < 0 ? 0 : 0 | p(e));
      }
      function h(e) {
        let t = e.length < 0 ? 0 : 0 | p(e.length),
          r = a(t);
        for (let i = 0; i < t; i += 1) r[i] = 255 & e[i];
        return r;
      }
      function u(e, t, r) {
        let i;
        if (t < 0 || e.byteLength < t)
          throw RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (r || 0))
          throw RangeError('"length" is outside of buffer bounds');
        return (
          Object.setPrototypeOf(
            (i =
              void 0 === t && void 0 === r
                ? new Uint8Array(e)
                : void 0 === r
                ? new Uint8Array(e, t)
                : new Uint8Array(e, t, r)),
            o.prototype
          ),
          i
        );
      }
      function p(e) {
        if (e >= 0x7fffffff)
          throw RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes"
          );
        return 0 | e;
      }
      function f(e, t) {
        if (o.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || M(e, ArrayBuffer)) return e.byteLength;
        if ("string" != typeof e)
          throw TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof e
          );
        let r = e.length,
          i = arguments.length > 2 && !0 === arguments[2];
        if (!i && 0 === r) return 0;
        let n = !1;
        for (;;)
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return $(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;
            case "hex":
              return r >>> 1;
            case "base64":
              return D(e).length;
            default:
              if (n) return i ? -1 : $(e).length;
              (t = ("" + t).toLowerCase()), (n = !0);
          }
      }
      function g(e, t, r) {
        let n = !1;
        if (
          ((void 0 === t || t < 0) && (t = 0),
          t > this.length ||
            ((void 0 === r || r > this.length) && (r = this.length),
            r <= 0 || (r >>>= 0) <= (t >>>= 0)))
        )
          return "";
        for (e || (e = "utf8"); ; )
          switch (e) {
            case "hex":
              return (function (e, t, r) {
                let i = e.length;
                (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
                let n = "";
                for (let i = t; i < r; ++i) n += L[e[i]];
                return n;
              })(this, t, r);
            case "utf8":
            case "utf-8":
              return b(this, t, r);
            case "ascii":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let n = t; n < r; ++n)
                  i += String.fromCharCode(127 & e[n]);
                return i;
              })(this, t, r);
            case "latin1":
            case "binary":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let n = t; n < r; ++n) i += String.fromCharCode(e[n]);
                return i;
              })(this, t, r);
            case "base64":
              var s, a, o;
              return (
                (s = this),
                (a = t),
                (o = r),
                0 === a && o === s.length
                  ? i.fromByteArray(s)
                  : i.fromByteArray(s.slice(a, o))
              );
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return (function (e, t, r) {
                let i = e.slice(t, r),
                  n = "";
                for (let e = 0; e < i.length - 1; e += 2)
                  n += String.fromCharCode(i[e] + 256 * i[e + 1]);
                return n;
              })(this, t, r);
            default:
              if (n) throw TypeError("Unknown encoding: " + e);
              (e = (e + "").toLowerCase()), (n = !0);
          }
      }
      function m(e, t, r) {
        let i = e[t];
        (e[t] = e[r]), (e[r] = i);
      }
      function y(e, t, r, i, n) {
        var s;
        if (0 === e.length) return -1;
        if (
          ("string" == typeof r
            ? ((i = r), (r = 0))
            : r > 0x7fffffff
            ? (r = 0x7fffffff)
            : r < -0x80000000 && (r = -0x80000000),
          (s = r *= 1) != s && (r = n ? 0 : e.length - 1),
          r < 0 && (r = e.length + r),
          r >= e.length)
        )
          if (n) return -1;
          else r = e.length - 1;
        else if (r < 0)
          if (!n) return -1;
          else r = 0;
        if (("string" == typeof t && (t = o.from(t, i)), o.isBuffer(t)))
          return 0 === t.length ? -1 : w(e, t, r, i, n);
        if ("number" == typeof t) {
          if (((t &= 255), "function" == typeof Uint8Array.prototype.indexOf))
            if (n) return Uint8Array.prototype.indexOf.call(e, t, r);
            else return Uint8Array.prototype.lastIndexOf.call(e, t, r);
          return w(e, [t], r, i, n);
        }
        throw TypeError("val must be string, number or Buffer");
      }
      function w(e, t, r, i, n) {
        let s,
          a = 1,
          o = e.length,
          c = t.length;
        if (
          void 0 !== i &&
          ("ucs2" === (i = String(i).toLowerCase()) ||
            "ucs-2" === i ||
            "utf16le" === i ||
            "utf-16le" === i)
        ) {
          if (e.length < 2 || t.length < 2) return -1;
          (a = 2), (o /= 2), (c /= 2), (r /= 2);
        }
        function l(e, t) {
          return 1 === a ? e[t] : e.readUInt16BE(t * a);
        }
        if (n) {
          let i = -1;
          for (s = r; s < o; s++)
            if (l(e, s) === l(t, -1 === i ? 0 : s - i)) {
              if ((-1 === i && (i = s), s - i + 1 === c)) return i * a;
            } else -1 !== i && (s -= s - i), (i = -1);
        } else
          for (r + c > o && (r = o - c), s = r; s >= 0; s--) {
            let r = !0;
            for (let i = 0; i < c; i++)
              if (l(e, s + i) !== l(t, i)) {
                r = !1;
                break;
              }
            if (r) return s;
          }
        return -1;
      }
      function b(e, t, r) {
        r = Math.min(e.length, r);
        let i = [],
          n = t;
        for (; n < r; ) {
          let t = e[n],
            s = null,
            a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
          if (n + a <= r) {
            let r, i, o, c;
            switch (a) {
              case 1:
                t < 128 && (s = t);
                break;
              case 2:
                (192 & (r = e[n + 1])) == 128 &&
                  (c = ((31 & t) << 6) | (63 & r)) > 127 &&
                  (s = c);
                break;
              case 3:
                (r = e[n + 1]),
                  (i = e[n + 2]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (c = ((15 & t) << 12) | ((63 & r) << 6) | (63 & i)) >
                      2047 &&
                    (c < 55296 || c > 57343) &&
                    (s = c);
                break;
              case 4:
                (r = e[n + 1]),
                  (i = e[n + 2]),
                  (o = e[n + 3]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (192 & o) == 128 &&
                    (c =
                      ((15 & t) << 18) |
                      ((63 & r) << 12) |
                      ((63 & i) << 6) |
                      (63 & o)) > 65535 &&
                    c < 1114112 &&
                    (s = c);
            }
          }
          null === s
            ? ((s = 65533), (a = 1))
            : s > 65535 &&
              ((s -= 65536),
              i.push(((s >>> 10) & 1023) | 55296),
              (s = 56320 | (1023 & s))),
            i.push(s),
            (n += a);
        }
        var s = i;
        let a = s.length;
        if (a <= 4096) return String.fromCharCode.apply(String, s);
        let o = "",
          c = 0;
        for (; c < a; )
          o += String.fromCharCode.apply(String, s.slice(c, (c += 4096)));
        return o;
      }
      function v(e, t, r) {
        if (e % 1 != 0 || e < 0) throw RangeError("offset is not uint");
        if (e + t > r)
          throw RangeError("Trying to access beyond buffer length");
      }
      function C(e, t, r, i, n, s) {
        if (!o.isBuffer(e))
          throw TypeError('"buffer" argument must be a Buffer instance');
        if (t > n || t < s)
          throw RangeError('"value" argument is out of bounds');
        if (r + i > e.length) throw RangeError("Index out of range");
      }
      function E(e, t, r, i, n) {
        T(t, i, n, e, r, 7);
        let s = Number(t & BigInt(0xffffffff));
        (e[r++] = s),
          (s >>= 8),
          (e[r++] = s),
          (s >>= 8),
          (e[r++] = s),
          (s >>= 8),
          (e[r++] = s);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          r
        );
      }
      function x(e, t, r, i, n) {
        T(t, i, n, e, r, 7);
        let s = Number(t & BigInt(0xffffffff));
        (e[r + 7] = s),
          (s >>= 8),
          (e[r + 6] = s),
          (s >>= 8),
          (e[r + 5] = s),
          (s >>= 8),
          (e[r + 4] = s);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r + 3] = a),
          (a >>= 8),
          (e[r + 2] = a),
          (a >>= 8),
          (e[r + 1] = a),
          (a >>= 8),
          (e[r] = a),
          r + 8
        );
      }
      function A(e, t, r, i, n, s) {
        if (r + i > e.length || r < 0) throw RangeError("Index out of range");
      }
      function _(e, t, r, i, s) {
        return (
          (t *= 1),
          (r >>>= 0),
          s || A(e, t, r, 4, 34028234663852886e22, -34028234663852886e22),
          n.write(e, t, r, i, 23, 4),
          r + 4
        );
      }
      function I(e, t, r, i, s) {
        return (
          (t *= 1),
          (r >>>= 0),
          s || A(e, t, r, 8, 17976931348623157e292, -17976931348623157e292),
          n.write(e, t, r, i, 52, 8),
          r + 8
        );
      }
      (t.Buffer = o),
        (t.SlowBuffer = function (e) {
          return +e != e && (e = 0), o.alloc(+e);
        }),
        (t.INSPECT_MAX_BYTES = 50),
        (t.kMaxLength = 0x7fffffff),
        (o.TYPED_ARRAY_SUPPORT = (function () {
          try {
            let e = new Uint8Array(1),
              t = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (e) {
            return !1;
          }
        })()),
        o.TYPED_ARRAY_SUPPORT ||
          "undefined" == typeof console ||
          "function" != typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(o.prototype, "parent", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(o.prototype, "offset", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.byteOffset;
          },
        }),
        (o.poolSize = 8192),
        (o.from = function (e, t, r) {
          return c(e, t, r);
        }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array),
        (o.alloc = function (e, t, r) {
          return (l(e), e <= 0)
            ? a(e)
            : void 0 !== t
            ? "string" == typeof r
              ? a(e).fill(t, r)
              : a(e).fill(t)
            : a(e);
        }),
        (o.allocUnsafe = function (e) {
          return d(e);
        }),
        (o.allocUnsafeSlow = function (e) {
          return d(e);
        }),
        (o.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== o.prototype;
        }),
        (o.compare = function (e, t) {
          if (
            (M(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            M(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            !o.isBuffer(e) || !o.isBuffer(t))
          )
            throw TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (e === t) return 0;
          let r = e.length,
            i = t.length;
          for (let n = 0, s = Math.min(r, i); n < s; ++n)
            if (e[n] !== t[n]) {
              (r = e[n]), (i = t[n]);
              break;
            }
          return r < i ? -1 : +(i < r);
        }),
        (o.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (o.concat = function (e, t) {
          let r;
          if (!Array.isArray(e))
            throw TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return o.alloc(0);
          if (void 0 === t)
            for (r = 0, t = 0; r < e.length; ++r) t += e[r].length;
          let i = o.allocUnsafe(t),
            n = 0;
          for (r = 0; r < e.length; ++r) {
            let t = e[r];
            if (M(t, Uint8Array))
              n + t.length > i.length
                ? (o.isBuffer(t) || (t = o.from(t)), t.copy(i, n))
                : Uint8Array.prototype.set.call(i, t, n);
            else if (o.isBuffer(t)) t.copy(i, n);
            else throw TypeError('"list" argument must be an Array of Buffers');
            n += t.length;
          }
          return i;
        }),
        (o.byteLength = f),
        (o.prototype._isBuffer = !0),
        (o.prototype.swap16 = function () {
          let e = this.length;
          if (e % 2 != 0)
            throw RangeError("Buffer size must be a multiple of 16-bits");
          for (let t = 0; t < e; t += 2) m(this, t, t + 1);
          return this;
        }),
        (o.prototype.swap32 = function () {
          let e = this.length;
          if (e % 4 != 0)
            throw RangeError("Buffer size must be a multiple of 32-bits");
          for (let t = 0; t < e; t += 4)
            m(this, t, t + 3), m(this, t + 1, t + 2);
          return this;
        }),
        (o.prototype.swap64 = function () {
          let e = this.length;
          if (e % 8 != 0)
            throw RangeError("Buffer size must be a multiple of 64-bits");
          for (let t = 0; t < e; t += 8)
            m(this, t, t + 7),
              m(this, t + 1, t + 6),
              m(this, t + 2, t + 5),
              m(this, t + 3, t + 4);
          return this;
        }),
        (o.prototype.toString = function () {
          let e = this.length;
          return 0 === e
            ? ""
            : 0 == arguments.length
            ? b(this, 0, e)
            : g.apply(this, arguments);
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (e) {
          if (!o.isBuffer(e)) throw TypeError("Argument must be a Buffer");
          return this === e || 0 === o.compare(this, e);
        }),
        (o.prototype.inspect = function () {
          let e = "",
            r = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString("hex", 0, r)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > r && (e += " ... "),
            "<Buffer " + e + ">"
          );
        }),
        s && (o.prototype[s] = o.prototype.inspect),
        (o.prototype.compare = function (e, t, r, i, n) {
          if (
            (M(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            !o.isBuffer(e))
          )
            throw TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof e
            );
          if (
            (void 0 === t && (t = 0),
            void 0 === r && (r = e ? e.length : 0),
            void 0 === i && (i = 0),
            void 0 === n && (n = this.length),
            t < 0 || r > e.length || i < 0 || n > this.length)
          )
            throw RangeError("out of range index");
          if (i >= n && t >= r) return 0;
          if (i >= n) return -1;
          if (t >= r) return 1;
          if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (n >>>= 0), this === e))
            return 0;
          let s = n - i,
            a = r - t,
            c = Math.min(s, a),
            l = this.slice(i, n),
            d = e.slice(t, r);
          for (let e = 0; e < c; ++e)
            if (l[e] !== d[e]) {
              (s = l[e]), (a = d[e]);
              break;
            }
          return s < a ? -1 : +(a < s);
        }),
        (o.prototype.includes = function (e, t, r) {
          return -1 !== this.indexOf(e, t, r);
        }),
        (o.prototype.indexOf = function (e, t, r) {
          return y(this, e, t, r, !0);
        }),
        (o.prototype.lastIndexOf = function (e, t, r) {
          return y(this, e, t, r, !1);
        }),
        (o.prototype.write = function (e, t, r, i) {
          var n, s, a, o, c, l, d, h;
          if (void 0 === t) (i = "utf8"), (r = this.length), (t = 0);
          else if (void 0 === r && "string" == typeof t)
            (i = t), (r = this.length), (t = 0);
          else if (isFinite(t))
            (t >>>= 0),
              isFinite(r)
                ? ((r >>>= 0), void 0 === i && (i = "utf8"))
                : ((i = r), (r = void 0));
          else
            throw Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          let u = this.length - t;
          if (
            ((void 0 === r || r > u) && (r = u),
            (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
          )
            throw RangeError("Attempt to write outside buffer bounds");
          i || (i = "utf8");
          let p = !1;
          for (;;)
            switch (i) {
              case "hex":
                return (function (e, t, r, i) {
                  let n;
                  r = Number(r) || 0;
                  let s = e.length - r;
                  i ? (i = Number(i)) > s && (i = s) : (i = s);
                  let a = t.length;
                  for (i > a / 2 && (i = a / 2), n = 0; n < i; ++n) {
                    var o;
                    let i = parseInt(t.substr(2 * n, 2), 16);
                    if ((o = i) != o) break;
                    e[r + n] = i;
                  }
                  return n;
                })(this, e, t, r);
              case "utf8":
              case "utf-8":
                return (n = t), (s = r), U($(e, this.length - n), this, n, s);
              case "ascii":
              case "latin1":
              case "binary":
                return (
                  (a = t),
                  (o = r),
                  U(
                    (function (e) {
                      let t = [];
                      for (let r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                      return t;
                    })(e),
                    this,
                    a,
                    o
                  )
                );
              case "base64":
                return (c = t), (l = r), U(D(e), this, c, l);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return (
                  (d = t),
                  (h = r),
                  U(
                    (function (e, t) {
                      let r,
                        i,
                        n = [];
                      for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
                        (i = (r = e.charCodeAt(s)) >> 8),
                          n.push(r % 256),
                          n.push(i);
                      return n;
                    })(e, this.length - d),
                    this,
                    d,
                    h
                  )
                );
              default:
                if (p) throw TypeError("Unknown encoding: " + i);
                (i = ("" + i).toLowerCase()), (p = !0);
            }
        }),
        (o.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        }),
        (o.prototype.slice = function (e, t) {
          let r = this.length;
          (e = ~~e),
            (t = void 0 === t ? r : ~~t),
            e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
            t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            t < e && (t = e);
          let i = this.subarray(e, t);
          return Object.setPrototypeOf(i, o.prototype), i;
        }),
        (o.prototype.readUintLE = o.prototype.readUIntLE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e],
              n = 1,
              s = 0;
            for (; ++s < t && (n *= 256); ) i += this[e + s] * n;
            return i;
          }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e + --t],
              n = 1;
            for (; t > 0 && (n *= 256); ) i += this[e + --t] * n;
            return i;
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (e, t) {
            return (e >>>= 0), t || v(e, 1, this.length), this[e];
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              this[e] | (this[e + 1] << 8)
            );
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              (this[e] << 8) | this[e + 1]
            );
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                0x1000000 * this[e + 3]
            );
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              0x1000000 * this[e] +
                ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
            );
          }),
        (o.prototype.readBigUInt64LE = B(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && P(e, this.length - 8);
          let i =
              t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e],
            n = this[++e] + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * r;
          return BigInt(i) + (BigInt(n) << BigInt(32));
        })),
        (o.prototype.readBigUInt64BE = B(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && P(e, this.length - 8);
          let i =
              0x1000000 * t + 65536 * this[++e] + 256 * this[++e] + this[++e],
            n = 0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r;
          return (BigInt(i) << BigInt(32)) + BigInt(n);
        })),
        (o.prototype.readIntLE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = this[e],
            n = 1,
            s = 0;
          for (; ++s < t && (n *= 256); ) i += this[e + s] * n;
          return i >= (n *= 128) && (i -= Math.pow(2, 8 * t)), i;
        }),
        (o.prototype.readIntBE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = t,
            n = 1,
            s = this[e + --i];
          for (; i > 0 && (n *= 256); ) s += this[e + --i] * n;
          return s >= (n *= 128) && (s -= Math.pow(2, 8 * t)), s;
        }),
        (o.prototype.readInt8 = function (e, t) {
          return ((e >>>= 0), t || v(e, 1, this.length), 128 & this[e])
            ? -((255 - this[e] + 1) * 1)
            : this[e];
        }),
        (o.prototype.readInt16LE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e] | (this[e + 1] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt16BE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e + 1] | (this[e] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt32LE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            this[e] |
              (this[e + 1] << 8) |
              (this[e + 2] << 16) |
              (this[e + 3] << 24)
          );
        }),
        (o.prototype.readInt32BE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            (this[e] << 24) |
              (this[e + 1] << 16) |
              (this[e + 2] << 8) |
              this[e + 3]
          );
        }),
        (o.prototype.readBigInt64LE = B(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && P(e, this.length - 8),
            (BigInt(
              this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24)
            ) <<
              BigInt(32)) +
              BigInt(
                t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e]
              )
          );
        })),
        (o.prototype.readBigInt64BE = B(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && P(e, this.length - 8),
            (BigInt(
              (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]
            ) <<
              BigInt(32)) +
              BigInt(
                0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r
              )
          );
        })),
        (o.prototype.readFloatLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), n.read(this, e, !0, 23, 4)
          );
        }),
        (o.prototype.readFloatBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), n.read(this, e, !1, 23, 4)
          );
        }),
        (o.prototype.readDoubleLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), n.read(this, e, !0, 52, 8)
          );
        }),
        (o.prototype.readDoubleBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), n.read(this, e, !1, 52, 8)
          );
        }),
        (o.prototype.writeUintLE = o.prototype.writeUIntLE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              C(this, e, t, r, i, 0);
            }
            let n = 1,
              s = 0;
            for (this[t] = 255 & e; ++s < r && (n *= 256); )
              this[t + s] = (e / n) & 255;
            return t + r;
          }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              C(this, e, t, r, i, 0);
            }
            let n = r - 1,
              s = 1;
            for (this[t + n] = 255 & e; --n >= 0 && (s *= 256); )
              this[t + n] = (e / s) & 255;
            return t + r;
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || C(this, e, t, 1, 255, 0),
              (this[t] = 255 & e),
              t + 1
            );
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || C(this, e, t, 2, 65535, 0),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              t + 2
            );
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || C(this, e, t, 2, 65535, 0),
              (this[t] = e >>> 8),
              (this[t + 1] = 255 & e),
              t + 2
            );
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || C(this, e, t, 4, 0xffffffff, 0),
              (this[t + 3] = e >>> 24),
              (this[t + 2] = e >>> 16),
              (this[t + 1] = e >>> 8),
              (this[t] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || C(this, e, t, 4, 0xffffffff, 0),
              (this[t] = e >>> 24),
              (this[t + 1] = e >>> 16),
              (this[t + 2] = e >>> 8),
              (this[t + 3] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeBigUInt64LE = B(function (e, t = 0) {
          return E(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeBigUInt64BE = B(function (e, t = 0) {
          return x(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeIntLE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            C(this, e, t, r, i - 1, -i);
          }
          let n = 0,
            s = 1,
            a = 0;
          for (this[t] = 255 & e; ++n < r && (s *= 256); )
            e < 0 && 0 === a && 0 !== this[t + n - 1] && (a = 1),
              (this[t + n] = (((e / s) | 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeIntBE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            C(this, e, t, r, i - 1, -i);
          }
          let n = r - 1,
            s = 1,
            a = 0;
          for (this[t + n] = 255 & e; --n >= 0 && (s *= 256); )
            e < 0 && 0 === a && 0 !== this[t + n + 1] && (a = 1),
              (this[t + n] = (((e / s) | 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeInt8 = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || C(this, e, t, 1, 127, -128),
            e < 0 && (e = 255 + e + 1),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (o.prototype.writeInt16LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || C(this, e, t, 2, 32767, -32768),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (o.prototype.writeInt16BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || C(this, e, t, 2, 32767, -32768),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (o.prototype.writeInt32LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || C(this, e, t, 4, 0x7fffffff, -0x80000000),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            (this[t + 2] = e >>> 16),
            (this[t + 3] = e >>> 24),
            t + 4
          );
        }),
        (o.prototype.writeInt32BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || C(this, e, t, 4, 0x7fffffff, -0x80000000),
            e < 0 && (e = 0xffffffff + e + 1),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (o.prototype.writeBigInt64LE = B(function (e, t = 0) {
          return E(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeBigInt64BE = B(function (e, t = 0) {
          return x(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeFloatLE = function (e, t, r) {
          return _(this, e, t, !0, r);
        }),
        (o.prototype.writeFloatBE = function (e, t, r) {
          return _(this, e, t, !1, r);
        }),
        (o.prototype.writeDoubleLE = function (e, t, r) {
          return I(this, e, t, !0, r);
        }),
        (o.prototype.writeDoubleBE = function (e, t, r) {
          return I(this, e, t, !1, r);
        }),
        (o.prototype.copy = function (e, t, r, i) {
          if (!o.isBuffer(e)) throw TypeError("argument should be a Buffer");
          if (
            (r || (r = 0),
            i || 0 === i || (i = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            i > 0 && i < r && (i = r),
            i === r || 0 === e.length || 0 === this.length)
          )
            return 0;
          if (t < 0) throw RangeError("targetStart out of bounds");
          if (r < 0 || r >= this.length) throw RangeError("Index out of range");
          if (i < 0) throw RangeError("sourceEnd out of bounds");
          i > this.length && (i = this.length),
            e.length - t < i - r && (i = e.length - t + r);
          let n = i - r;
          return (
            this === e && "function" == typeof Uint8Array.prototype.copyWithin
              ? this.copyWithin(t, r, i)
              : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
            n
          );
        }),
        (o.prototype.fill = function (e, t, r, i) {
          let n;
          if ("string" == typeof e) {
            if (
              ("string" == typeof t
                ? ((i = t), (t = 0), (r = this.length))
                : "string" == typeof r && ((i = r), (r = this.length)),
              void 0 !== i && "string" != typeof i)
            )
              throw TypeError("encoding must be a string");
            if ("string" == typeof i && !o.isEncoding(i))
              throw TypeError("Unknown encoding: " + i);
            if (1 === e.length) {
              let t = e.charCodeAt(0);
              (("utf8" === i && t < 128) || "latin1" === i) && (e = t);
            }
          } else
            "number" == typeof e
              ? (e &= 255)
              : "boolean" == typeof e && (e = Number(e));
          if (t < 0 || this.length < t || this.length < r)
            throw RangeError("Out of range index");
          if (r <= t) return this;
          if (
            ((t >>>= 0),
            (r = void 0 === r ? this.length : r >>> 0),
            e || (e = 0),
            "number" == typeof e)
          )
            for (n = t; n < r; ++n) this[n] = e;
          else {
            let s = o.isBuffer(e) ? e : o.from(e, i),
              a = s.length;
            if (0 === a)
              throw TypeError(
                'The value "' + e + '" is invalid for argument "value"'
              );
            for (n = 0; n < r - t; ++n) this[n + t] = s[n % a];
          }
          return this;
        });
      let S = {};
      function k(e, t, r) {
        S[e] = class extends r {
          constructor() {
            super(),
              Object.defineProperty(this, "message", {
                value: t.apply(this, arguments),
                writable: !0,
                configurable: !0,
              }),
              (this.name = `${this.name} [${e}]`),
              this.stack,
              delete this.name;
          }
          get code() {
            return e;
          }
          set code(e) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: e,
              writable: !0,
            });
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        };
      }
      function N(e) {
        let t = "",
          r = e.length,
          i = +("-" === e[0]);
        for (; r >= i + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
        return `${e.slice(0, r)}${t}`;
      }
      function T(e, t, r, i, n, s) {
        if (e > r || e < t) {
          let i,
            n = "bigint" == typeof t ? "n" : "";
          throw (
            ((i =
              s > 3
                ? 0 === t || t === BigInt(0)
                  ? `>= 0${n} and < 2${n} ** ${(s + 1) * 8}${n}`
                  : `>= -(2${n} ** ${(s + 1) * 8 - 1}${n}) and < 2 ** ${
                      (s + 1) * 8 - 1
                    }${n}`
                : `>= ${t}${n} and <= ${r}${n}`),
            new S.ERR_OUT_OF_RANGE("value", i, e))
          );
        }
        O(n, "offset"),
          (void 0 === i[n] || void 0 === i[n + s]) && P(n, i.length - (s + 1));
      }
      function O(e, t) {
        if ("number" != typeof e)
          throw new S.ERR_INVALID_ARG_TYPE(t, "number", e);
      }
      function P(e, t, r) {
        if (Math.floor(e) !== e)
          throw (
            (O(e, r), new S.ERR_OUT_OF_RANGE(r || "offset", "an integer", e))
          );
        if (t < 0) throw new S.ERR_BUFFER_OUT_OF_BOUNDS();
        throw new S.ERR_OUT_OF_RANGE(
          r || "offset",
          `>= ${+!!r} and <= ${t}`,
          e
        );
      }
      k(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function (e) {
          return e
            ? `${e} is outside of buffer bounds`
            : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ),
        k(
          "ERR_INVALID_ARG_TYPE",
          function (e, t) {
            return `The "${e}" argument must be of type number. Received type ${typeof t}`;
          },
          TypeError
        ),
        k(
          "ERR_OUT_OF_RANGE",
          function (e, t, r) {
            let i = `The value of "${e}" is out of range.`,
              n = r;
            return (
              Number.isInteger(r) && Math.abs(r) > 0x100000000
                ? (n = N(String(r)))
                : "bigint" == typeof r &&
                  ((n = String(r)),
                  (r > BigInt(2) ** BigInt(32) ||
                    r < -(BigInt(2) ** BigInt(32))) &&
                    (n = N(n)),
                  (n += "n")),
              (i += ` It must be ${t}. Received ${n}`)
            );
          },
          RangeError
        );
      let R = /[^+/0-9A-Za-z-_]/g;
      function $(e, t) {
        let r;
        t = t || 1 / 0;
        let i = e.length,
          n = null,
          s = [];
        for (let a = 0; a < i; ++a) {
          if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
            if (!n) {
              if (r > 56319 || a + 1 === i) {
                (t -= 3) > -1 && s.push(239, 191, 189);
                continue;
              }
              n = r;
              continue;
            }
            if (r < 56320) {
              (t -= 3) > -1 && s.push(239, 191, 189), (n = r);
              continue;
            }
            r = (((n - 55296) << 10) | (r - 56320)) + 65536;
          } else n && (t -= 3) > -1 && s.push(239, 191, 189);
          if (((n = null), r < 128)) {
            if ((t -= 1) < 0) break;
            s.push(r);
          } else if (r < 2048) {
            if ((t -= 2) < 0) break;
            s.push((r >> 6) | 192, (63 & r) | 128);
          } else if (r < 65536) {
            if ((t -= 3) < 0) break;
            s.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
          } else if (r < 1114112) {
            if ((t -= 4) < 0) break;
            s.push(
              (r >> 18) | 240,
              ((r >> 12) & 63) | 128,
              ((r >> 6) & 63) | 128,
              (63 & r) | 128
            );
          } else throw Error("Invalid code point");
        }
        return s;
      }
      function D(e) {
        return i.toByteArray(
          (function (e) {
            if ((e = (e = e.split("=")[0]).trim().replace(R, "")).length < 2)
              return "";
            for (; e.length % 4 != 0; ) e += "=";
            return e;
          })(e)
        );
      }
      function U(e, t, r, i) {
        let n;
        for (n = 0; n < i && !(n + r >= t.length) && !(n >= e.length); ++n)
          t[n + r] = e[n];
        return n;
      }
      function M(e, t) {
        return (
          e instanceof t ||
          (null != e &&
            null != e.constructor &&
            null != e.constructor.name &&
            e.constructor.name === t.name)
        );
      }
      let L = (function () {
        let e = "0123456789abcdef",
          t = Array(256);
        for (let r = 0; r < 16; ++r) {
          let i = 16 * r;
          for (let n = 0; n < 16; ++n) t[i + n] = e[r] + e[n];
        }
        return t;
      })();
      function B(e) {
        return "undefined" == typeof BigInt ? W : e;
      }
      function W() {
        throw Error("BigInt not supported");
      }
    },
    81345: (e, t, r) => {
      "use strict";
      r.d(t, { LU: () => i, R7: () => n });
      let i = {
          core: {
            backgroundAccentPrimary: "#0988F0",
            backgroundAccentCertified: "#C7B994",
            backgroundWalletKit: "#FFB800",
            backgroundAppKit: "#FF573B",
            backgroundCloud: "#0988F0",
            backgroundDocumentation: "#008847",
            backgroundSuccess: "rgba(48, 164, 107, 0.20)",
            backgroundError: "rgba(223, 74, 52, 0.20)",
            backgroundWarning: "rgba(243, 161, 63, 0.20)",
            textAccentPrimary: "#0988F0",
            textAccentCertified: "#C7B994",
            textWalletKit: "#FFB800",
            textAppKit: "#FF573B",
            textCloud: "#0988F0",
            textDocumentation: "#008847",
            textSuccess: "#30A46B",
            textError: "#DF4A34",
            textWarning: "#F3A13F",
            borderAccentPrimary: "#0988F0",
            borderSecondary: "#C7B994",
            borderSuccess: "#30A46B",
            borderError: "#DF4A34",
            borderWarning: "#F3A13F",
            foregroundAccent010: "rgba(9, 136, 240, 0.1)",
            foregroundAccent020: "rgba(9, 136, 240, 0.2)",
            foregroundAccent040: "rgba(9, 136, 240, 0.4)",
            foregroundAccent060: "rgba(9, 136, 240, 0.6)",
            foregroundSecondary020: "rgba(199, 185, 148, 0.2)",
            foregroundSecondary040: "rgba(199, 185, 148, 0.4)",
            foregroundSecondary060: "rgba(199, 185, 148, 0.6)",
            iconAccentPrimary: "#0988F0",
            iconAccentCertified: "#C7B994",
            iconSuccess: "#30A46B",
            iconError: "#DF4A34",
            iconWarning: "#F3A13F",
            glass010: "rgba(255, 255, 255, 0.1)",
            zIndex: "9999",
          },
          dark: {
            overlay: "rgba(0, 0, 0, 0.50)",
            backgroundPrimary: "#202020",
            backgroundInvert: "#FFFFFF",
            textPrimary: "#FFFFFF",
            textSecondary: "#9A9A9A",
            textTertiary: "#BBBBBB",
            textInvert: "#202020",
            borderPrimary: "#2A2A2A",
            borderPrimaryDark: "#363636",
            borderSecondary: "#4F4F4F",
            foregroundPrimary: "#252525",
            foregroundSecondary: "#2A2A2A",
            foregroundTertiary: "#363636",
            iconDefault: "#9A9A9A",
            iconInverse: "#FFFFFF",
          },
          light: {
            overlay: "rgba(230 , 230, 230, 0.5)",
            backgroundPrimary: "#FFFFFF",
            borderPrimaryDark: "#E9E9E9",
            backgroundInvert: "#202020",
            textPrimary: "#202020",
            textSecondary: "#9A9A9A",
            textTertiary: "#6C6C6C",
            textInvert: "#FFFFFF",
            borderPrimary: "#E9E9E9",
            borderSecondary: "#D0D0D0",
            foregroundPrimary: "#F3F3F3",
            foregroundSecondary: "#E9E9E9",
            foregroundTertiary: "#D0D0D0",
            iconDefault: "#9A9A9A",
            iconInverse: "#202020",
          },
        },
        n = {
          colors: {
            black: "#202020",
            white: "#FFFFFF",
            white010: "rgba(255, 255, 255, 0.1)",
            accent010: "rgba(9, 136, 240, 0.1)",
            accent020: "rgba(9, 136, 240, 0.2)",
            accent030: "rgba(9, 136, 240, 0.3)",
            accent040: "rgba(9, 136, 240, 0.4)",
            accent050: "rgba(9, 136, 240, 0.5)",
            accent060: "rgba(9, 136, 240, 0.6)",
            accent070: "rgba(9, 136, 240, 0.7)",
            accent080: "rgba(9, 136, 240, 0.8)",
            accent090: "rgba(9, 136, 240, 0.9)",
            accent100: "rgba(9, 136, 240, 1.0)",
            accentSecondary010: "rgba(199, 185, 148, 0.1)",
            accentSecondary020: "rgba(199, 185, 148, 0.2)",
            accentSecondary030: "rgba(199, 185, 148, 0.3)",
            accentSecondary040: "rgba(199, 185, 148, 0.4)",
            accentSecondary050: "rgba(199, 185, 148, 0.5)",
            accentSecondary060: "rgba(199, 185, 148, 0.6)",
            accentSecondary070: "rgba(199, 185, 148, 0.7)",
            accentSecondary080: "rgba(199, 185, 148, 0.8)",
            accentSecondary090: "rgba(199, 185, 148, 0.9)",
            accentSecondary100: "rgba(199, 185, 148, 1.0)",
            productWalletKit: "#FFB800",
            productAppKit: "#FF573B",
            productCloud: "#0988F0",
            productDocumentation: "#008847",
            neutrals050: "#F6F6F6",
            neutrals100: "#F3F3F3",
            neutrals200: "#E9E9E9",
            neutrals300: "#D0D0D0",
            neutrals400: "#BBB",
            neutrals500: "#9A9A9A",
            neutrals600: "#6C6C6C",
            neutrals700: "#4F4F4F",
            neutrals800: "#363636",
            neutrals900: "#2A2A2A",
            neutrals1000: "#252525",
            semanticSuccess010: "rgba(48, 164, 107, 0.1)",
            semanticSuccess020: "rgba(48, 164, 107, 0.2)",
            semanticSuccess030: "rgba(48, 164, 107, 0.3)",
            semanticSuccess040: "rgba(48, 164, 107, 0.4)",
            semanticSuccess050: "rgba(48, 164, 107, 0.5)",
            semanticSuccess060: "rgba(48, 164, 107, 0.6)",
            semanticSuccess070: "rgba(48, 164, 107, 0.7)",
            semanticSuccess080: "rgba(48, 164, 107, 0.8)",
            semanticSuccess090: "rgba(48, 164, 107, 0.9)",
            semanticSuccess100: "rgba(48, 164, 107, 1.0)",
            semanticError010: "rgba(223, 74, 52, 0.1)",
            semanticError020: "rgba(223, 74, 52, 0.2)",
            semanticError030: "rgba(223, 74, 52, 0.3)",
            semanticError040: "rgba(223, 74, 52, 0.4)",
            semanticError050: "rgba(223, 74, 52, 0.5)",
            semanticError060: "rgba(223, 74, 52, 0.6)",
            semanticError070: "rgba(223, 74, 52, 0.7)",
            semanticError080: "rgba(223, 74, 52, 0.8)",
            semanticError090: "rgba(223, 74, 52, 0.9)",
            semanticError100: "rgba(223, 74, 52, 1.0)",
            semanticWarning010: "rgba(243, 161, 63, 0.1)",
            semanticWarning020: "rgba(243, 161, 63, 0.2)",
            semanticWarning030: "rgba(243, 161, 63, 0.3)",
            semanticWarning040: "rgba(243, 161, 63, 0.4)",
            semanticWarning050: "rgba(243, 161, 63, 0.5)",
            semanticWarning060: "rgba(243, 161, 63, 0.6)",
            semanticWarning070: "rgba(243, 161, 63, 0.7)",
            semanticWarning080: "rgba(243, 161, 63, 0.8)",
            semanticWarning090: "rgba(243, 161, 63, 0.9)",
            semanticWarning100: "rgba(243, 161, 63, 1.0)",
          },
          fontFamily: { regular: "KHTeka", mono: "KHTekaMono" },
          fontWeight: { regular: "400", medium: "500" },
          textSize: {
            h1: "50px",
            h2: "44px",
            h3: "38px",
            h4: "32px",
            h5: "26px",
            h6: "20px",
            large: "16px",
            medium: "14px",
            small: "12px",
          },
          typography: {
            "h1-regular-mono": { lineHeight: "50px", letterSpacing: "-3px" },
            "h1-regular": { lineHeight: "50px", letterSpacing: "-1px" },
            "h1-medium": { lineHeight: "50px", letterSpacing: "-0.84px" },
            "h2-regular-mono": { lineHeight: "44px", letterSpacing: "-2.64px" },
            "h2-regular": { lineHeight: "44px", letterSpacing: "-0.88px" },
            "h2-medium": { lineHeight: "44px", letterSpacing: "-0.88px" },
            "h3-regular-mono": { lineHeight: "38px", letterSpacing: "-2.28px" },
            "h3-regular": { lineHeight: "38px", letterSpacing: "-0.76px" },
            "h3-medium": { lineHeight: "38px", letterSpacing: "-0.76px" },
            "h4-regular-mono": { lineHeight: "32px", letterSpacing: "-1.92px" },
            "h4-regular": { lineHeight: "32px", letterSpacing: "-0.32px" },
            "h4-medium": { lineHeight: "32px", letterSpacing: "-0.32px" },
            "h5-regular-mono": { lineHeight: "26px", letterSpacing: "-1.56px" },
            "h5-regular": { lineHeight: "26px", letterSpacing: "-0.26px" },
            "h5-medium": { lineHeight: "26px", letterSpacing: "-0.26px" },
            "h6-regular-mono": { lineHeight: "20px", letterSpacing: "-1.2px" },
            "h6-regular": { lineHeight: "20px", letterSpacing: "-0.6px" },
            "h6-medium": { lineHeight: "20px", letterSpacing: "-0.6px" },
            "lg-regular-mono": { lineHeight: "16px", letterSpacing: "-0.96px" },
            "lg-regular": { lineHeight: "18px", letterSpacing: "-0.16px" },
            "lg-medium": { lineHeight: "18px", letterSpacing: "-0.16px" },
            "md-regular-mono": { lineHeight: "14px", letterSpacing: "-0.84px" },
            "md-regular": { lineHeight: "16px", letterSpacing: "-0.14px" },
            "md-medium": { lineHeight: "16px", letterSpacing: "-0.14px" },
            "sm-regular-mono": { lineHeight: "12px", letterSpacing: "-0.72px" },
            "sm-regular": { lineHeight: "14px", letterSpacing: "-0.12px" },
            "sm-medium": { lineHeight: "14px", letterSpacing: "-0.12px" },
          },
          tokens: { core: i.core, theme: i.dark },
          borderRadius: {
            1: "4px",
            2: "8px",
            10: "10px",
            3: "12px",
            4: "16px",
            6: "24px",
            5: "20px",
            8: "32px",
            16: "64px",
            20: "80px",
            32: "128px",
            64: "256px",
            128: "512px",
            round: "9999px",
          },
          spacing: {
            0: "0px",
            "01": "2px",
            1: "4px",
            2: "8px",
            3: "12px",
            4: "16px",
            5: "20px",
            6: "24px",
            7: "28px",
            8: "32px",
            9: "36px",
            10: "40px",
            12: "48px",
            14: "56px",
            16: "64px",
            20: "80px",
            32: "128px",
            64: "256px",
          },
          durations: { xl: "400ms", lg: "200ms", md: "125ms", sm: "75ms" },
          easings: {
            "ease-out-power-2": "cubic-bezier(0.23, 0.09, 0.08, 1.13)",
            "ease-out-power-1": "cubic-bezier(0.12, 0.04, 0.2, 1.06)",
            "ease-in-power-2": "cubic-bezier(0.92, -0.13, 0.77, 0.91)",
            "ease-in-power-1": "cubic-bezier(0.88, -0.06, 0.8, 0.96)",
            "ease-inout-power-2": "cubic-bezier(0.77, 0.09, 0.23, 1.13)",
            "ease-inout-power-1": "cubic-bezier(0.88, 0.04, 0.12, 1.06)",
          },
        };
    },
    81452: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_THOUSAND = t.ONE_HUNDRED = void 0),
        (t.ONE_HUNDRED = 100),
        (t.ONE_THOUSAND = 1e3);
    },
    81701: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => y });
      var i = r(1220),
        n = r(98866),
        s = r(12319),
        a = r(8318),
        o = r(36964),
        c = r(72880),
        l = r(93481),
        d = r(97418),
        h = r(10899),
        u = r(70417),
        p = r(55480),
        f = r(6578),
        g = r(67869);
      let m = (0, i.BX)({
          loading: !1,
          loadingNamespaceMap: new Map(),
          open: !1,
          shake: !1,
          namespace: void 0,
        }),
        y = (0, o.X)({
          state: m,
          subscribe: (e) => (0, i.B1)(m, () => e(m)),
          subscribeKey: (e, t) => (0, n.u$)(m, e, t),
          async open(e) {
            let t = e?.namespace,
              r = l.W.state.activeChain,
              i = t && t !== r,
              n = l.W.getAccountData(e?.namespace)?.caipAddress,
              o = l.W.state.noAdapters;
            if (
              (d.x.state.wcBasic
                ? c.N.prefetch({
                    fetchNetworkImages: !1,
                    fetchConnectorImages: !1,
                    fetchWalletRanks: !1,
                  })
                : await c.N.prefetch(),
              h.a.setFilterByNamespace(e?.namespace),
              y.setLoading(!0, t),
              t && i)
            ) {
              let e =
                l.W.getNetworkData(t)?.caipNetwork ||
                l.W.getRequestedCaipNetworks(t)[0];
              e &&
                (o
                  ? (await l.W.switchActiveNetwork(e),
                    g.I.push("ConnectingWalletConnectBasic"))
                  : a.L.onSwitchNetwork({
                      network: e,
                      ignoreSwitchConfirmation: !0,
                    }));
            } else
              p.H.state.manualWCControl || (o && !n)
                ? s.w.isMobile()
                  ? g.I.reset("AllWallets")
                  : g.I.reset("ConnectingWalletConnectBasic")
                : e?.view
                ? g.I.reset(e.view, e.data)
                : n
                ? g.I.reset("Account")
                : g.I.reset("Connect");
            (m.open = !0),
              f.z.set({ open: !0 }),
              u.E.sendEvent({
                type: "track",
                event: "MODAL_OPEN",
                properties: { connected: !!n },
              });
          },
          close() {
            let e = p.H.state.enableEmbedded,
              t = !!l.W.state.activeCaipAddress;
            m.open &&
              u.E.sendEvent({
                type: "track",
                event: "MODAL_CLOSE",
                properties: { connected: t },
              }),
              (m.open = !1),
              g.I.reset("Connect"),
              y.clearLoading(),
              e
                ? t
                  ? g.I.replace("Account")
                  : g.I.push("Connect")
                : f.z.set({ open: !1 }),
              d.x.resetUri();
          },
          setLoading(e, t) {
            t && m.loadingNamespaceMap.set(t, e),
              (m.loading = e),
              f.z.set({ loading: e });
          },
          clearLoading() {
            m.loadingNamespaceMap.clear(),
              (m.loading = !1),
              f.z.set({ loading: !1 });
          },
          shake() {
            m.shake ||
              ((m.shake = !0),
              setTimeout(() => {
                m.shake = !1;
              }, 500));
          },
        });
    },
    82050: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => h });
      var i = r(4058),
        n = r(13933);
      class s extends n.C {
        constructor() {
          super(
            "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
            { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
          );
        }
      }
      var a = r(67550),
        o = r(56674),
        c = r(59350);
      let l = {
        current: 0,
        take() {
          return this.current++;
        },
        reset() {
          this.current = 0;
        },
      };
      var d = r(53473);
      function h(e, t = {}) {
        let {
          batch: r,
          fetchFn: n,
          fetchOptions: u,
          key: p = "http",
          methods: f,
          name: g = "HTTP JSON-RPC",
          onFetchRequest: m,
          onFetchResponse: y,
          retryDelay: w,
          raw: b,
        } = t;
        return ({ chain: h, retryCount: v, timeout: C }) => {
          let { batchSize: E = 1e3, wait: x = 0 } =
              "object" == typeof r ? r : {},
            A = t.retryCount ?? v,
            _ = C ?? t.timeout ?? 1e4,
            I = e || h?.rpcUrls.default.http[0];
          if (!I) throw new s();
          let S = (function (e, t = {}) {
            return {
              async request(r) {
                let {
                    body: n,
                    fetchFn: s = t.fetchFn ?? fetch,
                    onRequest: a = t.onRequest,
                    onResponse: d = t.onResponse,
                    timeout: h = t.timeout ?? 1e4,
                  } = r,
                  u = { ...(t.fetchOptions ?? {}), ...(r.fetchOptions ?? {}) },
                  { headers: p, method: f, signal: g } = u;
                try {
                  let t,
                    r = await (0, o.w)(
                      async ({ signal: t }) => {
                        let r = {
                            ...u,
                            body: Array.isArray(n)
                              ? (0, c.A)(
                                  n.map((e) => ({
                                    jsonrpc: "2.0",
                                    id: e.id ?? l.take(),
                                    ...e,
                                  }))
                                )
                              : (0, c.A)({
                                  jsonrpc: "2.0",
                                  id: n.id ?? l.take(),
                                  ...n,
                                }),
                            headers: {
                              "Content-Type": "application/json",
                              ...p,
                            },
                            method: f || "POST",
                            signal: g || (h > 0 ? t : null),
                          },
                          i = new Request(e, r),
                          o = (await a?.(i, r)) ?? { ...r, url: e };
                        return await s(o.url ?? e, o);
                      },
                      {
                        errorInstance: new i.MU({ body: n, url: e }),
                        timeout: h,
                        signal: !0,
                      }
                    );
                  if (
                    (d && (await d(r)),
                    r.headers
                      .get("Content-Type")
                      ?.startsWith("application/json"))
                  )
                    t = await r.json();
                  else {
                    t = await r.text();
                    try {
                      t = JSON.parse(t || "{}");
                    } catch (e) {
                      if (r.ok) throw e;
                      t = { error: t };
                    }
                  }
                  if (!r.ok)
                    throw new i.Ci({
                      body: n,
                      details: (0, c.A)(t.error) || r.statusText,
                      headers: r.headers,
                      status: r.status,
                      url: e,
                    });
                  return t;
                } catch (t) {
                  if (t instanceof i.Ci || t instanceof i.MU) throw t;
                  throw new i.Ci({ body: n, cause: t, url: e });
                }
              },
            };
          })(I, {
            fetchFn: n,
            fetchOptions: u,
            onRequest: m,
            onResponse: y,
            timeout: _,
          });
          return (0, d.o)(
            {
              key: p,
              methods: f,
              name: g,
              async request({ method: e, params: t }) {
                let n = { method: e, params: t },
                  { schedule: s } = (0, a.u)({
                    id: I,
                    wait: x,
                    shouldSplitBatch: (e) => e.length > E,
                    fn: (e) => S.request({ body: e }),
                    sort: (e, t) => e.id - t.id,
                  }),
                  o = async (e) => (r ? s(e) : [await S.request({ body: e })]),
                  [{ error: c, result: l }] = await o(n);
                if (b) return { error: c, result: l };
                if (c) throw new i.J8({ body: n, error: c, url: I });
                return l;
              },
              retryCount: A,
              retryDelay: w,
              timeout: _,
              type: "http",
            },
            { fetchOptions: u, url: I }
          );
        };
      }
    },
    82427: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => s });
      var i = r(27747);
      let n = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: 1 / 0,
        assertReadLimit() {
          if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new i.hX({
              count: this.recursiveReadCount + 1,
              limit: this.recursiveReadLimit,
            });
        },
        assertPosition(e) {
          if (e < 0 || e > this.bytes.length - 1)
            throw new i.SK({ length: this.bytes.length, position: e });
        },
        decrementPosition(e) {
          if (e < 0) throw new i.B4({ offset: e });
          let t = this.position - e;
          this.assertPosition(t), (this.position = t);
        },
        getReadCount(e) {
          return this.positionReadCount.get(e || this.position) || 0;
        },
        incrementPosition(e) {
          if (e < 0) throw new i.B4({ offset: e });
          let t = this.position + e;
          this.assertPosition(t), (this.position = t);
        },
        inspectByte(e) {
          let t = e ?? this.position;
          return this.assertPosition(t), this.bytes[t];
        },
        inspectBytes(e, t) {
          let r = t ?? this.position;
          return this.assertPosition(r + e - 1), this.bytes.subarray(r, r + e);
        },
        inspectUint8(e) {
          let t = e ?? this.position;
          return this.assertPosition(t), this.bytes[t];
        },
        inspectUint16(e) {
          let t = e ?? this.position;
          return this.assertPosition(t + 1), this.dataView.getUint16(t);
        },
        inspectUint24(e) {
          let t = e ?? this.position;
          return (
            this.assertPosition(t + 2),
            (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2)
          );
        },
        inspectUint32(e) {
          let t = e ?? this.position;
          return this.assertPosition(t + 3), this.dataView.getUint32(t);
        },
        pushByte(e) {
          this.assertPosition(this.position),
            (this.bytes[this.position] = e),
            this.position++;
        },
        pushBytes(e) {
          this.assertPosition(this.position + e.length - 1),
            this.bytes.set(e, this.position),
            (this.position += e.length);
        },
        pushUint8(e) {
          this.assertPosition(this.position),
            (this.bytes[this.position] = e),
            this.position++;
        },
        pushUint16(e) {
          this.assertPosition(this.position + 1),
            this.dataView.setUint16(this.position, e),
            (this.position += 2);
        },
        pushUint24(e) {
          this.assertPosition(this.position + 2),
            this.dataView.setUint16(this.position, e >> 8),
            this.dataView.setUint8(this.position + 2, 255 & e),
            (this.position += 3);
        },
        pushUint32(e) {
          this.assertPosition(this.position + 3),
            this.dataView.setUint32(this.position, e),
            (this.position += 4);
        },
        readByte() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectByte();
          return this.position++, e;
        },
        readBytes(e, t) {
          this.assertReadLimit(), this._touch();
          let r = this.inspectBytes(e);
          return (this.position += t ?? e), r;
        },
        readUint8() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint8();
          return (this.position += 1), e;
        },
        readUint16() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint16();
          return (this.position += 2), e;
        },
        readUint24() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint24();
          return (this.position += 3), e;
        },
        readUint32() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint32();
          return (this.position += 4), e;
        },
        get remaining() {
          return this.bytes.length - this.position;
        },
        setPosition(e) {
          let t = this.position;
          return (
            this.assertPosition(e),
            (this.position = e),
            () => (this.position = t)
          );
        },
        _touch() {
          if (this.recursiveReadLimit === 1 / 0) return;
          let e = this.getReadCount();
          this.positionReadCount.set(this.position, e + 1),
            e > 0 && this.recursiveReadCount++;
        },
      };
      function s(e, { recursiveReadLimit: t = 8192 } = {}) {
        let r = Object.create(n);
        return (
          (r.bytes = e),
          (r.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength)),
          (r.positionReadCount = new Map()),
          (r.recursiveReadLimit = t),
          r
        );
      }
    },
    82886: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(75751),
        a = r(55480),
        o = r(36211),
        c = r(78964),
        l = r(46747);
      r(99691), r(24772);
      var d = r(71084),
        h = r(47327),
        u = r(20296);
      let p = (0, u.AH)`
  label {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
    user-select: none;
    column-gap: ${({ spacing: e }) => e[2]};
  }

  label > input[type='checkbox'] {
    height: 0;
    width: 0;
    opacity: 0;
    position: absolute;
  }

  label > span {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    width: 100%;
    border: 1px solid ${({ colors: e }) => e.neutrals400};
    color: ${({ colors: e }) => e.white};
    background-color: transparent;
    will-change: border-color, background-color;
  }

  label > span > wui-icon {
    opacity: 0;
    will-change: opacity;
  }

  label > input[type='checkbox']:checked + span > wui-icon {
    color: ${({ colors: e }) => e.white};
  }

  label > input[type='checkbox']:not(:checked) > span > wui-icon {
    color: ${({ colors: e }) => e.neutrals900};
  }

  label > input[type='checkbox']:checked + span > wui-icon {
    opacity: 1;
  }

  /* -- Sizes --------------------------------------------------- */
  label[data-size='lg'] > span {
    width: 24px;
    height: 24px;
    min-width: 24px;
    min-height: 24px;
    border-radius: ${({ borderRadius: e }) => e[10]};
  }

  label[data-size='md'] > span {
    width: 20px;
    height: 20px;
    min-width: 20px;
    min-height: 20px;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  label[data-size='sm'] > span {
    width: 16px;
    height: 16px;
    min-width: 16px;
    min-height: 16px;
    border-radius: ${({ borderRadius: e }) => e[1]};
  }

  /* -- Focus states --------------------------------------------------- */
  label > input[type='checkbox']:focus-visible + span,
  label > input[type='checkbox']:focus + span {
    border: 1px solid ${({ tokens: e }) => e.core.borderAccentPrimary};
    box-shadow: 0px 0px 0px 4px rgba(9, 136, 240, 0.2);
  }

  /* -- Checked states --------------------------------------------------- */
  label > input[type='checkbox']:checked + span {
    background-color: ${({ tokens: e }) => e.core.iconAccentPrimary};
    border: 1px solid transparent;
  }

  /* -- Hover states --------------------------------------------------- */
  input[type='checkbox']:not(:checked):not(:disabled) + span:hover {
    border: 1px solid ${({ colors: e }) => e.neutrals700};
    background-color: ${({ colors: e }) => e.neutrals800};
    box-shadow: none;
  }

  input[type='checkbox']:checked:not(:disabled) + span:hover {
    border: 1px solid transparent;
    background-color: ${({ colors: e }) => e.accent080};
    box-shadow: none;
  }

  /* -- Disabled state --------------------------------------------------- */
  label > input[type='checkbox']:checked:disabled + span {
    border: 1px solid transparent;
    opacity: 0.3;
  }

  label > input[type='checkbox']:not(:checked):disabled + span {
    border: 1px solid ${({ colors: e }) => e.neutrals700};
  }

  label:has(input[type='checkbox']:disabled) {
    cursor: auto;
  }

  label > input[type='checkbox']:disabled + span {
    cursor: not-allowed;
  }
`;
      var f = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let g = { lg: "md", md: "sm", sm: "sm" },
        m = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.inputElementRef = (0, l._)()),
              (this.checked = void 0),
              (this.disabled = !1),
              (this.size = "md");
          }
          render() {
            let e = g[this.size];
            return (0, i.qy)`
      <label data-size=${this.size}>
        <input
          ${(0, l.K)(this.inputElementRef)}
          ?checked=${(0, c.J)(this.checked)}
          ?disabled=${this.disabled}
          type="checkbox"
          @change=${this.dispatchChangeEvent}
        />
        <span>
          <wui-icon name="checkmarkBold" size=${e}></wui-icon>
        </span>
        <slot></slot>
      </label>
    `;
          }
          dispatchChangeEvent() {
            this.dispatchEvent(
              new CustomEvent("checkboxChange", {
                detail: this.inputElementRef.value?.checked,
                bubbles: !0,
                composed: !0,
              })
            );
          }
        };
      (m.styles = [d.W5, p]),
        f([(0, n.MZ)({ type: Boolean })], m.prototype, "checked", void 0),
        f([(0, n.MZ)({ type: Boolean })], m.prototype, "disabled", void 0),
        f([(0, n.MZ)()], m.prototype, "size", void 0),
        (m = f([(0, h.E)("wui-checkbox")], m)),
        r(41163);
      let y = (0, o.AH)`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  wui-checkbox {
    padding: ${({ spacing: e }) => e["3"]};
  }
  a {
    text-decoration: none;
    color: ${({ tokens: e }) => e.theme.textSecondary};
    font-weight: 500;
  }
`;
      var w = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let b = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.checked = s.o.state.isLegalCheckboxChecked),
            this.unsubscribe.push(
              s.o.subscribeKey("isLegalCheckboxChecked", (e) => {
                this.checked = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = a.H.state,
            r = a.H.state.features?.legalCheckbox;
          return (e || t) && r
            ? (0, i.qy)`
      <wui-checkbox
        ?checked=${this.checked}
        @checkboxChange=${this.onCheckboxChange.bind(this)}
        data-testid="wui-checkbox"
      >
        <wui-text color="secondary" variant="sm-regular" align="left">
          I agree to our ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-checkbox>
    `
            : null;
        }
        andTemplate() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = a.H.state;
          return e && t ? "and" : "";
        }
        termsTemplate() {
          let { termsConditionsUrl: e } = a.H.state;
          return e
            ? (0,
              i.qy)`<a rel="noreferrer" target="_blank" href=${e}>terms of service</a>`
            : null;
        }
        privacyTemplate() {
          let { privacyPolicyUrl: e } = a.H.state;
          return e
            ? (0,
              i.qy)`<a rel="noreferrer" target="_blank" href=${e}>privacy policy</a>`
            : null;
        }
        onCheckboxChange() {
          s.o.setIsLegalCheckboxChecked(!this.checked);
        }
      };
      (b.styles = [y]),
        w([(0, n.wk)()], b.prototype, "checked", void 0),
        (b = w([(0, o.EM)("w3m-legal-checkbox")], b));
    },
    83138: (e, t, r) => {
      "use strict";
      r.d(t, {
        WF: () => a,
        AH: () => i.AH,
        qy: () => n.qy,
        JW: () => n.JW,
        iz: () => i.iz,
      });
      var i = r(98502),
        n = r(52321);
      let s = globalThis;
      class a extends i.mN {
        constructor() {
          super(...arguments),
            (this.renderOptions = { host: this }),
            (this._$Do = void 0);
        }
        createRenderRoot() {
          let e = super.createRenderRoot();
          return (this.renderOptions.renderBefore ??= e.firstChild), e;
        }
        update(e) {
          let t = this.render();
          this.hasUpdated ||
            (this.renderOptions.isConnected = this.isConnected),
            super.update(e),
            (this._$Do = (0, n.XX)(t, this.renderRoot, this.renderOptions));
        }
        connectedCallback() {
          super.connectedCallback(), this._$Do?.setConnected(!0);
        }
        disconnectedCallback() {
          super.disconnectedCallback(), this._$Do?.setConnected(!1);
        }
        render() {
          return n.c0;
        }
      }
      (a._$litElement$ = !0),
        (a.finalized = !0),
        s.litElementHydrateSupport?.({ LitElement: a });
      let o = s.litElementPolyfillSupport;
      o?.({ LitElement: a }), (s.litElementVersions ??= []).push("4.2.1");
    },
    83621: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          AppKitAccountButton: () => x,
          AppKitButton: () => k,
          AppKitConnectButton: () => D,
          AppKitNetworkButton: () => q,
          W3mAccountButton: () => E,
          W3mAccountSettingsView: () => el,
          W3mAccountView: () => ez,
          W3mAllWalletsView: () => tT,
          W3mButton: () => S,
          W3mChooseAccountNameView: () => r2,
          W3mConnectButton: () => $,
          W3mConnectView: () => rw,
          W3mConnectWalletsView: () => it,
          W3mConnectingExternalView: () => rO,
          W3mConnectingMultiChainView: () => r$,
          W3mConnectingWcBasicView: () => rX,
          W3mConnectingWcView: () => rJ,
          W3mDownloadsView: () => r3,
          W3mFooter: () => V.H,
          W3mGetWalletView: () => r5,
          W3mNetworkButton: () => H,
          W3mNetworkSwitchView: () => io,
          W3mNetworksView: () => ig,
          W3mProfileWalletsView: () => e7,
          W3mRouter: () => z.J,
          W3mSIWXSignMessageView: () => iM,
          W3mSwitchActiveChainView: () => ib,
          W3mUnsupportedChainView: () => iA,
          W3mWalletCompatibleNetworksView: () => iN,
          W3mWhatIsANetworkView: () => iC,
          W3mWhatIsAWalletView: () => r9,
        });
      var i = r(83138),
        n = r(98410),
        s = r(78964),
        a = r(55480),
        o = r(93481),
        c = r(29936),
        l = r(14744),
        d = r(12319),
        h = r(81701),
        u = r(36211);
      r(99691), r(45166), r(21129), r(24772), r(38534);
      var p = r(71084),
        f = r(8821),
        g = r(47327);
      r(1418);
      var m = r(20296);
      let y = (0, m.AH)`
  :host {
    display: block;
  }

  button {
    border-radius: ${({ borderRadius: e }) => e["20"]};
    background: ${({ tokens: e }) => e.theme.foregroundPrimary};
    display: flex;
    gap: ${({ spacing: e }) => e[1]};
    padding: ${({ spacing: e }) => e[1]};
    color: ${({ tokens: e }) => e.theme.textSecondary};
    border-radius: ${({ borderRadius: e }) => e[16]};
    height: 32px;
    transition: box-shadow ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: box-shadow;
  }

  button wui-flex.avatar-container {
    width: 28px;
    height: 24px;
    position: relative;

    wui-flex.network-image-container {
      position: absolute;
      bottom: 0px;
      right: 0px;
      width: 12px;
      height: 12px;
    }

    wui-avatar {
      width: 24px;
      min-width: 24px;
      height: 24px;
    }

    wui-icon {
      width: 12px;
      height: 12px;
    }
  }

  wui-image,
  wui-icon {
    border-radius: ${({ borderRadius: e }) => e[16]};
  }

  wui-text {
    white-space: nowrap;
  }

  button wui-flex.balance-container {
    height: 100%;
    border-radius: ${({ borderRadius: e }) => e[16]};
    padding-left: ${({ spacing: e }) => e[1]};
    padding-right: ${({ spacing: e }) => e[1]};
    background: ${({ tokens: e }) => e.theme.foregroundSecondary};
    color: ${({ tokens: e }) => e.theme.textPrimary};
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: background-color;
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  button:hover:enabled,
  button:focus-visible:enabled,
  button:active:enabled {
    box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.2);

    wui-flex.balance-container {
      background: ${({ tokens: e }) => e.theme.foregroundTertiary};
    }
  }

  /* -- Disabled states --------------------------------------------------- */
  button:disabled wui-text,
  button:disabled wui-flex.avatar-container {
    opacity: 0.3;
  }
`;
      var w = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let b = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.networkSrc = void 0),
            (this.avatarSrc = void 0),
            (this.balance = void 0),
            (this.isUnsupportedChain = void 0),
            (this.disabled = !1),
            (this.loading = !1),
            (this.address = ""),
            (this.profileName = ""),
            (this.charsStart = 4),
            (this.charsEnd = 6);
        }
        render() {
          return (0, i.qy)`
      <button
        ?disabled=${this.disabled}
        class=${(0, s.J)(this.balance ? void 0 : "local-no-balance")}
        data-error=${(0, s.J)(this.isUnsupportedChain)}
      >
        ${this.imageTemplate()} ${this.addressTemplate()} ${this.balanceTemplate()}
      </button>
    `;
        }
        imageTemplate() {
          let e = this.networkSrc
            ? (0, i.qy)`<wui-image src=${this.networkSrc}></wui-image>`
            : (0,
              i.qy)` <wui-icon size="inherit" color="inherit" icon="networkPlaceholder"></wui-icon> `;
          return (0, i.qy)`<wui-flex class="avatar-container">
      <wui-avatar
        .imageSrc=${this.avatarSrc}
        alt=${this.address}
        address=${this.address}
      ></wui-avatar>

      <wui-flex class="network-image-container">${e}</wui-flex>
    </wui-flex>`;
        }
        addressTemplate() {
          return (0, i.qy)`<wui-text variant="md-regular" color="inherit">
      ${
        this.address
          ? f.Z.getTruncateString({
              string: this.profileName || this.address,
              charsStart: this.profileName ? 18 : this.charsStart,
              charsEnd: this.profileName ? 0 : this.charsEnd,
              truncate: this.profileName ? "end" : "middle",
            })
          : null
      }
    </wui-text>`;
        }
        balanceTemplate() {
          if (this.balance) {
            let e = this.loading
              ? (0,
                i.qy)`<wui-loading-spinner size="md" color="inherit"></wui-loading-spinner>`
              : (0,
                i.qy)`<wui-text variant="md-regular" color="inherit"> ${this.balance}</wui-text>`;
            return (0,
            i.qy)`<wui-flex alignItems="center" justifyContent="center" class="balance-container"
        >${e}</wui-flex
      >`;
          }
          return null;
        }
      };
      (b.styles = [p.W5, p.fD, y]),
        w([(0, n.MZ)()], b.prototype, "networkSrc", void 0),
        w([(0, n.MZ)()], b.prototype, "avatarSrc", void 0),
        w([(0, n.MZ)()], b.prototype, "balance", void 0),
        w(
          [(0, n.MZ)({ type: Boolean })],
          b.prototype,
          "isUnsupportedChain",
          void 0
        ),
        w([(0, n.MZ)({ type: Boolean })], b.prototype, "disabled", void 0),
        w([(0, n.MZ)({ type: Boolean })], b.prototype, "loading", void 0),
        w([(0, n.MZ)()], b.prototype, "address", void 0),
        w([(0, n.MZ)()], b.prototype, "profileName", void 0),
        w([(0, n.MZ)()], b.prototype, "charsStart", void 0),
        w([(0, n.MZ)()], b.prototype, "charsEnd", void 0),
        (b = w([(0, g.E)("wui-account-button")], b));
      var v = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      class C extends i.WF {
        constructor() {
          super(...arguments),
            (this.unsubscribe = []),
            (this.disabled = !1),
            (this.balance = "show"),
            (this.charsStart = 4),
            (this.charsEnd = 6),
            (this.namespace = void 0),
            (this.isSupported =
              !!a.H.state.allowUnsupportedChain ||
              !o.W.state.activeChain ||
              o.W.checkIfSupportedNetwork(o.W.state.activeChain));
        }
        connectedCallback() {
          super.connectedCallback(),
            this.setAccountData(o.W.getAccountData(this.namespace)),
            this.setNetworkData(o.W.getNetworkData(this.namespace));
        }
        firstUpdated() {
          let e = this.namespace;
          e
            ? this.unsubscribe.push(
                o.W.subscribeChainProp(
                  "accountState",
                  (e) => {
                    this.setAccountData(e);
                  },
                  e
                ),
                o.W.subscribeChainProp(
                  "networkState",
                  (t) => {
                    this.setNetworkData(t),
                      (this.isSupported = o.W.checkIfSupportedNetwork(
                        e,
                        t?.caipNetwork?.caipNetworkId
                      ));
                  },
                  e
                )
              )
            : this.unsubscribe.push(
                c.j.subscribeNetworkImages(() => {
                  this.networkImage = l.$.getNetworkImage(this.network);
                }),
                o.W.subscribeKey("activeCaipAddress", (e) => {
                  this.caipAddress = e;
                }),
                o.W.subscribeChainProp("accountState", (e) => {
                  this.setAccountData(e);
                }),
                o.W.subscribeKey("activeCaipNetwork", (e) => {
                  (this.network = e),
                    (this.networkImage = l.$.getNetworkImage(e)),
                    (this.isSupported =
                      !e?.chainNamespace ||
                      o.W.checkIfSupportedNetwork(e?.chainNamespace)),
                    this.fetchNetworkImage(e);
                })
              );
        }
        updated() {
          this.fetchNetworkImage(this.network);
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          if (!o.W.state.activeChain) return null;
          let e = "show" === this.balance,
            t = "string" != typeof this.balanceVal,
            { formattedText: r } = d.w.parseBalance(
              this.balanceVal,
              this.balanceSymbol
            );
          return (0, i.qy)`
      <wui-account-button
        .disabled=${!!this.disabled}
        .isUnsupportedChain=${
          !a.H.state.allowUnsupportedChain && !this.isSupported
        }
        address=${(0, s.J)(d.w.getPlainAddress(this.caipAddress))}
        profileName=${(0, s.J)(this.profileName)}
        networkSrc=${(0, s.J)(this.networkImage)}
        avatarSrc=${(0, s.J)(this.profileImage)}
        balance=${e ? r : ""}
        @click=${this.onClick.bind(this)}
        data-testid=${`account-button${
          this.namespace ? `-${this.namespace}` : ""
        }`}
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
        ?loading=${t}
      >
      </wui-account-button>
    `;
        }
        onClick() {
          this.isSupported || a.H.state.allowUnsupportedChain
            ? h.W.open({ namespace: this.namespace })
            : h.W.open({ view: "UnsupportedChain" });
        }
        async fetchNetworkImage(e) {
          e?.assets?.imageId &&
            (this.networkImage = await l.$.fetchNetworkImage(
              e?.assets?.imageId
            ));
        }
        setAccountData(e) {
          e &&
            ((this.caipAddress = e.caipAddress),
            (this.balanceVal = e.balance),
            (this.balanceSymbol = e.balanceSymbol),
            (this.profileName = e.profileName),
            (this.profileImage = e.profileImage));
        }
        setNetworkData(e) {
          e &&
            ((this.network = e.caipNetwork),
            (this.networkImage = l.$.getNetworkImage(e.caipNetwork)));
        }
      }
      v([(0, n.MZ)({ type: Boolean })], C.prototype, "disabled", void 0),
        v([(0, n.MZ)()], C.prototype, "balance", void 0),
        v([(0, n.MZ)()], C.prototype, "charsStart", void 0),
        v([(0, n.MZ)()], C.prototype, "charsEnd", void 0),
        v([(0, n.MZ)()], C.prototype, "namespace", void 0),
        v([(0, n.wk)()], C.prototype, "caipAddress", void 0),
        v([(0, n.wk)()], C.prototype, "balanceVal", void 0),
        v([(0, n.wk)()], C.prototype, "balanceSymbol", void 0),
        v([(0, n.wk)()], C.prototype, "profileName", void 0),
        v([(0, n.wk)()], C.prototype, "profileImage", void 0),
        v([(0, n.wk)()], C.prototype, "network", void 0),
        v([(0, n.wk)()], C.prototype, "networkImage", void 0),
        v([(0, n.wk)()], C.prototype, "isSupported", void 0);
      let E = class extends C {};
      E = v([(0, u.EM)("w3m-account-button")], E);
      let x = class extends C {};
      x = v([(0, u.EM)("appkit-account-button")], x);
      let A = (0, i.AH)`
  :host {
    display: block;
    width: max-content;
  }
`;
      var _ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      class I extends i.WF {
        constructor() {
          super(...arguments),
            (this.unsubscribe = []),
            (this.disabled = !1),
            (this.balance = void 0),
            (this.size = void 0),
            (this.label = void 0),
            (this.loadingLabel = void 0),
            (this.charsStart = 4),
            (this.charsEnd = 6),
            (this.namespace = void 0);
        }
        firstUpdated() {
          (this.caipAddress = this.namespace
            ? o.W.getAccountData(this.namespace)?.caipAddress
            : o.W.state.activeCaipAddress),
            this.namespace
              ? this.unsubscribe.push(
                  o.W.subscribeChainProp(
                    "accountState",
                    (e) => {
                      this.caipAddress = e?.caipAddress;
                    },
                    this.namespace
                  )
                )
              : this.unsubscribe.push(
                  o.W.subscribeKey(
                    "activeCaipAddress",
                    (e) => (this.caipAddress = e)
                  )
                );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return this.caipAddress
            ? (0, i.qy)`
          <appkit-account-button
            .disabled=${!!this.disabled}
            balance=${(0, s.J)(this.balance)}
            .charsStart=${(0, s.J)(this.charsStart)}
            .charsEnd=${(0, s.J)(this.charsEnd)}
            namespace=${(0, s.J)(this.namespace)}
          >
          </appkit-account-button>
        `
            : (0, i.qy)`
          <appkit-connect-button
            size=${(0, s.J)(this.size)}
            label=${(0, s.J)(this.label)}
            loadingLabel=${(0, s.J)(this.loadingLabel)}
            namespace=${(0, s.J)(this.namespace)}
          ></appkit-connect-button>
        `;
        }
      }
      (I.styles = A),
        _([(0, n.MZ)({ type: Boolean })], I.prototype, "disabled", void 0),
        _([(0, n.MZ)()], I.prototype, "balance", void 0),
        _([(0, n.MZ)()], I.prototype, "size", void 0),
        _([(0, n.MZ)()], I.prototype, "label", void 0),
        _([(0, n.MZ)()], I.prototype, "loadingLabel", void 0),
        _([(0, n.MZ)()], I.prototype, "charsStart", void 0),
        _([(0, n.MZ)()], I.prototype, "charsEnd", void 0),
        _([(0, n.MZ)()], I.prototype, "namespace", void 0),
        _([(0, n.wk)()], I.prototype, "caipAddress", void 0);
      let S = class extends I {};
      S = _([(0, u.EM)("w3m-button")], S);
      let k = class extends I {};
      k = _([(0, u.EM)("appkit-button")], k);
      let N = (0, m.AH)`
  :host {
    position: relative;
    display: block;
  }

  button {
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  button[data-size='sm'] {
    padding: ${({ spacing: e }) => e[2]};
  }

  button[data-size='md'] {
    padding: ${({ spacing: e }) => e[3]};
  }

  button[data-size='lg'] {
    padding: ${({ spacing: e }) => e[4]};
  }

  button[data-variant='primary'] {
    background: ${({ tokens: e }) => e.core.backgroundAccentPrimary};
  }

  button[data-variant='secondary'] {
    background: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  button:hover:enabled {
    border-radius: ${({ borderRadius: e }) => e[3]};
  }

  button:disabled {
    cursor: not-allowed;
  }

  button[data-loading='true'] {
    cursor: not-allowed;
  }

  button[data-loading='true'][data-size='sm'] {
    border-radius: ${({ borderRadius: e }) => e[32]};
    padding: ${({ spacing: e }) => e[2]} ${({ spacing: e }) => e[3]};
  }

  button[data-loading='true'][data-size='md'] {
    border-radius: ${({ borderRadius: e }) => e[20]};
    padding: ${({ spacing: e }) => e[3]} ${({ spacing: e }) => e[4]};
  }

  button[data-loading='true'][data-size='lg'] {
    border-radius: ${({ borderRadius: e }) => e[16]};
    padding: ${({ spacing: e }) => e[4]} ${({ spacing: e }) => e[5]};
  }
`;
      var T = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let O = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.size = "md"),
            (this.variant = "primary"),
            (this.loading = !1),
            (this.text = "Connect Wallet");
        }
        render() {
          return (0, i.qy)`
      <button
        data-loading=${this.loading}
        data-variant=${this.variant}
        data-size=${this.size}
        ?disabled=${this.loading}
      >
        ${this.contentTemplate()}
      </button>
    `;
        }
        contentTemplate() {
          let e = { primary: "invert", secondary: "accent-primary" };
          return this.loading
            ? (0, i.qy)`<wui-loading-spinner
      color=${e[this.variant]}
      size=${this.size}
    ></wui-loading-spinner>`
            : (0, i.qy)` <wui-text variant=${
                { lg: "lg-regular", md: "md-regular", sm: "sm-regular" }[
                  this.size
                ]
              } color=${e[this.variant]}>
        ${this.text}
      </wui-text>`;
        }
      };
      (O.styles = [p.W5, p.fD, N]),
        T([(0, n.MZ)()], O.prototype, "size", void 0),
        T([(0, n.MZ)()], O.prototype, "variant", void 0),
        T([(0, n.MZ)({ type: Boolean })], O.prototype, "loading", void 0),
        T([(0, n.MZ)()], O.prototype, "text", void 0),
        (O = T([(0, g.E)("wui-connect-button")], O));
      var P = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      class R extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.size = "md"),
            (this.label = "Connect Wallet"),
            (this.loadingLabel = "Connecting..."),
            (this.open = h.W.state.open),
            (this.loading = this.namespace
              ? h.W.state.loadingNamespaceMap.get(this.namespace)
              : h.W.state.loading),
            this.unsubscribe.push(
              h.W.subscribe((e) => {
                (this.open = e.open),
                  (this.loading = this.namespace
                    ? e.loadingNamespaceMap.get(this.namespace)
                    : e.loading);
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      <wui-connect-button
        size=${(0, s.J)(this.size)}
        .loading=${this.loading}
        @click=${this.onClick.bind(this)}
        data-testid=${`connect-button${
          this.namespace ? `-${this.namespace}` : ""
        }`}
      >
        ${this.loading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
        }
        onClick() {
          this.open
            ? h.W.close()
            : this.loading ||
              h.W.open({ view: "Connect", namespace: this.namespace });
        }
      }
      P([(0, n.MZ)()], R.prototype, "size", void 0),
        P([(0, n.MZ)()], R.prototype, "label", void 0),
        P([(0, n.MZ)()], R.prototype, "loadingLabel", void 0),
        P([(0, n.MZ)()], R.prototype, "namespace", void 0),
        P([(0, n.wk)()], R.prototype, "open", void 0),
        P([(0, n.wk)()], R.prototype, "loading", void 0);
      let $ = class extends R {};
      $ = P([(0, u.EM)("w3m-connect-button")], $);
      let D = class extends R {};
      D = P([(0, u.EM)("appkit-connect-button")], D);
      var U = r(70417);
      r(84042);
      let M = (0, m.AH)`
  :host {
    display: block;
  }

  button {
    border-radius: ${({ borderRadius: e }) => e[32]};
    display: flex;
    gap: ${({ spacing: e }) => e[1]};
    padding: ${({ spacing: e }) => e[1]} ${({ spacing: e }) => e[2]}
      ${({ spacing: e }) => e[1]} ${({ spacing: e }) => e[1]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    }
  }

  button[data-size='sm'] > wui-icon-box,
  button[data-size='sm'] > wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > wui-icon-box,
  button[data-size='md'] > wui-image {
    width: 20px;
    height: 20px;
  }

  button[data-size='lg'] > wui-icon-box,
  button[data-size='lg'] > wui-image {
    width: 24px;
    height: 24px;
  }

  wui-image,
  wui-icon-box {
    border-radius: ${({ borderRadius: e }) => e[32]};
  }
`;
      var L = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let B = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.imageSrc = void 0),
            (this.isUnsupportedChain = void 0),
            (this.disabled = !1),
            (this.size = "lg");
        }
        render() {
          return (0, i.qy)`
      <button data-size=${
        this.size
      } data-testid="wui-network-button" ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant=${
          { sm: "sm-regular", md: "md-regular", lg: "lg-regular" }[this.size]
        } color="primary">
          <slot></slot>
        </wui-text>
      </button>
    `;
        }
        visualTemplate() {
          return this.isUnsupportedChain
            ? (0,
              i.qy)` <wui-icon-box color="error" icon="warningCircle"></wui-icon-box> `
            : this.imageSrc
            ? (0, i.qy)`<wui-image src=${this.imageSrc}></wui-image>`
            : (0,
              i.qy)` <wui-icon-box color="default" icon="networkPlaceholder"></wui-icon-box> `;
        }
      };
      (B.styles = [p.W5, p.fD, M]),
        L([(0, n.MZ)()], B.prototype, "imageSrc", void 0),
        L(
          [(0, n.MZ)({ type: Boolean })],
          B.prototype,
          "isUnsupportedChain",
          void 0
        ),
        L([(0, n.MZ)({ type: Boolean })], B.prototype, "disabled", void 0),
        L([(0, n.MZ)()], B.prototype, "size", void 0),
        (B = L([(0, g.E)("wui-network-button")], B));
      let W = (0, i.AH)`
  :host {
    display: block;
    width: max-content;
  }
`;
      var j = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      class F extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.disabled = !1),
            (this.network = o.W.state.activeCaipNetwork),
            (this.networkImage = l.$.getNetworkImage(this.network)),
            (this.caipAddress = o.W.state.activeCaipAddress),
            (this.loading = h.W.state.loading),
            (this.isSupported =
              !!a.H.state.allowUnsupportedChain ||
              !o.W.state.activeChain ||
              o.W.checkIfSupportedNetwork(o.W.state.activeChain)),
            this.unsubscribe.push(
              c.j.subscribeNetworkImages(() => {
                this.networkImage = l.$.getNetworkImage(this.network);
              }),
              o.W.subscribeKey("activeCaipAddress", (e) => {
                this.caipAddress = e;
              }),
              o.W.subscribeKey("activeCaipNetwork", (e) => {
                (this.network = e),
                  (this.networkImage = l.$.getNetworkImage(e)),
                  (this.isSupported =
                    !e?.chainNamespace ||
                    o.W.checkIfSupportedNetwork(e.chainNamespace)),
                  l.$.fetchNetworkImage(e?.assets?.imageId);
              }),
              h.W.subscribeKey("loading", (e) => (this.loading = e))
            );
        }
        firstUpdated() {
          l.$.fetchNetworkImage(this.network?.assets?.imageId);
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e =
            !this.network ||
            o.W.checkIfSupportedNetwork(this.network.chainNamespace);
          return (0, i.qy)`
      <wui-network-button
        .disabled=${!!(this.disabled || this.loading)}
        .isUnsupportedChain=${!a.H.state.allowUnsupportedChain && !e}
        imageSrc=${(0, s.J)(this.networkImage)}
        @click=${this.onClick.bind(this)}
        data-testid="w3m-network-button"
      >
        ${this.getLabel()}
        <slot></slot>
      </wui-network-button>
    `;
        }
        getLabel() {
          return this.network
            ? this.isSupported || a.H.state.allowUnsupportedChain
              ? this.network.name
              : "Switch Network"
            : this.label
            ? this.label
            : this.caipAddress
            ? "Unknown Network"
            : "Select Network";
        }
        onClick() {
          this.loading ||
            (U.E.sendEvent({ type: "track", event: "CLICK_NETWORKS" }),
            h.W.open({ view: "Networks" }));
        }
      }
      (F.styles = W),
        j([(0, n.MZ)({ type: Boolean })], F.prototype, "disabled", void 0),
        j([(0, n.MZ)({ type: String })], F.prototype, "label", void 0),
        j([(0, n.wk)()], F.prototype, "network", void 0),
        j([(0, n.wk)()], F.prototype, "networkImage", void 0),
        j([(0, n.wk)()], F.prototype, "caipAddress", void 0),
        j([(0, n.wk)()], F.prototype, "loading", void 0),
        j([(0, n.wk)()], F.prototype, "isSupported", void 0);
      let H = class extends F {};
      H = j([(0, u.EM)("w3m-network-button")], H);
      let q = class extends F {};
      q = j([(0, u.EM)("appkit-network-button")], q);
      var z = r(22588),
        V = r(65110),
        Z = r(45553),
        K = r(10899),
        G = r(28977),
        J = r(65374),
        Y = r(71305),
        X = r(67869),
        Q = r(97418),
        ee = r(25654);
      r(40575), r(51568), r(26670), r(37465);
      let et = (0, m.AH)`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: ${({ spacing: e }) => e[4]};
    padding: ${({ spacing: e }) => e[3]};
    border-radius: ${({ borderRadius: e }) => e[4]};
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  wui-flex > wui-icon {
    padding: ${({ spacing: e }) => e[2]};
    color: ${({ tokens: e }) => e.theme.textInvert};
    background-color: ${({ tokens: e }) => e.core.backgroundAccentPrimary};
    border-radius: ${({ borderRadius: e }) => e[2]};
    align-items: normal;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.core.foregroundAccent020};
    }
  }
`;
      var er = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ei = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.label = ""),
            (this.description = ""),
            (this.icon = "wallet");
        }
        render() {
          return (0, i.qy)`
      <button>
        <wui-flex gap="2" alignItems="center">
          <wui-icon weight="fill" size="md" name=${this.icon} color="inherit"></wui-icon>
          <wui-flex flexDirection="column" gap="1">
            <wui-text variant="md-medium" color="primary">${this.label}</wui-text>
            <wui-text variant="md-regular" color="tertiary">${this.description}</wui-text>
          </wui-flex>
        </wui-flex>
        <wui-icon size="lg" color="accent-primary" name="chevronRight"></wui-icon>
      </button>
    `;
        }
      };
      (ei.styles = [p.W5, p.fD, et]),
        er([(0, n.MZ)()], ei.prototype, "label", void 0),
        er([(0, n.MZ)()], ei.prototype, "description", void 0),
        er([(0, n.MZ)()], ei.prototype, "icon", void 0),
        (ei = er([(0, g.E)("wui-notice-card")], ei)),
        r(41163);
      var en = r(73537),
        es = r(58653),
        ea = function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        };
      let eo = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.socialProvider = es.i.getConnectedSocialProvider()),
            (this.socialUsername = es.i.getConnectedSocialUsername()),
            (this.namespace = o.W.state.activeChain),
            this.unsubscribe.push(
              o.W.subscribeKey("activeChain", (e) => {
                this.namespace = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e = K.a.getConnectorId(this.namespace),
            t = K.a.getAuthConnector();
          if (!t || e !== Z.o.CONNECTOR_ID.AUTH)
            return (this.style.cssText = "display: none"), null;
          let r = t.provider.getEmail() ?? "";
          return r || this.socialUsername
            ? (0, i.qy)`
      <wui-list-item
        ?rounded=${!0}
        icon=${this.socialProvider ?? "mail"}
        data-testid="w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
          this.onGoToUpdateEmail(r, this.socialProvider);
        }}
      >
        <wui-text variant="lg-regular" color="primary">${this.getAuthName(
          r
        )}</wui-text>
      </wui-list-item>
    `
            : ((this.style.cssText = "display: none"), null);
        }
        onGoToUpdateEmail(e, t) {
          t ||
            X.I.push("UpdateEmailWallet", {
              email: e,
              redirectView: "Account",
            });
        }
        getAuthName(e) {
          return this.socialUsername
            ? "discord" === this.socialProvider &&
              this.socialUsername.endsWith("0")
              ? this.socialUsername.slice(0, -1)
              : this.socialUsername
            : e.length > 30
            ? `${e.slice(0, -3)}...`
            : e;
        }
      };
      ea([(0, n.wk)()], eo.prototype, "namespace", void 0),
        (eo = ea([(0, u.EM)("w3m-account-auth-button")], eo));
      var ec = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let el = class extends i.WF {
        constructor() {
          super(),
            (this.usubscribe = []),
            (this.networkImages = c.j.state.networkImages),
            (this.address = o.W.getAccountData()?.address),
            (this.profileImage = o.W.getAccountData()?.profileImage),
            (this.profileName = o.W.getAccountData()?.profileName),
            (this.network = o.W.state.activeCaipNetwork),
            (this.disconnecting = !1),
            (this.loading = !1),
            (this.switched = !1),
            (this.text = ""),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            this.usubscribe.push(
              o.W.subscribeChainProp("accountState", (e) => {
                e &&
                  ((this.address = e.address),
                  (this.profileImage = e.profileImage),
                  (this.profileName = e.profileName));
              }),
              o.W.subscribeKey("activeCaipNetwork", (e) => {
                e?.id && (this.network = e);
              }),
              a.H.subscribeKey("remoteFeatures", (e) => {
                this.remoteFeatures = e;
              })
            );
        }
        disconnectedCallback() {
          this.usubscribe.forEach((e) => e());
        }
        render() {
          if (!this.address)
            throw Error("w3m-account-settings-view: No account provided");
          let e = this.networkImages[this.network?.assets?.imageId ?? ""];
          return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="4"
        .padding=${["0", "5", "3", "5"]}
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${(0, s.J)(this.profileImage)}
          size="lg"
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="1" alignItems="center" justifyContent="center">
            <wui-text variant="h5-medium" color="primary" data-testid="account-settings-address">
              ${u.Zv.getTruncateString({
                string: this.address,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle",
              })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="default"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" gap="4">
        <wui-flex flexDirection="column" gap="2" .padding=${[
          "6",
          "4",
          "3",
          "4",
        ]}>
          ${this.authCardTemplate()}
          <w3m-account-auth-button></w3m-account-auth-button>
          <wui-list-item
            imageSrc=${(0, s.J)(e)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            ?fullSize=${!0}
            ?rounded=${!0}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <wui-text variant="lg-regular" color="primary">
              ${this.network?.name ?? "Unknown"}
            </wui-text>
          </wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <wui-list-item
            ?rounded=${!0}
            icon="power"
            iconColor="error"
            ?chevron=${!1}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="lg-regular" color="primary">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
        }
        chooseNameButtonTemplate() {
          let e = this.network?.chainNamespace,
            t = K.a.getConnectorId(e),
            r = K.a.getAuthConnector();
          return o.W.checkIfNamesSupported() &&
            r &&
            t === Z.o.CONNECTOR_ID.AUTH &&
            !this.profileName
            ? (0, i.qy)`
      <wui-list-item
        icon="id"
        ?rounded=${!0}
        ?chevron=${!0}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <wui-text variant="lg-regular" color="primary">Choose account name </wui-text>
      </wui-list-item>
    `
            : null;
        }
        authCardTemplate() {
          let e = K.a.getConnectorId(this.network?.chainNamespace),
            t = K.a.getAuthConnector(),
            { origin: r } = location;
          return !t ||
            e !== Z.o.CONNECTOR_ID.AUTH ||
            r.includes(G.oU.SECURE_SITE)
            ? null
            : (0, i.qy)`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
        }
        isAllowedNetworkSwitch() {
          let e = o.W.getAllRequestedCaipNetworks(),
            t = !!e && e.length > 1,
            r = e?.find(({ id: e }) => e === this.network?.id);
          return t || !r;
        }
        onCopyAddress() {
          try {
            this.address &&
              (d.w.copyToClopboard(this.address),
              J.P.showSuccess("Address copied"));
          } catch {
            J.P.showError("Failed to copy");
          }
        }
        togglePreferredAccountBtnTemplate() {
          let e = this.network?.chainNamespace,
            t = o.W.checkIfSmartAccountEnabled(),
            r = K.a.getConnectorId(e);
          return K.a.getAuthConnector() && r === Z.o.CONNECTOR_ID.AUTH && t
            ? (this.switched ||
                (this.text =
                  (0, Y.lj)(e) === en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
                    ? "Switch to your EOA"
                    : "Switch to your Smart Account"),
              (0, i.qy)`
      <wui-list-item
        icon="swapHorizontal"
        ?rounded=${!0}
        ?chevron=${!0}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <wui-text variant="lg-regular" color="primary">${this.text}</wui-text>
      </wui-list-item>
    `)
            : null;
        }
        onChooseName() {
          X.I.push("ChooseAccountName");
        }
        async changePreferredAccountType() {
          let e = this.network?.chainNamespace,
            t = o.W.checkIfSmartAccountEnabled(),
            r =
              (0, Y.lj)(e) !== en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT && t
                ? en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
                : en.Vl.ACCOUNT_TYPES.EOA;
          K.a.getAuthConnector() &&
            ((this.loading = !0),
            await Q.x.setPreferredAccountType(r, e),
            (this.text =
              r === en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
                ? "Switch to your EOA"
                : "Switch to your Smart Account"),
            (this.switched = !0),
            ee.R.resetSend(),
            (this.loading = !1),
            this.requestUpdate());
        }
        onNetworks() {
          this.isAllowedNetworkSwitch() && X.I.push("Networks");
        }
        async onDisconnect() {
          try {
            this.disconnecting = !0;
            let e = this.network?.chainNamespace,
              t = Q.x.getConnections(e).length > 0,
              r = e && K.a.state.activeConnectorIds[e],
              i = this.remoteFeatures?.multiWallet;
            await Q.x.disconnect(i ? { id: r, namespace: e } : {}),
              t &&
                i &&
                (X.I.push("ProfileWallets"), J.P.showSuccess("Wallet deleted"));
          } catch {
            U.E.sendEvent({
              type: "track",
              event: "DISCONNECT_ERROR",
              properties: { message: "Failed to disconnect" },
            }),
              J.P.showError("Failed to disconnect");
          } finally {
            this.disconnecting = !1;
          }
        }
        onGoToUpgradeView() {
          U.E.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" }),
            X.I.push("UpgradeEmailWallet");
        }
      };
      ec([(0, n.wk)()], el.prototype, "address", void 0),
        ec([(0, n.wk)()], el.prototype, "profileImage", void 0),
        ec([(0, n.wk)()], el.prototype, "profileName", void 0),
        ec([(0, n.wk)()], el.prototype, "network", void 0),
        ec([(0, n.wk)()], el.prototype, "disconnecting", void 0),
        ec([(0, n.wk)()], el.prototype, "loading", void 0),
        ec([(0, n.wk)()], el.prototype, "switched", void 0),
        ec([(0, n.wk)()], el.prototype, "text", void 0),
        ec([(0, n.wk)()], el.prototype, "remoteFeatures", void 0),
        (el = ec([(0, u.EM)("w3m-account-settings-view")], el)),
        r(41028),
        r(77237);
      let ed = (0, m.AH)`
  :host {
    flex: 1;
    height: 100%;
  }

  button {
    width: 100%;
    height: 100%;
    display: inline-flex;
    align-items: center;
    padding: ${({ spacing: e }) => e[1]} ${({ spacing: e }) => e[2]};
    column-gap: ${({ spacing: e }) => e[1]};
    color: ${({ tokens: e }) => e.theme.textSecondary};
    border-radius: ${({ borderRadius: e }) => e[20]};
    background-color: transparent;
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: background-color;
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  button[data-active='true'] {
    color: ${({ tokens: e }) => e.theme.textPrimary};
    background-color: ${({ tokens: e }) => e.theme.foregroundTertiary};
  }

  button:hover:enabled:not([data-active='true']),
  button:active:enabled:not([data-active='true']) {
    wui-text,
    wui-icon {
      color: ${({ tokens: e }) => e.theme.textPrimary};
    }
  }
`;
      var eh = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eu = { lg: "lg-regular", md: "md-regular", sm: "sm-regular" },
        ep = { lg: "md", md: "sm", sm: "sm" },
        ef = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.icon = "mobile"),
              (this.size = "md"),
              (this.label = ""),
              (this.active = !1);
          }
          render() {
            return (0, i.qy)`
      <button data-active=${this.active}>
        ${
          this.icon
            ? (0, i.qy)`<wui-icon size=${ep[this.size]} name=${
                this.icon
              }></wui-icon>`
            : ""
        }
        <wui-text variant=${eu[this.size]}> ${this.label} </wui-text>
      </button>
    `;
          }
        };
      (ef.styles = [p.W5, p.fD, ed]),
        eh([(0, n.MZ)()], ef.prototype, "icon", void 0),
        eh([(0, n.MZ)()], ef.prototype, "size", void 0),
        eh([(0, n.MZ)()], ef.prototype, "label", void 0),
        eh([(0, n.MZ)({ type: Boolean })], ef.prototype, "active", void 0),
        (ef = eh([(0, g.E)("wui-tab-item")], ef));
      let eg = (0, m.AH)`
  :host {
    display: inline-flex;
    align-items: center;
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    border-radius: ${({ borderRadius: e }) => e[32]};
    padding: ${({ spacing: e }) => e["01"]};
    box-sizing: border-box;
  }

  :host([data-size='sm']) {
    height: 26px;
  }

  :host([data-size='md']) {
    height: 36px;
  }
`;
      var em = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ey = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.tabs = []),
            (this.onTabChange = () => null),
            (this.size = "md"),
            (this.activeTab = 0);
        }
        render() {
          return (
            (this.dataset.size = this.size),
            this.tabs.map((e, t) => {
              let r = t === this.activeTab;
              return (0, i.qy)`
        <wui-tab-item
          @click=${() => this.onTabClick(t)}
          icon=${e.icon}
          size=${this.size}
          label=${e.label}
          ?active=${r}
          data-active=${r}
          data-testid="tab-${e.label?.toLowerCase()}"
        ></wui-tab-item>
      `;
            })
          );
        }
        onTabClick(e) {
          (this.activeTab = e), this.onTabChange(e);
        }
      };
      (ey.styles = [p.W5, p.fD, eg]),
        em([(0, n.MZ)({ type: Array })], ey.prototype, "tabs", void 0),
        em([(0, n.MZ)()], ey.prototype, "onTabChange", void 0),
        em([(0, n.MZ)()], ey.prototype, "size", void 0),
        em([(0, n.wk)()], ey.prototype, "activeTab", void 0),
        (ey = em([(0, g.E)("wui-tabs")], ey)),
        r(44036);
      let ew = (0, m.AH)`
  button {
    display: flex;
    align-items: center;
    height: 40px;
    padding: ${({ spacing: e }) => e[2]};
    border-radius: ${({ borderRadius: e }) => e[4]};
    column-gap: ${({ spacing: e }) => e[1]};
    background-color: transparent;
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: background-color;
  }

  wui-image,
  .icon-box {
    width: ${({ spacing: e }) => e[6]};
    height: ${({ spacing: e }) => e[6]};
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  wui-text {
    flex: 1;
  }

  .icon-box {
    position: relative;
  }

  .icon-box[data-active='true'] {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  .circle {
    position: absolute;
    left: 16px;
    top: 15px;
    width: 8px;
    height: 8px;
    background-color: ${({ tokens: e }) => e.core.textSuccess};
    box-shadow: 0 0 0 2px ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: 50%;
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) {
    button:hover:enabled,
    button:active:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    }
  }
`;
      var eb = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ev = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.address = ""),
            (this.profileName = ""),
            (this.alt = ""),
            (this.imageSrc = ""),
            (this.icon = void 0),
            (this.iconSize = "md"),
            (this.loading = !1),
            (this.charsStart = 4),
            (this.charsEnd = 6);
        }
        render() {
          return (0, i.qy)`
      <button>
        ${this.leftImageTemplate()} ${this.textTemplate()} ${this.rightImageTemplate()}
      </button>
    `;
        }
        leftImageTemplate() {
          let e = this.icon
            ? (0, i.qy)`<wui-icon
          size=${(0, s.J)(this.iconSize)}
          color="default"
          name=${this.icon}
          class="icon"
        ></wui-icon>`
            : (0,
              i.qy)`<wui-image src=${this.imageSrc} alt=${this.alt}></wui-image>`;
          return (0, i.qy)`
      <wui-flex
        alignItems="center"
        justifyContent="center"
        class="icon-box"
        data-active=${!!this.icon}
      >
        ${e}
        <wui-flex class="circle"></wui-flex>
      </wui-flex>
    `;
        }
        textTemplate() {
          return (0, i.qy)`
      <wui-text variant="lg-regular" color="primary">
        ${f.Z.getTruncateString({
          string: this.profileName || this.address,
          charsStart: this.profileName ? 16 : this.charsStart,
          charsEnd: this.profileName ? 0 : this.charsEnd,
          truncate: this.profileName ? "end" : "middle",
        })}
      </wui-text>
    `;
        }
        rightImageTemplate() {
          return (0,
          i.qy)`<wui-icon name="chevronBottom" size="sm" color="default"></wui-icon>`;
        }
      };
      (ev.styles = [p.W5, p.fD, ew]),
        eb([(0, n.MZ)()], ev.prototype, "address", void 0),
        eb([(0, n.MZ)()], ev.prototype, "profileName", void 0),
        eb([(0, n.MZ)()], ev.prototype, "alt", void 0),
        eb([(0, n.MZ)()], ev.prototype, "imageSrc", void 0),
        eb([(0, n.MZ)()], ev.prototype, "icon", void 0),
        eb([(0, n.MZ)()], ev.prototype, "iconSize", void 0),
        eb([(0, n.MZ)({ type: Boolean })], ev.prototype, "loading", void 0),
        eb([(0, n.MZ)({ type: Number })], ev.prototype, "charsStart", void 0),
        eb([(0, n.MZ)({ type: Number })], ev.prototype, "charsEnd", void 0),
        (ev = eb([(0, g.E)("wui-wallet-switch")], ev));
      let eC = (0, u.AH)`
  wui-icon-link {
    margin-right: calc(${({ spacing: e }) => e["8"]} * -1);
  }

  wui-notice-card {
    margin-bottom: ${({ spacing: e }) => e["1"]};
  }

  wui-list-item > wui-text {
    flex: 1;
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ spacing: e }) => e["3"]};
    height: 48px;
    padding: ${({ spacing: e }) => e["2"]};
    padding-right: ${({ spacing: e }) => e["3"]};
    box-shadow: inset 0 0 0 1px ${({ tokens: e }) => e.theme.foregroundPrimary};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[6]};
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
  }

  .account-button:hover {
    background-color: ${({ tokens: e }) => e.core.glass010};
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px ${({ tokens: e }) => e.core.glass010};
  }

  wui-wallet-switch {
    margin-top: ${({ spacing: e }) => e["2"]};
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px ${({ tokens: e }) => e.core.glass010};
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition:
      background-color ${({ durations: e }) => e.md}
        ${({ easings: e }) => e["ease-out-power-1"]},
      opacity ${({ durations: e }) => e.md} ${({ easings: e }) =>
        e["ease-out-power-1"]};
    will-change: background-color, opacity;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;
      var eE = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ex = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.caipAddress = o.W.getAccountData()?.caipAddress),
            (this.address = d.w.getPlainAddress(
              o.W.getAccountData()?.caipAddress
            )),
            (this.profileImage = o.W.getAccountData()?.profileImage),
            (this.profileName = o.W.getAccountData()?.profileName),
            (this.disconnecting = !1),
            (this.balance = o.W.getAccountData()?.balance),
            (this.balanceSymbol = o.W.getAccountData()?.balanceSymbol),
            (this.features = a.H.state.features),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            (this.namespace = o.W.state.activeChain),
            (this.activeConnectorIds = K.a.state.activeConnectorIds),
            this.unsubscribe.push(
              o.W.subscribeChainProp("accountState", (e) => {
                (this.address = d.w.getPlainAddress(e?.caipAddress)),
                  (this.caipAddress = e?.caipAddress),
                  (this.balance = e?.balance),
                  (this.balanceSymbol = e?.balanceSymbol),
                  (this.profileName = e?.profileName),
                  (this.profileImage = e?.profileImage);
              }),
              a.H.subscribeKey("features", (e) => (this.features = e)),
              a.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              ),
              K.a.subscribeKey("activeConnectorIds", (e) => {
                this.activeConnectorIds = e;
              }),
              o.W.subscribeKey("activeChain", (e) => (this.namespace = e)),
              o.W.subscribeKey("activeCaipNetwork", (e) => {
                e?.chainNamespace && (this.namespace = e?.chainNamespace);
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          if (!this.caipAddress || !this.namespace) return null;
          let e = this.activeConnectorIds[this.namespace],
            t = e ? K.a.getConnectorById(e) : void 0,
            r = l.$.getConnectorImage(t),
            {
              value: n,
              decimals: a,
              symbol: o,
            } = d.w.parseBalance(this.balance, this.balanceSymbol);
          return (0, i.qy)`<wui-flex
        flexDirection="column"
        .padding=${["0", "5", "4", "5"]}
        alignItems="center"
        gap="3"
      >
        <wui-avatar
          alt=${(0, s.J)(this.caipAddress)}
          address=${(0, s.J)(d.w.getPlainAddress(this.caipAddress))}
          imageSrc=${(0, s.J)(
            null === this.profileImage ? void 0 : this.profileImage
          )}
          data-testid="single-account-avatar"
        ></wui-avatar>
        <wui-wallet-switch
          profileName=${this.profileName}
          address=${this.address}
          imageSrc=${r}
          alt=${t?.name}
          @click=${this.onGoToProfileWalletsView.bind(this)}
          data-testid="wui-wallet-switch"
        ></wui-wallet-switch>
        <wui-flex flexDirection="row" alignItems="flex-end" justifyContent="center" gap="1">
          <wui-text variant="h3-regular" color="primary">${n}</wui-text>
          <wui-text variant="h3-regular" color="secondary">.${a}</wui-text>
          <wui-text variant="h6-medium" color="primary">${o}</wui-text>
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="2" .padding=${["0", "3", "3", "3"]}>
        ${this.authCardTemplate()} <w3m-account-auth-button></w3m-account-auth-button>
        ${this.orderedFeaturesTemplate()} ${this.activityTemplate()}
        <wui-list-item
          .rounded=${!0}
          icon="power"
          iconColor="error"
          ?chevron=${!1}
          .loading=${this.disconnecting}
          .rightIcon=${!1}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="lg-regular" color="primary">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
        }
        fundWalletTemplate() {
          if (!this.namespace) return null;
          let e = G.oU.ONRAMP_SUPPORTED_CHAIN_NAMESPACES.includes(
              this.namespace
            ),
            t = G.oU.PAY_WITH_EXCHANGE_SUPPORTED_CHAIN_NAMESPACES.includes(
              this.namespace
            ),
            r = !!this.features?.receive,
            n = this.remoteFeatures?.onramp && e,
            s = this.remoteFeatures?.payWithExchange && t;
          return n || r || s
            ? (0, i.qy)`
      <wui-list-item
        .rounded=${!0}
        data-testid="w3m-account-default-fund-wallet-button"
        iconVariant="blue"
        icon="dollar"
        ?chevron=${!0}
        @click=${this.handleClickFundWallet.bind(this)}
      >
        <wui-text variant="lg-regular" color="primary">Fund wallet</wui-text>
      </wui-list-item>
    `
            : null;
        }
        orderedFeaturesTemplate() {
          return (
            this.features?.walletFeaturesOrder ||
            G.oU.DEFAULT_FEATURES.walletFeaturesOrder
          ).map((e) => {
            switch (e) {
              case "onramp":
                return this.fundWalletTemplate();
              case "swaps":
                return this.swapsTemplate();
              case "send":
                return this.sendTemplate();
              default:
                return null;
            }
          });
        }
        activityTemplate() {
          return this.namespace &&
            this.remoteFeatures?.activity &&
            G.oU.ACTIVITY_ENABLED_CHAIN_NAMESPACES.includes(this.namespace)
            ? (0, i.qy)` <wui-list-item
          .rounded=${!0}
          icon="clock"
          ?chevron=${!0}
          @click=${this.onTransactions.bind(this)}
          data-testid="w3m-account-default-activity-button"
        >
          <wui-text variant="lg-regular" color="primary">Activity</wui-text>
        </wui-list-item>`
            : null;
        }
        swapsTemplate() {
          let e = this.remoteFeatures?.swaps,
            t = o.W.state.activeChain === Z.o.CHAIN.EVM;
          return e && t
            ? (0, i.qy)`
      <wui-list-item
        .rounded=${!0}
        icon="recycleHorizontal"
        ?chevron=${!0}
        @click=${this.handleClickSwap.bind(this)}
        data-testid="w3m-account-default-swaps-button"
      >
        <wui-text variant="lg-regular" color="primary">Swap</wui-text>
      </wui-list-item>
    `
            : null;
        }
        sendTemplate() {
          let e = this.features?.send,
            t = o.W.state.activeChain;
          if (!t)
            throw Error("SendController:sendTemplate - namespace is required");
          let r = G.oU.SEND_SUPPORTED_NAMESPACES.includes(t);
          return e && r
            ? (0, i.qy)`
      <wui-list-item
        .rounded=${!0}
        icon="send"
        ?chevron=${!0}
        @click=${this.handleClickSend.bind(this)}
        data-testid="w3m-account-default-send-button"
      >
        <wui-text variant="lg-regular" color="primary">Send</wui-text>
      </wui-list-item>
    `
            : null;
        }
        authCardTemplate() {
          let e = o.W.state.activeChain;
          if (!e)
            throw Error(
              "AuthCardTemplate:authCardTemplate - namespace is required"
            );
          let t = K.a.getConnectorId(e),
            r = K.a.getAuthConnector(),
            { origin: n } = location;
          return !r ||
            t !== Z.o.CONNECTOR_ID.AUTH ||
            n.includes(G.oU.SECURE_SITE)
            ? null
            : (0, i.qy)`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
        }
        handleClickFundWallet() {
          X.I.push("FundWallet");
        }
        handleClickSwap() {
          X.I.push("Swap");
        }
        handleClickSend() {
          X.I.push("WalletSend");
        }
        explorerBtnTemplate() {
          return o.W.getAccountData()?.addressExplorerUrl
            ? (0, i.qy)`
      <wui-button size="md" variant="accent-primary" @click=${this.onExplorer.bind(
        this
      )}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `
            : null;
        }
        onTransactions() {
          U.E.sendEvent({
            type: "track",
            event: "CLICK_TRANSACTIONS",
            properties: {
              isSmartAccount:
                (0, Y.lj)(o.W.state.activeChain) ===
                en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
            },
          }),
            X.I.push("Transactions");
        }
        async onDisconnect() {
          try {
            this.disconnecting = !0;
            let e = Q.x.getConnections(this.namespace).length > 0,
              t =
                this.namespace && K.a.state.activeConnectorIds[this.namespace],
              r = this.remoteFeatures?.multiWallet;
            await Q.x.disconnect(r ? { id: t, namespace: this.namespace } : {}),
              e &&
                r &&
                (X.I.push("ProfileWallets"), J.P.showSuccess("Wallet deleted"));
          } catch {
            U.E.sendEvent({
              type: "track",
              event: "DISCONNECT_ERROR",
              properties: { message: "Failed to disconnect" },
            }),
              J.P.showError("Failed to disconnect");
          } finally {
            this.disconnecting = !1;
          }
        }
        onExplorer() {
          let e = o.W.getAccountData()?.addressExplorerUrl;
          e && d.w.openHref(e, "_blank");
        }
        onGoToUpgradeView() {
          U.E.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" }),
            X.I.push("UpgradeEmailWallet");
        }
        onGoToProfileWalletsView() {
          X.I.push("ProfileWallets");
        }
      };
      (ex.styles = eC),
        eE([(0, n.wk)()], ex.prototype, "caipAddress", void 0),
        eE([(0, n.wk)()], ex.prototype, "address", void 0),
        eE([(0, n.wk)()], ex.prototype, "profileImage", void 0),
        eE([(0, n.wk)()], ex.prototype, "profileName", void 0),
        eE([(0, n.wk)()], ex.prototype, "disconnecting", void 0),
        eE([(0, n.wk)()], ex.prototype, "balance", void 0),
        eE([(0, n.wk)()], ex.prototype, "balanceSymbol", void 0),
        eE([(0, n.wk)()], ex.prototype, "features", void 0),
        eE([(0, n.wk)()], ex.prototype, "remoteFeatures", void 0),
        eE([(0, n.wk)()], ex.prototype, "namespace", void 0),
        eE([(0, n.wk)()], ex.prototype, "activeConnectorIds", void 0),
        (ex = eE([(0, u.EM)("w3m-account-default-widget")], ex));
      let eA = (0, m.AH)`
  span {
    font-weight: 500;
    font-size: 38px;
    color: ${({ tokens: e }) => e.theme.textPrimary};
    line-height: 38px;
    letter-spacing: -2%;
    text-align: center;
    font-family: var(--apkt-fontFamily-regular);
  }

  .pennies {
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }
`;
      var e_ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eI = class extends i.WF {
        constructor() {
          super(...arguments), (this.dollars = "0"), (this.pennies = "00");
        }
        render() {
          return (0,
          i.qy)`<span>$${this.dollars}<span class="pennies">.${this.pennies}</span></span>`;
        }
      };
      (eI.styles = [p.W5, eA]),
        e_([(0, n.MZ)()], eI.prototype, "dollars", void 0),
        e_([(0, n.MZ)()], eI.prototype, "pennies", void 0),
        (eI = e_([(0, g.E)("wui-balance")], eI));
      let eS = (0, m.AH)`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  /* -- Variants --------------------------------------------------------- */
  :host([data-variant='fill']) {
    background-color: ${({ colors: e }) => e.neutrals100};
  }

  :host([data-variant='shade']) {
    background-color: ${({ colors: e }) => e.neutrals900};
  }

  :host([data-variant='fill']) > wui-text {
    color: ${({ colors: e }) => e.black};
  }

  :host([data-variant='shade']) > wui-text {
    color: ${({ colors: e }) => e.white};
  }

  :host([data-variant='fill']) > wui-icon {
    color: ${({ colors: e }) => e.neutrals100};
  }

  :host([data-variant='shade']) > wui-icon {
    color: ${({ colors: e }) => e.neutrals900};
  }

  /* -- Sizes --------------------------------------------------------- */
  :host([data-size='sm']) {
    padding: ${({ spacing: e }) => e[1]} ${({ spacing: e }) => e[2]};
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host([data-size='md']) {
    padding: ${({ spacing: e }) => e[2]} ${({ spacing: e }) => e[3]};
    border-radius: ${({ borderRadius: e }) => e[3]};
  }

  /* -- Placements --------------------------------------------------------- */
  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
      var ek = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eN = { sm: "sm-regular", md: "md-regular" },
        eT = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.placement = "top"),
              (this.variant = "fill"),
              (this.size = "md"),
              (this.message = "");
          }
          render() {
            return (
              (this.dataset.variant = this.variant),
              (this.dataset.size = this.size),
              (0, i.qy)`<wui-icon data-placement=${
                this.placement
              } size="inherit" name="cursor"></wui-icon>
      <wui-text variant=${eN[this.size]}>${this.message}</wui-text>`
            );
          }
        };
      (eT.styles = [p.W5, p.fD, eS]),
        ek([(0, n.MZ)()], eT.prototype, "placement", void 0),
        ek([(0, n.MZ)()], eT.prototype, "variant", void 0),
        ek([(0, n.MZ)()], eT.prototype, "size", void 0),
        ek([(0, n.MZ)()], eT.prototype, "message", void 0),
        (eT = ek([(0, g.E)("wui-tooltip")], eT));
      var eO = r(48981),
        eP = r(21471);
      r(20943);
      let eR = (0, i.AH)`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`,
        e$ = class extends i.WF {
          render() {
            return (0,
            i.qy)`<w3m-activity-list page="account"></w3m-activity-list>`;
          }
        };
      (e$.styles = eR),
        (e$ = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, u.EM)("w3m-account-activity-widget")], e$)),
        r(50505);
      let eD = (0, m.AH)`
  :host {
    width: 100%;
  }

  button {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: ${({ spacing: e }) => e[4]};
    padding: ${({ spacing: e }) => e[4]};
    background-color: transparent;
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  wui-text {
    max-width: 174px;
  }

  .tag-container {
    width: fit-content;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    }
  }
`;
      var eU = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eM = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.icon = "card"),
            (this.text = ""),
            (this.description = ""),
            (this.tag = void 0),
            (this.disabled = !1);
        }
        render() {
          return (0, i.qy)`
      <button ?disabled=${this.disabled}>
        <wui-flex alignItems="center" gap="3">
          <wui-icon-box padding="2" color="secondary" icon=${
            this.icon
          } size="lg"></wui-icon-box>
          <wui-flex flexDirection="column" gap="1">
            <wui-text variant="md-medium" color="primary">${
              this.text
            }</wui-text>
            ${
              this.description
                ? (0, i.qy)`<wui-text variant="md-regular" color="secondary">
                  ${this.description}</wui-text
                >`
                : null
            }
          </wui-flex>
        </wui-flex>

        <wui-flex class="tag-container" alignItems="center" gap="1" justifyContent="flex-end">
          ${
            this.tag
              ? (0,
                i.qy)`<wui-tag tagType="main" size="sm">${this.tag}</wui-tag>`
              : null
          }
          <wui-icon size="md" name="chevronRight" color="default"></wui-icon>
        </wui-flex>
      </button>
    `;
        }
      };
      (eM.styles = [p.W5, p.fD, eD]),
        eU([(0, n.MZ)()], eM.prototype, "icon", void 0),
        eU([(0, n.MZ)()], eM.prototype, "text", void 0),
        eU([(0, n.MZ)()], eM.prototype, "description", void 0),
        eU([(0, n.MZ)()], eM.prototype, "tag", void 0),
        eU([(0, n.MZ)({ type: Boolean })], eM.prototype, "disabled", void 0),
        (eM = eU([(0, g.E)("wui-list-description")], eM)),
        r(64501);
      let eL = (0, i.AH)`
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;
      var eB = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eW = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tokenBalance = o.W.getAccountData()?.tokenBalance),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            this.unsubscribe.push(
              o.W.subscribeChainProp("accountState", (e) => {
                this.tokenBalance = e?.tokenBalance;
              }),
              a.H.subscribeKey("remoteFeatures", (e) => {
                this.remoteFeatures = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`${this.tokenTemplate()}`;
        }
        tokenTemplate() {
          return this.tokenBalance && this.tokenBalance?.length > 0
            ? (0,
              i.qy)`<wui-flex class="contentContainer" flexDirection="column" gap="2">
        ${this.tokenItemTemplate()}
      </wui-flex>`
            : (0, i.qy)` <wui-flex flexDirection="column">
      ${this.onRampTemplate()}
      <wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Scan the QR code and receive funds"
        icon="qrCode"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
        data-testid="w3m-account-receive-button"
      ></wui-list-description
    ></wui-flex>`;
        }
        onRampTemplate() {
          return this.remoteFeatures?.onramp
            ? (0, i.qy)`<wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
        data-testid="w3m-account-onramp-button"
      ></wui-list-description>`
            : (0, i.qy)``;
        }
        tokenItemTemplate() {
          return this.tokenBalance?.map(
            (e) => (0, i.qy)`<wui-list-token
          tokenName=${e.name}
          tokenImageUrl=${e.iconUrl}
          tokenAmount=${e.quantity.numeric}
          tokenValue=${e.value}
          tokenCurrency=${e.symbol}
        ></wui-list-token>`
          );
        }
        onReceiveClick() {
          X.I.push("WalletReceive");
        }
        onBuyClick() {
          U.E.sendEvent({
            type: "track",
            event: "SELECT_BUY_CRYPTO",
            properties: {
              isSmartAccount:
                (0, Y.lj)(o.W.state.activeChain) ===
                en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
            },
          }),
            X.I.push("OnRampProviders");
        }
      };
      (eW.styles = eL),
        eB([(0, n.wk)()], eW.prototype, "tokenBalance", void 0),
        eB([(0, n.wk)()], eW.prototype, "remoteFeatures", void 0),
        (eW = eB([(0, u.EM)("w3m-account-tokens-widget")], eW)),
        r(61896),
        r(35135);
      let ej = (0, u.AH)`
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: calc(-1 * ${({ spacing: e }) => e["4"]});
  }

  wui-promo + wui-profile-button {
    margin-top: ${({ spacing: e }) => e["4"]};
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: ${({ borderRadius: e }) => e["3"]};
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
      var eF = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eH = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.unsubscribe = []),
            (this.network = o.W.state.activeCaipNetwork),
            (this.profileName = o.W.getAccountData()?.profileName),
            (this.address = o.W.getAccountData()?.address),
            (this.currentTab = o.W.getAccountData()?.currentTab),
            (this.tokenBalance = o.W.getAccountData()?.tokenBalance),
            (this.features = a.H.state.features),
            (this.namespace = o.W.state.activeChain),
            (this.activeConnectorIds = K.a.state.activeConnectorIds),
            (this.remoteFeatures = a.H.state.remoteFeatures);
        }
        firstUpdated() {
          o.W.fetchTokenBalance(),
            this.unsubscribe.push(
              o.W.subscribeChainProp("accountState", (e) => {
                e?.address
                  ? ((this.address = e.address),
                    (this.profileName = e.profileName),
                    (this.currentTab = e.currentTab),
                    (this.tokenBalance = e.tokenBalance))
                  : h.W.close();
              }),
              K.a.subscribeKey("activeConnectorIds", (e) => {
                this.activeConnectorIds = e;
              }),
              o.W.subscribeKey("activeChain", (e) => (this.namespace = e)),
              o.W.subscribeKey("activeCaipNetwork", (e) => (this.network = e)),
              a.H.subscribeKey("features", (e) => (this.features = e)),
              a.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              )
            ),
            this.watchSwapValues();
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e()),
            clearInterval(this.watchTokenBalance);
        }
        render() {
          if (!this.address)
            throw Error("w3m-account-features-widget: No account provided");
          if (!this.namespace) return null;
          let e = this.activeConnectorIds[this.namespace],
            t = e ? K.a.getConnectorById(e) : void 0,
            { icon: r, iconSize: n } = this.getAuthData();
          return (0, i.qy)`<wui-flex
      flexDirection="column"
      .padding=${["0", "3", "4", "3"]}
      alignItems="center"
      gap="4"
      data-testid="w3m-account-wallet-features-widget"
    >
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center" gap="2">
        <wui-wallet-switch
          profileName=${this.profileName}
          address=${this.address}
          icon=${r}
          iconSize=${n}
          alt=${t?.name}
          @click=${this.onGoToProfileWalletsView.bind(this)}
          data-testid="wui-wallet-switch"
        ></wui-wallet-switch>

        ${this.tokenBalanceTemplate()}
      </wui-flex>
      ${this.orderedWalletFeatures()} ${this.tabsTemplate()} ${this.listContentTemplate()}
    </wui-flex>`;
        }
        orderedWalletFeatures() {
          let e =
            this.features?.walletFeaturesOrder ||
            G.oU.DEFAULT_FEATURES.walletFeaturesOrder;
          if (
            e.every((e) =>
              "send" === e || "receive" === e
                ? !this.features?.[e]
                : ("swaps" !== e && "onramp" !== e) || !this.remoteFeatures?.[e]
            )
          )
            return null;
          let t = [
            ...new Set(
              e.map((e) => ("receive" === e || "onramp" === e ? "fund" : e))
            ),
          ];
          return (0, i.qy)`<wui-flex gap="2">
      ${t.map((e) => {
        switch (e) {
          case "fund":
            return this.fundWalletTemplate();
          case "swaps":
            return this.swapsTemplate();
          case "send":
            return this.sendTemplate();
          default:
            return null;
        }
      })}
    </wui-flex>`;
        }
        fundWalletTemplate() {
          if (!this.namespace) return null;
          let e = G.oU.ONRAMP_SUPPORTED_CHAIN_NAMESPACES.includes(
              this.namespace
            ),
            t = G.oU.PAY_WITH_EXCHANGE_SUPPORTED_CHAIN_NAMESPACES.includes(
              this.namespace
            ),
            r = this.features?.receive,
            n = this.remoteFeatures?.onramp && e,
            s = this.remoteFeatures?.payWithExchange && t;
          return n || r || s
            ? (0, i.qy)`
      <w3m-tooltip-trigger text="Fund wallet">
        <wui-button
          data-testid="wallet-features-fund-wallet-button"
          @click=${this.onFundWalletClick.bind(this)}
          variant="accent-secondary"
          size="lg"
          fullWidth
        >
          <wui-icon name="dollar"></wui-icon>
        </wui-button>
      </w3m-tooltip-trigger>
    `
            : null;
        }
        swapsTemplate() {
          let e = this.remoteFeatures?.swaps,
            t = o.W.state.activeChain === Z.o.CHAIN.EVM;
          return e && t
            ? (0, i.qy)`
      <w3m-tooltip-trigger text="Swap">
        <wui-button
          fullWidth
          data-testid="wallet-features-swaps-button"
          @click=${this.onSwapClick.bind(this)}
          variant="accent-secondary"
          size="lg"
        >
          <wui-icon name="recycleHorizontal"></wui-icon>
        </wui-button>
      </w3m-tooltip-trigger>
    `
            : null;
        }
        sendTemplate() {
          let e = this.features?.send,
            t = o.W.state.activeChain,
            r = G.oU.SEND_SUPPORTED_NAMESPACES.includes(t);
          return e && r
            ? (0, i.qy)`
      <w3m-tooltip-trigger text="Send">
        <wui-button
          fullWidth
          data-testid="wallet-features-send-button"
          @click=${this.onSendClick.bind(this)}
          variant="accent-secondary"
          size="lg"
        >
          <wui-icon name="send"></wui-icon>
        </wui-button>
      </w3m-tooltip-trigger>
    `
            : null;
        }
        watchSwapValues() {
          this.watchTokenBalance = setInterval(
            () => o.W.fetchTokenBalance((e) => this.onTokenBalanceError(e)),
            1e4
          );
        }
        onTokenBalanceError(e) {
          e instanceof Error &&
            e.cause instanceof Response &&
            e.cause.status === Z.o.HTTP_STATUS_CODES.SERVICE_UNAVAILABLE &&
            clearInterval(this.watchTokenBalance);
        }
        listContentTemplate() {
          return 0 === this.currentTab
            ? (0, i.qy)`<w3m-account-tokens-widget></w3m-account-tokens-widget>`
            : 1 === this.currentTab
            ? (0,
              i.qy)`<w3m-account-activity-widget></w3m-account-activity-widget>`
            : (0,
              i.qy)`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
        }
        tokenBalanceTemplate() {
          if (this.tokenBalance && this.tokenBalance?.length >= 0) {
            let e = d.w.calculateBalance(this.tokenBalance),
              { dollars: t = "0", pennies: r = "00" } =
                d.w.formatTokenBalance(e);
            return (0,
            i.qy)`<wui-balance dollars=${t} pennies=${r}></wui-balance>`;
          }
          return (0,
          i.qy)`<wui-balance dollars="0" pennies="00"></wui-balance>`;
        }
        tabsTemplate() {
          let e = eP.y.getTabsByNamespace(o.W.state.activeChain);
          return 0 === e.length
            ? null
            : (0, i.qy)`<wui-tabs
      .onTabChange=${this.onTabChange.bind(this)}
      .activeTab=${this.currentTab}
      .tabs=${e}
    ></wui-tabs>`;
        }
        onTabChange(e) {
          o.W.setAccountProp("currentTab", e, this.namespace);
        }
        onFundWalletClick() {
          X.I.push("FundWallet");
        }
        onSwapClick() {
          this.network?.caipNetworkId &&
          !G.oU.SWAP_SUPPORTED_NETWORKS.includes(this.network?.caipNetworkId)
            ? X.I.push("UnsupportedChain", { swapUnsupportedChain: !0 })
            : (U.E.sendEvent({
                type: "track",
                event: "OPEN_SWAP",
                properties: {
                  network: this.network?.caipNetworkId || "",
                  isSmartAccount:
                    (0, Y.lj)(o.W.state.activeChain) ===
                    en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                },
              }),
              X.I.push("Swap"));
        }
        getAuthData() {
          let e = es.i.getConnectedSocialProvider(),
            t = es.i.getConnectedSocialUsername(),
            r = K.a.getAuthConnector(),
            i = r?.provider.getEmail() ?? "";
          return {
            name: eO.g.getAuthName({
              email: i,
              socialUsername: t,
              socialProvider: e,
            }),
            icon: e ?? "mail",
            iconSize: e ? "xl" : "md",
          };
        }
        onGoToProfileWalletsView() {
          X.I.push("ProfileWallets");
        }
        onSendClick() {
          U.E.sendEvent({
            type: "track",
            event: "OPEN_SEND",
            properties: {
              network: this.network?.caipNetworkId || "",
              isSmartAccount:
                (0, Y.lj)(o.W.state.activeChain) ===
                en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
            },
          }),
            X.I.push("WalletSend");
        }
      };
      (eH.styles = ej),
        eF([(0, n.wk)()], eH.prototype, "watchTokenBalance", void 0),
        eF([(0, n.wk)()], eH.prototype, "network", void 0),
        eF([(0, n.wk)()], eH.prototype, "profileName", void 0),
        eF([(0, n.wk)()], eH.prototype, "address", void 0),
        eF([(0, n.wk)()], eH.prototype, "currentTab", void 0),
        eF([(0, n.wk)()], eH.prototype, "tokenBalance", void 0),
        eF([(0, n.wk)()], eH.prototype, "features", void 0),
        eF([(0, n.wk)()], eH.prototype, "namespace", void 0),
        eF([(0, n.wk)()], eH.prototype, "activeConnectorIds", void 0),
        eF([(0, n.wk)()], eH.prototype, "remoteFeatures", void 0),
        (eH = eF([(0, u.EM)("w3m-account-wallet-features-widget")], eH));
      var eq = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ez = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.namespace = o.W.state.activeChain),
            this.unsubscribe.push(
              o.W.subscribeKey("activeChain", (e) => {
                this.namespace = e;
              })
            );
        }
        render() {
          if (!this.namespace) return null;
          let e = K.a.getConnectorId(this.namespace),
            t = K.a.getAuthConnector();
          return (0, i.qy)`
      ${
        t && e === Z.o.CONNECTOR_ID.AUTH
          ? this.walletFeaturesTemplate()
          : this.defaultTemplate()
      }
    `;
        }
        walletFeaturesTemplate() {
          return (0,
          i.qy)`<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
        }
        defaultTemplate() {
          return (0,
          i.qy)`<w3m-account-default-widget></w3m-account-default-widget>`;
        }
      };
      eq([(0, n.wk)()], ez.prototype, "namespace", void 0),
        (ez = eq([(0, u.EM)("w3m-account-view")], ez));
      var eV = r(2354),
        eZ = r(65103),
        eK = r(4768);
      r(4693), r(18294);
      let eG = (0, m.AH)`
  wui-image {
    width: 24px;
    height: 24px;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  wui-image,
  .icon-box {
    width: 32px;
    height: 32px;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  wui-icon:not(.custom-icon, .icon-badge) {
    cursor: pointer;
  }

  .icon-box {
    position: relative;
    border-radius: ${({ borderRadius: e }) => e[2]};
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  .icon-badge {
    position: absolute;
    top: 18px;
    left: 23px;
    z-index: 3;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border: 2px solid ${({ tokens: e }) => e.theme.backgroundPrimary};
    border-radius: 50%;
    padding: ${({ spacing: e }) => e["01"]};
  }

  .icon-badge {
    width: 8px;
    height: 8px;
  }
`;
      var eJ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let eY = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.address = ""),
            (this.profileName = ""),
            (this.content = []),
            (this.alt = ""),
            (this.imageSrc = ""),
            (this.icon = void 0),
            (this.iconSize = "md"),
            (this.iconBadge = void 0),
            (this.iconBadgeSize = "md"),
            (this.buttonVariant = "neutral-primary"),
            (this.enableMoreButton = !1),
            (this.charsStart = 4),
            (this.charsEnd = 6);
        }
        render() {
          return (0, i.qy)`
      <wui-flex flexDirection="column" rowgap="2">
        ${this.topTemplate()} ${this.bottomTemplate()}
      </wui-flex>
    `;
        }
        topTemplate() {
          return (0, i.qy)`
      <wui-flex alignItems="flex-start" justifyContent="space-between">
        ${this.imageOrIconTemplate()}
        <wui-icon-link
          variant="secondary"
          size="md"
          icon="copy"
          @click=${this.dispatchCopyEvent}
        ></wui-icon-link>
        <wui-icon-link
          variant="secondary"
          size="md"
          icon="externalLink"
          @click=${this.dispatchExternalLinkEvent}
        ></wui-icon-link>
        ${
          this.enableMoreButton
            ? (0, i.qy)`<wui-icon-link
              variant="secondary"
              size="md"
              icon="threeDots"
              @click=${this.dispatchMoreButtonEvent}
              data-testid="wui-active-profile-wallet-item-more-button"
            ></wui-icon-link>`
            : null
        }
      </wui-flex>
    `;
        }
        bottomTemplate() {
          return (0,
          i.qy)` <wui-flex flexDirection="column">${this.contentTemplate()}</wui-flex> `;
        }
        imageOrIconTemplate() {
          return this.icon
            ? (0, i.qy)`
        <wui-flex flexGrow="1" alignItems="center">
          <wui-flex alignItems="center" justifyContent="center" class="icon-box">
            <wui-icon size="lg" color="default" name=${
              this.icon
            } class="custom-icon"></wui-icon>

            ${
              this.iconBadge
                ? (0, i.qy)`<wui-icon
                  color="accent-primary"
                  size="inherit"
                  name=${this.iconBadge}
                  class="icon-badge"
                ></wui-icon>`
                : null
            }
          </wui-flex>
        </wui-flex>
      `
            : (0, i.qy)`
      <wui-flex flexGrow="1" alignItems="center">
        <wui-image objectFit="contain" src=${this.imageSrc} alt=${this.alt}></wui-image>
      </wui-flex>
    `;
        }
        contentTemplate() {
          return 0 === this.content.length
            ? null
            : (0, i.qy)`
      <wui-flex flexDirection="column" rowgap="3">
        ${this.content.map((e) => this.labelAndTagTemplate(e))}
      </wui-flex>
    `;
        }
        labelAndTagTemplate({
          address: e,
          profileName: t,
          label: r,
          description: n,
          enableButton: s,
          buttonType: a,
          buttonLabel: o,
          buttonVariant: c,
          tagVariant: l,
          tagLabel: d,
          alignItems: h = "flex-end",
        }) {
          return (0, i.qy)`
      <wui-flex justifyContent="space-between" alignItems=${h} columngap="1">
        <wui-flex flexDirection="column" rowgap="01">
          ${
            r
              ? (0,
                i.qy)`<wui-text variant="sm-medium" color="secondary">${r}</wui-text>`
              : null
          }

          <wui-flex alignItems="center" columngap="1">
            <wui-text variant="md-regular" color="primary">
              ${f.Z.getTruncateString({
                string: t || e,
                charsStart: t ? 16 : this.charsStart,
                charsEnd: t ? 0 : this.charsEnd,
                truncate: t ? "end" : "middle",
              })}
            </wui-text>

            ${
              l && d
                ? (0, i.qy)`<wui-tag variant=${l} size="sm">${d}</wui-tag>`
                : null
            }
          </wui-flex>

          ${
            n
              ? (0,
                i.qy)`<wui-text variant="sm-regular" color="secondary">${n}</wui-text>`
              : null
          }
        </wui-flex>

        ${
          s
            ? this.buttonTemplate({
                buttonType: a,
                buttonLabel: o,
                buttonVariant: c,
              })
            : null
        }
      </wui-flex>
    `;
        }
        buttonTemplate({ buttonType: e, buttonLabel: t, buttonVariant: r }) {
          return (0, i.qy)`
      <wui-button
        size="sm"
        variant=${r}
        @click=${
          "disconnect" === e
            ? this.dispatchDisconnectEvent.bind(this)
            : this.dispatchSwitchEvent.bind(this)
        }
        data-testid=${
          "disconnect" === e
            ? "wui-active-profile-wallet-item-disconnect-button"
            : "wui-active-profile-wallet-item-switch-button"
        }
      >
        ${t}
      </wui-button>
    `;
        }
        dispatchDisconnectEvent() {
          this.dispatchEvent(
            new CustomEvent("disconnect", { bubbles: !0, composed: !0 })
          );
        }
        dispatchSwitchEvent() {
          this.dispatchEvent(
            new CustomEvent("switch", { bubbles: !0, composed: !0 })
          );
        }
        dispatchExternalLinkEvent() {
          this.dispatchEvent(
            new CustomEvent("externalLink", { bubbles: !0, composed: !0 })
          );
        }
        dispatchMoreButtonEvent() {
          this.dispatchEvent(
            new CustomEvent("more", { bubbles: !0, composed: !0 })
          );
        }
        dispatchCopyEvent() {
          this.dispatchEvent(
            new CustomEvent("copy", { bubbles: !0, composed: !0 })
          );
        }
      };
      (eY.styles = [p.W5, p.fD, eG]),
        eJ([(0, n.MZ)()], eY.prototype, "address", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "profileName", void 0),
        eJ([(0, n.MZ)({ type: Array })], eY.prototype, "content", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "alt", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "imageSrc", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "icon", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "iconSize", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "iconBadge", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "iconBadgeSize", void 0),
        eJ([(0, n.MZ)()], eY.prototype, "buttonVariant", void 0),
        eJ(
          [(0, n.MZ)({ type: Boolean })],
          eY.prototype,
          "enableMoreButton",
          void 0
        ),
        eJ([(0, n.MZ)({ type: Number })], eY.prototype, "charsStart", void 0),
        eJ([(0, n.MZ)({ type: Number })], eY.prototype, "charsEnd", void 0),
        (eY = eJ([(0, g.E)("wui-active-profile-wallet-item")], eY)),
        r(90721);
      let eX = (0, m.AH)`
  wui-image,
  .icon-box {
    width: 32px;
    height: 32px;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  .right-icon {
    cursor: pointer;
  }

  .icon-box {
    position: relative;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  .icon-badge {
    position: absolute;
    top: 18px;
    left: 23px;
    z-index: 3;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border: 2px solid ${({ tokens: e }) => e.theme.backgroundPrimary};
    border-radius: 50%;
    padding: ${({ spacing: e }) => e["01"]};
  }

  .icon-badge {
    width: 8px;
    height: 8px;
  }
`;
      var eQ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let e0 = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.address = ""),
            (this.profileName = ""),
            (this.alt = ""),
            (this.buttonLabel = ""),
            (this.buttonVariant = "accent-primary"),
            (this.imageSrc = ""),
            (this.icon = void 0),
            (this.iconSize = "md"),
            (this.iconBadgeSize = "md"),
            (this.rightIcon = "signOut"),
            (this.rightIconSize = "md"),
            (this.loading = !1),
            (this.charsStart = 4),
            (this.charsEnd = 6);
        }
        render() {
          return (0, i.qy)`
      <wui-flex alignItems="center" columngap="2">
        ${this.imageOrIconTemplate()} ${this.labelAndDescriptionTemplate()}
        ${this.buttonActionTemplate()}
      </wui-flex>
    `;
        }
        imageOrIconTemplate() {
          return this.icon
            ? (0, i.qy)`
        <wui-flex alignItems="center" justifyContent="center" class="icon-box">
          <wui-flex alignItems="center" justifyContent="center" class="icon-box">
            <wui-icon size="lg" color="default" name=${
              this.icon
            } class="custom-icon"></wui-icon>

            ${
              this.iconBadge
                ? (0, i.qy)`<wui-icon
                  color="default"
                  size="inherit"
                  name=${this.iconBadge}
                  class="icon-badge"
                ></wui-icon>`
                : null
            }
          </wui-flex>
        </wui-flex>
      `
            : (0,
              i.qy)`<wui-image objectFit="contain" src=${this.imageSrc} alt=${this.alt}></wui-image>`;
        }
        labelAndDescriptionTemplate() {
          return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        flexGrow="1"
        justifyContent="flex-start"
        alignItems="flex-start"
      >
        <wui-text variant="lg-regular" color="primary">
          ${f.Z.getTruncateString({
            string: this.profileName || this.address,
            charsStart: this.profileName ? 16 : this.charsStart,
            charsEnd: this.profileName ? 0 : this.charsEnd,
            truncate: this.profileName ? "end" : "middle",
          })}
        </wui-text>
      </wui-flex>
    `;
        }
        buttonActionTemplate() {
          return (0, i.qy)`
      <wui-flex columngap="1" alignItems="center" justifyContent="center">
        <wui-button
          size="sm"
          variant=${this.buttonVariant}
          .loading=${this.loading}
          @click=${this.handleButtonClick}
          data-testid="wui-inactive-profile-wallet-item-button"
        >
          ${this.buttonLabel}
        </wui-button>

        <wui-icon-link
          variant="secondary"
          size="md"
          icon=${(0, s.J)(this.rightIcon)}
          class="right-icon"
          @click=${this.handleIconClick}
        ></wui-icon-link>
      </wui-flex>
    `;
        }
        handleButtonClick() {
          this.dispatchEvent(
            new CustomEvent("buttonClick", { bubbles: !0, composed: !0 })
          );
        }
        handleIconClick() {
          this.dispatchEvent(
            new CustomEvent("iconClick", { bubbles: !0, composed: !0 })
          );
        }
      };
      (e0.styles = [p.W5, p.fD, eX]),
        eQ([(0, n.MZ)()], e0.prototype, "address", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "profileName", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "alt", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "buttonLabel", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "buttonVariant", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "imageSrc", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "icon", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "iconSize", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "iconBadge", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "iconBadgeSize", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "rightIcon", void 0),
        eQ([(0, n.MZ)()], e0.prototype, "rightIconSize", void 0),
        eQ([(0, n.MZ)({ type: Boolean })], e0.prototype, "loading", void 0),
        eQ([(0, n.MZ)({ type: Number })], e0.prototype, "charsStart", void 0),
        eQ([(0, n.MZ)({ type: Number })], e0.prototype, "charsEnd", void 0),
        (e0 = eQ([(0, g.E)("wui-inactive-profile-wallet-item")], e0)),
        r(39752);
      var e1 = r(79355);
      let e2 = {
          getAuthData(e) {
            let t = e.connectorId === Z.o.CONNECTOR_ID.AUTH;
            if (!t)
              return {
                isAuth: !1,
                icon: void 0,
                iconSize: void 0,
                name: void 0,
              };
            let r = e?.auth?.name ?? es.i.getConnectedSocialProvider(),
              i = e?.auth?.username ?? es.i.getConnectedSocialUsername(),
              n = K.a.getAuthConnector(),
              s = n?.provider.getEmail() ?? "";
            return {
              isAuth: !0,
              icon: r ?? "mail",
              iconSize: r ? "xl" : "md",
              name: t
                ? eO.g.getAuthName({
                    email: s,
                    socialUsername: i,
                    socialProvider: r,
                  })
                : void 0,
            };
          },
        },
        e3 = (0, u.AH)`
  :host {
    --connect-scroll--top-opacity: 0;
    --connect-scroll--bottom-opacity: 0;
  }

  .balance-amount {
    flex: 1;
  }

  .wallet-list {
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
    transition: opacity ${({ easings: e }) => e["ease-out-power-1"]}
      ${({ durations: e }) => e.md};
    will-change: opacity;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--connect-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--connect-scroll--top-opacity))) 1px,
      black 40px,
      black calc(100% - 40px),
      rgba(155, 155, 155, calc(1 - var(--connect-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--connect-scroll--bottom-opacity))) 100%
    );
  }

  .active-wallets {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e["4"]};
  }

  .active-wallets-box {
    height: 330px;
  }

  .empty-wallet-list-box {
    height: 400px;
  }

  .empty-box {
    width: 100%;
    padding: ${({ spacing: e }) => e["4"]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e["4"]};
  }

  wui-separator {
    margin: ${({ spacing: e }) => e["2"]} 0 ${({ spacing: e }) => e["2"]} 0;
  }

  .active-connection {
    padding: ${({ spacing: e }) => e["2"]};
  }

  .recent-connection {
    padding: ${({ spacing: e }) => e["2"]} 0 ${({ spacing: e }) => e["2"]} 0;
  }

  @media (max-width: 430px) {
    .active-wallets-box,
    .empty-wallet-list-box {
      height: auto;
      max-height: clamp(360px, 470px, 80vh);
    }
  }
`;
      var e5 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let e4 = {
          ADDRESS_DISPLAY: { START: 4, END: 6 },
          BADGE: { SIZE: "md", ICON: "lightbulb" },
          SCROLL_THRESHOLD: 50,
          OPACITY_RANGE: [0, 1],
        },
        e6 = { eip155: "ethereum", solana: "solana", bip122: "bitcoin" },
        e8 = [
          { namespace: "eip155", icon: e6.eip155, label: "EVM" },
          { namespace: "solana", icon: e6.solana, label: "Solana" },
          { namespace: "bip122", icon: e6.bip122, label: "Bitcoin" },
        ],
        e9 = {
          eip155: {
            title: "Add EVM Wallet",
            description: "Add your first EVM wallet",
          },
          solana: {
            title: "Add Solana Wallet",
            description: "Add your first Solana wallet",
          },
          bip122: {
            title: "Add Bitcoin Wallet",
            description: "Add your first Bitcoin wallet",
          },
        },
        e7 = class extends i.WF {
          constructor() {
            super(),
              (this.unsubscribers = []),
              (this.currentTab = 0),
              (this.namespace = o.W.state.activeChain),
              (this.namespaces = Array.from(o.W.state.chains.keys())),
              (this.caipAddress = void 0),
              (this.profileName = void 0),
              (this.activeConnectorIds = K.a.state.activeConnectorIds),
              (this.lastSelectedAddress = ""),
              (this.lastSelectedConnectorId = ""),
              (this.isSwitching = !1),
              (this.caipNetwork = o.W.state.activeCaipNetwork),
              (this.user = o.W.getAccountData()?.user),
              (this.remoteFeatures = a.H.state.remoteFeatures),
              (this.currentTab = this.namespace
                ? this.namespaces.indexOf(this.namespace)
                : 0),
              (this.caipAddress = o.W.getAccountData(
                this.namespace
              )?.caipAddress),
              (this.profileName = o.W.getAccountData(
                this.namespace
              )?.profileName),
              this.unsubscribers.push(
                Q.x.subscribeKey("connections", () =>
                  this.onConnectionsChange()
                ),
                Q.x.subscribeKey("recentConnections", () =>
                  this.requestUpdate()
                ),
                K.a.subscribeKey("activeConnectorIds", (e) => {
                  this.activeConnectorIds = e;
                }),
                o.W.subscribeKey(
                  "activeCaipNetwork",
                  (e) => (this.caipNetwork = e)
                ),
                o.W.subscribeChainProp("accountState", (e) => {
                  this.user = e?.user;
                }),
                a.H.subscribeKey(
                  "remoteFeatures",
                  (e) => (this.remoteFeatures = e)
                )
              ),
              (this.chainListener = o.W.subscribeChainProp(
                "accountState",
                (e) => {
                  (this.caipAddress = e?.caipAddress),
                    (this.profileName = e?.profileName);
                },
                this.namespace
              ));
          }
          disconnectedCallback() {
            this.unsubscribers.forEach((e) => e()),
              this.resizeObserver?.disconnect(),
              this.removeScrollListener(),
              this.chainListener?.();
          }
          firstUpdated() {
            let e = this.shadowRoot?.querySelector(".wallet-list");
            if (!e) return;
            let t = () => this.updateScrollOpacity(e);
            requestAnimationFrame(t),
              e.addEventListener("scroll", t),
              (this.resizeObserver = new ResizeObserver(t)),
              this.resizeObserver.observe(e),
              t();
          }
          render() {
            let e = this.namespace;
            if (!e) throw Error("Namespace is not set");
            return (0, i.qy)`
      <wui-flex flexDirection="column" .padding=${["0", "4", "4", "4"]} gap="4">
        ${this.renderTabs()} ${this.renderHeader(e)} ${this.renderConnections(
              e
            )}
        ${this.renderAddConnectionButton(e)}
      </wui-flex>
    `;
          }
          renderTabs() {
            let e = e8.filter((e) => this.namespaces.includes(e.namespace));
            return e.length > 1
              ? (0, i.qy)`
        <wui-tabs
          .onTabChange=${(e) => this.handleTabChange(e)}
          .activeTab=${this.currentTab}
          .tabs=${e}
        ></wui-tabs>
      `
              : null;
          }
          renderHeader(e) {
            let t =
              this.getActiveConnections(e).flatMap(({ accounts: e }) => e)
                .length + +!!this.caipAddress;
            return (0, i.qy)`
      <wui-flex alignItems="center" columngap="1">
        <wui-icon
          size="sm"
          name=${e6[e] ?? e6.eip155}
        ></wui-icon>
        <wui-text color="secondary" variant="lg-regular"
          >${t > 1 ? "Wallets" : "Wallet"}</wui-text
        >
        <wui-text
          color="primary"
          variant="lg-regular"
          class="balance-amount"
          data-testid="balance-amount"
        >
          ${t}
        </wui-text>
        <wui-link
          color="secondary"
          variant="secondary"
          @click=${() => Q.x.disconnect({ namespace: e })}
          ?disabled=${!this.hasAnyConnections(e)}
          data-testid="disconnect-all-button"
        >
          Disconnect All
        </wui-link>
      </wui-flex>
    `;
          }
          renderConnections(e) {
            let t = this.hasAnyConnections(e);
            return (0, i.qy)`
      <wui-flex flexDirection="column" class=${(0, eV.H)({
        "wallet-list": !0,
        "active-wallets-box": t,
        "empty-wallet-list-box": !t,
      })} rowgap="3">
        ${t ? this.renderActiveConnections(e) : this.renderEmptyState(e)}
      </wui-flex>
    `;
          }
          renderActiveConnections(e) {
            let t = this.getActiveConnections(e),
              r = this.activeConnectorIds[e],
              n = this.getPlainAddress();
            return (0, i.qy)`
      ${
        n || r || t.length > 0
          ? (0, i.qy)`<wui-flex
            flexDirection="column"
            .padding=${["4", "0", "4", "0"]}
            class="active-wallets"
          >
            ${this.renderActiveProfile(e)} ${this.renderActiveConnectionsList(
              e
            )}
          </wui-flex>`
          : null
      }
      ${this.renderRecentConnections(e)}
    `;
          }
          renderActiveProfile(e) {
            let t = this.activeConnectorIds[e];
            if (!t) return null;
            let { connections: r } = eK.b.getConnectionsData(e),
              n = K.a.getConnectorById(t),
              s = l.$.getConnectorImage(n),
              a = this.getPlainAddress();
            if (!a) return null;
            let o = e === Z.o.CHAIN.BITCOIN,
              c = e2.getAuthData({ connectorId: t, accounts: [] }),
              d =
                this.getActiveConnections(e).flatMap((e) => e.accounts).length >
                0,
              h = r.find((e) => e.connectorId === t),
              u = h?.accounts.filter(
                (e) => !e1.y.isLowerCaseMatch(e.address, a)
              );
            return (0, i.qy)`
      <wui-flex flexDirection="column" .padding=${["0", "4", "0", "4"]}>
        <wui-active-profile-wallet-item
          address=${a}
          alt=${n?.name}
          .content=${this.getProfileContent({
            address: a,
            connections: r,
            connectorId: t,
            namespace: e,
          })}
          .charsStart=${e4.ADDRESS_DISPLAY.START}
          .charsEnd=${e4.ADDRESS_DISPLAY.END}
          .icon=${c.icon}
          .iconSize=${c.iconSize}
          .iconBadge=${this.isSmartAccount(a) ? e4.BADGE.ICON : void 0}
          .iconBadgeSize=${this.isSmartAccount(a) ? e4.BADGE.SIZE : void 0}
          imageSrc=${s}
          ?enableMoreButton=${c.isAuth}
          @copy=${() => this.handleCopyAddress(a)}
          @disconnect=${() => this.handleDisconnect(e, t)}
          @switch=${() => {
            o && h && u?.[0] && this.handleSwitchWallet(h, u[0].address, e);
          }}
          @externalLink=${() => this.handleExternalLink(a)}
          @more=${() => this.handleMore()}
          data-testid="wui-active-profile-wallet-item"
        ></wui-active-profile-wallet-item>
        ${d ? (0, i.qy)`<wui-separator></wui-separator>` : null}
      </wui-flex>
    `;
          }
          renderActiveConnectionsList(e) {
            let t = this.getActiveConnections(e);
            return 0 === t.length
              ? null
              : (0, i.qy)`
      <wui-flex flexDirection="column" .padding=${["0", "2", "0", "2"]}>
        ${this.renderConnectionList(t, !1, e)}
      </wui-flex>
    `;
          }
          renderRecentConnections(e) {
            let { recentConnections: t } = eK.b.getConnectionsData(e);
            return 0 === t.flatMap((e) => e.accounts).length
              ? null
              : (0, i.qy)`
      <wui-flex flexDirection="column" .padding=${[
        "0",
        "2",
        "0",
        "2",
      ]} rowGap="2">
        <wui-text color="secondary" variant="sm-medium" data-testid="recently-connected-text"
          >RECENTLY CONNECTED</wui-text
        >
        <wui-flex flexDirection="column" .padding=${["0", "2", "0", "2"]}>
          ${this.renderConnectionList(t, !0, e)}
        </wui-flex>
      </wui-flex>
    `;
          }
          renderConnectionList(e, t, r) {
            return e
              .filter((e) => e.accounts.length > 0)
              .map((e, n) => {
                let s = K.a.getConnectorById(e.connectorId),
                  a = l.$.getConnectorImage(s) ?? "",
                  o = e2.getAuthData(e);
                return e.accounts.map((s, c) => {
                  let l = this.isAccountLoading(e.connectorId, s.address);
                  return (0, i.qy)`
            <wui-flex flexDirection="column">
              ${
                0 !== n || 0 !== c
                  ? (0, i.qy)`<wui-separator></wui-separator>`
                  : null
              }
              <wui-inactive-profile-wallet-item
                address=${s.address}
                alt=${e.connectorId}
                buttonLabel=${t ? "Connect" : "Switch"}
                buttonVariant=${t ? "neutral-secondary" : "accent-secondary"}
                rightIcon=${t ? "bin" : "power"}
                rightIconSize="sm"
                class=${t ? "recent-connection" : "active-connection"}
                data-testid=${t ? "recent-connection" : "active-connection"}
                imageSrc=${a}
                .iconBadge=${
                  this.isSmartAccount(s.address) ? e4.BADGE.ICON : void 0
                }
                .iconBadgeSize=${
                  this.isSmartAccount(s.address) ? e4.BADGE.SIZE : void 0
                }
                .icon=${o.icon}
                .iconSize=${o.iconSize}
                .loading=${l}
                .showBalance=${!1}
                .charsStart=${e4.ADDRESS_DISPLAY.START}
                .charsEnd=${e4.ADDRESS_DISPLAY.END}
                @buttonClick=${() => this.handleSwitchWallet(e, s.address, r)}
                @iconClick=${() =>
                  this.handleWalletAction({
                    connection: e,
                    address: s.address,
                    isRecentConnection: t,
                    namespace: r,
                  })}
              ></wui-inactive-profile-wallet-item>
            </wui-flex>
          `;
                });
              });
          }
          renderAddConnectionButton(e) {
            if (
              (!this.isMultiWalletEnabled() && this.caipAddress) ||
              !this.hasAnyConnections(e)
            )
              return null;
            let { title: t } = this.getChainLabelInfo(e);
            return (0, i.qy)`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="plus"
        iconSize="sm"
        ?chevron=${!0}
        @click=${() => this.handleAddConnection(e)}
        data-testid="add-connection-button"
      >
        <wui-text variant="md-medium" color="secondary">${t}</wui-text>
      </wui-list-item>
    `;
          }
          renderEmptyState(e) {
            let { title: t, description: r } = this.getChainLabelInfo(e);
            return (0, i.qy)`
      <wui-flex alignItems="flex-start" class="empty-template" data-testid="empty-template">
        <wui-flex
          flexDirection="column"
          alignItems="center"
          justifyContent="center"
          rowgap="3"
          class="empty-box"
        >
          <wui-icon-box size="xl" icon="wallet" color="secondary"></wui-icon-box>

          <wui-flex flexDirection="column" alignItems="center" justifyContent="center" gap="1">
            <wui-text color="primary" variant="lg-regular" data-testid="empty-state-text"
              >No wallet connected</wui-text
            >
            <wui-text color="secondary" variant="md-regular" data-testid="empty-state-description"
              >${r}</wui-text
            >
          </wui-flex>

          <wui-link
            @click=${() => this.handleAddConnection(e)}
            data-testid="empty-state-button"
            icon="plus"
          >
            ${t}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
          }
          handleTabChange(e) {
            let t = this.namespaces[e];
            t &&
              (this.chainListener?.(),
              (this.currentTab = this.namespaces.indexOf(t)),
              (this.namespace = t),
              (this.caipAddress = o.W.getAccountData(t)?.caipAddress),
              (this.profileName = o.W.getAccountData(t)?.profileName),
              (this.chainListener = o.W.subscribeChainProp(
                "accountState",
                (e) => {
                  this.caipAddress = e?.caipAddress;
                },
                t
              )));
          }
          async handleSwitchWallet(e, t, r) {
            try {
              (this.isSwitching = !0),
                (this.lastSelectedConnectorId = e.connectorId),
                (this.lastSelectedAddress = t),
                await Q.x.switchConnection({
                  connection: e,
                  address: t,
                  namespace: r,
                  closeModalOnConnect: !1,
                  onChange({ hasSwitchedAccount: e, hasSwitchedWallet: t }) {
                    t
                      ? J.P.showSuccess("Wallet switched")
                      : e && J.P.showSuccess("Account switched");
                  },
                });
            } catch (e) {
              J.P.showError("Failed to switch wallet");
            } finally {
              this.isSwitching = !1;
            }
          }
          handleWalletAction(e) {
            let {
              connection: t,
              address: r,
              isRecentConnection: i,
              namespace: n,
            } = e;
            i
              ? (es.i.deleteAddressFromConnection({
                  connectorId: t.connectorId,
                  address: r,
                  namespace: n,
                }),
                Q.x.syncStorageConnections(),
                J.P.showSuccess("Wallet deleted"))
              : this.handleDisconnect(n, t.connectorId);
          }
          async handleDisconnect(e, t) {
            try {
              await Q.x.disconnectConnector({ id: t, namespace: e }),
                J.P.showSuccess("Wallet disconnected");
            } catch {
              J.P.showError("Failed to disconnect wallet");
            }
          }
          handleCopyAddress(e) {
            d.w.copyToClopboard(e), J.P.showSuccess("Address copied");
          }
          handleMore() {
            X.I.push("AccountSettings");
          }
          handleExternalLink(e) {
            let t = this.caipNetwork?.blockExplorers?.default.url;
            t && d.w.openHref(`${t}/address/${e}`, "_blank");
          }
          handleAddConnection(e) {
            K.a.setFilterByNamespace(e),
              X.I.push("Connect", { addWalletForNamespace: e });
          }
          getChainLabelInfo(e) {
            return (
              e9[e] ?? {
                title: "Add Wallet",
                description: "Add your first wallet",
              }
            );
          }
          isSmartAccount(e) {
            if (!this.namespace) return !1;
            let t = this.user?.accounts?.find((e) => "smartAccount" === e.type);
            return !!t && !!e && e1.y.isLowerCaseMatch(t.address, e);
          }
          getPlainAddress() {
            return this.caipAddress
              ? d.w.getPlainAddress(this.caipAddress)
              : void 0;
          }
          getActiveConnections(e) {
            let t = this.activeConnectorIds[e],
              { connections: r } = eK.b.getConnectionsData(e),
              [i] = r.filter((e) => e1.y.isLowerCaseMatch(e.connectorId, t));
            if (!t) return r;
            let n = e === Z.o.CHAIN.BITCOIN,
              { address: s } = this.caipAddress
                ? eZ.C.parseCaipAddress(this.caipAddress)
                : {},
              a = [...(s ? [s] : [])];
            return (
              n && i && (a = i.accounts.map((e) => e.address) || []),
              eK.b.excludeConnectorAddressFromConnections({
                connectorId: t,
                addresses: a,
                connections: r,
              })
            );
          }
          hasAnyConnections(e) {
            let t = this.getActiveConnections(e),
              { recentConnections: r } = eK.b.getConnectionsData(e);
            return !!this.caipAddress || t.length > 0 || r.length > 0;
          }
          isAccountLoading(e, t) {
            return (
              e1.y.isLowerCaseMatch(this.lastSelectedConnectorId, e) &&
              e1.y.isLowerCaseMatch(this.lastSelectedAddress, t) &&
              this.isSwitching
            );
          }
          getProfileContent(e) {
            let {
                address: t,
                connections: r,
                connectorId: i,
                namespace: n,
              } = e,
              [s] = r.filter((e) => e1.y.isLowerCaseMatch(e.connectorId, i));
            if (
              n === Z.o.CHAIN.BITCOIN &&
              s?.accounts.every((e) => "string" == typeof e.type)
            )
              return this.getBitcoinProfileContent(s.accounts, t);
            let a = e2.getAuthData({ connectorId: i, accounts: [] });
            return [
              {
                address: t,
                tagLabel: "Active",
                tagVariant: "success",
                enableButton: !0,
                profileName: this.profileName,
                buttonType: "disconnect",
                buttonLabel: "Disconnect",
                buttonVariant: "neutral-secondary",
                ...(a.isAuth
                  ? {
                      description: this.isSmartAccount(t)
                        ? "Smart Account"
                        : "EOA Account",
                    }
                  : {}),
              },
            ];
          }
          getBitcoinProfileContent(e, t) {
            let r = e.length > 1,
              i = this.getPlainAddress();
            return e.map((e) => {
              let n = e1.y.isLowerCaseMatch(e.address, i),
                s = "PAYMENT";
              return (
                "ordinal" === e.type && (s = "ORDINALS"),
                {
                  address: e.address,
                  tagLabel: e1.y.isLowerCaseMatch(e.address, t)
                    ? "Active"
                    : void 0,
                  tagVariant: e1.y.isLowerCaseMatch(e.address, t)
                    ? "success"
                    : void 0,
                  enableButton: !0,
                  ...(r
                    ? {
                        label: s,
                        alignItems: "flex-end",
                        buttonType: n ? "disconnect" : "switch",
                        buttonLabel: n ? "Disconnect" : "Switch",
                        buttonVariant: n
                          ? "neutral-secondary"
                          : "accent-secondary",
                      }
                    : {
                        alignItems: "center",
                        buttonType: "disconnect",
                        buttonLabel: "Disconnect",
                        buttonVariant: "neutral-secondary",
                      }),
                }
              );
            });
          }
          removeScrollListener() {
            let e = this.shadowRoot?.querySelector(".wallet-list");
            e &&
              e.removeEventListener("scroll", () =>
                this.handleConnectListScroll()
              );
          }
          handleConnectListScroll() {
            let e = this.shadowRoot?.querySelector(".wallet-list");
            e && this.updateScrollOpacity(e);
          }
          isMultiWalletEnabled() {
            return !!this.remoteFeatures?.multiWallet;
          }
          updateScrollOpacity(e) {
            e.style.setProperty(
              "--connect-scroll--top-opacity",
              u.z8
                .interpolate(
                  [0, e4.SCROLL_THRESHOLD],
                  e4.OPACITY_RANGE,
                  e.scrollTop
                )
                .toString()
            ),
              e.style.setProperty(
                "--connect-scroll--bottom-opacity",
                u.z8
                  .interpolate(
                    [0, e4.SCROLL_THRESHOLD],
                    e4.OPACITY_RANGE,
                    e.scrollHeight - e.scrollTop - e.offsetHeight
                  )
                  .toString()
              );
          }
          onConnectionsChange() {
            if (this.isMultiWalletEnabled() && this.namespace) {
              let { connections: e } = eK.b.getConnectionsData(this.namespace);
              0 === e.length && X.I.reset("ProfileWallets");
            }
            this.requestUpdate();
          }
        };
      (e7.styles = e3),
        e5([(0, n.wk)()], e7.prototype, "currentTab", void 0),
        e5([(0, n.wk)()], e7.prototype, "namespace", void 0),
        e5([(0, n.wk)()], e7.prototype, "namespaces", void 0),
        e5([(0, n.wk)()], e7.prototype, "caipAddress", void 0),
        e5([(0, n.wk)()], e7.prototype, "profileName", void 0),
        e5([(0, n.wk)()], e7.prototype, "activeConnectorIds", void 0),
        e5([(0, n.wk)()], e7.prototype, "lastSelectedAddress", void 0),
        e5([(0, n.wk)()], e7.prototype, "lastSelectedConnectorId", void 0),
        e5([(0, n.wk)()], e7.prototype, "isSwitching", void 0),
        e5([(0, n.wk)()], e7.prototype, "caipNetwork", void 0),
        e5([(0, n.wk)()], e7.prototype, "user", void 0),
        e5([(0, n.wk)()], e7.prototype, "remoteFeatures", void 0),
        (e7 = e5([(0, u.EM)("w3m-profile-wallets-view")], e7));
      var te = r(46747);
      let tt = (0, m.AH)`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  label {
    position: relative;
    display: inline-block;
    user-select: none;
    transition:
      background-color ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      color ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      border ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      box-shadow ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      width ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      height ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      transform ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      opacity ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]};
    will-change: background-color, color, border, box-shadow, width, height, transform, opacity;
  }

  input {
    width: 0;
    height: 0;
    opacity: 0;
  }

  span {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: ${({ colors: e }) => e.neutrals300};
    border-radius: ${({ borderRadius: e }) => e.round};
    border: 1px solid transparent;
    will-change: border;
    transition:
      background-color ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      color ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      border ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      box-shadow ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      width ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      height ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      transform ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]},
      opacity ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]};
    will-change: background-color, color, border, box-shadow, width, height, transform, opacity;
  }

  span:before {
    content: '';
    position: absolute;
    background-color: ${({ colors: e }) => e.white};
    border-radius: 50%;
  }

  /* -- Sizes --------------------------------------------------------- */
  label[data-size='lg'] {
    width: 48px;
    height: 32px;
  }

  label[data-size='md'] {
    width: 40px;
    height: 28px;
  }

  label[data-size='sm'] {
    width: 32px;
    height: 22px;
  }

  label[data-size='lg'] > span:before {
    height: 24px;
    width: 24px;
    left: 4px;
    top: 3px;
  }

  label[data-size='md'] > span:before {
    height: 20px;
    width: 20px;
    left: 4px;
    top: 3px;
  }

  label[data-size='sm'] > span:before {
    height: 16px;
    width: 16px;
    left: 3px;
    top: 2px;
  }

  /* -- Focus states --------------------------------------------------- */
  input:focus-visible:not(:checked) + span,
  input:focus:not(:checked) + span {
    border: 1px solid ${({ tokens: e }) => e.core.iconAccentPrimary};
    background-color: ${({ tokens: e }) => e.theme.textTertiary};
    box-shadow: 0px 0px 0px 4px rgba(9, 136, 240, 0.2);
  }

  input:focus-visible:checked + span,
  input:focus:checked + span {
    border: 1px solid ${({ tokens: e }) => e.core.iconAccentPrimary};
    box-shadow: 0px 0px 0px 4px rgba(9, 136, 240, 0.2);
  }

  /* -- Checked states --------------------------------------------------- */
  input:checked + span {
    background-color: ${({ tokens: e }) => e.core.iconAccentPrimary};
  }

  label[data-size='lg'] > input:checked + span:before {
    transform: translateX(calc(100% - 9px));
  }

  label[data-size='md'] > input:checked + span:before {
    transform: translateX(calc(100% - 9px));
  }

  label[data-size='sm'] > input:checked + span:before {
    transform: translateX(calc(100% - 7px));
  }

  /* -- Hover states ------------------------------------------------------- */
  label:hover > input:not(:checked):not(:disabled) + span {
    background-color: ${({ colors: e }) => e.neutrals400};
  }

  label:hover > input:checked:not(:disabled) + span {
    background-color: ${({ colors: e }) => e.accent080};
  }

  /* -- Disabled state --------------------------------------------------- */
  label:has(input:disabled) {
    pointer-events: none;
    user-select: none;
  }

  input:not(:checked):disabled + span {
    background-color: ${({ colors: e }) => e.neutrals700};
  }

  input:checked:disabled + span {
    background-color: ${({ colors: e }) => e.neutrals700};
  }

  input:not(:checked):disabled + span::before {
    background-color: ${({ colors: e }) => e.neutrals400};
  }

  input:checked:disabled + span::before {
    background-color: ${({ tokens: e }) => e.theme.textTertiary};
  }
`;
      var tr = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ti = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.inputElementRef = (0, te._)()),
            (this.checked = !1),
            (this.disabled = !1),
            (this.size = "md");
        }
        render() {
          return (0, i.qy)`
      <label data-size=${this.size}>
        <input
          ${(0, te.K)(this.inputElementRef)}
          type="checkbox"
          ?checked=${this.checked}
          ?disabled=${this.disabled}
          @change=${this.dispatchChangeEvent.bind(this)}
        />
        <span></span>
      </label>
    `;
        }
        dispatchChangeEvent() {
          this.dispatchEvent(
            new CustomEvent("switchChange", {
              detail: this.inputElementRef.value?.checked,
              bubbles: !0,
              composed: !0,
            })
          );
        }
      };
      (ti.styles = [p.W5, p.fD, tt]),
        tr([(0, n.MZ)({ type: Boolean })], ti.prototype, "checked", void 0),
        tr([(0, n.MZ)({ type: Boolean })], ti.prototype, "disabled", void 0),
        tr([(0, n.MZ)()], ti.prototype, "size", void 0),
        (ti = tr([(0, g.E)("wui-toggle")], ti));
      let tn = (0, m.AH)`
  :host {
    height: auto;
  }

  :host > wui-flex {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    column-gap: ${({ spacing: e }) => e["2"]};
    padding: ${({ spacing: e }) => e["2"]} ${({ spacing: e }) => e["3"]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e["4"]};
    box-shadow: inset 0 0 0 1px ${({ tokens: e }) => e.theme.foregroundPrimary};
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: background-color;
    cursor: pointer;
  }

  wui-switch {
    pointer-events: none;
  }
`;
      var ts = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ta = class extends i.WF {
        constructor() {
          super(...arguments), (this.checked = !1);
        }
        render() {
          return (0, i.qy)`
      <wui-flex>
        <wui-icon size="xl" name="walletConnectBrown"></wui-icon>
        <wui-toggle
          ?checked=${this.checked}
          size="sm"
          @switchChange=${this.handleToggleChange.bind(this)}
        ></wui-toggle>
      </wui-flex>
    `;
        }
        handleToggleChange(e) {
          e.stopPropagation(),
            (this.checked = e.detail),
            this.dispatchSwitchEvent();
        }
        dispatchSwitchEvent() {
          this.dispatchEvent(
            new CustomEvent("certifiedSwitchChange", {
              detail: this.checked,
              bubbles: !0,
              composed: !0,
            })
          );
        }
      };
      (ta.styles = [p.W5, p.fD, tn]),
        ts([(0, n.MZ)({ type: Boolean })], ta.prototype, "checked", void 0),
        (ta = ts([(0, g.E)("wui-certified-switch")], ta)),
        r(5089);
      let to = (0, m.AH)`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: ${({ spacing: e }) => e[3]};
    color: ${({ tokens: e }) => e.theme.iconDefault};
    cursor: pointer;
    padding: ${({ spacing: e }) => e[2]};
    background-color: transparent;
    border-radius: ${({ borderRadius: e }) => e[4]};
    transition: background-color ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
  }

  @media (hover: hover) {
    wui-icon:hover {
      background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    }
  }
`;
      var tc = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tl = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.inputComponentRef = (0, te._)()),
            (this.inputValue = "");
        }
        render() {
          return (0, i.qy)`
      <wui-input-text
        ${(0, te.K)(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
        @inputChange=${this.onInputChange}
      >
        ${
          this.inputValue
            ? (0, i.qy)`<wui-icon
              @click=${this.clearValue}
              color="inherit"
              size="sm"
              name="close"
            ></wui-icon>`
            : null
        }
      </wui-input-text>
    `;
        }
        onInputChange(e) {
          this.inputValue = e.detail || "";
        }
        clearValue() {
          let e = this.inputComponentRef.value,
            t = e?.inputElementRef.value;
          t &&
            ((t.value = ""),
            (this.inputValue = ""),
            t.focus(),
            t.dispatchEvent(new Event("input")));
        }
      };
      (tl.styles = [p.W5, to]),
        tc([(0, n.MZ)()], tl.prototype, "inputValue", void 0),
        (tl = tc([(0, g.E)("wui-search-bar")], tl));
      var td = r(72880),
        th = r(27313);
      r(40396);
      let tu = (0, m.AH)`
  :host {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 104px;
    width: 104px;
    row-gap: ${({ spacing: e }) => e[2]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[5]};
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--apkt-path-network);
    clip-path: var(--apkt-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: ${({ tokens: e }) => e.theme.foregroundSecondary};
    stroke-width: 1px;
  }

  @media (max-width: 350px) {
    :host {
      width: 100%;
    }
  }
`;
      var tp = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tf = class extends i.WF {
        constructor() {
          super(...arguments), (this.type = "wallet");
        }
        render() {
          return (0, i.qy)`
      ${this.shimmerTemplate()}
      <wui-shimmer width="80px" height="20px"></wui-shimmer>
    `;
        }
        shimmerTemplate() {
          return "network" === this.type
            ? (0,
              i.qy)` <wui-shimmer data-type=${this.type} width="48px" height="54px"></wui-shimmer>
        ${th.a}`
            : (0, i.qy)`<wui-shimmer width="56px" height="56px"></wui-shimmer>`;
        }
      };
      (tf.styles = [p.W5, p.fD, tu]),
        tp([(0, n.MZ)()], tf.prototype, "type", void 0),
        (tf = tp([(0, g.E)("wui-card-select-loader")], tf));
      let tg = (0, i.AH)`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
      var tm = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ty = class extends i.WF {
        render() {
          return (
            (this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--apkt-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--apkt-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--apkt-spacing-${this.gap})`};
      padding-top: ${this.padding && f.Z.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && f.Z.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && f.Z.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && f.Z.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && f.Z.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && f.Z.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && f.Z.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && f.Z.getSpacingStyles(this.margin, 3)};
    `),
            (0, i.qy)`<slot></slot>`
          );
        }
      };
      (ty.styles = [p.W5, tg]),
        tm([(0, n.MZ)()], ty.prototype, "gridTemplateRows", void 0),
        tm([(0, n.MZ)()], ty.prototype, "gridTemplateColumns", void 0),
        tm([(0, n.MZ)()], ty.prototype, "justifyItems", void 0),
        tm([(0, n.MZ)()], ty.prototype, "alignItems", void 0),
        tm([(0, n.MZ)()], ty.prototype, "justifyContent", void 0),
        tm([(0, n.MZ)()], ty.prototype, "alignContent", void 0),
        tm([(0, n.MZ)()], ty.prototype, "columnGap", void 0),
        tm([(0, n.MZ)()], ty.prototype, "rowGap", void 0),
        tm([(0, n.MZ)()], ty.prototype, "gap", void 0),
        tm([(0, n.MZ)()], ty.prototype, "padding", void 0),
        tm([(0, n.MZ)()], ty.prototype, "margin", void 0),
        (ty = tm([(0, g.E)("wui-grid")], ty));
      var tw = r(18635);
      r(41699), r(1805);
      let tb = (0, u.AH)`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    width: 104px;
    row-gap: ${({ spacing: e }) => e["2"]};
    padding: ${({ spacing: e }) => e["3"]} ${({ spacing: e }) => e["0"]};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: clamp(0px, ${({ borderRadius: e }) => e["4"]}, 20px);
    transition:
      color ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-1"]},
      background-color ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-1"]},
      border-radius ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-1"]};
    will-change: background-color, color, border-radius;
    outline: none;
    border: none;
  }

  button > wui-flex > wui-text {
    color: ${({ tokens: e }) => e.theme.textPrimary};
    max-width: 86px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button > wui-flex > wui-text.certified {
    max-width: 66px;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
    }
  }

  button:disabled > wui-flex > wui-text {
    color: ${({ tokens: e }) => e.core.glass010};
  }

  [data-selected='true'] {
    background-color: ${({ colors: e }) => e.accent020};
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: ${({ colors: e }) => e.accent010};
    }
  }

  [data-selected='true']:active:enabled {
    background-color: ${({ colors: e }) => e.accent010};
  }

  @media (max-width: 350px) {
    button {
      width: 100%;
    }
  }
`;
      var tv = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tC = class extends i.WF {
        constructor() {
          super(),
            (this.observer = new IntersectionObserver(() => void 0)),
            (this.visible = !1),
            (this.imageSrc = void 0),
            (this.imageLoading = !1),
            (this.isImpressed = !1),
            (this.explorerId = ""),
            (this.walletQuery = ""),
            (this.certified = !1),
            (this.wallet = void 0),
            (this.observer = new IntersectionObserver(
              (e) => {
                e.forEach((e) => {
                  e.isIntersecting
                    ? ((this.visible = !0),
                      this.fetchImageSrc(),
                      this.sendImpressionEvent())
                    : (this.visible = !1);
                });
              },
              { threshold: 0.01 }
            ));
        }
        firstUpdated() {
          this.observer.observe(this);
        }
        disconnectedCallback() {
          this.observer.disconnect();
        }
        render() {
          let e = this.wallet?.badge_type === "certified";
          return (0, i.qy)`
      <button>
        ${this.imageTemplate()}
        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="1">
          <wui-text
            variant="md-regular"
            color="inherit"
            class=${(0, s.J)(e ? "certified" : void 0)}
            >${this.wallet?.name}</wui-text
          >
          ${
            e
              ? (0,
                i.qy)`<wui-icon size="sm" name="walletConnectBrown"></wui-icon>`
              : null
          }
        </wui-flex>
      </button>
    `;
        }
        imageTemplate() {
          return (this.visible || this.imageSrc) && !this.imageLoading
            ? (0, i.qy)`
      <wui-wallet-image
        size="lg"
        imageSrc=${(0, s.J)(this.imageSrc)}
        name=${(0, s.J)(this.wallet?.name)}
        .installed=${this.wallet?.installed ?? !1}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `
            : this.shimmerTemplate();
        }
        shimmerTemplate() {
          return (0,
          i.qy)`<wui-shimmer width="56px" height="56px"></wui-shimmer>`;
        }
        async fetchImageSrc() {
          this.wallet &&
            ((this.imageSrc = l.$.getWalletImage(this.wallet)),
            this.imageSrc ||
              ((this.imageLoading = !0),
              (this.imageSrc = await l.$.fetchWalletImage(
                this.wallet.image_id
              )),
              (this.imageLoading = !1)));
        }
        sendImpressionEvent() {
          this.wallet &&
            !this.isImpressed &&
            ((this.isImpressed = !0),
            U.E.sendEvent({
              type: "track",
              event: "WALLET_IMPRESSION",
              properties: {
                name: this.wallet.name,
                walletRank: this.wallet.order,
                explorerId: this.explorerId,
                view: X.I.state.view,
                query: this.walletQuery,
                certified: this.certified,
              },
            }));
        }
      };
      (tC.styles = tb),
        tv([(0, n.wk)()], tC.prototype, "visible", void 0),
        tv([(0, n.wk)()], tC.prototype, "imageSrc", void 0),
        tv([(0, n.wk)()], tC.prototype, "imageLoading", void 0),
        tv([(0, n.wk)()], tC.prototype, "isImpressed", void 0),
        tv([(0, n.MZ)()], tC.prototype, "explorerId", void 0),
        tv([(0, n.MZ)()], tC.prototype, "walletQuery", void 0),
        tv([(0, n.MZ)()], tC.prototype, "certified", void 0),
        tv([(0, n.MZ)({ type: Object })], tC.prototype, "wallet", void 0),
        (tC = tv([(0, u.EM)("w3m-all-wallets-list-item")], tC));
      let tE = (0, u.AH)`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  :host([data-mobile-fullscreen='true']) wui-grid {
    max-height: none;
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  w3m-all-wallets-list-item {
    opacity: 0;
    animation-duration: ${({ durations: e }) => e.xl};
    animation-timing-function: ${({ easings: e }) => e["ease-inout-power-2"]};
    animation-name: fade-in;
    animation-fill-mode: forwards;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-loading-spinner {
    padding-top: ${({ spacing: e }) => e["4"]};
    padding-bottom: ${({ spacing: e }) => e["4"]};
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
      var tx = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tA = "local-paginator",
        t_ = class extends i.WF {
          constructor() {
            super(),
              (this.unsubscribe = []),
              (this.paginationObserver = void 0),
              (this.loading = !td.N.state.wallets.length),
              (this.wallets = td.N.state.wallets),
              (this.recommended = td.N.state.recommended),
              (this.featured = td.N.state.featured),
              (this.filteredWallets = td.N.state.filteredWallets),
              (this.mobileFullScreen = a.H.state.enableMobileFullScreen),
              this.unsubscribe.push(
                td.N.subscribeKey("wallets", (e) => (this.wallets = e)),
                td.N.subscribeKey("recommended", (e) => (this.recommended = e)),
                td.N.subscribeKey("featured", (e) => (this.featured = e)),
                td.N.subscribeKey(
                  "filteredWallets",
                  (e) => (this.filteredWallets = e)
                )
              );
          }
          firstUpdated() {
            this.initialFetch(), this.createPaginationObserver();
          }
          disconnectedCallback() {
            this.unsubscribe.forEach((e) => e()),
              this.paginationObserver?.disconnect();
          }
          render() {
            return (
              this.mobileFullScreen &&
                this.setAttribute("data-mobile-fullscreen", "true"),
              (0, i.qy)`
      <wui-grid
        data-scroll=${!this.loading}
        .padding=${["0", "3", "3", "3"]}
        gap="2"
        justifyContent="space-between"
      >
        ${this.loading ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `
            );
          }
          async initialFetch() {
            this.loading = !0;
            let e = this.shadowRoot?.querySelector("wui-grid");
            e &&
              (await td.N.fetchWalletsByPage({ page: 1 }),
              await e.animate([{ opacity: 1 }, { opacity: 0 }], {
                duration: 200,
                fill: "forwards",
                easing: "ease",
              }).finished,
              (this.loading = !1),
              e.animate([{ opacity: 0 }, { opacity: 1 }], {
                duration: 200,
                fill: "forwards",
                easing: "ease",
              }));
          }
          shimmerTemplate(e, t) {
            return [...Array(e)].map(
              () => (0, i.qy)`
        <wui-card-select-loader type="wallet" id=${(0, s.J)(
          t
        )}></wui-card-select-loader>
      `
            );
          }
          getWallets() {
            let e = [...this.featured, ...this.recommended];
            this.filteredWallets?.length > 0
              ? e.push(...this.filteredWallets)
              : e.push(...this.wallets);
            let t = d.w.uniqueBy(e, "id"),
              r = tw.A.markWalletsAsInstalled(t);
            return tw.A.markWalletsWithDisplayIndex(r);
          }
          walletsTemplate() {
            return this.getWallets().map(
              (e) => (0, i.qy)`
        <w3m-all-wallets-list-item
          data-testid="wallet-search-item-${e.id}"
          @click=${() => this.onConnectWallet(e)}
          .wallet=${e}
          explorerId=${e.id}
          certified=${"certified" === this.badge}
        ></w3m-all-wallets-list-item>
      `
            );
          }
          paginationLoaderTemplate() {
            let {
                wallets: e,
                recommended: t,
                featured: r,
                count: i,
                mobileFilteredOutWalletsLength: n,
              } = td.N.state,
              s = window.innerWidth < 352 ? 3 : 4,
              a = e.length + t.length,
              o = Math.ceil(a / s) * s - a + s;
            return ((o -= e.length ? r.length % s : 0), 0 === i && r.length > 0)
              ? null
              : 0 === i || [...r, ...e, ...t].length < i - (n ?? 0)
              ? this.shimmerTemplate(o, tA)
              : null;
          }
          createPaginationObserver() {
            let e = this.shadowRoot?.querySelector(`#${tA}`);
            e &&
              ((this.paginationObserver = new IntersectionObserver(([e]) => {
                if (e?.isIntersecting && !this.loading) {
                  let { page: e, count: t, wallets: r } = td.N.state;
                  r.length < t && td.N.fetchWalletsByPage({ page: e + 1 });
                }
              })),
              this.paginationObserver.observe(e));
          }
          onConnectWallet(e) {
            K.a.selectWalletConnector(e);
          }
        };
      (t_.styles = tE),
        tx([(0, n.wk)()], t_.prototype, "loading", void 0),
        tx([(0, n.wk)()], t_.prototype, "wallets", void 0),
        tx([(0, n.wk)()], t_.prototype, "recommended", void 0),
        tx([(0, n.wk)()], t_.prototype, "featured", void 0),
        tx([(0, n.wk)()], t_.prototype, "filteredWallets", void 0),
        tx([(0, n.wk)()], t_.prototype, "badge", void 0),
        tx([(0, n.wk)()], t_.prototype, "mobileFullScreen", void 0),
        (t_ = tx([(0, u.EM)("w3m-all-wallets-list")], t_)),
        r(75484);
      let tI = (0, i.AH)`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  :host([data-mobile-fullscreen='true']) wui-grid {
    max-height: none;
    height: auto;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
`;
      var tS = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tk = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.prevQuery = ""),
            (this.prevBadge = void 0),
            (this.loading = !0),
            (this.mobileFullScreen = a.H.state.enableMobileFullScreen),
            (this.query = "");
        }
        render() {
          return (
            this.mobileFullScreen &&
              this.setAttribute("data-mobile-fullscreen", "true"),
            this.onSearch(),
            this.loading
              ? (0,
                i.qy)`<wui-loading-spinner color="accent-primary"></wui-loading-spinner>`
              : this.walletsTemplate()
          );
        }
        async onSearch() {
          (this.query.trim() !== this.prevQuery.trim() ||
            this.badge !== this.prevBadge) &&
            ((this.prevQuery = this.query),
            (this.prevBadge = this.badge),
            (this.loading = !0),
            await td.N.searchWallet({ search: this.query, badge: this.badge }),
            (this.loading = !1));
        }
        walletsTemplate() {
          let { search: e } = td.N.state,
            t = tw.A.markWalletsAsInstalled(e);
          return e.length
            ? (0, i.qy)`
      <wui-grid
        data-testid="wallet-list"
        .padding=${["0", "3", "3", "3"]}
        rowGap="4"
        columngap="2"
        justifyContent="space-between"
      >
        ${t.map(
          (e) => (0, i.qy)`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(e)}
              .wallet=${e}
              data-testid="wallet-search-item-${e.id}"
              explorerId=${e.id}
              certified=${"certified" === this.badge}
              walletQuery=${this.query}
            ></w3m-all-wallets-list-item>
          `
        )}
      </wui-grid>
    `
            : (0, i.qy)`
        <wui-flex
          data-testid="no-wallet-found"
          justifyContent="center"
          alignItems="center"
          gap="3"
          flexDirection="column"
        >
          <wui-icon-box size="lg" color="default" icon="wallet"></wui-icon-box>
          <wui-text data-testid="no-wallet-found-text" color="secondary" variant="md-medium">
            No Wallet found
          </wui-text>
        </wui-flex>
      `;
        }
        onConnectWallet(e) {
          K.a.selectWalletConnector(e);
        }
      };
      (tk.styles = tI),
        tS([(0, n.wk)()], tk.prototype, "loading", void 0),
        tS([(0, n.wk)()], tk.prototype, "mobileFullScreen", void 0),
        tS([(0, n.MZ)()], tk.prototype, "query", void 0),
        tS([(0, n.MZ)()], tk.prototype, "badge", void 0),
        (tk = tS([(0, u.EM)("w3m-all-wallets-search")], tk));
      var tN = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tT = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.search = ""),
            (this.badge = void 0),
            (this.onDebouncedSearch = d.w.debounce((e) => {
              this.search = e;
            }));
        }
        render() {
          let e = this.search.length >= 2;
          return (0, i.qy)`
      <wui-flex .padding=${["1", "3", "3", "3"]} gap="2" alignItems="center">
        <wui-search-bar @inputChange=${this.onInputChange.bind(
          this
        )}></wui-search-bar>
        <wui-certified-switch
          ?checked=${"certified" === this.badge}
          @certifiedSwitchChange=${this.onCertifiedSwitchChange.bind(this)}
          data-testid="wui-certified-switch"
        ></wui-certified-switch>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${
        e || this.badge
          ? (0, i.qy)`<w3m-all-wallets-search
            query=${this.search}
            .badge=${this.badge}
          ></w3m-all-wallets-search>`
          : (0,
            i.qy)`<w3m-all-wallets-list .badge=${this.badge}></w3m-all-wallets-list>`
      }
    `;
        }
        onInputChange(e) {
          this.onDebouncedSearch(e.detail);
        }
        onCertifiedSwitchChange(e) {
          e.detail
            ? ((this.badge = "certified"),
              J.P.showSvg("Only WalletConnect certified", {
                icon: "walletConnectBrown",
                iconColor: "accent-100",
              }))
            : (this.badge = void 0);
        }
        qrButtonTemplate() {
          return d.w.isMobile()
            ? (0, i.qy)`
        <wui-icon-box
          size="xl"
          iconSize="xl"
          color="accent-primary"
          icon="qrCode"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `
            : null;
        }
        onWalletConnectQr() {
          X.I.push("ConnectingWalletConnect");
        }
      };
      tN([(0, n.wk)()], tT.prototype, "search", void 0),
        tN([(0, n.wk)()], tT.prototype, "badge", void 0),
        (tT = tN([(0, u.EM)("w3m-all-wallets-view")], tT));
      var tO = r(3515),
        tP = r(75751);
      let tR = (0, m.AH)`
  button {
    display: flex;
    gap: ${({ spacing: e }) => e[1]};
    padding: ${({ spacing: e }) => e[4]};
    width: 100%;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[4]};
    justify-content: center;
    align-items: center;
  }

  :host([data-size='sm']) button {
    padding: ${({ spacing: e }) => e[2]};
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host([data-size='md']) button {
    padding: ${({ spacing: e }) => e[3]};
    border-radius: ${({ borderRadius: e }) => e[3]};
  }

  button:hover {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  button:disabled {
    opacity: 0.5;
  }
`;
      var t$ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tD = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.text = ""),
            (this.disabled = !1),
            (this.size = "lg"),
            (this.icon = "copy"),
            (this.tabIdx = void 0);
        }
        render() {
          this.dataset.size = this.size;
          let e = `${this.size}-regular`;
          return (0, i.qy)`
      <button ?disabled=${this.disabled} tabindex=${(0, s.J)(this.tabIdx)}>
        <wui-icon name=${this.icon} size=${
            this.size
          } color="default"></wui-icon>
        <wui-text align="center" variant=${e} color="primary">${
            this.text
          }</wui-text>
      </button>
    `;
        }
      };
      (tD.styles = [p.W5, p.fD, tR]),
        t$([(0, n.MZ)()], tD.prototype, "text", void 0),
        t$([(0, n.MZ)({ type: Boolean })], tD.prototype, "disabled", void 0),
        t$([(0, n.MZ)()], tD.prototype, "size", void 0),
        t$([(0, n.MZ)()], tD.prototype, "icon", void 0),
        t$([(0, n.MZ)()], tD.prototype, "tabIdx", void 0),
        (tD = t$([(0, g.E)("wui-list-button")], tD)),
        r(55877);
      var tU = r(8567),
        tM = r(52502);
      r(48876);
      var tL = r(89600);
      let tB = (0, u.AH)`
  wui-separator {
    margin: ${({ spacing: e }) => e["3"]} calc(${({ spacing: e }) =>
        e["3"]} * -1);
    width: calc(100% + ${({ spacing: e }) => e["3"]} * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: ${({ spacing: e }) => e["2"]};
  }

  wui-loading-spinner {
    right: ${({ spacing: e }) => e["3"]};
  }

  wui-text {
    margin: ${({ spacing: e }) => e["2"]} ${({ spacing: e }) => e["3"]}
      ${({ spacing: e }) => e["0"]} ${({ spacing: e }) => e["3"]};
  }
`;
      var tW = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tj = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.formRef = (0, te._)()),
            (this.email = ""),
            (this.loading = !1),
            (this.error = ""),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            this.unsubscribe.push(
              a.H.subscribeKey("remoteFeatures", (e) => {
                this.remoteFeatures = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        firstUpdated() {
          this.formRef.value?.addEventListener("keydown", (e) => {
            "Enter" === e.key && this.onSubmitEmail(e);
          });
        }
        render() {
          let e = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.AUTH);
          return (0, i.qy)`
      <form ${(0, te.K)(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          tabIdx=${(0, s.J)(this.tabIdx)}
          ?disabled=${e}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>
      ${this.templateError()}
    `;
        }
        submitButtonTemplate() {
          return !this.loading && this.email.length > 3
            ? (0, i.qy)`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        `
            : null;
        }
        loadingTemplate() {
          return this.loading
            ? (0,
              i.qy)`<wui-loading-spinner size="md" color="accent-primary"></wui-loading-spinner>`
            : null;
        }
        templateError() {
          return this.error
            ? (0,
              i.qy)`<wui-text variant="sm-medium" color="error">${this.error}</wui-text>`
            : null;
        }
        onEmailInputChange(e) {
          (this.email = e.detail.trim()), (this.error = "");
        }
        async onSubmitEmail(e) {
          if (!eP.y.isValidEmail(this.email))
            return void tM.h.open(
              {
                displayMessage:
                  tL.R.ALERT_WARNINGS.INVALID_EMAIL.displayMessage,
              },
              "warning"
            );
          if (
            !Z.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
              (e) => e === o.W.state.activeChain
            )
          ) {
            let e = o.W.getFirstCaipNetworkSupportsAuthConnector();
            if (e) return void X.I.push("SwitchNetwork", { network: e });
          }
          try {
            if (this.loading) return;
            (this.loading = !0), e.preventDefault();
            let t = K.a.getAuthConnector();
            if (!t)
              throw Error("w3m-email-login-widget: Auth connector not found");
            let { action: r } = await t.provider.connectEmail({
              email: this.email,
            });
            if (
              (U.E.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" }),
              "VERIFY_OTP" === r)
            )
              U.E.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT",
              }),
                X.I.push("EmailVerifyOtp", { email: this.email });
            else if ("VERIFY_DEVICE" === r)
              X.I.push("EmailVerifyDevice", { email: this.email });
            else if ("CONNECT" === r) {
              let e = this.remoteFeatures?.multiWallet;
              await Q.x.connectExternal(t, o.W.state.activeChain),
                e
                  ? (X.I.replace("ProfileWallets"),
                    J.P.showSuccess("New Wallet Added"))
                  : X.I.replace("Account");
            }
          } catch (t) {
            let e = d.w.parseError(t);
            e?.includes("Invalid email")
              ? (this.error = "Invalid email. Try again.")
              : J.P.showError(t);
          } finally {
            this.loading = !1;
          }
        }
        onFocusEvent() {
          U.E.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
        }
      };
      (tj.styles = tB),
        tW([(0, n.MZ)()], tj.prototype, "tabIdx", void 0),
        tW([(0, n.wk)()], tj.prototype, "email", void 0),
        tW([(0, n.wk)()], tj.prototype, "loading", void 0),
        tW([(0, n.wk)()], tj.prototype, "error", void 0),
        tW([(0, n.wk)()], tj.prototype, "remoteFeatures", void 0),
        (tj = tW([(0, u.EM)("w3m-email-login-widget")], tj)),
        r(82886);
      var tF = r(30112);
      r(1507), r(47824);
      let tH = (0, m.AH)`
  :host {
    display: block;
    width: 100%;
  }

  button {
    width: 100%;
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  @media (hover: hover) {
    button:hover:enabled {
      background: ${({ tokens: e }) => e.theme.foregroundSecondary};
    }
  }

  button:disabled {
    cursor: not-allowed;
    opacity: 0.5;
  }
`;
      var tq = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tz = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.logo = "google"),
            (this.disabled = !1),
            (this.tabIdx = void 0);
        }
        render() {
          return (0, i.qy)`
      <button ?disabled=${this.disabled} tabindex=${(0, s.J)(this.tabIdx)}>
        <wui-icon size="xxl" name=${this.logo}></wui-icon>
      </button>
    `;
        }
      };
      (tz.styles = [p.W5, p.fD, tH]),
        tq([(0, n.MZ)()], tz.prototype, "logo", void 0),
        tq([(0, n.MZ)({ type: Boolean })], tz.prototype, "disabled", void 0),
        tq([(0, n.MZ)()], tz.prototype, "tabIdx", void 0),
        (tz = tq([(0, g.E)("wui-logo-select")], tz));
      var tV = r(3375);
      let tZ = (0, u.AH)`
  wui-separator {
    margin: ${({ spacing: e }) => e["3"]} calc(${({ spacing: e }) =>
        e["3"]} * -1)
      ${({ spacing: e }) => e["3"]} calc(${({ spacing: e }) => e["3"]} * -1);
    width: calc(100% + ${({ spacing: e }) => e["3"]} * 2);
  }
`;
      var tK = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tG = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.walletGuide = "get-started"),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            (this.authConnector = this.connectors.find(
              (e) => "AUTH" === e.type
            )),
            (this.isPwaLoading = !1),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => {
                (this.connectors = e),
                  (this.authConnector = this.connectors.find(
                    (e) => "AUTH" === e.type
                  ));
              }),
              a.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              )
            );
        }
        connectedCallback() {
          super.connectedCallback(), this.handlePwaFrameLoad();
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      <wui-flex
        class="container"
        flexDirection="column"
        gap="2"
        data-testid="w3m-social-login-widget"
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </wui-flex>
    `;
        }
        topViewTemplate() {
          let e = "explore" === this.walletGuide,
            t = this.remoteFeatures?.socials;
          return !t && e
            ? ((t = G.oU.DEFAULT_SOCIALS), this.renderTopViewContent(t))
            : t
            ? this.renderTopViewContent(t)
            : null;
        }
        renderTopViewContent(e) {
          return 2 === e.length
            ? (0, i.qy)` <wui-flex gap="2">
        ${e.slice(0, 2).map(
          (e) => (0, i.qy)`<wui-logo-select
              data-testid=${`social-selector-${e}`}
              @click=${() => {
                this.onSocialClick(e);
              }}
              logo=${e}
              tabIdx=${(0, s.J)(this.tabIdx)}
              ?disabled=${this.isPwaLoading || this.hasConnection()}
            ></wui-logo-select>`
        )}
      </wui-flex>`
            : (0, i.qy)` <wui-list-button
      data-testid=${`social-selector-${e[0]}`}
      @click=${() => {
        this.onSocialClick(e[0]);
      }}
      size="lg"
      icon=${(0, s.J)(e[0])}
      text=${`Continue with ${u.Zv.capitalize(e[0])}`}
      tabIdx=${(0, s.J)(this.tabIdx)}
      ?disabled=${this.isPwaLoading || this.hasConnection()}
    ></wui-list-button>`;
        }
        bottomViewTemplate() {
          let e = this.remoteFeatures?.socials,
            t = "explore" === this.walletGuide;
          return ((this.authConnector && e && 0 !== e.length) ||
            !t ||
            (e = G.oU.DEFAULT_SOCIALS),
          !e || e.length <= 2)
            ? null
            : e && e.length > 6
            ? (0, i.qy)`<wui-flex gap="2">
        ${e.slice(1, 5).map(
          (e) => (0, i.qy)`<wui-logo-select
              data-testid=${`social-selector-${e}`}
              @click=${() => {
                this.onSocialClick(e);
              }}
              logo=${e}
              tabIdx=${(0, s.J)(this.tabIdx)}
              ?focusable=${void 0 !== this.tabIdx && this.tabIdx >= 0}
              ?disabled=${this.isPwaLoading || this.hasConnection()}
            ></wui-logo-select>`
        )}
        <wui-logo-select
          logo="more"
          tabIdx=${(0, s.J)(this.tabIdx)}
          @click=${this.onMoreSocialsClick.bind(this)}
          ?disabled=${this.isPwaLoading || this.hasConnection()}
          data-testid="social-selector-more"
        ></wui-logo-select>
      </wui-flex>`
            : e
            ? (0, i.qy)`<wui-flex gap="2">
      ${e.slice(1, e.length).map(
        (e) => (0, i.qy)`<wui-logo-select
            data-testid=${`social-selector-${e}`}
            @click=${() => {
              this.onSocialClick(e);
            }}
            logo=${e}
            tabIdx=${(0, s.J)(this.tabIdx)}
            ?focusable=${void 0 !== this.tabIdx && this.tabIdx >= 0}
            ?disabled=${this.isPwaLoading || this.hasConnection()}
          ></wui-logo-select>`
      )}
    </wui-flex>`
            : null;
        }
        onMoreSocialsClick() {
          X.I.push("ConnectSocials");
        }
        async onSocialClick(e) {
          if (
            !Z.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
              (e) => e === o.W.state.activeChain
            )
          ) {
            let e = o.W.getFirstCaipNetworkSupportsAuthConnector();
            if (e) return void X.I.push("SwitchNetwork", { network: e });
          }
          e && (await (0, tF.Up)(e));
        }
        async handlePwaFrameLoad() {
          if (d.w.isPWA()) {
            this.isPwaLoading = !0;
            try {
              this.authConnector?.provider instanceof tV.Y &&
                (await this.authConnector.provider.init());
            } catch (e) {
              tM.h.open(
                {
                  displayMessage: "Error loading embedded wallet in PWA",
                  debugMessage: e.message,
                },
                "error"
              );
            } finally {
              this.isPwaLoading = !1;
            }
          }
        }
        hasConnection() {
          return Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.AUTH);
        }
      };
      (tG.styles = tZ),
        tK([(0, n.MZ)()], tG.prototype, "walletGuide", void 0),
        tK([(0, n.MZ)()], tG.prototype, "tabIdx", void 0),
        tK([(0, n.wk)()], tG.prototype, "connectors", void 0),
        tK([(0, n.wk)()], tG.prototype, "remoteFeatures", void 0),
        tK([(0, n.wk)()], tG.prototype, "authConnector", void 0),
        tK([(0, n.wk)()], tG.prototype, "isPwaLoading", void 0),
        (tG = tK([(0, u.EM)("w3m-social-login-widget")], tG)),
        r(78790);
      var tJ = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let tY = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            (this.count = td.N.state.count),
            (this.filteredCount = td.N.state.filteredWallets.length),
            (this.isFetchingRecommendedWallets =
              td.N.state.isFetchingRecommendedWallets),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e)),
              td.N.subscribeKey("count", (e) => (this.count = e)),
              td.N.subscribeKey(
                "filteredWallets",
                (e) => (this.filteredCount = e.length)
              ),
              td.N.subscribeKey(
                "isFetchingRecommendedWallets",
                (e) => (this.isFetchingRecommendedWallets = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e = this.connectors.find((e) => "walletConnect" === e.id),
            { allWallets: t } = a.H.state;
          if (!e || "HIDE" === t || ("ONLY_MOBILE" === t && !d.w.isMobile()))
            return null;
          let r = td.N.state.featured.length,
            n = this.count + r,
            o = n < 10 ? n : 10 * Math.floor(n / 10),
            c = this.filteredCount > 0 ? this.filteredCount : o,
            l = `${c}`;
          this.filteredCount > 0
            ? (l = `${this.filteredCount}`)
            : c < n && (l = `${c}+`);
          let h = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <wui-list-wallet
        name="Search Wallet"
        walletIcon="search"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${l}
        tagVariant="info"
        data-testid="all-wallets"
        tabIdx=${(0, s.J)(this.tabIdx)}
        .loading=${this.isFetchingRecommendedWallets}
        ?disabled=${h}
        size="sm"
      ></wui-list-wallet>
    `;
        }
        onAllWallets() {
          U.E.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" }),
            X.I.push("AllWallets", {
              redirectView: X.I.state.data?.redirectView,
            });
        }
      };
      tJ([(0, n.MZ)()], tY.prototype, "tabIdx", void 0),
        tJ([(0, n.wk)()], tY.prototype, "connectors", void 0),
        tJ([(0, n.wk)()], tY.prototype, "count", void 0),
        tJ([(0, n.wk)()], tY.prototype, "filteredCount", void 0),
        tJ([(0, n.wk)()], tY.prototype, "isFetchingRecommendedWallets", void 0),
        (tY = tJ([(0, u.EM)("w3m-all-wallets-widget")], tY));
      var tX = r(52321),
        tQ = r(32973),
        t0 = r(34777);
      let t1 = (e, t, r) => {
          let i = new Map();
          for (let n = t; n <= r; n++) i.set(e[n], n);
          return i;
        },
        t2 = (0, tQ.u$)(
          class extends tQ.WL {
            constructor(e) {
              if ((super(e), e.type !== tQ.OA.CHILD))
                throw Error("repeat() can only be used in text expressions");
            }
            dt(e, t, r) {
              let i;
              void 0 === r ? (r = t) : void 0 !== t && (i = t);
              let n = [],
                s = [],
                a = 0;
              for (let t of e) (n[a] = i ? i(t, a) : a), (s[a] = r(t, a)), a++;
              return { values: s, keys: n };
            }
            render(e, t, r) {
              return this.dt(e, t, r).values;
            }
            update(e, [t, r, i]) {
              let n = (0, t0.cN)(e),
                { values: s, keys: a } = this.dt(t, r, i);
              if (!Array.isArray(n)) return (this.ut = a), s;
              let o = (this.ut ??= []),
                c = [],
                l,
                d,
                h = 0,
                u = n.length - 1,
                p = 0,
                f = s.length - 1;
              for (; h <= u && p <= f; )
                if (null === n[h]) h++;
                else if (null === n[u]) u--;
                else if (o[h] === a[p])
                  (c[p] = (0, t0.lx)(n[h], s[p])), h++, p++;
                else if (o[u] === a[f])
                  (c[f] = (0, t0.lx)(n[u], s[f])), u--, f--;
                else if (o[h] === a[f])
                  (c[f] = (0, t0.lx)(n[h], s[f])),
                    (0, t0.Dx)(e, c[f + 1], n[h]),
                    h++,
                    f--;
                else if (o[u] === a[p])
                  (c[p] = (0, t0.lx)(n[u], s[p])),
                    (0, t0.Dx)(e, n[h], n[u]),
                    u--,
                    p++;
                else if (
                  (void 0 === l && ((l = t1(a, p, f)), (d = t1(o, h, u))),
                  l.has(o[h]))
                )
                  if (l.has(o[u])) {
                    let t = d.get(a[p]),
                      r = void 0 !== t ? n[t] : null;
                    if (null === r) {
                      let t = (0, t0.Dx)(e, n[h]);
                      (0, t0.lx)(t, s[p]), (c[p] = t);
                    } else
                      (c[p] = (0, t0.lx)(r, s[p])),
                        (0, t0.Dx)(e, n[h], r),
                        (n[t] = null);
                    p++;
                  } else (0, t0.KO)(n[u]), u--;
                else (0, t0.KO)(n[h]), h++;
              for (; p <= f; ) {
                let t = (0, t0.Dx)(e, c[f + 1]);
                (0, t0.lx)(t, s[p]), (c[p++] = t);
              }
              for (; h <= u; ) {
                let e = n[h++];
                null !== e && (0, t0.KO)(e);
              }
              return (this.ut = a), (0, t0.mY)(e, c), tX.c0;
            }
          }
        );
      var t3 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let t5 = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.connectors = []),
            (this.connections = Q.x.state.connections),
            this.unsubscribe.push(
              Q.x.subscribeKey("connections", (e) => (this.connections = e))
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e = this.connectors.filter((e) => "ANNOUNCED" === e.type);
          return e?.length
            ? (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${t2(
          e.filter(eO.g.showConnector),
          (e) => e.id,
          (e) => {
            let t = (this.connections.get(e.chain) ?? []).some((t) =>
              e1.y.isLowerCaseMatch(t.connectorId, e.id)
            );
            return (0, i.qy)`
              <w3m-list-wallet
                imageSrc=${(0, s.J)(l.$.getConnectorImage(e))}
                name=${e.name ?? "Unknown"}
                @click=${() => this.onConnector(e)}
                tagVariant=${t ? "info" : "success"}
                tagLabel=${t ? "connected" : "installed"}
                size="sm"
                data-testid=${`wallet-selector-${e.id}`}
                .installed=${!0}
                tabIdx=${(0, s.J)(this.tabIdx)}
                rdnsId=${(0, s.J)(e.explorerWallet?.rdns || void 0)}
                walletRank=${(0, s.J)(e.explorerWallet?.order)}
              >
              </w3m-list-wallet>
            `;
          }
        )}
      </wui-flex>
    `
            : ((this.style.cssText = "display: none"), null);
        }
        onConnector(e) {
          let t = X.I.state.data?.redirectView;
          "walletConnect" === e.id
            ? d.w.isMobile()
              ? X.I.push("AllWallets")
              : X.I.push("ConnectingWalletConnect", { redirectView: t })
            : X.I.push("ConnectingExternal", {
                connector: e,
                redirectView: t,
                wallet: e.explorerWallet,
              });
        }
      };
      t3([(0, n.MZ)({ type: Number })], t5.prototype, "tabIdx", void 0),
        t3([(0, n.MZ)({ attribute: !1 })], t5.prototype, "connectors", void 0),
        t3([(0, n.wk)()], t5.prototype, "connections", void 0),
        (t5 = t3([(0, u.EM)("w3m-connect-announced-widget")], t5));
      var t4 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let t6 = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            (this.loading = !1),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e))
            ),
            d.w.isTelegram() &&
              d.w.isIos() &&
              ((this.loading = !Q.x.state.wcUri),
              this.unsubscribe.push(
                Q.x.subscribeKey("wcUri", (e) => (this.loading = !e))
              ));
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let { customWallets: e } = a.H.state;
          if (!e?.length) return (this.style.cssText = "display: none"), null;
          let t = this.filterOutDuplicateWallets(e),
            r = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`<wui-flex flexDirection="column" gap="2">
      ${t.map(
        (e) => (0, i.qy)`
          <w3m-list-wallet
            imageSrc=${(0, s.J)(l.$.getWalletImage(e))}
            name=${e.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(e)}
            size="sm"
            data-testid=${`wallet-selector-${e.id}`}
            tabIdx=${(0, s.J)(this.tabIdx)}
            ?loading=${this.loading}
            ?disabled=${r}
            rdnsId=${e.rdns}
            walletRank=${e.order}
          >
          </w3m-list-wallet>
        `
      )}
    </wui-flex>`;
        }
        filterOutDuplicateWallets(e) {
          let t = es.i.getRecentWallets(),
            r = this.connectors.map((e) => e.info?.rdns).filter(Boolean),
            i = t.map((e) => e.rdns).filter(Boolean),
            n = r.concat(i);
          if (n.includes("io.metamask.mobile") && d.w.isMobile()) {
            let e = n.indexOf("io.metamask.mobile");
            n[e] = "io.metamask";
          }
          return e.filter((e) => !n.includes(String(e?.rdns)));
        }
        onConnectWallet(e) {
          this.loading ||
            X.I.push("ConnectingWalletConnect", {
              wallet: e,
              redirectView: X.I.state.data?.redirectView,
            });
        }
      };
      t4([(0, n.MZ)()], t6.prototype, "tabIdx", void 0),
        t4([(0, n.wk)()], t6.prototype, "connectors", void 0),
        t4([(0, n.wk)()], t6.prototype, "loading", void 0),
        (t6 = t4([(0, u.EM)("w3m-connect-custom-widget")], t6));
      var t8 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let t9 = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e))
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e = this.connectors
            .filter((e) => "EXTERNAL" === e.type)
            .filter(eO.g.showConnector)
            .filter((e) => e.id !== Z.o.CONNECTOR_ID.COINBASE_SDK);
          if (!e?.length) return (this.style.cssText = "display: none"), null;
          let t = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${e.map(
          (e) => (0, i.qy)`
            <w3m-list-wallet
              imageSrc=${(0, s.J)(l.$.getConnectorImage(e))}
              .installed=${!0}
              name=${e.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${e.id}`}
              size="sm"
              @click=${() => this.onConnector(e)}
              tabIdx=${(0, s.J)(this.tabIdx)}
              ?disabled=${t}
              rdnsId=${e.explorerWallet?.rdns}
              walletRank=${e.explorerWallet?.order}
            >
            </w3m-list-wallet>
          `
        )}
      </wui-flex>
    `;
        }
        onConnector(e) {
          X.I.push("ConnectingExternal", {
            connector: e,
            redirectView: X.I.state.data?.redirectView,
          });
        }
      };
      t8([(0, n.MZ)()], t9.prototype, "tabIdx", void 0),
        t8([(0, n.wk)()], t9.prototype, "connectors", void 0),
        (t9 = t8([(0, u.EM)("w3m-connect-external-widget")], t9));
      var t7 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let re = class extends i.WF {
        constructor() {
          super(...arguments), (this.tabIdx = void 0), (this.wallets = []);
        }
        render() {
          if (!this.wallets.length)
            return (this.style.cssText = "display: none"), null;
          let e = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${this.wallets.map(
          (t) => (0, i.qy)`
            <w3m-list-wallet
              data-testid=${`wallet-selector-featured-${t.id}`}
              imageSrc=${(0, s.J)(l.$.getWalletImage(t))}
              name=${t.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(t)}
              tabIdx=${(0, s.J)(this.tabIdx)}
              size="sm"
              ?disabled=${e}
              rdnsId=${t.rdns}
              walletRank=${t.order}
            >
            </w3m-list-wallet>
          `
        )}
      </wui-flex>
    `;
        }
        onConnectWallet(e) {
          K.a.selectWalletConnector(e);
        }
      };
      t7([(0, n.MZ)()], re.prototype, "tabIdx", void 0),
        t7([(0, n.MZ)()], re.prototype, "wallets", void 0),
        (re = t7([(0, u.EM)("w3m-connect-featured-widget")], re));
      var rt = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rr = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.connectors = []),
            (this.connections = Q.x.state.connections),
            this.unsubscribe.push(
              Q.x.subscribeKey("connections", (e) => (this.connections = e))
            );
        }
        render() {
          let e = eO.g.sortConnectorsByExplorerWallet(
            this.connectors.filter(eO.g.showConnector)
          );
          return 0 === e.length
            ? ((this.style.cssText = "display: none"), null)
            : (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${t2(
          e,
          (e) => e.id,
          (e) => {
            let t = (this.connections.get(e.chain) ?? []).some((t) =>
              e1.y.isLowerCaseMatch(t.connectorId, e.id)
            );
            return (0, i.qy)`
              <w3m-list-wallet
                imageSrc=${(0, s.J)(l.$.getConnectorImage(e))}
                .installed=${!0}
                name=${e.name ?? "Unknown"}
                tagVariant=${t ? "info" : "success"}
                tagLabel=${t ? "connected" : "installed"}
                data-testid=${`wallet-selector-${e.id}`}
                size="sm"
                @click=${() => this.onConnector(e)}
                tabIdx=${(0, s.J)(this.tabIdx)}
                rdnsId=${(0, s.J)(e.explorerWallet?.rdns || void 0)}
                walletRank=${(0, s.J)(e.explorerWallet?.order)}
              >
              </w3m-list-wallet>
            `;
          }
        )}
      </wui-flex>
    `;
        }
        onConnector(e) {
          K.a.setActiveConnector(e),
            X.I.push("ConnectingExternal", {
              connector: e,
              redirectView: X.I.state.data?.redirectView,
              wallet: e.explorerWallet,
            });
        }
      };
      rt([(0, n.MZ)({ type: Number })], rr.prototype, "tabIdx", void 0),
        rt([(0, n.MZ)({ attribute: !1 })], rr.prototype, "connectors", void 0),
        rt([(0, n.wk)()], rr.prototype, "connections", void 0),
        (rr = rt([(0, u.EM)("w3m-connect-injected-widget")], rr));
      var ri = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rn = class extends i.WF {
        constructor() {
          super(), (this.tabIdx = void 0), (this.connectors = []);
        }
        render() {
          let e = this.connectors.filter(
            (e) => "MULTI_CHAIN" === e.type && "WalletConnect" !== e.name
          );
          if (!e?.length) return (this.style.cssText = "display: none"), null;
          let t = eO.g.sortConnectorsByExplorerWallet(e);
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${t.map(
          (e) => (0, i.qy)`
            <w3m-list-wallet
              imageSrc=${(0, s.J)(l.$.getConnectorImage(e))}
              .installed=${!0}
              name=${e.name ?? "Unknown"}
              tagVariant="info"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${e.id}`}
              size="sm"
              @click=${() => this.onConnector(e)}
              tabIdx=${(0, s.J)(this.tabIdx)}
              rdnsId=${(0, s.J)(e.explorerWallet?.rdns || void 0)}
              walletRank=${(0, s.J)(e.explorerWallet?.order)}
            >
            </w3m-list-wallet>
          `
        )}
      </wui-flex>
    `;
        }
        onConnector(e) {
          K.a.setActiveConnector(e),
            X.I.push("ConnectingMultiChain", {
              redirectView: X.I.state.data?.redirectView,
            });
        }
      };
      ri([(0, n.MZ)()], rn.prototype, "tabIdx", void 0),
        ri([(0, n.MZ)()], rn.prototype, "connectors", void 0),
        (rn = ri([(0, u.EM)("w3m-connect-multi-chain-widget")], rn));
      var rs = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ra = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            (this.loading = !1),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e))
            ),
            d.w.isTelegram() &&
              d.w.isIos() &&
              ((this.loading = !Q.x.state.wcUri),
              this.unsubscribe.push(
                Q.x.subscribeKey("wcUri", (e) => (this.loading = !e))
              ));
        }
        render() {
          let e = es.i
            .getRecentWallets()
            .filter((e) => !tw.A.isExcluded(e))
            .filter((e) => !this.hasWalletConnector(e))
            .filter((e) => this.isWalletCompatibleWithCurrentChain(e));
          if (!e.length) return (this.style.cssText = "display: none"), null;
          let t = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${e.map(
          (e) => (0, i.qy)`
            <w3m-list-wallet
              imageSrc=${(0, s.J)(l.$.getWalletImage(e))}
              name=${e.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(e)}
              tagLabel="recent"
              tagVariant="info"
              size="sm"
              tabIdx=${(0, s.J)(this.tabIdx)}
              ?loading=${this.loading}
              ?disabled=${t}
              rdnsId=${e.rdns}
              walletRank=${e.order}
            >
            </w3m-list-wallet>
          `
        )}
      </wui-flex>
    `;
        }
        onConnectWallet(e) {
          this.loading || K.a.selectWalletConnector(e);
        }
        hasWalletConnector(e) {
          return this.connectors.some(
            (t) => t.id === e.id || t.name === e.name
          );
        }
        isWalletCompatibleWithCurrentChain(e) {
          let t = o.W.state.activeChain;
          return !t || !e.chains || e.chains.some((e) => t === e.split(":")[0]);
        }
      };
      rs([(0, n.MZ)()], ra.prototype, "tabIdx", void 0),
        rs([(0, n.wk)()], ra.prototype, "connectors", void 0),
        rs([(0, n.wk)()], ra.prototype, "loading", void 0),
        (ra = rs([(0, u.EM)("w3m-connect-recent-widget")], ra));
      var ro = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rc = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.wallets = []),
            (this.loading = !1),
            d.w.isTelegram() &&
              d.w.isIos() &&
              ((this.loading = !Q.x.state.wcUri),
              this.unsubscribe.push(
                Q.x.subscribeKey("wcUri", (e) => (this.loading = !e))
              ));
        }
        render() {
          let { connectors: e } = K.a.state,
            { customWallets: t, featuredWalletIds: r } = a.H.state,
            n = e.find((e) => "walletConnect" === e.id),
            o = e.filter(
              (e) =>
                "INJECTED" === e.type ||
                "ANNOUNCED" === e.type ||
                "MULTI_CHAIN" === e.type
            );
          if (!n && !o.length && !t?.length) return null;
          let c = !!(
              a.H.state.features?.email || a.H.state.remoteFeatures?.email
            ),
            d =
              (Array.isArray(a.H.state.features?.socials) &&
                a.H.state.features?.socials.length > 0) ||
              (Array.isArray(a.H.state.remoteFeatures?.socials) &&
                a.H.state.remoteFeatures?.socials.length > 0),
            h = o.filter((e) => "Browser Wallet" !== e.name),
            u = r?.length || 0,
            p = t?.length || 0,
            f = u + p + (h.length || 0) + +!!c + +!!d;
          if (f >= 4) return (this.style.cssText = "display: none"), null;
          let g = tw.A.filterOutDuplicateWallets(this.wallets).slice(0, 4 - f);
          if (!g.length) return (this.style.cssText = "display: none"), null;
          let m = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        ${g.map(
          (e) => (0, i.qy)`
            <w3m-list-wallet
              imageSrc=${(0, s.J)(l.$.getWalletImage(e))}
              name=${e?.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(e)}
              size="sm"
              tabIdx=${(0, s.J)(this.tabIdx)}
              ?loading=${this.loading}
              ?disabled=${m}
              rdnsId=${e.rdns}
              walletRank=${e.order}
            >
            </w3m-list-wallet>
          `
        )}
      </wui-flex>
    `;
        }
        onConnectWallet(e) {
          if (this.loading) return;
          let t = X.I.state.data?.redirectView,
            r = K.a.getConnector({ id: e.id, rdns: e.rdns });
          r
            ? X.I.push("ConnectingExternal", { connector: r, redirectView: t })
            : X.I.push("ConnectingWalletConnect", {
                wallet: e,
                redirectView: t,
              });
        }
      };
      ro([(0, n.MZ)()], rc.prototype, "tabIdx", void 0),
        ro([(0, n.MZ)()], rc.prototype, "wallets", void 0),
        ro([(0, n.wk)()], rc.prototype, "loading", void 0),
        (rc = ro([(0, u.EM)("w3m-connect-recommended-widget")], rc));
      var rl = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rd = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.tabIdx = void 0),
            (this.connectors = K.a.state.connectors),
            (this.connectorImages = c.j.state.connectorImages),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e)),
              c.j.subscribeKey(
                "connectorImages",
                (e) => (this.connectorImages = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          if (d.w.isMobile())
            return (this.style.cssText = "display: none"), null;
          let e = this.connectors.find((e) => "walletConnect" === e.id);
          if (!e) return (this.style.cssText = "display: none"), null;
          let t = e.imageUrl || this.connectorImages[e?.imageId ?? ""],
            r = Q.x.hasAnyConnection(Z.o.CONNECTOR_ID.WALLET_CONNECT);
          return (0, i.qy)`
      <w3m-list-wallet
        imageSrc=${(0, s.J)(t)}
        name=${e.name ?? "Unknown"}
        @click=${() => this.onConnector(e)}
        tagLabel="qr code"
        tagVariant="accent"
        tabIdx=${(0, s.J)(this.tabIdx)}
        data-testid="wallet-selector-walletconnect"
        size="sm"
        ?disabled=${r}
        rdnsId=${e.explorerWallet?.rdns}
      >
      </w3m-list-wallet>
    `;
        }
        onConnector(e) {
          K.a.setActiveConnector(e),
            X.I.push("ConnectingWalletConnect", {
              redirectView: X.I.state.data?.redirectView,
            });
        }
      };
      rl([(0, n.MZ)()], rd.prototype, "tabIdx", void 0),
        rl([(0, n.wk)()], rd.prototype, "connectors", void 0),
        rl([(0, n.wk)()], rd.prototype, "connectorImages", void 0),
        (rd = rl([(0, u.EM)("w3m-connect-walletconnect-widget")], rd));
      let rh = (0, u.AH)`
  :host {
    margin-top: ${({ spacing: e }) => e["1"]};
  }
  wui-separator {
    margin: ${({ spacing: e }) => e["3"]} calc(${({ spacing: e }) =>
        e["3"]} * -1)
      ${({ spacing: e }) => e["2"]} calc(${({ spacing: e }) => e["3"]} * -1);
    width: calc(100% + ${({ spacing: e }) => e["3"]} * 2);
  }
`;
      var ru = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rp = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.connectors = K.a.state.connectors),
            (this.recommended = td.N.state.recommended),
            (this.featured = td.N.state.featured),
            (this.explorerWallets = td.N.state.explorerWallets),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => (this.connectors = e)),
              td.N.subscribeKey("recommended", (e) => (this.recommended = e)),
              td.N.subscribeKey("featured", (e) => (this.featured = e)),
              td.N.subscribeKey("explorerFilteredWallets", (e) => {
                this.explorerWallets = e?.length
                  ? e
                  : td.N.state.explorerWallets;
              }),
              td.N.subscribeKey("explorerWallets", (e) => {
                this.explorerWallets?.length || (this.explorerWallets = e);
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2"> ${this.connectorListTemplate()} </wui-flex>
    `;
        }
        mapConnectorsToExplorerWallets(e, t) {
          return e.map((e) => {
            if ("MULTI_CHAIN" === e.type && e.connectors) {
              let r = e.connectors.map((e) => e.id),
                i = e.connectors.map((e) => e.name),
                n = e.connectors.map((e) => e.info?.rdns);
              return (
                (e.explorerWallet =
                  t?.find(
                    (e) =>
                      r.includes(e.id) ||
                      i.includes(e.name) ||
                      (e.rdns && (n.includes(e.rdns) || r.includes(e.rdns)))
                  ) ?? e.explorerWallet),
                e
              );
            }
            let r = t?.find(
              (t) =>
                t.id === e.id || t.rdns === e.info?.rdns || t.name === e.name
            );
            return (e.explorerWallet = r ?? e.explorerWallet), e;
          });
        }
        processConnectorsByType(e, t = !0) {
          if (!this.explorerWallets?.length) return e;
          let r = eO.g.sortConnectorsByExplorerWallet([...e]);
          return t ? r.filter(eO.g.showConnector) : r;
        }
        connectorListTemplate() {
          let e = this.mapConnectorsToExplorerWallets(
              this.connectors,
              this.explorerWallets ?? []
            ),
            t = eO.g.getConnectorsByType(e, this.recommended, this.featured),
            r = this.processConnectorsByType(t.announced),
            n = this.processConnectorsByType(t.injected),
            a = this.processConnectorsByType(t.multiChain, !1),
            o = t.custom,
            c = t.recent,
            l = t.external,
            d = t.recommended,
            h = t.featured;
          return eO.g
            .getConnectorTypeOrder({
              custom: o,
              recent: c,
              announced: r,
              injected: n,
              multiChain: a,
              recommended: d,
              featured: h,
              external: l,
            })
            .map((e) => {
              switch (e) {
                case "injected":
                  return (0, i.qy)`
            ${
              a.length
                ? (0, i.qy)`<w3m-connect-multi-chain-widget
                  tabIdx=${(0, s.J)(this.tabIdx)}
                  .connectors=${a}
                ></w3m-connect-multi-chain-widget>`
                : null
            }
            ${
              r.length
                ? (0, i.qy)`<w3m-connect-announced-widget
                  tabIdx=${(0, s.J)(this.tabIdx)}
                  .connectors=${r}
                ></w3m-connect-announced-widget>`
                : null
            }
            ${
              n.length
                ? (0, i.qy)`<w3m-connect-injected-widget
                  .connectors=${n}
                  tabIdx=${(0, s.J)(this.tabIdx)}
                ></w3m-connect-injected-widget>`
                : null
            }
          `;
                case "walletConnect":
                  return (0, i.qy)`<w3m-connect-walletconnect-widget
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-walletconnect-widget>`;
                case "recent":
                  return (0, i.qy)`<w3m-connect-recent-widget
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-recent-widget>`;
                case "featured":
                  return (0, i.qy)`<w3m-connect-featured-widget
            .wallets=${h}
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-featured-widget>`;
                case "custom":
                  return (0, i.qy)`<w3m-connect-custom-widget
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-custom-widget>`;
                case "external":
                  return (0, i.qy)`<w3m-connect-external-widget
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-external-widget>`;
                case "recommended":
                  return (0, i.qy)`<w3m-connect-recommended-widget
            .wallets=${d}
            tabIdx=${(0, s.J)(this.tabIdx)}
          ></w3m-connect-recommended-widget>`;
                default:
                  return console.warn(`Unknown connector type: ${e}`), null;
              }
            });
        }
      };
      (rp.styles = rh),
        ru([(0, n.MZ)({ type: Number })], rp.prototype, "tabIdx", void 0),
        ru([(0, n.wk)()], rp.prototype, "connectors", void 0),
        ru([(0, n.wk)()], rp.prototype, "recommended", void 0),
        ru([(0, n.wk)()], rp.prototype, "featured", void 0),
        ru([(0, n.wk)()], rp.prototype, "explorerWallets", void 0),
        (rp = ru([(0, u.EM)("w3m-connector-list")], rp));
      var rf = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rg = class extends i.WF {
        constructor() {
          super(...arguments), (this.tabIdx = void 0);
        }
        render() {
          return (0, i.qy)`
      <wui-flex flexDirection="column" gap="2">
        <w3m-connector-list tabIdx=${(0, s.J)(
          this.tabIdx
        )}></w3m-connector-list>
        <w3m-all-wallets-widget tabIdx=${(0, s.J)(
          this.tabIdx
        )}></w3m-all-wallets-widget>
      </wui-flex>
    `;
        }
      };
      rf([(0, n.MZ)()], rg.prototype, "tabIdx", void 0),
        (rg = rf([(0, u.EM)("w3m-wallet-login-list")], rg));
      let rm = (0, u.AH)`
  :host {
    --connect-scroll--top-opacity: 0;
    --connect-scroll--bottom-opacity: 0;
    --connect-mask-image: none;
  }

  .connect {
    max-height: clamp(360px, 470px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
    transition: opacity ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity;
    mask-image: var(--connect-mask-image);
  }

  .guide {
    transition: opacity ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity;
  }

  .connect::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }

  .connect.disabled,
  .guide.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }

  wui-separator {
    margin: ${({ spacing: e }) => e["3"]} calc(${({ spacing: e }) =>
        e["3"]} * -1);
    width: calc(100% + ${({ spacing: e }) => e["3"]} * 2);
  }
`;
      var ry = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rw = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.connectors = K.a.state.connectors),
            (this.authConnector = this.connectors.find(
              (e) => "AUTH" === e.type
            )),
            (this.features = a.H.state.features),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            (this.enableWallets = a.H.state.enableWallets),
            (this.noAdapters = o.W.state.noAdapters),
            (this.walletGuide = "get-started"),
            (this.checked = tP.o.state.isLegalCheckboxChecked),
            (this.isEmailEnabled =
              this.remoteFeatures?.email && !o.W.state.noAdapters),
            (this.isSocialEnabled =
              this.remoteFeatures?.socials &&
              this.remoteFeatures.socials.length > 0 &&
              !o.W.state.noAdapters),
            (this.isAuthEnabled = this.checkIfAuthEnabled(this.connectors)),
            this.unsubscribe.push(
              K.a.subscribeKey("connectors", (e) => {
                (this.connectors = e),
                  (this.authConnector = this.connectors.find(
                    (e) => "AUTH" === e.type
                  )),
                  (this.isAuthEnabled = this.checkIfAuthEnabled(
                    this.connectors
                  ));
              }),
              a.H.subscribeKey("features", (e) => {
                this.features = e;
              }),
              a.H.subscribeKey("remoteFeatures", (e) => {
                (this.remoteFeatures = e),
                  this.setEmailAndSocialEnableCheck(
                    this.noAdapters,
                    this.remoteFeatures
                  );
              }),
              a.H.subscribeKey(
                "enableWallets",
                (e) => (this.enableWallets = e)
              ),
              o.W.subscribeKey("noAdapters", (e) =>
                this.setEmailAndSocialEnableCheck(e, this.remoteFeatures)
              ),
              tP.o.subscribeKey(
                "isLegalCheckboxChecked",
                (e) => (this.checked = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e()),
            this.resizeObserver?.disconnect();
          let e = this.shadowRoot?.querySelector(".connect");
          e?.removeEventListener(
            "scroll",
            this.handleConnectListScroll.bind(this)
          );
        }
        firstUpdated() {
          let e = this.shadowRoot?.querySelector(".connect");
          e &&
            (requestAnimationFrame(this.handleConnectListScroll.bind(this)),
            e?.addEventListener(
              "scroll",
              this.handleConnectListScroll.bind(this)
            ),
            (this.resizeObserver = new ResizeObserver(() => {
              this.handleConnectListScroll();
            })),
            this.resizeObserver?.observe(e),
            this.handleConnectListScroll());
        }
        render() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = a.H.state,
            r = a.H.state.features?.legalCheckbox,
            n =
              !!(e || t) &&
              !!r &&
              "get-started" === this.walletGuide &&
              !this.checked,
            s = a.H.state.enableWalletGuide,
            o = this.enableWallets,
            c = this.isSocialEnabled || this.authConnector;
          return (0, i.qy)`
      <wui-flex flexDirection="column">
        ${this.legalCheckboxTemplate()}
        <wui-flex
          data-testid="w3m-connect-scroll-view"
          flexDirection="column"
          .padding=${["0", "0", "4", "0"]}
          class=${(0, eV.H)({ connect: !0, disabled: n })}
        >
          <wui-flex
            class="connect-methods"
            flexDirection="column"
            gap="2"
            .padding=${
              c && o && s && "get-started" === this.walletGuide
                ? ["0", "3", "0", "3"]
                : ["0", "3", "3", "3"]
            }
          >
            ${this.renderConnectMethod(n ? -1 : void 0)}
          </wui-flex>
        </wui-flex>
        ${this.reownBrandingTemplate()}
      </wui-flex>
    `;
        }
        reownBrandingTemplate() {
          return eP.y.hasFooter() || !this.remoteFeatures?.reownBranding
            ? null
            : (0, i.qy)`<wui-ux-by-reown></wui-ux-by-reown>`;
        }
        setEmailAndSocialEnableCheck(e, t) {
          (this.isEmailEnabled = t?.email && !e),
            (this.isSocialEnabled = t?.socials && t.socials.length > 0 && !e),
            (this.remoteFeatures = t),
            (this.noAdapters = e);
        }
        checkIfAuthEnabled(e) {
          let t = e
            .filter((e) => e.type === tU.o.CONNECTOR_TYPE_AUTH)
            .map((e) => e.chain);
          return Z.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.some((e) => t.includes(e));
        }
        renderConnectMethod(e) {
          let t = tw.A.getConnectOrderMethod(this.features, this.connectors);
          return (0, i.qy)`${t.map((t, r) => {
            switch (t) {
              case "email":
                return (0, i.qy)`${this.emailTemplate(
                  e
                )} ${this.separatorTemplate(r, "email")}`;
              case "social":
                return (0, i.qy)`${this.socialListTemplate(e)}
          ${this.separatorTemplate(r, "social")}`;
              case "wallet":
                return (0, i.qy)`${this.walletListTemplate(e)}
          ${this.separatorTemplate(r, "wallet")}`;
              default:
                return null;
            }
          })}`;
        }
        checkMethodEnabled(e) {
          switch (e) {
            case "wallet":
              return this.enableWallets;
            case "social":
              return this.isSocialEnabled && this.isAuthEnabled;
            case "email":
              return this.isEmailEnabled && this.isAuthEnabled;
            default:
              return null;
          }
        }
        checkIsThereNextMethod(e) {
          let t = tw.A.getConnectOrderMethod(this.features, this.connectors)[
            e + 1
          ];
          return t
            ? this.checkMethodEnabled(t)
              ? t
              : this.checkIsThereNextMethod(e + 1)
            : void 0;
        }
        separatorTemplate(e, t) {
          let r = this.checkIsThereNextMethod(e),
            n = "explore" === this.walletGuide;
          switch (t) {
            case "wallet":
              return this.enableWallets && r && !n
                ? (0,
                  i.qy)`<wui-separator data-testid="wui-separator" text="or"></wui-separator>`
                : null;
            case "email":
              return this.isAuthEnabled &&
                this.isEmailEnabled &&
                "social" !== r &&
                r
                ? (0, i.qy)`<wui-separator
              data-testid="w3m-email-login-or-separator"
              text="or"
            ></wui-separator>`
                : null;
            case "social":
              return this.isAuthEnabled &&
                this.isSocialEnabled &&
                "email" !== r &&
                r
                ? (0,
                  i.qy)`<wui-separator data-testid="wui-separator" text="or"></wui-separator>`
                : null;
            default:
              return null;
          }
        }
        emailTemplate(e) {
          return this.isEmailEnabled && this.isAuthEnabled
            ? (0, i.qy)`<w3m-email-login-widget tabIdx=${(0, s.J)(
                e
              )}></w3m-email-login-widget>`
            : null;
        }
        socialListTemplate(e) {
          return this.isSocialEnabled && this.isAuthEnabled
            ? (0, i.qy)`<w3m-social-login-widget
      walletGuide=${this.walletGuide}
      tabIdx=${(0, s.J)(e)}
    ></w3m-social-login-widget>`
            : null;
        }
        walletListTemplate(e) {
          let t = this.enableWallets,
            r = this.features?.emailShowWallets === !1,
            n = this.features?.collapseWallets;
          return t
            ? (d.w.isTelegram() &&
                (d.w.isSafari() || d.w.isIos()) &&
                Q.x.connectWalletConnect().catch((e) => ({})),
              "explore" === this.walletGuide)
              ? null
              : this.isAuthEnabled &&
                (this.isEmailEnabled || this.isSocialEnabled) &&
                (r || n)
              ? (0, i.qy)`<wui-list-button
        data-testid="w3m-collapse-wallets-button"
        tabIdx=${(0, s.J)(e)}
        @click=${this.onContinueWalletClick.bind(this)}
        text="Continue with a wallet"
      ></wui-list-button>`
              : (0, i.qy)`<w3m-wallet-login-list tabIdx=${(0, s.J)(
                  e
                )}></w3m-wallet-login-list>`
            : null;
        }
        legalCheckboxTemplate() {
          return "explore" === this.walletGuide
            ? null
            : (0,
              i.qy)`<w3m-legal-checkbox data-testid="w3m-legal-checkbox"></w3m-legal-checkbox>`;
        }
        handleConnectListScroll() {
          let e = this.shadowRoot?.querySelector(".connect");
          e &&
            (e.scrollHeight > 470
              ? (e.style.setProperty(
                  "--connect-mask-image",
                  `linear-gradient(
          to bottom,
          rgba(0, 0, 0, calc(1 - var(--connect-scroll--top-opacity))) 0px,
          rgba(200, 200, 200, calc(1 - var(--connect-scroll--top-opacity))) 1px,
          black 100px,
          black calc(100% - 100px),
          rgba(155, 155, 155, calc(1 - var(--connect-scroll--bottom-opacity))) calc(100% - 1px),
          rgba(0, 0, 0, calc(1 - var(--connect-scroll--bottom-opacity))) 100%
        )`
                ),
                e.style.setProperty(
                  "--connect-scroll--top-opacity",
                  u.z8.interpolate([0, 50], [0, 1], e.scrollTop).toString()
                ),
                e.style.setProperty(
                  "--connect-scroll--bottom-opacity",
                  u.z8
                    .interpolate(
                      [0, 50],
                      [0, 1],
                      e.scrollHeight - e.scrollTop - e.offsetHeight
                    )
                    .toString()
                ))
              : (e.style.setProperty("--connect-mask-image", "none"),
                e.style.setProperty("--connect-scroll--top-opacity", "0"),
                e.style.setProperty("--connect-scroll--bottom-opacity", "0")));
        }
        onContinueWalletClick() {
          X.I.push("ConnectWallets");
        }
      };
      (rw.styles = rm),
        ry([(0, tO.w)()], rw.prototype, "connectors", void 0),
        ry([(0, tO.w)()], rw.prototype, "authConnector", void 0),
        ry([(0, tO.w)()], rw.prototype, "features", void 0),
        ry([(0, tO.w)()], rw.prototype, "remoteFeatures", void 0),
        ry([(0, tO.w)()], rw.prototype, "enableWallets", void 0),
        ry([(0, tO.w)()], rw.prototype, "noAdapters", void 0),
        ry([(0, n.MZ)()], rw.prototype, "walletGuide", void 0),
        ry([(0, tO.w)()], rw.prototype, "checked", void 0),
        ry([(0, tO.w)()], rw.prototype, "isEmailEnabled", void 0),
        ry([(0, tO.w)()], rw.prototype, "isSocialEnabled", void 0),
        ry([(0, tO.w)()], rw.prototype, "isAuthEnabled", void 0),
        (rw = ry([(0, u.EM)("w3m-connect-view")], rw));
      var rb = r(79530),
        rv = r(36964),
        rC = r(45069);
      r(48352), r(64731);
      let rE = (0, m.AH)`
  wui-flex {
    width: 100%;
    height: 52px;
    box-sizing: border-box;
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    border-radius: ${({ borderRadius: e }) => e[5]};
    padding-left: ${({ spacing: e }) => e[3]};
    padding-right: ${({ spacing: e }) => e[3]};
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: ${({ spacing: e }) => e[6]};
  }

  wui-text {
    color: ${({ tokens: e }) => e.theme.textSecondary};
  }

  wui-icon {
    width: 12px;
    height: 12px;
  }
`;
      var rx = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rA = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.disabled = !1),
            (this.label = ""),
            (this.buttonLabel = "");
        }
        render() {
          return (0, i.qy)`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="lg-regular" color="inherit">${this.label}</wui-text>
        <wui-button variant="accent-secondary" size="sm">
          ${this.buttonLabel}
          <wui-icon name="chevronRight" color="inherit" size="inherit" slot="iconRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
        }
      };
      (rA.styles = [p.W5, p.fD, rE]),
        rx([(0, n.MZ)({ type: Boolean })], rA.prototype, "disabled", void 0),
        rx([(0, n.MZ)()], rA.prototype, "label", void 0),
        rx([(0, n.MZ)()], rA.prototype, "buttonLabel", void 0),
        (rA = rx([(0, g.E)("wui-cta-button")], rA));
      let r_ = (0, u.AH)`
  :host {
    display: block;
    padding: 0 ${({ spacing: e }) => e["5"]} ${({ spacing: e }) => e["5"]};
  }
`;
      var rI = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rS = class extends i.WF {
        constructor() {
          super(...arguments), (this.wallet = void 0);
        }
        render() {
          if (!this.wallet) return (this.style.display = "none"), null;
          let {
              name: e,
              app_store: t,
              play_store: r,
              chrome_store: n,
              homepage: s,
            } = this.wallet,
            a = d.w.isMobile(),
            o = d.w.isIos(),
            c = d.w.isAndroid(),
            l = [t, r, s, n].filter(Boolean).length > 1,
            h = u.Zv.getTruncateString({
              string: e,
              charsStart: 12,
              charsEnd: 0,
              truncate: "end",
            });
          return l && !a
            ? (0, i.qy)`
        <wui-cta-button
          label=${`Don't have ${h}?`}
          buttonLabel="Get"
          @click=${() => X.I.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `
            : !l && s
            ? (0, i.qy)`
        <wui-cta-button
          label=${`Don't have ${h}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `
            : t && o
            ? (0, i.qy)`
        <wui-cta-button
          label=${`Don't have ${h}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `
            : r && c
            ? (0, i.qy)`
        <wui-cta-button
          label=${`Don't have ${h}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `
            : ((this.style.display = "none"), null);
        }
        onAppStore() {
          this.wallet?.app_store &&
            d.w.openHref(this.wallet.app_store, "_blank");
        }
        onPlayStore() {
          this.wallet?.play_store &&
            d.w.openHref(this.wallet.play_store, "_blank");
        }
        onHomePage() {
          this.wallet?.homepage && d.w.openHref(this.wallet.homepage, "_blank");
        }
      };
      (rS.styles = [r_]),
        rI([(0, n.MZ)({ type: Object })], rS.prototype, "wallet", void 0),
        (rS = rI([(0, u.EM)("w3m-mobile-download-links")], rS));
      let rk = (0, u.AH)`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-wallet-image {
    width: 56px;
    height: 56px;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(${({ spacing: e }) => e["1"]} * -1);
    bottom: calc(${({ spacing: e }) => e["1"]} * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: ${({ durations: e }) => e.lg};
    transition-timing-function: ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px ${({ spacing: e }) => e["4"]};
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms ${({ easings: e }) => e["ease-out-power-2"]} both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  w3m-mobile-download-links {
    padding: 0px;
    width: 100%;
  }
`;
      var rN = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      class rT extends i.WF {
        constructor() {
          super(),
            (this.wallet = X.I.state.data?.wallet),
            (this.connector = X.I.state.data?.connector),
            (this.timeout = void 0),
            (this.secondaryBtnIcon = "refresh"),
            (this.onConnect = void 0),
            (this.onRender = void 0),
            (this.onAutoConnect = void 0),
            (this.isWalletConnect = !0),
            (this.unsubscribe = []),
            (this.imageSrc =
              l.$.getConnectorImage(this.connector) ??
              l.$.getWalletImage(this.wallet)),
            (this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet"),
            (this.isRetrying = !1),
            (this.uri = Q.x.state.wcUri),
            (this.error = Q.x.state.wcError),
            (this.ready = !1),
            (this.showRetry = !1),
            (this.label = void 0),
            (this.secondaryBtnLabel = "Try again"),
            (this.secondaryLabel = "Accept connection request in the wallet"),
            (this.isLoading = !1),
            (this.isMobile = !1),
            (this.onRetry = void 0),
            this.unsubscribe.push(
              Q.x.subscribeKey("wcUri", (e) => {
                (this.uri = e),
                  this.isRetrying &&
                    this.onRetry &&
                    ((this.isRetrying = !1), this.onConnect?.());
              }),
              Q.x.subscribeKey("wcError", (e) => (this.error = e))
            ),
            (d.w.isTelegram() || d.w.isSafari()) &&
              d.w.isIos() &&
              Q.x.state.wcUri &&
              this.onConnect?.();
        }
        firstUpdated() {
          this.onAutoConnect?.(), (this.showRetry = !this.onAutoConnect);
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e()),
            Q.x.setWcError(!1),
            clearTimeout(this.timeout);
        }
        render() {
          this.onRender?.(), this.onShowRetry();
          let e = this.error
              ? "Connection can be declined if a previous request is still active"
              : this.secondaryLabel,
            t = "";
          return (
            this.label
              ? (t = this.label)
              : ((t = `Continue in ${this.name}`),
                this.error && (t = "Connection declined")),
            (0, i.qy)`
      <wui-flex
        data-error=${(0, s.J)(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["10", "5", "5", "5"]}
        gap="6"
      >
        <wui-flex gap="2" justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${(0, s.J)(
            this.imageSrc
          )}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            color="error"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="6"> <wui-flex
          flexDirection="column"
          alignItems="center"
          gap="2"
          .padding=${["2", "0", "0", "0"]}
        >
          <wui-text align="center" variant="lg-medium" color=${
            this.error ? "error" : "primary"
          }>
            ${t}
          </wui-text>
          <wui-text align="center" variant="lg-regular" color="secondary">${e}</wui-text>
        </wui-flex>

        ${
          this.secondaryBtnLabel
            ? (0, i.qy)`
                <wui-button
                  variant="neutral-secondary"
                  size="md"
                  ?disabled=${this.isRetrying || this.isLoading}
                  @click=${this.onTryAgain.bind(this)}
                  data-testid="w3m-connecting-widget-secondary-button"
                >
                  <wui-icon
                    color="inherit"
                    slot="iconLeft"
                    name=${this.secondaryBtnIcon}
                  ></wui-icon>
                  ${this.secondaryBtnLabel}
                </wui-button>
              `
            : null
        }
      </wui-flex>

      ${
        this.isWalletConnect
          ? (0, i.qy)`
              <wui-flex .padding=${[
                "0",
                "5",
                "5",
                "5",
              ]} justifyContent="center">
                <wui-link
                  @click=${this.onCopyUri}
                  variant="secondary"
                  icon="copy"
                  data-testid="wui-link-copy"
                >
                  Copy link
                </wui-link>
              </wui-flex>
            `
          : null
      }

      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links></wui-flex>
      </wui-flex>
    `
          );
        }
        onShowRetry() {
          if (this.error && !this.showRetry) {
            this.showRetry = !0;
            let e = this.shadowRoot?.querySelector("wui-button");
            e?.animate([{ opacity: 0 }, { opacity: 1 }], {
              fill: "forwards",
              easing: "ease",
            });
          }
        }
        onTryAgain() {
          Q.x.setWcError(!1),
            this.onRetry
              ? ((this.isRetrying = !0), this.onRetry?.())
              : this.onConnect?.();
        }
        loaderTemplate() {
          let e = rC.W.state.themeVariables["--w3m-border-radius-master"],
            t = e ? parseInt(e.replace("px", ""), 10) : 4;
          return (0, i.qy)`<wui-loading-thumbnail radius=${
            9 * t
          }></wui-loading-thumbnail>`;
        }
        onCopyUri() {
          try {
            this.uri &&
              (d.w.copyToClopboard(this.uri), J.P.showSuccess("Link copied"));
          } catch {
            J.P.showError("Failed to copy");
          }
        }
      }
      (rT.styles = rk),
        rN([(0, n.wk)()], rT.prototype, "isRetrying", void 0),
        rN([(0, n.wk)()], rT.prototype, "uri", void 0),
        rN([(0, n.wk)()], rT.prototype, "error", void 0),
        rN([(0, n.wk)()], rT.prototype, "ready", void 0),
        rN([(0, n.wk)()], rT.prototype, "showRetry", void 0),
        rN([(0, n.wk)()], rT.prototype, "label", void 0),
        rN([(0, n.wk)()], rT.prototype, "secondaryBtnLabel", void 0),
        rN([(0, n.wk)()], rT.prototype, "secondaryLabel", void 0),
        rN([(0, n.wk)()], rT.prototype, "isLoading", void 0),
        rN([(0, n.MZ)({ type: Boolean })], rT.prototype, "isMobile", void 0),
        rN([(0, n.MZ)()], rT.prototype, "onRetry", void 0);
      let rO = class extends rT {
        constructor() {
          if (
            (super(),
            (this.externalViewUnsubscribe = []),
            (this.connectionsByNamespace = Q.x.getConnections(
              this.connector?.chain
            )),
            (this.hasMultipleConnections =
              this.connectionsByNamespace.length > 0),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            (this.currentActiveConnectorId =
              K.a.state.activeConnectorIds[this.connector?.chain]),
            !this.connector)
          )
            throw Error("w3m-connecting-view: No connector provided");
          let e = this.connector?.chain;
          this.isAlreadyConnected(this.connector) &&
            ((this.secondaryBtnLabel = void 0),
            (this.label = `This account is already linked, change your account in ${this.connector.name}`),
            (this.secondaryLabel = `To link a new account, open ${this.connector.name} and switch to the account you want to link`)),
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.connector.name ?? "Unknown",
                platform: "browser",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet?.order,
                view: X.I.state.view,
              },
            }),
            (this.onConnect = this.onConnectProxy.bind(this)),
            (this.onAutoConnect = this.onConnectProxy.bind(this)),
            (this.isWalletConnect = !1),
            this.externalViewUnsubscribe.push(
              K.a.subscribeKey("activeConnectorIds", (t) => {
                let r = t[e],
                  i = this.remoteFeatures?.multiWallet,
                  { redirectView: n } = X.I.state.data ?? {};
                r !== this.currentActiveConnectorId &&
                  (this.hasMultipleConnections && i
                    ? (X.I.replace("ProfileWallets"),
                      J.P.showSuccess("New Wallet Added"))
                    : n
                    ? X.I.replace(n)
                    : h.W.close());
              }),
              Q.x.subscribeKey(
                "connections",
                this.onConnectionsChange.bind(this)
              )
            );
        }
        disconnectedCallback() {
          this.externalViewUnsubscribe.forEach((e) => e());
        }
        async onConnectProxy() {
          try {
            if (((this.error = !1), this.connector)) {
              if (this.isAlreadyConnected(this.connector)) return;
              (this.connector.id === Z.o.CONNECTOR_ID.COINBASE_SDK &&
                this.error) ||
                (await Q.x.connectExternal(
                  this.connector,
                  this.connector.chain
                ),
                U.E.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  properties: {
                    method: "browser",
                    name: this.connector.name || "Unknown",
                    view: X.I.state.view,
                    walletRank: this.wallet?.order,
                  },
                }));
            }
          } catch (e) {
            e instanceof rv.A &&
            e.originalName ===
              rb.RQ.PROVIDER_RPC_ERROR_NAME.USER_REJECTED_REQUEST
              ? U.E.sendEvent({
                  type: "track",
                  event: "USER_REJECTED",
                  properties: { message: e.message },
                })
              : U.E.sendEvent({
                  type: "track",
                  event: "CONNECT_ERROR",
                  properties: { message: e?.message ?? "Unknown" },
                }),
              (this.error = !0);
          }
        }
        onConnectionsChange(e) {
          if (
            this.connector?.chain &&
            e.get(this.connector.chain) &&
            this.isAlreadyConnected(this.connector)
          ) {
            let t = e.get(this.connector.chain) ?? [],
              r = this.remoteFeatures?.multiWallet;
            if (0 === t.length) X.I.replace("Connect");
            else {
              let e = eK.b
                  .getConnectionsByConnectorId(
                    this.connectionsByNamespace,
                    this.connector.id
                  )
                  .flatMap((e) => e.accounts),
                i = eK.b
                  .getConnectionsByConnectorId(t, this.connector.id)
                  .flatMap((e) => e.accounts);
              0 === i.length
                ? this.hasMultipleConnections && r
                  ? (X.I.replace("ProfileWallets"),
                    J.P.showSuccess("Wallet deleted"))
                  : h.W.close()
                : !e.every((e) =>
                    i.some((t) => e1.y.isLowerCaseMatch(e.address, t.address))
                  ) &&
                  r &&
                  X.I.replace("ProfileWallets");
            }
          }
        }
        isAlreadyConnected(e) {
          return (
            !!e &&
            this.connectionsByNamespace.some((t) =>
              e1.y.isLowerCaseMatch(t.connectorId, e.id)
            )
          );
        }
      };
      rO = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-connecting-external-view")], rO);
      let rP = (0, i.AH)`
  wui-flex,
  wui-list-wallet {
    width: 100%;
  }
`;
      var rR = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let r$ = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.activeConnector = K.a.state.activeConnector),
            this.unsubscribe.push(
              K.a.subscribeKey(
                "activeConnector",
                (e) => (this.activeConnector = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3", "5", "5", "5"]}
        gap="5"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image
            size="lg"
            imageSrc=${(0, s.J)(l.$.getConnectorImage(this.activeConnector))}
          ></wui-wallet-image>
        </wui-flex>
        <wui-flex
          flexDirection="column"
          alignItems="center"
          gap="2"
          .padding=${["0", "3", "0", "3"]}
        >
          <wui-text variant="lg-medium" color="primary">
            Select Chain for ${this.activeConnector?.name}
          </wui-text>
          <wui-text align="center" variant="lg-regular" color="secondary"
            >Select which chain to connect to your multi chain wallet</wui-text
          >
        </wui-flex>
        <wui-flex
          flexGrow="1"
          flexDirection="column"
          alignItems="center"
          gap="2"
          .padding=${["2", "0", "2", "0"]}
        >
          ${this.networksTemplate()}
        </wui-flex>
      </wui-flex>
    `;
        }
        networksTemplate() {
          return this.activeConnector?.connectors?.map((e) =>
            e.name
              ? (0, i.qy)`
            <w3m-list-wallet
              imageSrc=${(0, s.J)(l.$.getChainImage(e.chain))}
              name=${Z.o.CHAIN_NAME_MAP[e.chain]}
              @click=${() => this.onConnector(e)}
              size="sm"
              data-testid="wui-list-chain-${e.chain}"
              rdnsId=${e.explorerWallet?.rdns}
            ></w3m-list-wallet>
          `
              : null
          );
        }
        onConnector(e) {
          let t = this.activeConnector?.connectors?.find(
              (t) => t.chain === e.chain
            ),
            r = X.I.state.data?.redirectView;
          if (!t) return void J.P.showError("Failed to find connector");
          "walletConnect" === t.id
            ? d.w.isMobile()
              ? X.I.push("AllWallets")
              : X.I.push("ConnectingWalletConnect", { redirectView: r })
            : X.I.push("ConnectingExternal", {
                connector: t,
                redirectView: r,
                wallet: this.activeConnector?.explorerWallet,
              });
        }
      };
      (r$.styles = rP),
        rR([(0, n.wk)()], r$.prototype, "activeConnector", void 0),
        (r$ = rR([(0, u.EM)("w3m-connecting-multi-chain-view")], r$));
      var rD = r(55283),
        rU = function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        };
      let rM = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.platformTabs = []),
            (this.unsubscribe = []),
            (this.platforms = []),
            (this.onSelectPlatfrom = void 0);
        }
        disconnectCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let e = this.generateTabs();
          return (0, i.qy)`
      <wui-flex justifyContent="center" .padding=${["0", "0", "4", "0"]}>
        <wui-tabs .tabs=${e} .onTabChange=${this.onTabChange.bind(
            this
          )}></wui-tabs>
      </wui-flex>
    `;
        }
        generateTabs() {
          let e = this.platforms.map((e) => {
            if ("browser" === e)
              return {
                label: "Browser",
                icon: "extension",
                platform: "browser",
              };
            if ("mobile" === e)
              return { label: "Mobile", icon: "mobile", platform: "mobile" };
            if ("qrcode" === e)
              return { label: "Mobile", icon: "mobile", platform: "qrcode" };
            if ("web" === e)
              return { label: "Webapp", icon: "browser", platform: "web" };
            if ("desktop" === e)
              return { label: "Desktop", icon: "desktop", platform: "desktop" };
            return {
              label: "Browser",
              icon: "extension",
              platform: "unsupported",
            };
          });
          return (this.platformTabs = e.map(({ platform: e }) => e)), e;
        }
        onTabChange(e) {
          let t = this.platformTabs[e];
          t && this.onSelectPlatfrom?.(t);
        }
      };
      rU([(0, n.MZ)({ type: Array })], rM.prototype, "platforms", void 0),
        rU([(0, n.MZ)()], rM.prototype, "onSelectPlatfrom", void 0),
        (rM = rU([(0, u.EM)("w3m-connecting-header")], rM));
      let rL = class extends rT {
        constructor() {
          if ((super(), !this.wallet))
            throw Error("w3m-connecting-wc-browser: No wallet provided");
          (this.onConnect = this.onConnectProxy.bind(this)),
            (this.onAutoConnect = this.onConnectProxy.bind(this)),
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.wallet.name,
                platform: "browser",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet.order,
                view: X.I.state.view,
              },
            });
        }
        async onConnectProxy() {
          try {
            this.error = !1;
            let { connectors: e } = K.a.state,
              t = e.find(
                (e) =>
                  ("ANNOUNCED" === e.type &&
                    e.info?.rdns === this.wallet?.rdns) ||
                  "INJECTED" === e.type ||
                  e.name === this.wallet?.name
              );
            if (t) await Q.x.connectExternal(t, t.chain);
            else throw Error("w3m-connecting-wc-browser: No connector found");
            h.W.close(),
              U.E.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                  method: "browser",
                  name: this.wallet?.name || "Unknown",
                  view: X.I.state.view,
                  walletRank: this.wallet?.order,
                },
              });
          } catch (e) {
            e instanceof rv.A &&
            e.originalName ===
              rb.RQ.PROVIDER_RPC_ERROR_NAME.USER_REJECTED_REQUEST
              ? U.E.sendEvent({
                  type: "track",
                  event: "USER_REJECTED",
                  properties: { message: e.message },
                })
              : U.E.sendEvent({
                  type: "track",
                  event: "CONNECT_ERROR",
                  properties: { message: e?.message ?? "Unknown" },
                }),
              (this.error = !0);
          }
        }
      };
      rL = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-connecting-wc-browser")], rL);
      let rB = class extends rT {
        constructor() {
          if ((super(), !this.wallet))
            throw Error("w3m-connecting-wc-desktop: No wallet provided");
          (this.onConnect = this.onConnectProxy.bind(this)),
            (this.onRender = this.onRenderProxy.bind(this)),
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.wallet.name,
                platform: "desktop",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet.order,
                view: X.I.state.view,
              },
            });
        }
        onRenderProxy() {
          !this.ready && this.uri && ((this.ready = !0), this.onConnect?.());
        }
        onConnectProxy() {
          if (this.wallet?.desktop_link && this.uri)
            try {
              this.error = !1;
              let { desktop_link: e, name: t } = this.wallet,
                { redirect: r, href: i } = d.w.formatNativeUrl(e, this.uri);
              Q.x.setWcLinking({ name: t, href: i }),
                Q.x.setRecentWallet(this.wallet),
                d.w.openHref(r, "_blank");
            } catch {
              this.error = !0;
            }
        }
      };
      rB = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-connecting-wc-desktop")], rB);
      var rW = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rj = class extends rT {
        constructor() {
          if (
            (super(),
            (this.btnLabelTimeout = void 0),
            (this.redirectDeeplink = void 0),
            (this.redirectUniversalLink = void 0),
            (this.target = void 0),
            (this.preferUniversalLinks =
              a.H.state.experimental_preferUniversalLinks),
            (this.isLoading = !0),
            (this.onConnect = () => {
              if (this.wallet?.mobile_link && this.uri)
                try {
                  this.error = !1;
                  let { mobile_link: e, link_mode: t, name: r } = this.wallet,
                    {
                      redirect: i,
                      redirectUniversalLink: n,
                      href: s,
                    } = d.w.formatNativeUrl(e, this.uri, t);
                  (this.redirectDeeplink = i),
                    (this.redirectUniversalLink = n),
                    (this.target = d.w.isIframe() ? "_top" : "_self"),
                    Q.x.setWcLinking({ name: r, href: s }),
                    Q.x.setRecentWallet(this.wallet),
                    this.preferUniversalLinks && this.redirectUniversalLink
                      ? d.w.openHref(this.redirectUniversalLink, this.target)
                      : d.w.openHref(this.redirectDeeplink, this.target);
                } catch (e) {
                  U.E.sendEvent({
                    type: "track",
                    event: "CONNECT_PROXY_ERROR",
                    properties: {
                      message:
                        e instanceof Error
                          ? e.message
                          : "Error parsing the deeplink",
                      uri: this.uri,
                      mobile_link: this.wallet.mobile_link,
                      name: this.wallet.name,
                    },
                  }),
                    (this.error = !0);
                }
            }),
            !this.wallet)
          )
            throw Error("w3m-connecting-wc-mobile: No wallet provided");
          (this.secondaryBtnLabel = "Open"),
            (this.secondaryLabel = G.oU.CONNECT_LABELS.MOBILE),
            (this.secondaryBtnIcon = "externalLink"),
            this.onHandleURI(),
            this.unsubscribe.push(
              Q.x.subscribeKey("wcUri", () => {
                this.onHandleURI();
              })
            ),
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.wallet.name,
                platform: "mobile",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet.order,
                view: X.I.state.view,
              },
            });
        }
        disconnectedCallback() {
          super.disconnectedCallback(), clearTimeout(this.btnLabelTimeout);
        }
        onHandleURI() {
          (this.isLoading = !this.uri),
            !this.ready && this.uri && ((this.ready = !0), this.onConnect?.());
        }
        onTryAgain() {
          Q.x.setWcError(!1), this.onConnect?.();
        }
      };
      rW([(0, n.wk)()], rj.prototype, "redirectDeeplink", void 0),
        rW([(0, n.wk)()], rj.prototype, "redirectUniversalLink", void 0),
        rW([(0, n.wk)()], rj.prototype, "target", void 0),
        rW([(0, n.wk)()], rj.prototype, "preferUniversalLinks", void 0),
        rW([(0, n.wk)()], rj.prototype, "isLoading", void 0),
        (rj = rW([(0, u.EM)("w3m-connecting-wc-mobile")], rj)),
        r(34563);
      let rF = (0, u.AH)`
  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: ${({ durations: e }) => e.xl};
    animation-timing-function: ${({ easings: e }) => e["ease-out-power-2"]};
    animation-name: fade-in;
    animation-fill-mode: forwards;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
`;
      var rH = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rq = class extends rT {
        constructor() {
          super(),
            (this.basic = !1),
            (this.forceUpdate = () => {
              this.requestUpdate();
            }),
            window.addEventListener("resize", this.forceUpdate);
        }
        firstUpdated() {
          this.basic ||
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.wallet?.name ?? "WalletConnect",
                platform: "qrcode",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet?.order,
                view: X.I.state.view,
              },
            });
        }
        disconnectedCallback() {
          super.disconnectedCallback(),
            this.unsubscribe?.forEach((e) => e()),
            window.removeEventListener("resize", this.forceUpdate);
        }
        render() {
          return (
            this.onRenderProxy(),
            (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "5", "5", "5"]}
        gap="5"
      >
        <wui-shimmer width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>
        <wui-text variant="lg-medium" color="primary"> Scan this QR Code with your phone </wui-text>
        ${this.copyTemplate()}
      </wui-flex>
      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links>
    `
          );
        }
        onRenderProxy() {
          !this.ready &&
            this.uri &&
            (this.timeout = setTimeout(() => {
              this.ready = !0;
            }, 200));
        }
        qrCodeTemplate() {
          if (!this.uri || !this.ready) return null;
          let e = this.getBoundingClientRect().width - 40,
            t = this.wallet ? this.wallet.name : void 0;
          Q.x.setWcLinking(void 0), Q.x.setRecentWallet(this.wallet);
          let r = this.uri;
          if (this.wallet?.mobile_link) {
            let { redirect: e } = d.w.formatNativeUrl(
              this.wallet?.mobile_link,
              this.uri,
              null
            );
            r = e;
          }
          return (0, i.qy)` <wui-qr-code
      size=${e}
      theme=${rC.W.state.themeMode}
      uri=${r}
      imageSrc=${(0, s.J)(l.$.getWalletImage(this.wallet))}
      color=${(0, s.J)(rC.W.state.themeVariables["--w3m-qr-color"])}
      alt=${(0, s.J)(t)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
        }
        copyTemplate() {
          let e = !this.uri || !this.ready;
          return (0, i.qy)`<wui-button
      .disabled=${e}
      @click=${this.onCopyUri}
      variant="neutral-secondary"
      size="sm"
      data-testid="copy-wc2-uri"
    >
      Copy link
      <wui-icon size="sm" color="inherit" name="copy" slot="iconRight"></wui-icon>
    </wui-button>`;
        }
      };
      (rq.styles = rF),
        rH([(0, n.MZ)({ type: Boolean })], rq.prototype, "basic", void 0),
        (rq = rH([(0, u.EM)("w3m-connecting-wc-qrcode")], rq));
      let rz = class extends i.WF {
        constructor() {
          if ((super(), (this.wallet = X.I.state.data?.wallet), !this.wallet))
            throw Error("w3m-connecting-wc-unsupported: No wallet provided");
          U.E.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet.name,
              platform: "browser",
              displayIndex: this.wallet?.display_index,
              walletRank: this.wallet?.order,
              view: X.I.state.view,
            },
          });
        }
        render() {
          return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["10", "5", "5", "5"]}
        gap="5"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${(0, s.J)(l.$.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="md-regular" color="primary">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${
        this.wallet
      }></w3m-mobile-download-links>
    `;
        }
      };
      rz = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-connecting-wc-unsupported")], rz);
      var rV = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rZ = class extends rT {
        constructor() {
          if ((super(), (this.isLoading = !0), !this.wallet))
            throw Error("w3m-connecting-wc-web: No wallet provided");
          (this.onConnect = this.onConnectProxy.bind(this)),
            (this.secondaryBtnLabel = "Open"),
            (this.secondaryLabel = G.oU.CONNECT_LABELS.MOBILE),
            (this.secondaryBtnIcon = "externalLink"),
            this.updateLoadingState(),
            this.unsubscribe.push(
              Q.x.subscribeKey("wcUri", () => {
                this.updateLoadingState();
              })
            ),
            U.E.sendEvent({
              type: "track",
              event: "SELECT_WALLET",
              properties: {
                name: this.wallet.name,
                platform: "web",
                displayIndex: this.wallet?.display_index,
                walletRank: this.wallet?.order,
                view: X.I.state.view,
              },
            });
        }
        updateLoadingState() {
          this.isLoading = !this.uri;
        }
        onConnectProxy() {
          if (this.wallet?.webapp_link && this.uri)
            try {
              this.error = !1;
              let { webapp_link: e, name: t } = this.wallet,
                { redirect: r, href: i } = d.w.formatUniversalUrl(e, this.uri);
              Q.x.setWcLinking({ name: t, href: i }),
                Q.x.setRecentWallet(this.wallet),
                d.w.openHref(r, "_blank");
            } catch {
              this.error = !0;
            }
        }
      };
      rV([(0, n.wk)()], rZ.prototype, "isLoading", void 0),
        (rZ = rV([(0, u.EM)("w3m-connecting-wc-web")], rZ));
      let rK = (0, u.AH)`
  :host([data-mobile-fullscreen='true']) {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  :host([data-mobile-fullscreen='true']) wui-ux-by-reown {
    margin-top: auto;
  }
`;
      var rG = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rJ = class extends i.WF {
        constructor() {
          super(),
            (this.wallet = X.I.state.data?.wallet),
            (this.unsubscribe = []),
            (this.platform = void 0),
            (this.platforms = []),
            (this.isSiwxEnabled = !!a.H.state.siwx),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            (this.displayBranding = !0),
            (this.basic = !1),
            this.determinePlatforms(),
            this.initializeConnection(),
            this.unsubscribe.push(
              a.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (
            a.H.state.enableMobileFullScreen &&
              this.setAttribute("data-mobile-fullscreen", "true"),
            (0, i.qy)`
      ${this.headerTemplate()}
      <div class="platform-container">${this.platformTemplate()}</div>
      ${this.reownBrandingTemplate()}
    `
          );
        }
        reownBrandingTemplate() {
          return this.remoteFeatures?.reownBranding && this.displayBranding
            ? (0, i.qy)`<wui-ux-by-reown></wui-ux-by-reown>`
            : null;
        }
        async initializeConnection(e = !1) {
          if ("browser" !== this.platform && (!a.H.state.manualWCControl || e))
            try {
              let { wcPairingExpiry: t, status: r } = Q.x.state,
                { redirectView: i } = X.I.state.data ?? {};
              if (
                e ||
                a.H.state.enableEmbedded ||
                d.w.isPairingExpired(t) ||
                "connecting" === r
              ) {
                let e = Q.x.getConnections(o.W.state.activeChain),
                  t = this.remoteFeatures?.multiWallet,
                  r = e.length > 0;
                await Q.x.connectWalletConnect({ cache: "never" }),
                  this.isSiwxEnabled ||
                    (r && t
                      ? (X.I.replace("ProfileWallets"),
                        J.P.showSuccess("New Wallet Added"))
                      : i
                      ? X.I.replace(i)
                      : h.W.close());
              }
            } catch (e) {
              if (
                e instanceof Error &&
                e.message.includes(
                  "An error occurred when attempting to switch chain"
                ) &&
                !a.H.state.enableNetworkSwitch &&
                o.W.state.activeChain
              ) {
                o.W.setActiveCaipNetwork(
                  rD.R.getUnsupportedNetwork(
                    `${o.W.state.activeChain}:${o.W.state.activeCaipNetwork?.id}`
                  )
                ),
                  o.W.showUnsupportedChainUI();
                return;
              }
              e instanceof rv.A &&
              e.originalName ===
                rb.RQ.PROVIDER_RPC_ERROR_NAME.USER_REJECTED_REQUEST
                ? U.E.sendEvent({
                    type: "track",
                    event: "USER_REJECTED",
                    properties: { message: e.message },
                  })
                : U.E.sendEvent({
                    type: "track",
                    event: "CONNECT_ERROR",
                    properties: { message: e?.message ?? "Unknown" },
                  }),
                Q.x.setWcError(!0),
                J.P.showError(e.message ?? "Connection error"),
                Q.x.resetWcConnection(),
                X.I.goBack();
            }
        }
        determinePlatforms() {
          if (!this.wallet) {
            this.platforms.push("qrcode"), (this.platform = "qrcode");
            return;
          }
          if (this.platform) return;
          let {
              mobile_link: e,
              desktop_link: t,
              webapp_link: r,
              injected: i,
              rdns: n,
            } = this.wallet,
            s = i?.map(({ injected_id: e }) => e).filter(Boolean),
            c = [...(n ? [n] : s ?? [])],
            l = !a.H.state.isUniversalProvider && c.length,
            h = Q.x.checkInstalled(c),
            u = l && h,
            p = t && !d.w.isMobile();
          u && !o.W.state.noAdapters && this.platforms.push("browser"),
            e && this.platforms.push(d.w.isMobile() ? "mobile" : "qrcode"),
            r && this.platforms.push("web"),
            p && this.platforms.push("desktop"),
            u ||
              !l ||
              o.W.state.noAdapters ||
              this.platforms.push("unsupported"),
            (this.platform = this.platforms[0]);
        }
        platformTemplate() {
          switch (this.platform) {
            case "browser":
              return (0,
              i.qy)`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
            case "web":
              return (0, i.qy)`<w3m-connecting-wc-web></w3m-connecting-wc-web>`;
            case "desktop":
              return (0, i.qy)`
          <w3m-connecting-wc-desktop .onRetry=${() =>
            this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
            case "mobile":
              return (0, i.qy)`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() =>
            this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
            case "qrcode":
              return (0,
              i.qy)`<w3m-connecting-wc-qrcode ?basic=${this.basic}></w3m-connecting-wc-qrcode>`;
            default:
              return (0,
              i.qy)`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
          }
        }
        headerTemplate() {
          return this.platforms.length > 1
            ? (0, i.qy)`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `
            : null;
        }
        async onSelectPlatform(e) {
          let t = this.shadowRoot?.querySelector("div");
          t &&
            (await t.animate([{ opacity: 1 }, { opacity: 0 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }).finished,
            (this.platform = e),
            t.animate([{ opacity: 0 }, { opacity: 1 }], {
              duration: 200,
              fill: "forwards",
              easing: "ease",
            }));
        }
      };
      (rJ.styles = rK),
        rG([(0, n.wk)()], rJ.prototype, "platform", void 0),
        rG([(0, n.wk)()], rJ.prototype, "platforms", void 0),
        rG([(0, n.wk)()], rJ.prototype, "isSiwxEnabled", void 0),
        rG([(0, n.wk)()], rJ.prototype, "remoteFeatures", void 0),
        rG(
          [(0, n.MZ)({ type: Boolean })],
          rJ.prototype,
          "displayBranding",
          void 0
        ),
        rG([(0, n.MZ)({ type: Boolean })], rJ.prototype, "basic", void 0),
        (rJ = rG([(0, u.EM)("w3m-connecting-wc-view")], rJ));
      var rY = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let rX = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.isMobile = d.w.isMobile()),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            this.unsubscribe.push(
              a.H.subscribeKey(
                "remoteFeatures",
                (e) => (this.remoteFeatures = e)
              )
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          if (this.isMobile) {
            let { featured: e, recommended: t } = td.N.state,
              { customWallets: r } = a.H.state,
              n = es.i.getRecentWallets(),
              s = e.length || t.length || r?.length || n.length;
            return (0,
            i.qy)`<wui-flex flexDirection="column" gap="2" .margin=${[
              "1",
              "3",
              "3",
              "3",
            ]}>
        ${s ? (0, i.qy)`<w3m-connector-list></w3m-connector-list>` : null}
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>`;
          }
          return (0, i.qy)`<wui-flex flexDirection="column" .padding=${[
            "0",
            "0",
            "4",
            "0",
          ]}>
        <w3m-connecting-wc-view ?basic=${!0} .displayBranding=${!1}></w3m-connecting-wc-view>
        <wui-flex flexDirection="column" .padding=${["0", "3", "0", "3"]}>
          <w3m-all-wallets-widget></w3m-all-wallets-widget>
        </wui-flex>
      </wui-flex>
      ${this.reownBrandingTemplate()} `;
        }
        reownBrandingTemplate() {
          return this.remoteFeatures?.reownBranding
            ? (0, i.qy)` <wui-flex flexDirection="column" .padding=${[
                "1",
                "0",
                "1",
                "0",
              ]}>
      <wui-ux-by-reown></wui-ux-by-reown>
    </wui-flex>`
            : null;
        }
      };
      rY([(0, n.wk)()], rX.prototype, "isMobile", void 0),
        rY([(0, n.wk)()], rX.prototype, "remoteFeatures", void 0),
        (rX = rY([(0, u.EM)("w3m-connecting-wc-basic-view")], rX));
      var rQ = r(74678);
      let r0 = (0, i.AH)`
  .continue-button-container {
    width: 100%;
  }
`;
      var r1 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let r2 = class extends i.WF {
        constructor() {
          super(...arguments), (this.loading = !1);
        }
        render() {
          return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="6"
        .padding=${["0", "0", "4", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
            d.w.openHref(rQ.T.URLS.FAQ, "_blank");
          }}
        >
          Learn more about names
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
        }
        onboardingTemplate() {
          return (0, i.qy)` <wui-flex
      flexDirection="column"
      gap="6"
      alignItems="center"
      .padding=${["0", "6", "0", "6"]}
    >
      <wui-flex gap="3" alignItems="center" justifyContent="center">
        <wui-icon-box icon="id" size="xl" iconSize="xxl" color="default"></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="3">
        <wui-text align="center" variant="lg-medium" color="primary">
          Choose your account name
        </wui-text>
        <wui-text align="center" variant="md-regular" color="primary">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </wui-text>
      </wui-flex>
    </wui-flex>`;
        }
        buttonsTemplate() {
          return (0, i.qy)`<wui-flex
      .padding=${["0", "8", "0", "8"]}
      gap="3"
      class="continue-button-container"
    >
      <wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </wui-button>
    </wui-flex>`;
        }
        handleContinue() {
          X.I.push("RegisterAccountName"),
            U.E.sendEvent({
              type: "track",
              event: "OPEN_ENS_FLOW",
              properties: {
                isSmartAccount:
                  (0, Y.lj)(o.W.state.activeChain) ===
                  en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
              },
            });
        }
      };
      (r2.styles = r0),
        r1([(0, n.wk)()], r2.prototype, "loading", void 0),
        (r2 = r1([(0, u.EM)("w3m-choose-account-name-view")], r2));
      let r3 = class extends i.WF {
        constructor() {
          super(...arguments), (this.wallet = X.I.state.data?.wallet);
        }
        render() {
          if (!this.wallet) throw Error("w3m-downloads-view");
          return (0, i.qy)`
      <wui-flex gap="2" flexDirection="column" .padding=${["3", "3", "4", "3"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
        }
        chromeTemplate() {
          return this.wallet?.chrome_store
            ? (0, i.qy)`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="md-medium" color="primary">Chrome Extension</wui-text>
    </wui-list-item>`
            : null;
        }
        iosTemplate() {
          return this.wallet?.app_store
            ? (0, i.qy)`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="md-medium" color="primary">iOS App</wui-text>
    </wui-list-item>`
            : null;
        }
        androidTemplate() {
          return this.wallet?.play_store
            ? (0, i.qy)`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="md-medium" color="primary">Android App</wui-text>
    </wui-list-item>`
            : null;
        }
        homepageTemplate() {
          return this.wallet?.homepage
            ? (0, i.qy)`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="md-medium" color="primary">Website</wui-text>
      </wui-list-item>
    `
            : null;
        }
        openStore(e) {
          e.href &&
            this.wallet &&
            (U.E.sendEvent({
              type: "track",
              event: "GET_WALLET",
              properties: {
                name: this.wallet.name,
                walletRank: this.wallet.order,
                explorerId: this.wallet.id,
                type: e.type,
              },
            }),
            d.w.openHref(e.href, "_blank"));
        }
        onChromeStore() {
          this.wallet?.chrome_store &&
            this.openStore({
              href: this.wallet.chrome_store,
              type: "chrome_store",
            });
        }
        onAppStore() {
          this.wallet?.app_store &&
            this.openStore({ href: this.wallet.app_store, type: "app_store" });
        }
        onPlayStore() {
          this.wallet?.play_store &&
            this.openStore({
              href: this.wallet.play_store,
              type: "play_store",
            });
        }
        onHomePage() {
          this.wallet?.homepage &&
            this.openStore({ href: this.wallet.homepage, type: "homepage" });
        }
      };
      r3 = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-downloads-view")], r3);
      let r5 = class extends i.WF {
        render() {
          return (0, i.qy)`
      <wui-flex flexDirection="column" .padding=${["0", "3", "3", "3"]} gap="2">
        ${this.recommendedWalletsTemplate()}
        <w3m-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          size="sm"
          @click=${() => {
            d.w.openHref(
              "https://walletconnect.com/explorer?type=wallet",
              "_blank"
            );
          }}
        ></w3m-list-wallet>
      </wui-flex>
    `;
        }
        recommendedWalletsTemplate() {
          let { recommended: e, featured: t } = td.N.state,
            { customWallets: r } = a.H.state;
          return [...t, ...(r ?? []), ...e].slice(0, 4).map(
            (e) => (0, i.qy)`
        <w3m-list-wallet
          name=${e.name ?? "Unknown"}
          tagVariant="accent"
          size="sm"
          imageSrc=${(0, s.J)(l.$.getWalletImage(e))}
          @click=${() => {
            this.onWalletClick(e);
          }}
        ></w3m-list-wallet>
      `
          );
        }
        onWalletClick(e) {
          U.E.sendEvent({
            type: "track",
            event: "GET_WALLET",
            properties: {
              name: e.name,
              walletRank: void 0,
              explorerId: e.id,
              type: "homepage",
            },
          }),
            d.w.openHref(
              e.homepage ?? "https://walletconnect.com/explorer",
              "_blank"
            );
        }
      };
      (r5 = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-get-wallet-view")], r5)),
        r(76275);
      var r4 = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let r6 = class extends i.WF {
        constructor() {
          super(...arguments), (this.data = []);
        }
        render() {
          return (0, i.qy)`
      <wui-flex flexDirection="column" alignItems="center" gap="4">
        ${this.data.map(
          (e) => (0, i.qy)`
            <wui-flex flexDirection="column" alignItems="center" gap="5">
              <wui-flex flexDirection="row" justifyContent="center" gap="1">
                ${e.images.map(
                  (e) =>
                    (0, i.qy)`<wui-visual size="sm" name=${e}></wui-visual>`
                )}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="1">
              <wui-text variant="md-regular" color="primary" align="center">${
                e.title
              }</wui-text>
              <wui-text variant="sm-regular" color="secondary" align="center"
                >${e.text}</wui-text
              >
            </wui-flex>
          `
        )}
      </wui-flex>
    `;
        }
      };
      r4([(0, n.MZ)({ type: Array })], r6.prototype, "data", void 0),
        (r6 = r4([(0, u.EM)("w3m-help-widget")], r6));
      let r8 = [
          {
            images: ["login", "profile", "lock"],
            title: "One login for all of web3",
            text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!",
          },
          {
            images: ["defi", "nft", "eth"],
            title: "A home for your digital assets",
            text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs.",
          },
          {
            images: ["browser", "noun", "dao"],
            title: "Your gateway to a new web",
            text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more.",
          },
        ],
        r9 = class extends i.WF {
          render() {
            return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        .padding=${["6", "5", "5", "5"]}
        alignItems="center"
        gap="5"
      >
        <w3m-help-widget .data=${r8}></w3m-help-widget>
        <wui-button variant="accent-primary" size="md" @click=${this.onGetWallet.bind(
          this
        )}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
          }
          onGetWallet() {
            U.E.sendEvent({ type: "track", event: "CLICK_GET_WALLET_HELP" }),
              X.I.push("GetWallet");
          }
        };
      r9 = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-what-is-a-wallet-view")], r9);
      let r7 = (0, u.AH)`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    transition: opacity ${({ durations: e }) => e.lg}
      ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;
      var ie = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let it = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.checked = tP.o.state.isLegalCheckboxChecked),
            this.unsubscribe.push(
              tP.o.subscribeKey("isLegalCheckboxChecked", (e) => {
                this.checked = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          let { termsConditionsUrl: e, privacyPolicyUrl: t } = a.H.state,
            r = a.H.state.features?.legalCheckbox,
            n = !!(e || t) && !!r,
            o = n && !this.checked;
          return (0, i.qy)`
      <w3m-legal-checkbox></w3m-legal-checkbox>
      <wui-flex
        flexDirection="column"
        .padding=${n ? ["0", "3", "3", "3"] : "3"}
        gap="2"
        class=${(0, s.J)(o ? "disabled" : void 0)}
      >
        <w3m-wallet-login-list tabIdx=${(0, s.J)(
          o ? -1 : void 0
        )}></w3m-wallet-login-list>
      </wui-flex>
    `;
        }
      };
      (it.styles = r7),
        ie([(0, n.wk)()], it.prototype, "checked", void 0),
        (it = ie([(0, u.EM)("w3m-connect-wallets-view")], it));
      let ir = (0, m.AH)`
  :host {
    display: block;
    width: 120px;
    height: 120px;
  }

  svg {
    width: 120px;
    height: 120px;
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
  }

  use {
    stroke: ${(e) => e.colors.accent100};
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`,
        ii = class extends i.WF {
          render() {
            return (0, i.qy)`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
          }
        };
      (ii.styles = [p.W5, ir]),
        (ii = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, g.E)("wui-loading-hexagon")], ii)),
        r(56975);
      let is = (0, i.AH)`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
      var ia = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let io = class extends i.WF {
        constructor() {
          super(),
            (this.network = X.I.state.data?.network),
            (this.unsubscribe = []),
            (this.showRetry = !1),
            (this.error = !1);
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        firstUpdated() {
          this.onSwitchNetwork();
        }
        render() {
          if (!this.network)
            throw Error("w3m-network-switch-view: No network provided");
          this.onShowRetry();
          let e = this.getLabel(),
            t = this.getSubLabel();
          return (0, i.qy)`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["10", "5", "10", "5"]}
        gap="7"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${(0, s.J)(l.$.getNetworkImage(this.network))}
          ></wui-network-image>

          ${
            this.error
              ? null
              : (0, i.qy)`<wui-loading-hexagon></wui-loading-hexagon>`
          }

          <wui-icon-box color="error" icon="close" size="sm"></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="2">
          <wui-text align="center" variant="h6-regular" color="primary">${e}</wui-text>
          <wui-text align="center" variant="md-regular" color="secondary">${t}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="accent-primary"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
        }
        getSubLabel() {
          let e = K.a.getConnectorId(o.W.state.activeChain);
          return K.a.getAuthConnector() && e === Z.o.CONNECTOR_ID.AUTH
            ? ""
            : this.error
            ? "Switch can be declined if chain is not supported by a wallet or previous request is still active"
            : "Accept connection request in your wallet";
        }
        getLabel() {
          let e = K.a.getConnectorId(o.W.state.activeChain);
          return K.a.getAuthConnector() && e === Z.o.CONNECTOR_ID.AUTH
            ? `Switching to ${this.network?.name ?? "Unknown"} network...`
            : this.error
            ? "Switch declined"
            : "Approve in wallet";
        }
        onShowRetry() {
          if (this.error && !this.showRetry) {
            this.showRetry = !0;
            let e = this.shadowRoot?.querySelector("wui-button");
            e?.animate([{ opacity: 0 }, { opacity: 1 }], {
              fill: "forwards",
              easing: "ease",
            });
          }
        }
        async onSwitchNetwork() {
          try {
            (this.error = !1),
              o.W.state.activeChain !== this.network?.chainNamespace &&
                o.W.setIsSwitchingNamespace(!0),
              this.network && (await o.W.switchActiveNetwork(this.network));
          } catch (e) {
            this.error = !0;
          }
        }
      };
      (io.styles = is),
        ia([(0, n.wk)()], io.prototype, "showRetry", void 0),
        ia([(0, n.wk)()], io.prototype, "error", void 0),
        (io = ia([(0, u.EM)("w3m-network-switch-view")], io));
      var ic = r(8318);
      r(40284);
      let il = (0, m.AH)`
  :host {
    width: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: ${({ spacing: e }) => e[3]};
    width: 100%;
    background-color: transparent;
    border-radius: ${({ borderRadius: e }) => e[4]};
  }

  wui-text {
    text-transform: capitalize;
  }

  @media (hover: hover) {
    button:hover:enabled {
      background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
    }
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
      var id = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ih = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.imageSrc = "ethereum"),
            (this.name = "Ethereum"),
            (this.disabled = !1);
        }
        render() {
          return (0, i.qy)`
      <button ?disabled=${this.disabled} tabindex=${(0, s.J)(this.tabIdx)}>
        <wui-flex gap="2" alignItems="center">
          <wui-image ?boxed=${!0} src=${this.imageSrc}></wui-image>
          <wui-text variant="lg-regular" color="primary">${this.name}</wui-text>
        </wui-flex>
        <wui-icon name="chevronRight" size="lg" color="default"></wui-icon>
      </button>
    `;
        }
      };
      (ih.styles = [p.W5, p.fD, il]),
        id([(0, n.MZ)()], ih.prototype, "imageSrc", void 0),
        id([(0, n.MZ)()], ih.prototype, "name", void 0),
        id([(0, n.MZ)()], ih.prototype, "tabIdx", void 0),
        id([(0, n.MZ)({ type: Boolean })], ih.prototype, "disabled", void 0),
        (ih = id([(0, g.E)("wui-list-network")], ih));
      let iu = (0, i.AH)`
  .container {
    max-height: 360px;
    overflow: auto;
  }

  .container::-webkit-scrollbar {
    display: none;
  }
`;
      var ip = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let ig = class extends i.WF {
        constructor() {
          super(),
            (this.unsubscribe = []),
            (this.network = o.W.state.activeCaipNetwork),
            (this.requestedCaipNetworks = o.W.getCaipNetworks()),
            (this.search = ""),
            (this.onDebouncedSearch = d.w.debounce((e) => {
              this.search = e;
            }, 100)),
            this.unsubscribe.push(
              c.j.subscribeNetworkImages(() => this.requestUpdate()),
              o.W.subscribeKey("activeCaipNetwork", (e) => (this.network = e)),
              o.W.subscribe(() => {
                this.requestedCaipNetworks = o.W.getAllRequestedCaipNetworks();
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      ${this.templateSearchInput()}
      <wui-flex
        class="container"
        .padding=${["0", "3", "3", "3"]}
        flexDirection="column"
        gap="2"
      >
        ${this.networksTemplate()}
      </wui-flex>
    `;
        }
        templateSearchInput() {
          return (0, i.qy)`
      <wui-flex gap="2" .padding=${["0", "3", "3", "3"]}>
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="md"
          placeholder="Search network"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
        }
        onInputChange(e) {
          this.onDebouncedSearch(e.detail);
        }
        networksTemplate() {
          let e = o.W.getAllApprovedCaipNetworkIds(),
            t = d.w.sortRequestedNetworks(e, this.requestedCaipNetworks);
          return (
            this.search
              ? (this.filteredNetworks = t?.filter((e) =>
                  e?.name?.toLowerCase().includes(this.search.toLowerCase())
                ))
              : (this.filteredNetworks = t),
            this.filteredNetworks?.map(
              (e) => (0, i.qy)`
        <wui-list-network
          .selected=${this.network?.id === e.id}
          imageSrc=${(0, s.J)(l.$.getNetworkImage(e))}
          type="network"
          name=${e.name ?? e.id}
          @click=${() => this.onSwitchNetwork(e)}
          .disabled=${this.getNetworkDisabled(e)}
          data-testid=${`w3m-network-switch-${e.name ?? e.id}`}
        ></wui-list-network>
      `
            )
          );
        }
        getNetworkDisabled(e) {
          let t = e.chainNamespace,
            r = !!o.W.getAccountData(t)?.caipAddress,
            i = o.W.getAllApprovedCaipNetworkIds(),
            n = !1 !== o.W.getNetworkProp("supportsAllNetworks", t),
            s = K.a.getConnectorId(t),
            a = K.a.getAuthConnector(),
            c = s === Z.o.CONNECTOR_ID.AUTH && a;
          return !!r && !n && !c && !i?.includes(e.caipNetworkId);
        }
        onSwitchNetwork(e) {
          ic.L.onSwitchNetwork({ network: e });
        }
      };
      (ig.styles = iu),
        ip([(0, n.wk)()], ig.prototype, "network", void 0),
        ip([(0, n.wk)()], ig.prototype, "requestedCaipNetworks", void 0),
        ip([(0, n.wk)()], ig.prototype, "filteredNetworks", void 0),
        ip([(0, n.wk)()], ig.prototype, "search", void 0),
        (ig = ip([(0, u.EM)("w3m-networks-view")], ig));
      let im = (0, u.AH)`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    border-radius: calc(
      ${({ borderRadius: e }) => e["1"]} * 9 - ${({ borderRadius: e }) =>
        e["3"]}
    );
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(
      ${({ borderRadius: e }) => e["1"]} * 9 - ${({ borderRadius: e }) =>
        e["3"]}
    );
    box-shadow: inset 0 0 0 1px ${({ tokens: e }) => e.core.glass010};
  }

  wui-icon-box {
    position: absolute;
    right: calc(${({ spacing: e }) => e["1"]} * -1);
    bottom: calc(${({ spacing: e }) => e["1"]} * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity ${({ durations: e }) => e.lg} ${({ easings: e }) =>
        e["ease-out-power-2"]},
      transform ${({ durations: e }) => e.lg}
        ${({ easings: e }) => e["ease-out-power-2"]};
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px ${({ spacing: e }) => e["4"]};
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms ${({ easings: e }) => e["ease-out-power-2"]} both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: ${({ spacing: e }) => e["01"]} ${({ spacing: e }) => e["2"]};
  }

  .capitalize {
    text-transform: capitalize;
  }
`;
      var iy = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let iw = {
          eip155: "eth",
          solana: "solana",
          bip122: "bitcoin",
          polkadot: void 0,
        },
        ib = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.unsubscribe = []),
              (this.switchToChain = X.I.state.data?.switchToChain),
              (this.caipNetwork = X.I.state.data?.network),
              (this.activeChain = o.W.state.activeChain);
          }
          firstUpdated() {
            this.unsubscribe.push(
              o.W.subscribeKey("activeChain", (e) => (this.activeChain = e))
            );
          }
          disconnectedCallback() {
            this.unsubscribe.forEach((e) => e());
          }
          render() {
            let e = this.switchToChain
              ? Z.o.CHAIN_NAME_MAP[this.switchToChain]
              : "supported";
            if (!this.switchToChain) return null;
            let t = Z.o.CHAIN_NAME_MAP[this.switchToChain];
            return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["4", "2", "2", "2"]}
        gap="4"
      >
        <wui-flex justifyContent="center" flexDirection="column" alignItems="center" gap="2">
          <wui-visual
            size="md"
            name=${(0, s.J)(iw[this.switchToChain])}
          ></wui-visual>
          <wui-flex gap="2" flexDirection="column">
            <wui-text
              data-testid=${`w3m-switch-active-chain-to-${t}`}
              variant="lg-regular"
              color="primary"
              align="center"
              >Switch to <span class="capitalize">${t}</span></wui-text
            >
            <wui-text variant="md-regular" color="secondary" align="center">
              Connected wallet doesn't support connecting to ${e} chain. You
              need to connect with a different wallet.
            </wui-text>
          </wui-flex>
          <wui-button
            data-testid="w3m-switch-active-chain-button"
            size="md"
            @click=${this.switchActiveChain.bind(this)}
            >Switch</wui-button
          >
        </wui-flex>
      </wui-flex>
    `;
          }
          async switchActiveChain() {
            this.switchToChain &&
              (o.W.setIsSwitchingNamespace(!0),
              K.a.setFilterByNamespace(this.switchToChain),
              this.caipNetwork
                ? await o.W.switchActiveNetwork(this.caipNetwork)
                : o.W.setActiveNamespace(this.switchToChain),
              X.I.reset("Connect"));
          }
        };
      (ib.styles = im),
        iy([(0, n.MZ)()], ib.prototype, "activeChain", void 0),
        (ib = iy([(0, u.EM)("w3m-switch-active-chain-view")], ib));
      let iv = [
          {
            images: ["network", "layers", "system"],
            title: "The systems nuts and bolts",
            text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services.",
          },
          {
            images: ["noun", "defiAlt", "dao"],
            title: "Designed for different uses",
            text: "Each network is designed differently, and may therefore suit certain apps and experiences.",
          },
        ],
        iC = class extends i.WF {
          render() {
            return (0, i.qy)`
      <wui-flex
        flexDirection="column"
        .padding=${["6", "5", "5", "5"]}
        alignItems="center"
        gap="5"
      >
        <w3m-help-widget .data=${iv}></w3m-help-widget>
        <wui-button
          variant="accent-primary"
          size="md"
          @click=${() => {
            d.w.openHref(
              "https://ethereum.org/en/developers/docs/networks/",
              "_blank"
            );
          }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
          }
        };
      iC = (function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      })([(0, u.EM)("w3m-what-is-a-network-view")], iC);
      let iE = (0, i.AH)`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
      var ix = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let iA = class extends i.WF {
        constructor() {
          super(),
            (this.swapUnsupportedChain = X.I.state.data?.swapUnsupportedChain),
            (this.unsubscribe = []),
            (this.disconnecting = !1),
            (this.remoteFeatures = a.H.state.remoteFeatures),
            this.unsubscribe.push(
              c.j.subscribeNetworkImages(() => this.requestUpdate()),
              a.H.subscribeKey("remoteFeatures", (e) => {
                this.remoteFeatures = e;
              })
            );
        }
        disconnectedCallback() {
          this.unsubscribe.forEach((e) => e());
        }
        render() {
          return (0, i.qy)`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["3", "5", "2", "5"]}
          alignItems="center"
          gap="5"
        >
          ${this.descriptionTemplate()}
        </wui-flex>

        <wui-flex flexDirection="column" padding="3" gap="2"> ${this.networksTemplate()} </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="3" gap="2">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="signOut"
            ?chevron=${!1}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="md-medium" color="secondary">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
        }
        descriptionTemplate() {
          return this.swapUnsupportedChain
            ? (0, i.qy)`
        <wui-text variant="sm-regular" color="secondary" align="center">
          The swap feature doesnt support your current network. Switch to an available option to
          continue.
        </wui-text>
      `
            : (0, i.qy)`
      <wui-text variant="sm-regular" color="secondary" align="center">
        This app doesnt support your current network. Switch to an available option to continue.
      </wui-text>
    `;
        }
        networksTemplate() {
          let e = o.W.getAllRequestedCaipNetworks(),
            t = o.W.getAllApprovedCaipNetworkIds(),
            r = d.w.sortRequestedNetworks(t, e);
          return (
            this.swapUnsupportedChain
              ? r.filter((e) =>
                  G.oU.SWAP_SUPPORTED_NETWORKS.includes(e.caipNetworkId)
                )
              : r
          ).map(
            (e) => (0, i.qy)`
        <wui-list-network
          imageSrc=${(0, s.J)(l.$.getNetworkImage(e))}
          name=${e.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(e)}
        >
        </wui-list-network>
      `
          );
        }
        async onDisconnect() {
          try {
            this.disconnecting = !0;
            let e = o.W.state.activeChain,
              t = Q.x.getConnections(e).length > 0,
              r = e && K.a.state.activeConnectorIds[e],
              i = this.remoteFeatures?.multiWallet;
            await Q.x.disconnect(i ? { id: r, namespace: e } : {}),
              t &&
                i &&
                (X.I.push("ProfileWallets"), J.P.showSuccess("Wallet deleted"));
          } catch {
            U.E.sendEvent({
              type: "track",
              event: "DISCONNECT_ERROR",
              properties: { message: "Failed to disconnect" },
            }),
              J.P.showError("Failed to disconnect");
          } finally {
            this.disconnecting = !1;
          }
        }
        async onSwitchNetwork(e) {
          let t = o.W.getActiveCaipAddress(),
            r = o.W.getAllApprovedCaipNetworkIds(),
            i =
              (o.W.getNetworkProp("supportsAllNetworks", e.chainNamespace),
              X.I.state.data);
          t
            ? r?.includes(e.caipNetworkId)
              ? await o.W.switchActiveNetwork(e)
              : X.I.push("SwitchNetwork", { ...i, network: e })
            : t || (o.W.setActiveCaipNetwork(e), X.I.push("Connect"));
        }
      };
      (iA.styles = iE),
        ix([(0, n.wk)()], iA.prototype, "disconnecting", void 0),
        ix([(0, n.wk)()], iA.prototype, "remoteFeatures", void 0),
        (iA = ix([(0, u.EM)("w3m-unsupported-chain-view")], iA));
      let i_ = (0, m.AH)`
  wui-flex {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ spacing: e }) => e[2]};
    border-radius: ${({ borderRadius: e }) => e[4]};
    padding: ${({ spacing: e }) => e[3]};
  }

  /* -- Types --------------------------------------------------------- */
  wui-flex[data-type='info'] {
    color: ${({ tokens: e }) => e.theme.textSecondary};
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  wui-flex[data-type='success'] {
    color: ${({ tokens: e }) => e.core.textSuccess};
    background-color: ${({ tokens: e }) => e.core.backgroundSuccess};
  }

  wui-flex[data-type='error'] {
    color: ${({ tokens: e }) => e.core.textError};
    background-color: ${({ tokens: e }) => e.core.backgroundError};
  }

  wui-flex[data-type='warning'] {
    color: ${({ tokens: e }) => e.core.textWarning};
    background-color: ${({ tokens: e }) => e.core.backgroundWarning};
  }

  wui-flex[data-type='info'] wui-icon-box {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  wui-flex[data-type='success'] wui-icon-box {
    background-color: ${({ tokens: e }) => e.core.backgroundSuccess};
  }

  wui-flex[data-type='error'] wui-icon-box {
    background-color: ${({ tokens: e }) => e.core.backgroundError};
  }

  wui-flex[data-type='warning'] wui-icon-box {
    background-color: ${({ tokens: e }) => e.core.backgroundWarning};
  }

  wui-text {
    flex: 1;
  }
`;
      var iI = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let iS = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.icon = "externalLink"),
            (this.text = ""),
            (this.type = "info");
        }
        render() {
          return (0, i.qy)`
      <wui-flex alignItems="center" data-type=${this.type}>
        <wui-icon-box size="sm" color="inherit" icon=${this.icon}></wui-icon-box>
        <wui-text variant="md-regular" color="inherit">${this.text}</wui-text>
      </wui-flex>
    `;
        }
      };
      (iS.styles = [p.W5, p.fD, i_]),
        iI([(0, n.MZ)()], iS.prototype, "icon", void 0),
        iI([(0, n.MZ)()], iS.prototype, "text", void 0),
        iI([(0, n.MZ)()], iS.prototype, "type", void 0),
        (iS = iI([(0, g.E)("wui-banner")], iS));
      let ik = (0, i.AH)`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`,
        iN = class extends i.WF {
          constructor() {
            super(), (this.unsubscribe = []);
          }
          disconnectedCallback() {
            this.unsubscribe.forEach((e) => e());
          }
          render() {
            return (0, i.qy)` <wui-flex flexDirection="column" .padding=${[
              "2",
              "3",
              "3",
              "3",
            ]} gap="2">
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
          }
          networkTemplate() {
            let e = o.W.getAllRequestedCaipNetworks(),
              t = o.W.getAllApprovedCaipNetworkIds(),
              r = o.W.state.activeCaipNetwork,
              n = o.W.checkIfSmartAccountEnabled(),
              a = d.w.sortRequestedNetworks(t, e);
            if (
              n &&
              (0, Y.lj)(r?.chainNamespace) === en.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
            ) {
              if (!r) return null;
              a = [r];
            }
            return a
              .filter((e) => e.chainNamespace === r?.chainNamespace)
              .map(
                (e) => (0, i.qy)`
        <wui-list-network
          imageSrc=${(0, s.J)(l.$.getNetworkImage(e))}
          name=${e.name ?? "Unknown"}
          ?transparent=${!0}
        >
        </wui-list-network>
      `
              );
          }
        };
      (iN.styles = ik),
        (iN = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, u.EM)("w3m-wallet-compatible-networks-view")], iN));
      var iT = r(67243);
      let iO = (0, m.AH)`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 56px;
    height: 56px;
    box-shadow: 0 0 0 8px ${({ tokens: e }) => e.theme.borderPrimary};
    border-radius: ${({ borderRadius: e }) => e[4]};
    overflow: hidden;
  }

  :host([data-border-radius-full='true']) {
    border-radius: 50px;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
      var iP = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let iR = class extends i.WF {
        render() {
          return (
            (this.dataset.borderRadiusFull = this.borderRadiusFull
              ? "true"
              : "false"),
            (0, i.qy)`${this.templateVisual()}`
          );
        }
        templateVisual() {
          return this.imageSrc
            ? (0, i.qy)`<wui-image src=${this.imageSrc} alt=${
                this.alt ?? ""
              }></wui-image>`
            : (0, i.qy)`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="wallet"
    ></wui-icon>`;
        }
      };
      (iR.styles = [p.W5, iO]),
        iP([(0, n.MZ)()], iR.prototype, "imageSrc", void 0),
        iP([(0, n.MZ)()], iR.prototype, "alt", void 0),
        iP(
          [(0, n.MZ)({ type: Boolean })],
          iR.prototype,
          "borderRadiusFull",
          void 0
        ),
        (iR = iP([(0, g.E)("wui-visual-thumbnail")], iR));
      let i$ = (0, u.AH)`
  :host {
    display: flex;
    justify-content: center;
    gap: ${({ spacing: e }) => e["4"]};
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`,
        iD = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.dappImageUrl = a.H.state.metadata?.icons),
              (this.walletImageUrl =
                o.W.getAccountData()?.connectedWalletInfo?.icon);
          }
          firstUpdated() {
            let e = this.shadowRoot?.querySelectorAll("wui-visual-thumbnail");
            e?.[0] && this.createAnimation(e[0], "translate(18px)"),
              e?.[1] && this.createAnimation(e[1], "translate(-18px)");
          }
          render() {
            return (0, i.qy)`
      <wui-visual-thumbnail
        ?borderRadiusFull=${!0}
        .imageSrc=${this.dappImageUrl?.[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${
        this.walletImageUrl
      }></wui-visual-thumbnail>
    `;
          }
          createAnimation(e, t) {
            e.animate([{ transform: "translateX(0px)" }, { transform: t }], {
              duration: 1600,
              easing: "cubic-bezier(0.56, 0, 0.48, 1)",
              direction: "alternate",
              iterations: 1 / 0,
            });
          }
        };
      (iD.styles = i$),
        (iD = (function (e, t, r, i) {
          var n,
            s = arguments.length,
            a =
              s < 3
                ? t
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(t, r))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            a = Reflect.decorate(e, t, r, i);
          else
            for (var o = e.length - 1; o >= 0; o--)
              (n = e[o]) &&
                (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
          return s > 3 && a && Object.defineProperty(t, r, a), a;
        })([(0, u.EM)("w3m-siwx-sign-message-thumbnails")], iD));
      var iU = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let iM = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.dappName = a.H.state.metadata?.name),
            (this.isCancelling = !1),
            (this.isSigning = !1);
        }
        render() {
          return (0, i.qy)`
      <wui-flex justifyContent="center" .padding=${["8", "0", "6", "0"]}>
        <w3m-siwx-sign-message-thumbnails></w3m-siwx-sign-message-thumbnails>
      </wui-flex>
      <wui-flex .padding=${[
        "0",
        "20",
        "5",
        "20",
      ]} gap="3" justifyContent="space-between">
        <wui-text variant="lg-medium" align="center" color="primary"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${[
        "0",
        "10",
        "4",
        "10",
      ]} gap="3" justifyContent="space-between">
        <wui-text variant="md-regular" align="center" color="secondary"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${[
        "4",
        "5",
        "5",
        "5",
      ]} gap="3" justifyContent="space-between">
        <wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="neutral-secondary"
          ?loading=${this.isCancelling}
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          ${this.isCancelling ? "Cancelling..." : "Cancel"}
        </wui-button>
        <wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="neutral-primary"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `;
        }
        async onSign() {
          this.isSigning = !0;
          try {
            await iT.U.requestSignMessage();
          } catch (e) {
            if (e instanceof Error && e.message.includes("OTP is required")) {
              J.P.showError({
                message:
                  "Something went wrong. We need to verify your account again.",
              }),
                X.I.replace("DataCapture");
              return;
            }
            throw e;
          } finally {
            this.isSigning = !1;
          }
        }
        async onCancel() {
          (this.isCancelling = !0),
            await iT.U.cancelSignMessage().finally(
              () => (this.isCancelling = !1)
            );
        }
      };
      iU([(0, n.wk)()], iM.prototype, "isCancelling", void 0),
        iU([(0, n.wk)()], iM.prototype, "isSigning", void 0),
        (iM = iU([(0, u.EM)("w3m-siwx-sign-message-view")], iM));
    },
    83804: (e, t, r) => {
      "use strict";
      r.d(t, {
        D8t: () => n,
        E3H: () => $,
        X5s: () => z,
        NBY: () => D,
        xHY: () => F,
        vRv: () => U,
        rCZ: () => M.r,
        Rry: () => L,
        n1: () => B,
        tWt: () => H,
        Rn0: () => q,
        TqE: () => W,
        K53: () => j,
      });
      var i = r(91053);
      let n = (0, i.x)({
        id: 42161,
        name: "Arbitrum One",
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        blockTime: 250,
        rpcUrls: { default: { http: ["https://arb1.arbitrum.io/rpc"] } },
        blockExplorers: {
          default: {
            name: "Arbiscan",
            url: "https://arbiscan.io",
            apiUrl: "https://api.arbiscan.io/api",
          },
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7654707,
          },
        },
      });
      var s = r(11914),
        a = r(61936),
        o = r(15885),
        c = r(90523);
      let l = {
        block: (0, a.R)({
          format: (e) => ({
            transactions: e.transactions?.map((e) => {
              if ("string" == typeof e) return e;
              let t = (0, o.uP)(e);
              return (
                "0x7e" === t.typeHex &&
                  ((t.isSystemTx = e.isSystemTx),
                  (t.mint = e.mint ? (0, s.uU)(e.mint) : void 0),
                  (t.sourceHash = e.sourceHash),
                  (t.type = "deposit")),
                t
              );
            }),
            stateRoot: e.stateRoot,
          }),
        }),
        transaction: (0, o.gU)({
          format(e) {
            let t = {};
            return (
              "0x7e" === e.type &&
                ((t.isSystemTx = e.isSystemTx),
                (t.mint = e.mint ? (0, s.uU)(e.mint) : void 0),
                (t.sourceHash = e.sourceHash),
                (t.type = "deposit")),
              t
            );
          },
        }),
        transactionReceipt: (0, c.WB)({
          format: (e) => ({
            l1GasPrice: e.l1GasPrice ? (0, s.uU)(e.l1GasPrice) : null,
            l1GasUsed: e.l1GasUsed ? (0, s.uU)(e.l1GasUsed) : null,
            l1Fee: e.l1Fee ? (0, s.uU)(e.l1Fee) : null,
            l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null,
          }),
        }),
      };
      var d = r(76115),
        h = r(24784),
        u = r(40290),
        p = r(34561),
        f = r(88210),
        g = r(50879),
        m = r(30718),
        y = r(17679),
        w = r(46333),
        b = r(35766),
        v = r(42438),
        C = r(19781),
        E = r(44016),
        x = r(13933),
        A = r(5082),
        _ = r(29454),
        I = r(88737),
        S = r(16871),
        k = r(44352);
      function N(e) {
        let { chainId: t, maxPriorityFeePerGas: r, maxFeePerGas: i, to: n } = e;
        if (t <= 0) throw new _.qD({ chainId: t });
        if (n && !(0, h.P)(n)) throw new d.M({ address: n });
        if (i && i > E.Ao) throw new I.BG({ maxFeePerGas: i });
        if (r && i && r > i)
          throw new I.lN({ maxFeePerGas: i, maxPriorityFeePerGas: r });
      }
      var T = r(90656);
      function O(e) {
        if (!e || 0 === e.length) return [];
        let t = [];
        for (let r = 0; r < e.length; r++) {
          let { address: i, storageKeys: n } = e[r];
          for (let e = 0; e < n.length; e++)
            if (n[e].length - 2 != 64) throw new g.fZ({ storageKey: n[e] });
          if (!(0, h.P)(i, { strict: !1 })) throw new d.M({ address: i });
          t.push([i, n]);
        }
        return t;
      }
      function P(e, t) {
        let r = t ?? e,
          { v: i, yParity: n } = r;
        if (void 0 === r.r || void 0 === r.s || (void 0 === i && void 0 === n))
          return [];
        let s = (0, v.B)(r.r),
          a = (0, v.B)(r.s);
        return [
          "number" == typeof n
            ? n
              ? (0, p.cK)(1)
              : "0x"
            : 0n === i
            ? "0x"
            : 1n === i
            ? (0, p.cK)(1)
            : 27n === i
            ? "0x"
            : (0, p.cK)(1),
          "0x00" === s ? "0x" : s,
          "0x00" === a ? "0x" : a,
        ];
      }
      let R = {
          blockTime: 2e3,
          contracts: {
            gasPriceOracle: {
              address: "0x420000000000000000000000000000000000000F",
            },
            l1Block: { address: "0x4200000000000000000000000000000000000015" },
            l2CrossDomainMessenger: {
              address: "0x4200000000000000000000000000000000000007",
            },
            l2Erc721Bridge: {
              address: "0x4200000000000000000000000000000000000014",
            },
            l2StandardBridge: {
              address: "0x4200000000000000000000000000000000000010",
            },
            l2ToL1MessagePasser: {
              address: "0x4200000000000000000000000000000000000016",
            },
          },
          formatters: l,
          serializers: {
            transaction: function (e, t) {
              var r;
              if ("deposit" === (r = e).type || void 0 !== r.sourceHash) {
                var i = e,
                  n = i;
                let { from: t, to: r } = n;
                if (t && !(0, h.P)(t)) throw new d.M({ address: t });
                if (r && !(0, h.P)(r)) throw new d.M({ address: r });
                let {
                    sourceHash: s,
                    data: a,
                    from: o,
                    gas: c,
                    isSystemTx: l,
                    mint: g,
                    to: m,
                    value: y,
                  } = i,
                  w = [
                    s,
                    o,
                    m ?? "0x",
                    g ? (0, p.nj)(g) : "0x",
                    y ? (0, p.nj)(y) : "0x",
                    c ? (0, p.nj)(c) : "0x",
                    l ? "0x1" : "0x",
                    a ?? "0x",
                  ];
                return (0, u.aP)(["0x7e", (0, f.EQ)(w)]);
              }
              let a = (0, T.L)(e);
              return "eip1559" === a
                ? (function (e, t) {
                    let {
                      chainId: r,
                      gas: i,
                      nonce: n,
                      to: s,
                      value: a,
                      maxFeePerGas: o,
                      maxPriorityFeePerGas: c,
                      accessList: l,
                      data: d,
                    } = e;
                    N(e);
                    let h = O(l),
                      g = [
                        (0, p.cK)(r),
                        n ? (0, p.cK)(n) : "0x",
                        c ? (0, p.cK)(c) : "0x",
                        o ? (0, p.cK)(o) : "0x",
                        i ? (0, p.cK)(i) : "0x",
                        s ?? "0x",
                        a ? (0, p.cK)(a) : "0x",
                        d ?? "0x",
                        h,
                        ...P(e, t),
                      ];
                    return (0, u.aP)(["0x02", (0, f.EQ)(g)]);
                  })(e, t)
                : "eip2930" === a
                ? (function (e, t) {
                    let {
                        chainId: r,
                        gas: i,
                        data: n,
                        nonce: s,
                        to: a,
                        value: o,
                        accessList: c,
                        gasPrice: l,
                      } = e,
                      {
                        chainId: g,
                        maxPriorityFeePerGas: m,
                        gasPrice: y,
                        maxFeePerGas: w,
                        to: b,
                      } = e;
                    if (g <= 0) throw new _.qD({ chainId: g });
                    if (b && !(0, h.P)(b)) throw new d.M({ address: b });
                    if (m || w)
                      throw new x.C(
                        "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute."
                      );
                    if (y && y > E.Ao) throw new I.BG({ maxFeePerGas: y });
                    let v = O(c),
                      C = [
                        (0, p.cK)(r),
                        s ? (0, p.cK)(s) : "0x",
                        l ? (0, p.cK)(l) : "0x",
                        i ? (0, p.cK)(i) : "0x",
                        a ?? "0x",
                        o ? (0, p.cK)(o) : "0x",
                        n ?? "0x",
                        v,
                        ...P(e, t),
                      ];
                    return (0, u.aP)(["0x01", (0, f.EQ)(C)]);
                  })(e, t)
                : "eip4844" === a
                ? (function (e, t) {
                    let {
                        chainId: r,
                        gas: i,
                        nonce: n,
                        to: a,
                        value: o,
                        maxFeePerBlobGas: c,
                        maxFeePerGas: l,
                        maxPriorityFeePerGas: d,
                        accessList: h,
                        data: g,
                      } = e,
                      { blobVersionedHashes: v } = e;
                    if (v) {
                      if (0 === v.length) throw new A.zF();
                      for (let e of v) {
                        let t = (0, S.E)(e),
                          r = (0, s.ME)((0, k.di)(e, 0, 1));
                        if (32 !== t) throw new A.uP({ hash: e, size: t });
                        if (r !== C.E) throw new A.PK({ hash: e, version: r });
                      }
                    }
                    N(e);
                    let E = e.blobVersionedHashes,
                      x = e.sidecars;
                    if (e.blobs && (void 0 === E || void 0 === x)) {
                      let t =
                          "string" == typeof e.blobs[0]
                            ? e.blobs
                            : e.blobs.map((e) => (0, p.My)(e)),
                        r = e.kzg,
                        i = (0, m.S)({ blobs: t, kzg: r });
                      if (
                        (void 0 === E && (E = (0, w.d)({ commitments: i })),
                        void 0 === x)
                      ) {
                        let e = (0, y.t)({ blobs: t, commitments: i, kzg: r });
                        x = (0, b.T)({ blobs: t, commitments: i, proofs: e });
                      }
                    }
                    let _ = O(h),
                      I = [
                        (0, p.cK)(r),
                        n ? (0, p.cK)(n) : "0x",
                        d ? (0, p.cK)(d) : "0x",
                        l ? (0, p.cK)(l) : "0x",
                        i ? (0, p.cK)(i) : "0x",
                        a ?? "0x",
                        o ? (0, p.cK)(o) : "0x",
                        g ?? "0x",
                        _,
                        c ? (0, p.cK)(c) : "0x",
                        E ?? [],
                        ...P(e, t),
                      ],
                      T = [],
                      R = [],
                      $ = [];
                    if (x)
                      for (let e = 0; e < x.length; e++) {
                        let { blob: t, commitment: r, proof: i } = x[e];
                        T.push(t), R.push(r), $.push(i);
                      }
                    return (0, u.aP)([
                      "0x03",
                      x ? (0, f.EQ)([I, T, R, $]) : (0, f.EQ)(I),
                    ]);
                  })(e, t)
                : "eip7702" === a
                ? (function (e, t) {
                    let {
                        authorizationList: r,
                        chainId: i,
                        gas: n,
                        nonce: s,
                        to: a,
                        value: o,
                        maxFeePerGas: c,
                        maxPriorityFeePerGas: l,
                        accessList: g,
                        data: m,
                      } = e,
                      { authorizationList: y } = e;
                    if (y)
                      for (let e of y) {
                        let { chainId: t } = e,
                          r = e.address;
                        if (!(0, h.P)(r)) throw new d.M({ address: r });
                        if (t < 0) throw new _.qD({ chainId: t });
                      }
                    N(e);
                    let w = O(g),
                      b = (function (e) {
                        if (!e || 0 === e.length) return [];
                        let t = [];
                        for (let r of e) {
                          let { chainId: e, nonce: i, ...n } = r,
                            s = r.address;
                          t.push([
                            e ? (0, p.nj)(e) : "0x",
                            s,
                            i ? (0, p.nj)(i) : "0x",
                            ...P({}, n),
                          ]);
                        }
                        return t;
                      })(r);
                    return (0, u.aP)([
                      "0x04",
                      (0, f.EQ)([
                        (0, p.cK)(i),
                        s ? (0, p.cK)(s) : "0x",
                        l ? (0, p.cK)(l) : "0x",
                        c ? (0, p.cK)(c) : "0x",
                        n ? (0, p.cK)(n) : "0x",
                        a ?? "0x",
                        o ? (0, p.cK)(o) : "0x",
                        m ?? "0x",
                        w,
                        b,
                        ...P(e, t),
                      ]),
                    ]);
                  })(e, t)
                : (function (e, t) {
                    let {
                        chainId: r = 0,
                        gas: i,
                        data: n,
                        nonce: s,
                        to: a,
                        value: o,
                        gasPrice: c,
                      } = e,
                      {
                        chainId: l,
                        maxPriorityFeePerGas: u,
                        gasPrice: m,
                        maxFeePerGas: y,
                        to: w,
                      } = e;
                    if (w && !(0, h.P)(w)) throw new d.M({ address: w });
                    if (void 0 !== l && l <= 0) throw new _.qD({ chainId: l });
                    if (u || y)
                      throw new x.C(
                        "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute."
                      );
                    if (m && m > E.Ao) throw new I.BG({ maxFeePerGas: m });
                    let b = [
                      s ? (0, p.cK)(s) : "0x",
                      c ? (0, p.cK)(c) : "0x",
                      i ? (0, p.cK)(i) : "0x",
                      a ?? "0x",
                      o ? (0, p.cK)(o) : "0x",
                      n ?? "0x",
                    ];
                    if (t) {
                      let e = (() => {
                          if (t.v >= 35n)
                            return (t.v - 35n) / 2n > 0
                              ? t.v
                              : 27n + (35n === t.v ? 0n : 1n);
                          if (r > 0)
                            return BigInt(2 * r) + BigInt(35n + t.v - 27n);
                          let e = 27n + (27n === t.v ? 0n : 1n);
                          if (t.v !== e) throw new g.zW({ v: t.v });
                          return e;
                        })(),
                        i = (0, v.B)(t.r),
                        n = (0, v.B)(t.s);
                      b = [
                        ...b,
                        (0, p.cK)(e),
                        "0x00" === i ? "0x" : i,
                        "0x00" === n ? "0x" : n,
                      ];
                    } else r > 0 && (b = [...b, (0, p.cK)(r), "0x", "0x"]);
                    return (0, f.EQ)(b);
                  })(e, t);
            },
          },
        },
        $ = (0, i.x)({
          ...R,
          id: 8453,
          name: "Base",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://mainnet.base.org"] } },
          blockExplorers: {
            default: {
              name: "Basescan",
              url: "https://basescan.org",
              apiUrl: "https://api.basescan.org/api",
            },
          },
          contracts: {
            ...R.contracts,
            disputeGameFactory: {
              1: { address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e" },
            },
            l2OutputOracle: {
              1: { address: "0x56315b90c40730925ec5485cf004d835058518A0" },
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 5022,
            },
            portal: {
              1: {
                address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
                blockCreated: 0x10ac19f,
              },
            },
            l1StandardBridge: {
              1: {
                address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
                blockCreated: 0x10ac19f,
              },
            },
          },
          sourceId: 1,
        });
      ({
        ...$,
        experimental_preconfirmationTime: 200,
        rpcUrls: { default: { http: ["https://mainnet-preconf.base.org"] } },
      });
      let D = (0, i.x)({
          id: 56,
          name: "BNB Smart Chain",
          blockTime: 750,
          nativeCurrency: { decimals: 18, name: "BNB", symbol: "BNB" },
          rpcUrls: { default: { http: ["https://56.rpc.thirdweb.com"] } },
          blockExplorers: {
            default: {
              name: "BscScan",
              url: "https://bscscan.com",
              apiUrl: "https://api.bscscan.com/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 0xf2f12c,
            },
          },
        }),
        U = (0, i.x)({
          id: 2e3,
          name: "Dogechain",
          nativeCurrency: {
            decimals: 18,
            name: "Wrapped Dogecoin",
            symbol: "WDOGE",
          },
          rpcUrls: { default: { http: ["https://rpc.dogechain.dog"] } },
          blockExplorers: {
            default: {
              name: "DogeChainExplorer",
              url: "https://explorer.dogechain.dog",
              apiUrl: "https://explorer.dogechain.dog/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
              blockCreated: 0x183545f,
            },
          },
        });
      var M = r(33791);
      let L = (0, i.x)({
          ...R,
          id: 10,
          name: "OP Mainnet",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://mainnet.optimism.io"] } },
          blockExplorers: {
            default: {
              name: "Optimism Explorer",
              url: "https://optimistic.etherscan.io",
              apiUrl: "https://api-optimistic.etherscan.io/api",
            },
          },
          contracts: {
            ...R.contracts,
            disputeGameFactory: {
              1: { address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9" },
            },
            l2OutputOracle: {
              1: { address: "0xdfe97868233d1aa22e815a266982f2cf17685a27" },
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 4286263,
            },
            portal: {
              1: { address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed" },
            },
            l1StandardBridge: {
              1: { address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1" },
            },
          },
          sourceId: 1,
        }),
        B = (0, i.x)({
          id: 137,
          name: "Polygon",
          nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
          rpcUrls: { default: { http: ["https://polygon-rpc.com"] } },
          blockExplorers: {
            default: {
              name: "PolygonScan",
              url: "https://polygonscan.com",
              apiUrl: "https://api.polygonscan.com/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 0x18938b0,
            },
          },
        }),
        W = (0, i.x)({
          id: 146,
          name: "Sonic",
          blockTime: 630,
          nativeCurrency: { decimals: 18, name: "Sonic", symbol: "S" },
          rpcUrls: { default: { http: ["https://rpc.soniclabs.com"] } },
          blockExplorers: {
            default: { name: "Sonic Explorer", url: "https://sonicscan.org" },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 60,
            },
          },
          testnet: !1,
        }),
        j = (0, i.x)({
          id: 0x2b6653dc,
          name: "Tron",
          nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
          rpcUrls: { default: { http: ["https://api.trongrid.io/jsonrpc"] } },
          blockExplorers: {
            default: {
              name: "Tronscan",
              url: "https://tronscan.org",
              apiUrl: "https://apilist.tronscanapi.com/api",
            },
          },
        });
      function F(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      let H = F({
          id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          name: "Solana",
          network: "solana-mainnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !1,
          chainNamespace: "solana",
          caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
        }),
        q = F({
          id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          name: "Solana Devnet",
          network: "solana-devnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !0,
          chainNamespace: "solana",
          caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
        });
      F({
        id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
        name: "Solana Testnet",
        network: "solana-testnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !0,
        chainNamespace: "solana",
        caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      });
      let z = F({
        id: "000000000019d6689c085ae165831e93",
        caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
        chainNamespace: "bip122",
        name: "Bitcoin",
        nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
      });
      F({
        id: "000000000933ea01ad0ee984209779ba",
        caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
        chainNamespace: "bip122",
        name: "Bitcoin Testnet",
        nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        testnet: !0,
      }),
        F({
          id: "00000008819873e925422c1ff0f99f7c",
          caipNetworkId: "bip122:00000008819873e925422c1ff0f99f7c",
          chainNamespace: "bip122",
          name: "Bitcoin Signet",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          testnet: !0,
        });
    },
    83941: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => c });
      var i = r(44826),
        n = r(93481),
        s = r(97418),
        a = r(30982),
        o = r(71305);
      let c = {
        async getTokenList(e) {
          let t = await i.T.fetchSwapTokens({ chainId: e });
          return (
            t?.tokens?.map((e) => ({
              ...e,
              eip2612: !1,
              quantity: { decimals: "0", numeric: "0" },
              price: 0,
              value: 0,
            })) || []
          );
        },
        async fetchGasPrice() {
          let e = n.W.state.activeCaipNetwork;
          if (!e) return null;
          try {
            if ("solana" !== e.chainNamespace)
              return await i.T.fetchGasPrice({ chainId: e.caipNetworkId });
            {
              let e = (
                await s.x?.estimateGas({ chainNamespace: "solana" })
              )?.toString();
              return { standard: e, fast: e, instant: e };
            }
          } catch {
            return null;
          }
        },
        async fetchSwapAllowance({
          tokenAddress: e,
          userAddress: t,
          sourceTokenAmount: r,
          sourceTokenDecimals: n,
        }) {
          let a = await i.T.fetchSwapAllowance({
            tokenAddress: e,
            userAddress: t,
          });
          if (a?.allowance && r && n) {
            let e = s.x.parseUnits(r, n) || 0;
            return BigInt(a.allowance) >= e;
          }
          return !1;
        },
        async getMyTokensWithBalance(e) {
          let t = await a.Z.getMyTokensWithBalance(e);
          return (
            n.W.setAccountProp("tokenBalance", t, n.W.state.activeChain),
            this.mapBalancesToSwapTokens(t)
          );
        },
        mapBalancesToSwapTokens: (e) =>
          e?.map((e) => ({
            ...e,
            address: e?.address ? e.address : (0, o.K1)(),
            decimals: parseInt(e.quantity.decimals, 10),
            logoUri: e.iconUrl,
            eip2612: !1,
          })) || [],
        async handleSwapError(e) {
          try {
            let t = e?.cause;
            if (!t?.json) return;
            let r = await t.json(),
              i = r?.reasons?.[0]?.description;
            if (i?.includes("insufficient liquidity"))
              return "Insufficient liquidity";
            return;
          } catch {
            return;
          }
        },
      };
    },
    84042: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(78964);
      r(99691);
      var a = r(71084),
        o = r(47327),
        c = r(20296);
      let l = (0, c.AH)`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    border-radius: ${({ borderRadius: e }) => e[2]};
    padding: ${({ spacing: e }) => e[1]} !important;
    background-color: ${({ tokens: e }) => e.theme.backgroundPrimary};
    position: relative;
  }

  :host([data-padding='2']) {
    padding: ${({ spacing: e }) => e[2]} !important;
  }

  :host:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: ${({ borderRadius: e }) => e[2]};
  }

  :host > wui-icon {
    z-index: 10;
  }

  /* -- Colors --------------------------------------------------- */
  :host([data-color='accent-primary']) {
    color: ${({ tokens: e }) => e.core.iconAccentPrimary};
  }

  :host([data-color='accent-primary']):after {
    background-color: ${({ tokens: e }) => e.core.foregroundAccent010};
  }

  :host([data-color='default']),
  :host([data-color='secondary']) {
    color: ${({ tokens: e }) => e.theme.iconDefault};
  }

  :host([data-color='default']):after {
    background-color: ${({ tokens: e }) => e.theme.foregroundPrimary};
  }

  :host([data-color='secondary']):after {
    background-color: ${({ tokens: e }) => e.theme.foregroundSecondary};
  }

  :host([data-color='success']) {
    color: ${({ tokens: e }) => e.core.iconSuccess};
  }

  :host([data-color='success']):after {
    background-color: ${({ tokens: e }) => e.core.backgroundSuccess};
  }

  :host([data-color='error']) {
    color: ${({ tokens: e }) => e.core.iconError};
  }

  :host([data-color='error']):after {
    background-color: ${({ tokens: e }) => e.core.backgroundError};
  }

  :host([data-color='warning']) {
    color: ${({ tokens: e }) => e.core.iconWarning};
  }

  :host([data-color='warning']):after {
    background-color: ${({ tokens: e }) => e.core.backgroundWarning};
  }

  :host([data-color='inverse']) {
    color: ${({ tokens: e }) => e.theme.iconInverse};
  }

  :host([data-color='inverse']):after {
    background-color: transparent;
  }
`;
      var d = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let h = class extends i.WF {
        constructor() {
          super(...arguments),
            (this.icon = "copy"),
            (this.size = "md"),
            (this.padding = "1"),
            (this.color = "default");
        }
        render() {
          return (
            (this.dataset.padding = this.padding),
            (this.dataset.color = this.color),
            (0, i.qy)`
      <wui-icon size=${(0, s.J)(this.size)} name=${
              this.icon
            } color="inherit"></wui-icon>
    `
          );
        }
      };
      (h.styles = [a.W5, a.fD, l]),
        d([(0, n.MZ)()], h.prototype, "icon", void 0),
        d([(0, n.MZ)()], h.prototype, "size", void 0),
        d([(0, n.MZ)()], h.prototype, "padding", void 0),
        d([(0, n.MZ)()], h.prototype, "color", void 0),
        (h = d([(0, o.E)("wui-icon-box")], h));
    },
    85268: (e, t, r) => {
      let i = r(89699);
      function n(e, t, r) {
        let i = e[t] + e[r],
          n = e[t + 1] + e[r + 1];
        i >= 0x100000000 && n++, (e[t] = i), (e[t + 1] = n);
      }
      function s(e, t, r, i) {
        let n = e[t] + r;
        r < 0 && (n += 0x100000000);
        let s = e[t + 1] + i;
        n >= 0x100000000 && s++, (e[t] = n), (e[t + 1] = s);
      }
      function a(e, t) {
        return e[t] ^ (e[t + 1] << 8) ^ (e[t + 2] << 16) ^ (e[t + 3] << 24);
      }
      function o(e, t, r, i, a, o) {
        let c = h[a],
          l = h[a + 1],
          u = h[o],
          p = h[o + 1];
        n(d, e, t), s(d, e, c, l);
        let f = d[i] ^ d[e],
          g = d[i + 1] ^ d[e + 1];
        (d[i] = g),
          (d[i + 1] = f),
          n(d, r, i),
          (f = d[t] ^ d[r]),
          (g = d[t + 1] ^ d[r + 1]),
          (d[t] = (f >>> 24) ^ (g << 8)),
          (d[t + 1] = (g >>> 24) ^ (f << 8)),
          n(d, e, t),
          s(d, e, u, p),
          (f = d[i] ^ d[e]),
          (g = d[i + 1] ^ d[e + 1]),
          (d[i] = (f >>> 16) ^ (g << 16)),
          (d[i + 1] = (g >>> 16) ^ (f << 16)),
          n(d, r, i),
          (f = d[t] ^ d[r]),
          (g = d[t + 1] ^ d[r + 1]),
          (d[t] = (g >>> 31) ^ (f << 1)),
          (d[t + 1] = (f >>> 31) ^ (g << 1));
      }
      let c = new Uint32Array([
          0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b,
          0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f,
          0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179,
          0x5be0cd19,
        ]),
        l = new Uint8Array(
          [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8,
            9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13,
            10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10,
            4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
            2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15,
            14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9,
            5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7,
            1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8,
            9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
          ].map(function (e) {
            return 2 * e;
          })
        ),
        d = new Uint32Array(32),
        h = new Uint32Array(32);
      function u(e, t) {
        let r = 0;
        for (r = 0; r < 16; r++) (d[r] = e.h[r]), (d[r + 16] = c[r]);
        for (
          d[24] = d[24] ^ e.t,
            d[25] = d[25] ^ (e.t / 0x100000000),
            t && ((d[28] = ~d[28]), (d[29] = ~d[29])),
            r = 0;
          r < 32;
          r++
        )
          h[r] = a(e.b, 4 * r);
        for (r = 0; r < 12; r++)
          o(0, 8, 16, 24, l[16 * r + 0], l[16 * r + 1]),
            o(2, 10, 18, 26, l[16 * r + 2], l[16 * r + 3]),
            o(4, 12, 20, 28, l[16 * r + 4], l[16 * r + 5]),
            o(6, 14, 22, 30, l[16 * r + 6], l[16 * r + 7]),
            o(0, 10, 20, 30, l[16 * r + 8], l[16 * r + 9]),
            o(2, 12, 22, 24, l[16 * r + 10], l[16 * r + 11]),
            o(4, 14, 16, 26, l[16 * r + 12], l[16 * r + 13]),
            o(6, 8, 18, 28, l[16 * r + 14], l[16 * r + 15]);
        for (r = 0; r < 16; r++) e.h[r] = e.h[r] ^ d[r] ^ d[r + 16];
      }
      let p = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ]);
      function f(e, t, r, i) {
        if (0 === e || e > 64)
          throw Error("Illegal output length, expected 0 < length <= 64");
        if (t && t.length > 64)
          throw Error("Illegal key, expected Uint8Array with 0 < length <= 64");
        if (r && 16 !== r.length)
          throw Error("Illegal salt, expected Uint8Array with length is 16");
        if (i && 16 !== i.length)
          throw Error(
            "Illegal personal, expected Uint8Array with length is 16"
          );
        let n = {
          b: new Uint8Array(128),
          h: new Uint32Array(16),
          t: 0,
          c: 0,
          outlen: e,
        };
        p.fill(0),
          (p[0] = e),
          t && (p[1] = t.length),
          (p[2] = 1),
          (p[3] = 1),
          r && p.set(r, 32),
          i && p.set(i, 48);
        for (let e = 0; e < 16; e++) n.h[e] = c[e] ^ a(p, 4 * e);
        return t && (g(n, t), (n.c = 128)), n;
      }
      function g(e, t) {
        for (let r = 0; r < t.length; r++)
          128 === e.c && ((e.t += e.c), u(e, !1), (e.c = 0)),
            (e.b[e.c++] = t[r]);
      }
      function m(e) {
        for (e.t += e.c; e.c < 128; ) e.b[e.c++] = 0;
        u(e, !0);
        let t = new Uint8Array(e.outlen);
        for (let r = 0; r < e.outlen; r++) t[r] = e.h[r >> 2] >> (8 * (3 & r));
        return t;
      }
      function y(e, t, r, n, s) {
        (r = r || 64),
          (e = i.normalizeInput(e)),
          n && (n = i.normalizeInput(n)),
          s && (s = i.normalizeInput(s));
        let a = f(r, t, n, s);
        return g(a, e), m(a);
      }
      e.exports = {
        blake2b: y,
        blake2bHex: function (e, t, r, n, s) {
          let a = y(e, t, r, n, s);
          return i.toHex(a);
        },
        blake2bInit: f,
        blake2bUpdate: g,
        blake2bFinal: m,
      };
    },
    85289: (e, t, r) => {
      let i = r(52686);
      (t.render = function (e, t, r) {
        var n;
        let s = r,
          a = t;
        void 0 !== s || (t && t.getContext) || ((s = t), (t = void 0)),
          t ||
            (a = (function () {
              try {
                return document.createElement("canvas");
              } catch (e) {
                throw Error("You need to specify a canvas element");
              }
            })()),
          (s = i.getOptions(s));
        let o = i.getImageWidth(e.modules.size, s),
          c = a.getContext("2d"),
          l = c.createImageData(o, o);
        return (
          i.qrToImageData(l.data, e, s),
          (n = a),
          c.clearRect(0, 0, n.width, n.height),
          n.style || (n.style = {}),
          (n.height = o),
          (n.width = o),
          (n.style.height = o + "px"),
          (n.style.width = o + "px"),
          c.putImageData(l, 0, 0),
          a
        );
      }),
        (t.renderToDataURL = function (e, r, i) {
          let n = i;
          void 0 !== n || (r && r.getContext) || ((n = r), (r = void 0)),
            n || (n = {});
          let s = t.render(e, r, n),
            a = n.type || "image/png",
            o = n.rendererOpts || {};
          return s.toDataURL(a, o.quality);
        });
    },
    87822: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(11870);
      i.__exportStar(r(64663), t), i.__exportStar(r(91609), t);
    },
    88072: (e) => {
      "use strict";
      var t = {
        single_source_shortest_paths: function (e, r, i) {
          var n,
            s,
            a,
            o,
            c,
            l,
            d,
            h = {},
            u = {};
          u[r] = 0;
          var p = t.PriorityQueue.make();
          for (p.push(r, 0); !p.empty(); )
            for (a in ((s = (n = p.pop()).value),
            (o = n.cost),
            (c = e[s] || {})))
              c.hasOwnProperty(a) &&
                ((l = o + c[a]),
                (d = u[a]),
                (void 0 === u[a] || d > l) &&
                  ((u[a] = l), p.push(a, l), (h[a] = s)));
          if (void 0 !== i && void 0 === u[i])
            throw Error("Could not find a path from " + r + " to " + i + ".");
          return h;
        },
        extract_shortest_path_from_predecessor_list: function (e, t) {
          for (var r = [], i = t; i; ) r.push(i), e[i], (i = e[i]);
          return r.reverse(), r;
        },
        find_path: function (e, r, i) {
          var n = t.single_source_shortest_paths(e, r, i);
          return t.extract_shortest_path_from_predecessor_list(n, i);
        },
        PriorityQueue: {
          make: function (e) {
            var r,
              i = t.PriorityQueue,
              n = {};
            for (r in ((e = e || {}), i)) i.hasOwnProperty(r) && (n[r] = i[r]);
            return (n.queue = []), (n.sorter = e.sorter || i.default_sorter), n;
          },
          default_sorter: function (e, t) {
            return e.cost - t.cost;
          },
          push: function (e, t) {
            this.queue.push({ value: e, cost: t }),
              this.queue.sort(this.sorter);
          },
          pop: function () {
            return this.queue.shift();
          },
          empty: function () {
            return 0 === this.queue.length;
          },
        },
      };
      e.exports = t;
    },
    88210: (e, t, r) => {
      "use strict";
      r.d(t, { EQ: () => o });
      var i = r(13933),
        n = r(82427),
        s = r(55563),
        a = r(34561);
      function o(e, t = "hex") {
        let r = (function e(t) {
            return Array.isArray(t)
              ? (function (e) {
                  let t = e.reduce((e, t) => e + t.length, 0),
                    r = c(t);
                  return {
                    length: t <= 55 ? 1 + t : 1 + r + t,
                    encode(i) {
                      for (let { encode: n } of (t <= 55
                        ? i.pushByte(192 + t)
                        : (i.pushByte(247 + r),
                          1 === r
                            ? i.pushUint8(t)
                            : 2 === r
                            ? i.pushUint16(t)
                            : 3 === r
                            ? i.pushUint24(t)
                            : i.pushUint32(t)),
                      e))
                        n(i);
                    },
                  };
                })(t.map((t) => e(t)))
              : (function (e) {
                  let t = "string" == typeof e ? (0, s.aT)(e) : e,
                    r = c(t.length);
                  return {
                    length:
                      1 === t.length && t[0] < 128
                        ? 1
                        : t.length <= 55
                        ? 1 + t.length
                        : 1 + r + t.length,
                    encode(e) {
                      (1 === t.length && t[0] < 128) ||
                        (t.length <= 55
                          ? e.pushByte(128 + t.length)
                          : (e.pushByte(183 + r),
                            1 === r
                              ? e.pushUint8(t.length)
                              : 2 === r
                              ? e.pushUint16(t.length)
                              : 3 === r
                              ? e.pushUint24(t.length)
                              : e.pushUint32(t.length))),
                        e.pushBytes(t);
                    },
                  };
                })(t);
          })(e),
          i = (0, n.l)(new Uint8Array(r.length));
        return (r.encode(i), "hex" === t) ? (0, a.My)(i.bytes) : i.bytes;
      }
      function c(e) {
        if (e < 256) return 1;
        if (e < 65536) return 2;
        if (e < 0x1000000) return 3;
        if (e < 0x100000000) return 4;
        throw new i.C("Length is too large.");
      }
    },
    88254: (e, t, r) => {
      "use strict";
      let i;
      function n(e) {
        return new Promise((t, r) => {
          (e.oncomplete = e.onsuccess = () => t(e.result)),
            (e.onabort = e.onerror = () => r(e.error));
        });
      }
      function s(e, t) {
        let r = indexedDB.open(e);
        r.onupgradeneeded = () => r.result.createObjectStore(t);
        let i = n(r);
        return (e, r) => i.then((i) => r(i.transaction(t, e).objectStore(t)));
      }
      function a() {
        return i || (i = s("keyval-store", "keyval")), i;
      }
      function o(e, t = a()) {
        return t("readonly", (t) => n(t.get(e)));
      }
      function c(e, t, r = a()) {
        return r("readwrite", (r) => (r.put(t, e), n(r.transaction)));
      }
      function l(e, t = a()) {
        return t("readwrite", (t) => (t.delete(e), n(t.transaction)));
      }
      function d(e = a()) {
        return e("readwrite", (e) => (e.clear(), n(e.transaction)));
      }
      function h(e = a()) {
        return e("readonly", (e) => {
          var t;
          if (e.getAllKeys) return n(e.getAllKeys());
          let r = [];
          return ((t = (e) => r.push(e.key)),
          (e.openCursor().onsuccess = function () {
            this.result && (t(this.result), this.result.continue());
          }),
          n(e.transaction)).then(() => r);
        });
      }
      r.d(t, {
        HP: () => h,
        IU: () => d,
        Jt: () => o,
        hZ: () => c,
        y$: () => s,
        yH: () => l,
      });
    },
    88737: (e, t, r) => {
      "use strict";
      r.d(t, {
        A7: () => s,
        BG: () => a,
        Fo: () => p,
        K0: () => c,
        Oh: () => l,
        RM: () => m,
        jj: () => o,
        k5: () => h,
        lN: () => g,
        lY: () => u,
        uC: () => f,
        vW: () => d,
      });
      var i = r(42503),
        n = r(13933);
      class s extends n.C {
        constructor({ cause: e, message: t } = {}) {
          let r = t
            ?.replace("execution reverted: ", "")
            ?.replace("execution reverted", "");
          super(
            `Execution reverted ${
              r ? `with reason: ${r}` : "for an unknown reason"
            }.`,
            { cause: e, name: "ExecutionRevertedError" }
          );
        }
      }
      Object.defineProperty(s, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
        Object.defineProperty(s, "nodeMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /execution reverted/,
        });
      class a extends n.C {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)} gwei` : ""
            }) cannot be higher than the maximum allowed value (2^256-1).`,
            { cause: e, name: "FeeCapTooHighError" }
          );
        }
      }
      Object.defineProperty(a, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
      });
      class o extends n.C {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)}` : ""
            } gwei) cannot be lower than the block base fee.`,
            { cause: e, name: "FeeCapTooLowError" }
          );
        }
      }
      Object.defineProperty(o, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
      });
      class c extends n.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is higher than the next one expected.`,
            { cause: e, name: "NonceTooHighError" }
          );
        }
      }
      Object.defineProperty(c, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too high/,
      });
      class l extends n.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is lower than the current nonce of the account.
Try increasing the nonce or find the latest nonce with \`getTransactionCount\`.`,
            { cause: e, name: "NonceTooLowError" }
          );
        }
      }
      Object.defineProperty(l, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too low|transaction already imported|already known/,
      });
      class d extends n.C {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }exceeds the maximum allowed nonce.`,
            { cause: e, name: "NonceMaxValueError" }
          );
        }
      }
      Object.defineProperty(d, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce has max value/,
      });
      class h extends n.C {
        constructor({ cause: e } = {}) {
          super(
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
            {
              cause: e,
              metaMessages: [
                "This error could arise when the account does not have enough funds to:",
                " - pay for the total gas fee,",
                " - pay for the value to send.",
                " ",
                "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
                " - `gas` is the amount of gas needed for transaction to execute,",
                " - `gas fee` is the gas fee,",
                " - `value` is the amount of ether to send to the recipient.",
              ],
              name: "InsufficientFundsError",
            }
          );
        }
      }
      Object.defineProperty(h, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /insufficient funds|exceeds transaction sender account balance/,
      });
      class u extends n.C {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction exceeds the limit allowed for the block.`,
            { cause: e, name: "IntrinsicGasTooHighError" }
          );
        }
      }
      Object.defineProperty(u, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too high|gas limit reached/,
      });
      class p extends n.C {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction is too low.`,
            { cause: e, name: "IntrinsicGasTooLowError" }
          );
        }
      }
      Object.defineProperty(p, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too low/,
      });
      class f extends n.C {
        constructor({ cause: e }) {
          super("The transaction type is not supported for this chain.", {
            cause: e,
            name: "TransactionTypeNotSupportedError",
          });
        }
      }
      Object.defineProperty(f, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /transaction type not valid/,
      });
      class g extends n.C {
        constructor({
          cause: e,
          maxPriorityFeePerGas: t,
          maxFeePerGas: r,
        } = {}) {
          super(
            `The provided tip (\`maxPriorityFeePerGas\`${
              t ? ` = ${(0, i.Q)(t)} gwei` : ""
            }) cannot be higher than the fee cap (\`maxFeePerGas\`${
              r ? ` = ${(0, i.Q)(r)} gwei` : ""
            }).`,
            { cause: e, name: "TipAboveFeeCapError" }
          );
        }
      }
      Object.defineProperty(g, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
      });
      class m extends n.C {
        constructor({ cause: e }) {
          super(`An error occurred while executing: ${e?.shortMessage}`, {
            cause: e,
            name: "UnknownNodeError",
          });
        }
      }
    },
    88759: (e) => {
      "use strict";
      function t(e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      e.exports = function (e, r, i) {
        var n = (i && i.stringify) || t;
        if ("object" == typeof e && null !== e) {
          var s = r.length + 1;
          if (1 === s) return e;
          var a = Array(s);
          a[0] = n(e);
          for (var o = 1; o < s; o++) a[o] = n(r[o]);
          return a.join(" ");
        }
        if ("string" != typeof e) return e;
        var c = r.length;
        if (0 === c) return e;
        for (
          var l = "", d = 0, h = -1, u = (e && e.length) || 0, p = 0;
          p < u;

        ) {
          if (37 === e.charCodeAt(p) && p + 1 < u) {
            switch (((h = h > -1 ? h : 0), e.charCodeAt(p + 1))) {
              case 100:
              case 102:
                if (d >= c || null == r[d]) break;
                h < p && (l += e.slice(h, p)),
                  (l += Number(r[d])),
                  (h = p + 2),
                  p++;
                break;
              case 105:
                if (d >= c || null == r[d]) break;
                h < p && (l += e.slice(h, p)),
                  (l += Math.floor(Number(r[d]))),
                  (h = p + 2),
                  p++;
                break;
              case 79:
              case 111:
              case 106:
                if (d >= c || void 0 === r[d]) break;
                h < p && (l += e.slice(h, p));
                var f = typeof r[d];
                if ("string" === f) {
                  (l += "'" + r[d] + "'"), (h = p + 2), p++;
                  break;
                }
                if ("function" === f) {
                  (l += r[d].name || "<anonymous>"), (h = p + 2), p++;
                  break;
                }
                (l += n(r[d])), (h = p + 2), p++;
                break;
              case 115:
                if (d >= c) break;
                h < p && (l += e.slice(h, p)),
                  (l += String(r[d])),
                  (h = p + 2),
                  p++;
                break;
              case 37:
                h < p && (l += e.slice(h, p)),
                  (l += "%"),
                  (h = p + 2),
                  p++,
                  d--;
            }
            ++d;
          }
          ++p;
        }
        return -1 === h ? e : (h < u && (l += e.slice(h)), l);
      };
    },
    88955: (e, t, r) => {
      "use strict";
      t.g = void 0;
      let i = r(26662);
      t.g = function () {
        let e, t, r;
        try {
          (e = i.getDocumentOrThrow()), (t = i.getLocationOrThrow());
        } catch (e) {
          return null;
        }
        function n(...t) {
          let r = e.getElementsByTagName("meta");
          for (let e = 0; e < r.length; e++) {
            let i = r[e],
              n = ["itemprop", "property", "name"]
                .map((e) => i.getAttribute(e))
                .filter((e) => !!e && t.includes(e));
            if (n.length && n) {
              let e = i.getAttribute("content");
              if (e) return e;
            }
          }
          return "";
        }
        let s =
            ((r = n("name", "og:site_name", "og:title", "twitter:title")) ||
              (r = e.title),
            r),
          a = n(
            "description",
            "og:description",
            "twitter:description",
            "keywords"
          ),
          o = t.origin;
        return {
          description: a,
          url: o,
          icons: (function () {
            let r = e.getElementsByTagName("link"),
              i = [];
            for (let e = 0; e < r.length; e++) {
              let n = r[e],
                s = n.getAttribute("rel");
              if (s && s.toLowerCase().indexOf("icon") > -1) {
                let e = n.getAttribute("href");
                if (e)
                  if (
                    -1 === e.toLowerCase().indexOf("https:") &&
                    -1 === e.toLowerCase().indexOf("http:") &&
                    0 !== e.indexOf("//")
                  ) {
                    let r = t.protocol + "//" + t.host;
                    if (0 === e.indexOf("/")) r += e;
                    else {
                      let i = t.pathname.split("/");
                      i.pop(), (r += i.join("/") + "/" + e);
                    }
                    i.push(r);
                  } else if (0 === e.indexOf("//")) {
                    let r = t.protocol + e;
                    i.push(r);
                  } else i.push(e);
              }
            }
            return i;
          })(),
          name: s,
        };
      };
    },
    89158: (e, t, r) => {
      let i = r(29762),
        n = r(53896);
      (t.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }),
        (t.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] }),
        (t.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }),
        (t.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }),
        (t.MIXED = { bit: -1 }),
        (t.getCharCountIndicator = function (e, t) {
          if (!e.ccBits) throw Error("Invalid mode: " + e);
          if (!i.isValid(t)) throw Error("Invalid version: " + t);
          return t >= 1 && t < 10
            ? e.ccBits[0]
            : t < 27
            ? e.ccBits[1]
            : e.ccBits[2];
        }),
        (t.getBestModeForData = function (e) {
          return n.testNumeric(e)
            ? t.NUMERIC
            : n.testAlphanumeric(e)
            ? t.ALPHANUMERIC
            : n.testKanji(e)
            ? t.KANJI
            : t.BYTE;
        }),
        (t.toString = function (e) {
          if (e && e.id) return e.id;
          throw Error("Invalid mode");
        }),
        (t.isValid = function (e) {
          return e && e.bit && e.ccBits;
        }),
        (t.from = function (e, r) {
          if (t.isValid(e)) return e;
          try {
            if ("string" != typeof e) throw Error("Param is not a string");
            switch (e.toLowerCase()) {
              case "numeric":
                return t.NUMERIC;
              case "alphanumeric":
                return t.ALPHANUMERIC;
              case "kanji":
                return t.KANJI;
              case "byte":
                return t.BYTE;
              default:
                throw Error("Unknown mode: " + e);
            }
          } catch (e) {
            return r;
          }
        });
    },
    89600: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n });
      var i = r(93965);
      let n = {
        EmbeddedWalletAbortController: new AbortController(),
        UniversalProviderErrors: {
          UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: "Unauthorized: origin not allowed",
            alertErrorKey: "ORIGIN_NOT_ALLOWED",
          },
          JWT_VALIDATION_ERROR: {
            message: "JWT validation error: JWT Token is not yet valid",
            alertErrorKey: "JWT_TOKEN_NOT_VALID",
          },
          INVALID_KEY: {
            message: "Unauthorized: invalid key",
            alertErrorKey: "INVALID_PROJECT_ID",
          },
        },
        ALERT_ERRORS: {
          SWITCH_NETWORK_NOT_FOUND: {
            code: "APKT001",
            displayMessage: "Network Not Found",
            debugMessage:
              "The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration.",
          },
          ORIGIN_NOT_ALLOWED: {
            code: "APKT002",
            displayMessage: "Invalid App Configuration",
            debugMessage: () =>
              `The origin ${
                (0, i.IP)() ? window.origin : "unknown"
              } is not in your allow list. Please update your allowed domains at https://dashboard.reown.com.`,
          },
          IFRAME_LOAD_FAILED: {
            code: "APKT003",
            displayMessage: "Network Error: Wallet Load Failed",
            debugMessage: () =>
              "Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists.",
          },
          IFRAME_REQUEST_TIMEOUT: {
            code: "APKT004",
            displayMessage: "Wallet Request Timeout",
            debugMessage: () =>
              "The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists.",
          },
          UNVERIFIED_DOMAIN: {
            code: "APKT005",
            displayMessage: "Unverified Domain",
            debugMessage: () =>
              "Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com.",
          },
          JWT_TOKEN_NOT_VALID: {
            code: "APKT006",
            displayMessage: "Session Expired",
            debugMessage:
              "Your session is invalid or expired. Please check your systems date and time settings, then reconnect.",
          },
          INVALID_PROJECT_ID: {
            code: "APKT007",
            displayMessage: "Invalid Project ID",
            debugMessage:
              "The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID.",
          },
          PROJECT_ID_NOT_CONFIGURED: {
            code: "APKT008",
            displayMessage: "Project ID Missing",
            debugMessage:
              "No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com.",
          },
          SERVER_ERROR_APP_CONFIGURATION: {
            code: "APKT009",
            displayMessage: "Server Error",
            debugMessage: (e) =>
              `Unable to fetch App Configuration. ${e}. Please check your network connection and try again shortly. Contact support if the issue persists.`,
          },
          RATE_LIMITED_APP_CONFIGURATION: {
            code: "APKT010",
            displayMessage: "Rate Limited",
            debugMessage:
              "You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists.",
          },
        },
        ALERT_WARNINGS: {
          LOCAL_CONFIGURATION_IGNORED: {
            debugMessage: (e) => `[Reown Config Notice] ${e}`,
          },
          INACTIVE_NAMESPACE_NOT_CONNECTED: {
            code: "APKTW001",
            displayMessage: "Inactive Namespace Not Connected",
            debugMessage: (e, t) =>
              `An error occurred while connecting an inactive namespace ${e}: "${t}"`,
          },
          INVALID_EMAIL: {
            code: "APKTW002",
            displayMessage: "Invalid Email Address",
            debugMessage: "Please enter a valid email address",
          },
        },
      };
    },
    89699: (e) => {
      function t(e) {
        return (0x100000000 + e).toString(16).substring(1);
      }
      e.exports = {
        normalizeInput: function (e) {
          let t;
          if (e instanceof Uint8Array) t = e;
          else if ("string" == typeof e) t = new TextEncoder().encode(e);
          else throw Error("Input must be an string, Buffer or Uint8Array");
          return t;
        },
        toHex: function (e) {
          return Array.prototype.map
            .call(e, function (e) {
              return (e < 16 ? "0" : "") + e.toString(16);
            })
            .join("");
        },
        debugPrint: function (e, r, i) {
          let n = "\n" + e + " = ";
          for (let s = 0; s < r.length; s += 2) {
            if (32 === i)
              (n += t(r[s]).toUpperCase()),
                (n += " "),
                (n += t(r[s + 1]).toUpperCase());
            else if (64 === i)
              (n += t(r[s + 1]).toUpperCase()), (n += t(r[s]).toUpperCase());
            else throw Error("Invalid size " + i);
            s % 6 == 4
              ? (n += "\n" + Array(e.length + 4).join(" "))
              : s < r.length - 2 && (n += " ");
          }
          console.log(n);
        },
        testSpeed: function (e, t, r) {
          let i = new Date().getTime(),
            n = new Uint8Array(t);
          for (let e = 0; e < t; e++) n[e] = e % 256;
          let s = new Date().getTime();
          console.log("Generated random input in " + (s - i) + "ms"), (i = s);
          for (let s = 0; s < r; s++) {
            let r = e(n),
              s = new Date().getTime(),
              a = s - i;
            (i = s),
              console.log(
                "Hashed in " + a + "ms: " + r.substring(0, 20) + "..."
              ),
              console.log(
                Math.round((t / 1048576 / (a / 1e3)) * 100) / 100 +
                  " MB PER SECOND"
              );
          }
        },
      };
    },
    90332: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(12590).__exportStar(r(19511), t);
    },
    90523: (e, t, r) => {
      "use strict";
      r.d(t, { Lj: () => o, WB: () => l, uL: () => c });
      var i = r(11914),
        n = r(50707),
        s = r(52623),
        a = r(15885);
      let o = { "0x0": "reverted", "0x1": "success" };
      function c(e) {
        let t = {
          ...e,
          blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
          contractAddress: e.contractAddress ? e.contractAddress : null,
          cumulativeGasUsed: e.cumulativeGasUsed
            ? BigInt(e.cumulativeGasUsed)
            : null,
          effectiveGasPrice: e.effectiveGasPrice
            ? BigInt(e.effectiveGasPrice)
            : null,
          gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
          logs: e.logs ? e.logs.map((e) => (0, s.e)(e)) : null,
          to: e.to ? e.to : null,
          transactionIndex: e.transactionIndex
            ? (0, i.ME)(e.transactionIndex)
            : null,
          status: e.status ? o[e.status] : null,
          type: e.type ? a.b4[e.type] || e.type : null,
        };
        return (
          e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)),
          e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)),
          t
        );
      }
      let l = (0, n.q)("transactionReceipt", c);
    },
    90656: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var i = r(50879);
      function n(e) {
        if (e.type) return e.type;
        if (void 0 !== e.authorizationList) return "eip7702";
        if (
          void 0 !== e.blobs ||
          void 0 !== e.blobVersionedHashes ||
          void 0 !== e.maxFeePerBlobGas ||
          void 0 !== e.sidecars
        )
          return "eip4844";
        if (void 0 !== e.maxFeePerGas || void 0 !== e.maxPriorityFeePerGas)
          return "eip1559";
        if (void 0 !== e.gasPrice)
          return void 0 !== e.accessList ? "eip2930" : "legacy";
        throw new i.Vg({ transaction: e });
      }
    },
    90721: (e, t, r) => {
      "use strict";
      r(84042);
    },
    91053: (e, t, r) => {
      "use strict";
      function i(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      r.d(t, { x: () => i });
    },
    91609: (e, t, r) => {
      "use strict";
      var i = r(95704);
      function n() {
        return (
          "undefined" == typeof document &&
          "undefined" != typeof navigator &&
          "ReactNative" === navigator.product
        );
      }
      function s() {
        return (
          void 0 !== i && void 0 !== i.versions && void 0 !== i.versions.node
        );
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowser = t.isNode = t.isReactNative = void 0),
        (t.isReactNative = n),
        (t.isNode = s),
        (t.isBrowser = function () {
          return !n() && !s();
        });
    },
    91791: (e) => {
      e.exports = function () {
        return (
          "function" == typeof Promise &&
          Promise.prototype &&
          Promise.prototype.then
        );
      };
    },
    91867: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var i = r(95704);
      let n = {
        ACCOUNT_TABS: [{ label: "Tokens" }, { label: "Activity" }],
        SECURE_SITE_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        VIEW_DIRECTION: { Next: "next", Prev: "prev" },
        DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
        ANIMATION_DURATIONS: {
          HeaderText: 120,
          ModalHeight: 150,
          ViewTransition: 150,
        },
        VIEWS_WITH_LEGAL_FOOTER: [
          "Connect",
          "ConnectWallets",
          "OnRampTokenSelect",
          "OnRampFiatSelect",
          "OnRampProviders",
        ],
        VIEWS_WITH_DEFAULT_FOOTER: ["Networks"],
      };
    },
    93481: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => I });
      var i = r(1220),
        n = r(98866),
        s = r(65103),
        a = r(76190),
        o = r(45553),
        c = r(30982),
        l = r(28977),
        d = r(12319),
        h = r(58653),
        u = r(36964),
        p = r(97418),
        f = r(10899),
        g = r(70417),
        m = r(81701),
        y = r(55480),
        w = r(6578),
        b = r(67869),
        v = r(25654),
        C = r(65374);
      let E = {
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          user: void 0,
          preferredAccountType: void 0,
        },
        x = {
          caipNetwork: void 0,
          supportsAllNetworks: !0,
          smartAccountEnabledNetworks: [],
        },
        A = (0, i.BX)({
          chains: (0, n.zC)(),
          activeCaipAddress: void 0,
          activeChain: void 0,
          activeCaipNetwork: void 0,
          noAdapters: !1,
          universalAdapter: {
            networkControllerClient: void 0,
            connectionControllerClient: void 0,
          },
          isSwitchingNamespace: !1,
        }),
        _ = {
          state: A,
          subscribe: (e) =>
            (0, i.B1)(A, () => {
              e(A);
            }),
          subscribeKey: (e, t) => (0, n.u$)(A, e, t),
          subscribeAccountStateProp(e, t, r) {
            let i = r || A.activeChain;
            return i
              ? (0, n.u$)(A.chains.get(i)?.accountState || {}, e, t)
              : () => void 0;
          },
          subscribeChainProp(e, t, r) {
            let n;
            return (0, i.B1)(A.chains, () => {
              let i = r || A.activeChain;
              if (i) {
                let r = A.chains.get(i)?.[e];
                n !== r && ((n = r), t(r));
              }
            });
          },
          initialize(e, t, r) {
            let { chainId: n, namespace: s } = h.i.getActiveNetworkProps(),
              a = t?.find((e) => e.id.toString() === n?.toString()),
              o = e.find((e) => e?.namespace === s) || e?.[0],
              c = e.map((e) => e.namespace).filter((e) => void 0 !== e),
              l = new Set(
                y.H.state.enableEmbedded
                  ? [...c]
                  : [...(t?.map((e) => e.chainNamespace) ?? [])]
              );
            (e?.length !== 0 && o) || (A.noAdapters = !0),
              !A.noAdapters &&
                ((A.activeChain = o?.namespace),
                (A.activeCaipNetwork = a),
                I.setChainNetworkData(o?.namespace, { caipNetwork: a }),
                A.activeChain && w.z.set({ activeChain: o?.namespace })),
              l.forEach((e) => {
                let n = t?.filter((t) => t.chainNamespace === e),
                  s = h.i.getPreferredAccountTypes() || {},
                  a = { ...y.H.state.defaultAccountTypes, ...s };
                I.state.chains.set(e, {
                  namespace: e,
                  networkState: (0, i.BX)({ ...x, caipNetwork: n?.[0] }),
                  accountState: (0, i.BX)({ ...E, preferredAccountType: a[e] }),
                  caipNetworks: n ?? [],
                  ...r,
                }),
                  I.setRequestedCaipNetworks(n ?? [], e);
              });
          },
          removeAdapter(e) {
            if (A.activeChain === e) {
              let t = Array.from(A.chains.entries()).find(([t]) => t !== e);
              if (t) {
                let e = t[1]?.caipNetworks?.[0];
                e && I.setActiveCaipNetwork(e);
              }
            }
            A.chains.delete(e);
          },
          addAdapter(
            e,
            { networkControllerClient: t, connectionControllerClient: r },
            i
          ) {
            if (!e.namespace)
              throw Error(
                "ChainController:addAdapter - adapter must have a namespace"
              );
            A.chains.set(e.namespace, {
              namespace: e.namespace,
              networkState: { ...x, caipNetwork: i[0] },
              accountState: { ...E },
              caipNetworks: i,
              connectionControllerClient: r,
              networkControllerClient: t,
            }),
              I.setRequestedCaipNetworks(
                i?.filter((t) => t.chainNamespace === e.namespace) ?? [],
                e.namespace
              );
          },
          addNetwork(e) {
            let t = A.chains.get(e.chainNamespace);
            if (t) {
              let r = [...(t.caipNetworks || [])];
              t.caipNetworks?.find((t) => t.id === e.id) || r.push(e),
                A.chains.set(e.chainNamespace, { ...t, caipNetworks: r }),
                I.setRequestedCaipNetworks(r, e.chainNamespace),
                f.a.filterByNamespace(e.chainNamespace, !0);
            }
          },
          removeNetwork(e, t) {
            let r = A.chains.get(e);
            if (r) {
              let i = A.activeCaipNetwork?.id === t,
                n = [...(r.caipNetworks?.filter((e) => e.id !== t) || [])];
              i &&
                r?.caipNetworks?.[0] &&
                I.setActiveCaipNetwork(r.caipNetworks[0]),
                A.chains.set(e, { ...r, caipNetworks: n }),
                I.setRequestedCaipNetworks(n || [], e),
                0 === n.length && f.a.filterByNamespace(e, !1);
            }
          },
          setAdapterNetworkState(e, t) {
            let r = A.chains.get(e);
            r &&
              ((r.networkState = { ...(r.networkState || x), ...t }),
              A.chains.set(e, r));
          },
          setChainAccountData(e, t, r = !0) {
            if (!e)
              throw Error("Chain is required to update chain account data");
            let i = A.chains.get(e);
            if (i) {
              let r = { ...(i.accountState || E), ...t };
              A.chains.set(e, { ...i, accountState: r }),
                (1 === A.chains.size || A.activeChain === e) &&
                  t.caipAddress &&
                  (A.activeCaipAddress = t.caipAddress);
            }
          },
          setChainNetworkData(e, t) {
            if (!e) return;
            let r = A.chains.get(e);
            if (r) {
              let i = { ...(r.networkState || x), ...t };
              A.chains.set(e, { ...r, networkState: i });
            }
          },
          setAccountProp(e, t, r, i = !0) {
            I.setChainAccountData(r, { [e]: t }, i);
          },
          setActiveNamespace(e) {
            A.activeChain = e;
            let t = e ? A.chains.get(e) : void 0,
              r = t?.networkState?.caipNetwork;
            r?.id &&
              e &&
              ((A.activeCaipAddress = t?.accountState?.caipAddress),
              (A.activeCaipNetwork = r),
              I.setChainNetworkData(e, { caipNetwork: r }),
              h.i.setActiveCaipNetworkId(r?.caipNetworkId),
              w.z.set({ activeChain: e, selectedNetworkId: r?.caipNetworkId }));
          },
          setActiveCaipNetwork(e) {
            if (!e) return;
            let t = A.activeChain === e.chainNamespace;
            t || I.setIsSwitchingNamespace(!0);
            let r = A.chains.get(e.chainNamespace);
            (A.activeChain = e.chainNamespace),
              (A.activeCaipNetwork = e),
              I.setChainNetworkData(e.chainNamespace, { caipNetwork: e });
            let i = r?.accountState?.address;
            if (i) A.activeCaipAddress = `${e.chainNamespace}:${e.id}:${i}`;
            else if (t && A.activeCaipAddress) {
              let { address: t } = s.C.parseCaipAddress(A.activeCaipAddress);
              (i = t), (A.activeCaipAddress = `${e.caipNetworkId}:${i}`);
            } else A.activeCaipAddress = void 0;
            I.setChainAccountData(e.chainNamespace, {
              address: i,
              caipAddress: A.activeCaipAddress,
            }),
              v.R.resetSend(),
              w.z.set({
                activeChain: A.activeChain,
                selectedNetworkId: A.activeCaipNetwork?.caipNetworkId,
              }),
              h.i.setActiveCaipNetworkId(e.caipNetworkId),
              I.checkIfSupportedNetwork(e.chainNamespace) ||
                !y.H.state.enableNetworkSwitch ||
                y.H.state.allowUnsupportedChain ||
                p.x.state.wcBasic ||
                I.showUnsupportedChainUI();
          },
          addCaipNetwork(e) {
            if (!e) return;
            let t = A.chains.get(e.chainNamespace);
            t && t?.caipNetworks?.push(e);
          },
          async switchActiveNamespace(e) {
            if (!e) return;
            let t = e !== I.state.activeChain,
              r = I.getNetworkData(e)?.caipNetwork,
              i = I.getCaipNetworkByNamespace(e, r?.id);
            t && i && (await I.switchActiveNetwork(i));
          },
          async switchActiveNetwork(e, { throwOnFailure: t = !1 } = {}) {
            let r = I.state.activeChain;
            if (!r)
              throw Error(
                "ChainController:switchActiveNetwork - namespace is required"
              );
            let i = I.state.chains.get(r),
              n = !i?.caipNetworks?.some(
                (e) => e.id === A.activeCaipNetwork?.id
              ),
              s = I.getNetworkControllerClient(e.chainNamespace);
            if (s) {
              try {
                await s.switchCaipNetwork(e), n && m.W.close();
              } catch (e) {
                if (t) throw e;
                b.I.goBack();
              }
              g.E.sendEvent({
                type: "track",
                event: "SWITCH_NETWORK",
                properties: { network: e.caipNetworkId },
              });
            }
          },
          getNetworkControllerClient(e) {
            let t = e || A.activeChain;
            if (!t)
              throw Error(
                "ChainController:getNetworkControllerClient - chain is required"
              );
            let r = A.chains.get(t);
            if (!r) throw Error("Chain adapter not found");
            if (!r.networkControllerClient)
              throw Error("NetworkController client not set");
            return r.networkControllerClient;
          },
          getConnectionControllerClient(e) {
            let t = e || A.activeChain;
            if (!t)
              throw Error(
                "Chain is required to get connection controller client"
              );
            let r = A.chains.get(t);
            if (!r?.connectionControllerClient)
              throw Error("ConnectionController client not set");
            return r.connectionControllerClient;
          },
          getNetworkProp(e, t) {
            let r = A.chains.get(t)?.networkState;
            if (r) return r[e];
          },
          getRequestedCaipNetworks(e) {
            let t = A.chains.get(e),
              {
                approvedCaipNetworkIds: r = [],
                requestedCaipNetworks: i = [],
              } = t?.networkState || {};
            return d.w.sortRequestedNetworks(r, i).filter((e) => e?.id);
          },
          getAllRequestedCaipNetworks() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                if (!t.namespace)
                  throw Error(
                    "ChainController:getAllRequestedCaipNetworks - chainAdapter must have a namespace"
                  );
                let r = I.getRequestedCaipNetworks(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          setRequestedCaipNetworks(e, t) {
            I.setAdapterNetworkState(t, { requestedCaipNetworks: e });
            let r = Array.from(
              new Set(
                I.getAllRequestedCaipNetworks().map((e) => e.chainNamespace)
              )
            );
            f.a.filterByNamespaces(r);
          },
          getAllApprovedCaipNetworkIds() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                if (!t.namespace)
                  throw Error(
                    "ChainController:getAllApprovedCaipNetworkIds - chainAdapter must have a namespace"
                  );
                let r = I.getApprovedCaipNetworkIds(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          getActiveCaipNetwork: (e) =>
            e
              ? A.chains.get(e)?.networkState?.caipNetwork
              : A.activeCaipNetwork,
          getActiveCaipAddress: () => A.activeCaipAddress,
          getApprovedCaipNetworkIds(e) {
            let t = A.chains.get(e);
            return t?.networkState?.approvedCaipNetworkIds || [];
          },
          async setApprovedCaipNetworksData(e) {
            let t = I.getNetworkControllerClient(),
              r = await t?.getApprovedCaipNetworksData();
            I.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: r?.approvedCaipNetworkIds,
              supportsAllNetworks: r?.supportsAllNetworks,
            });
          },
          checkIfSupportedNetwork(e, t) {
            let r = t || A.activeCaipNetwork?.caipNetworkId,
              i = I.getRequestedCaipNetworks(e);
            return !i.length || i?.some((e) => e.caipNetworkId === r);
          },
          checkIfSupportedChainId(e) {
            if (!A.activeChain) return !0;
            let t = I.getRequestedCaipNetworks(A.activeChain);
            return t?.some((t) => t.id === e);
          },
          setSmartAccountEnabledNetworks(e, t) {
            I.setAdapterNetworkState(t, { smartAccountEnabledNetworks: e });
          },
          checkIfSmartAccountEnabled() {
            let e = a.L.caipNetworkIdToNumber(
                A.activeCaipNetwork?.caipNetworkId
              ),
              t = A.activeChain;
            if (!t || !e) return !1;
            let r = I.getNetworkProp("smartAccountEnabledNetworks", t);
            return !!r?.includes(Number(e));
          },
          showUnsupportedChainUI() {
            m.W.open({ view: "UnsupportedChain" });
          },
          checkIfNamesSupported() {
            let e = A.activeCaipNetwork;
            return !!(
              e?.chainNamespace &&
              l.oU.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(e.chainNamespace)
            );
          },
          resetNetwork(e) {
            I.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: void 0,
              supportsAllNetworks: !0,
            });
          },
          resetAccount(e) {
            if (!e) throw Error("Chain is required to set account prop");
            let t = I.state.chains.get(e)?.accountState?.preferredAccountType,
              r = y.H.state.defaultAccountTypes[e];
            (A.activeCaipAddress = void 0),
              I.setChainAccountData(e, {
                smartAccountDeployed: !1,
                currentTab: 0,
                caipAddress: void 0,
                address: void 0,
                balance: void 0,
                balanceSymbol: void 0,
                profileName: void 0,
                profileImage: void 0,
                addressExplorerUrl: void 0,
                tokenBalance: [],
                connectedWalletInfo: void 0,
                preferredAccountType: r || t,
                socialProvider: void 0,
                socialWindow: void 0,
                farcasterUrl: void 0,
                user: void 0,
                status: "disconnected",
              }),
              f.a.removeConnectorId(e);
          },
          setIsSwitchingNamespace(e) {
            A.isSwitchingNamespace = e;
          },
          getFirstCaipNetworkSupportsAuthConnector() {
            let e = [];
            if (
              (A.chains.forEach((t) => {
                o.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
                  (e) => e === t.namespace
                ) &&
                  t.namespace &&
                  e.push(t.namespace);
              }),
              e.length > 0)
            ) {
              let t = e[0];
              return t ? A.chains.get(t)?.caipNetworks?.[0] : void 0;
            }
          },
          getAccountData(e) {
            let t = e || A.activeChain;
            if (t) return I.state.chains.get(t)?.accountState;
          },
          getNetworkData(e) {
            let t = e || A.activeChain;
            if (t) return I.state.chains.get(t)?.networkState;
          },
          getCaipNetworkByNamespace(e, t) {
            if (!e) return;
            let r = I.state.chains.get(e),
              i = r?.caipNetworks?.find((e) => e.id === t);
            return i || r?.networkState?.caipNetwork || r?.caipNetworks?.[0];
          },
          getRequestedCaipNetworkIds() {
            let e = f.a.state.filterByNamespace;
            return (e ? [A.chains.get(e)] : Array.from(A.chains.values()))
              .flatMap((e) => e?.caipNetworks || [])
              .map((e) => e.caipNetworkId);
          },
          getCaipNetworks: (e) =>
            e ? I.getRequestedCaipNetworks(e) : I.getAllRequestedCaipNetworks(),
          getCaipNetworkById: (e, t) =>
            _.getCaipNetworks(t).find(
              (t) =>
                t.id.toString() === e.toString() ||
                t.caipNetworkId.toString() === e.toString()
            ),
          setLastConnectedSIWECaipNetwork(e) {
            A.lastConnectedSIWECaipNetwork = e;
          },
          getLastConnectedSIWECaipNetwork: () => A.lastConnectedSIWECaipNetwork,
          async fetchTokenBalance(e) {
            let t = I.getAccountData();
            if (!t) return [];
            let r = I.state.activeCaipNetwork?.caipNetworkId,
              i = I.state.activeCaipNetwork?.chainNamespace,
              n = I.state.activeCaipAddress,
              s = n ? d.w.getPlainAddress(n) : void 0;
            if (
              (I.setAccountProp("balanceLoading", !0, i),
              t.lastRetry &&
                !d.w.isAllowedRetry(t.lastRetry, 30 * l.oU.ONE_SEC_MS))
            )
              return I.setAccountProp("balanceLoading", !1, i), [];
            try {
              if (s && r && i) {
                let e = await c.Z.getMyTokensWithBalance();
                return (
                  I.setAccountProp("tokenBalance", e, i),
                  I.setAccountProp("lastRetry", void 0, i),
                  I.setAccountProp("balanceLoading", !1, i),
                  e
                );
              }
            } catch (t) {
              I.setAccountProp("lastRetry", Date.now(), i),
                e?.(t),
                C.P.showError("Token Balance Unavailable");
            } finally {
              I.setAccountProp("balanceLoading", !1, i);
            }
            return [];
          },
        },
        I = (0, u.X)(_);
    },
    93711: (e, t, r) => {
      let i = r(46342),
        n = r(24967),
        s = r(35425),
        a = r(62546),
        o = r(669),
        c = r(35630),
        l = r(19542),
        d = r(81010),
        h = r(95230),
        u = r(69435),
        p = r(41953),
        f = r(89158),
        g = r(70371);
      function m(e, t, r) {
        let i,
          n,
          s = e.size,
          a = p.getEncodedBits(t, r);
        for (i = 0; i < 15; i++)
          (n = ((a >> i) & 1) == 1),
            i < 6
              ? e.set(i, 8, n, !0)
              : i < 8
              ? e.set(i + 1, 8, n, !0)
              : e.set(s - 15 + i, 8, n, !0),
            i < 8
              ? e.set(8, s - i - 1, n, !0)
              : i < 9
              ? e.set(8, 15 - i - 1 + 1, n, !0)
              : e.set(8, 15 - i - 1, n, !0);
        e.set(s - 8, 8, 1, !0);
      }
      t.create = function (e, t) {
        let r, p;
        if (void 0 === e || "" === e) throw Error("No input text");
        let y = n.M;
        return (
          void 0 !== t &&
            ((y = n.from(t.errorCorrectionLevel, n.M)),
            (r = u.from(t.version)),
            (p = l.from(t.maskPattern)),
            t.toSJISFunc && i.setToSJISFunction(t.toSJISFunc)),
          (function (e, t, r, n) {
            let p;
            if (Array.isArray(e)) p = g.fromArray(e);
            else if ("string" == typeof e) {
              let i = t;
              if (!i) {
                let t = g.rawSplit(e);
                i = u.getBestVersionForData(t, r);
              }
              p = g.fromString(e, i || 40);
            } else throw Error("Invalid data");
            let y = u.getBestVersionForData(p, r);
            if (!y)
              throw Error(
                "The amount of data is too big to be stored in a QR Code"
              );
            if (t) {
              if (t < y)
                throw Error(
                  "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " +
                    y +
                    ".\n"
                );
            } else t = y;
            let w = (function (e, t, r) {
                let n = new s();
                r.forEach(function (t) {
                  n.put(t.mode.bit, 4),
                    n.put(t.getLength(), f.getCharCountIndicator(t.mode, e)),
                    t.write(n);
                });
                let a =
                  (i.getSymbolTotalCodewords(e) -
                    d.getTotalCodewordsCount(e, t)) *
                  8;
                for (
                  n.getLengthInBits() + 4 <= a && n.put(0, 4);
                  n.getLengthInBits() % 8 != 0;

                )
                  n.putBit(0);
                let o = (a - n.getLengthInBits()) / 8;
                for (let e = 0; e < o; e++) n.put(e % 2 ? 17 : 236, 8);
                return (function (e, t, r) {
                  let n,
                    s,
                    a = i.getSymbolTotalCodewords(t),
                    o = a - d.getTotalCodewordsCount(t, r),
                    c = d.getBlocksCount(t, r),
                    l = a % c,
                    u = c - l,
                    p = Math.floor(a / c),
                    f = Math.floor(o / c),
                    g = f + 1,
                    m = p - f,
                    y = new h(m),
                    w = 0,
                    b = Array(c),
                    v = Array(c),
                    C = 0,
                    E = new Uint8Array(e.buffer);
                  for (let e = 0; e < c; e++) {
                    let t = e < u ? f : g;
                    (b[e] = E.slice(w, w + t)),
                      (v[e] = y.encode(b[e])),
                      (w += t),
                      (C = Math.max(C, t));
                  }
                  let x = new Uint8Array(a),
                    A = 0;
                  for (n = 0; n < C; n++)
                    for (s = 0; s < c; s++)
                      n < b[s].length && (x[A++] = b[s][n]);
                  for (n = 0; n < m; n++)
                    for (s = 0; s < c; s++) x[A++] = v[s][n];
                  return x;
                })(n, e, t);
              })(t, r, p),
              b = new a(i.getSymbolSize(t));
            !(function (e, t) {
              let r = e.size,
                i = c.getPositions(t);
              for (let t = 0; t < i.length; t++) {
                let n = i[t][0],
                  s = i[t][1];
                for (let t = -1; t <= 7; t++)
                  if (!(n + t <= -1) && !(r <= n + t))
                    for (let i = -1; i <= 7; i++)
                      s + i <= -1 ||
                        r <= s + i ||
                        ((t >= 0 && t <= 6 && (0 === i || 6 === i)) ||
                        (i >= 0 && i <= 6 && (0 === t || 6 === t)) ||
                        (t >= 2 && t <= 4 && i >= 2 && i <= 4)
                          ? e.set(n + t, s + i, !0, !0)
                          : e.set(n + t, s + i, !1, !0));
              }
            })(b, t);
            let v = b.size;
            for (let e = 8; e < v - 8; e++) {
              let t = e % 2 == 0;
              b.set(e, 6, t, !0), b.set(6, e, t, !0);
            }
            return (
              !(function (e, t) {
                let r = o.getPositions(t);
                for (let t = 0; t < r.length; t++) {
                  let i = r[t][0],
                    n = r[t][1];
                  for (let t = -2; t <= 2; t++)
                    for (let r = -2; r <= 2; r++)
                      -2 === t ||
                      2 === t ||
                      -2 === r ||
                      2 === r ||
                      (0 === t && 0 === r)
                        ? e.set(i + t, n + r, !0, !0)
                        : e.set(i + t, n + r, !1, !0);
                }
              })(b, t),
              m(b, r, 0),
              t >= 7 &&
                (function (e, t) {
                  let r,
                    i,
                    n,
                    s = e.size,
                    a = u.getEncodedBits(t);
                  for (let t = 0; t < 18; t++)
                    (r = Math.floor(t / 3)),
                      (i = (t % 3) + s - 8 - 3),
                      (n = ((a >> t) & 1) == 1),
                      e.set(r, i, n, !0),
                      e.set(i, r, n, !0);
                })(b, t),
              !(function (e, t) {
                let r = e.size,
                  i = -1,
                  n = r - 1,
                  s = 7,
                  a = 0;
                for (let o = r - 1; o > 0; o -= 2)
                  for (6 === o && o--; ; ) {
                    for (let r = 0; r < 2; r++)
                      if (!e.isReserved(n, o - r)) {
                        let i = !1;
                        a < t.length && (i = ((t[a] >>> s) & 1) == 1),
                          e.set(n, o - r, i),
                          -1 == --s && (a++, (s = 7));
                      }
                    if ((n += i) < 0 || r <= n) {
                      (n -= i), (i = -i);
                      break;
                    }
                  }
              })(b, w),
              isNaN(n) && (n = l.getBestMask(b, m.bind(null, b, r))),
              l.applyMask(n, b),
              m(b, r, n),
              {
                modules: b,
                version: t,
                errorCorrectionLevel: r,
                maskPattern: n,
                segments: p,
              }
            );
          })(e, r, y, p)
        );
      };
    },
    93878: (e, t, r) => {
      "use strict";
      r.d(t, {
        Vw: () => m,
        DO: () => s,
        CC: () => o,
        sd: () => a,
        Fe: () => n,
        Ht: () => c,
        uH: () => d,
        Id: () => g,
        qj: () => y,
        O8: () => h,
        po: () => w,
        Ow: () => u,
        fd: () => p,
        ZJ: () => f,
        DH: () => l,
      });
      let i =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      function n(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function s(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function a(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.createHasher");
        n(e.outputLen), n(e.blockLen);
      }
      function o(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function c(e, t) {
        s(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      function l(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function d(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      function h(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function u(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let p =
        68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0]
          ? (e) => e
          : function (e) {
              for (let r = 0; r < e.length; r++) {
                var t;
                e[r] =
                  (((t = e[r]) << 24) & 0xff000000) |
                  ((t << 8) & 0xff0000) |
                  ((t >>> 8) & 65280) |
                  ((t >>> 24) & 255);
              }
              return e;
            };
      function f(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e) throw Error("string expected");
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          s(e),
          e
        );
      }
      function g(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          s(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let n = e[t];
          r.set(n, i), (i += n.length);
        }
        return r;
      }
      class m {}
      function y(e) {
        let t = (t) => e().update(f(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function w(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        if (i && "function" == typeof i.randomBytes)
          return Uint8Array.from(i.randomBytes(e));
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    93965: (e, t, r) => {
      "use strict";
      r.d(t, { IP: () => a, T8: () => n, Ud: () => s, Ws: () => i });
      let i = {
        WALLET_ID: "@appkit/wallet_id",
        WALLET_NAME: "@appkit/wallet_name",
        SOLANA_WALLET: "@appkit/solana_wallet",
        SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
        ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
        CONNECTED_SOCIAL: "@appkit/connected_social",
        CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
        RECENT_WALLETS: "@appkit/recent_wallets",
        RECENT_WALLET: "@appkit/recent_wallet",
        DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
        ACTIVE_NAMESPACE: "@appkit/active_namespace",
        CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
        CONNECTION_STATUS: "@appkit/connection_status",
        SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
        SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
        TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
        NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
        PORTFOLIO_CACHE: "@appkit/portfolio_cache",
        ENS_CACHE: "@appkit/ens_cache",
        IDENTITY_CACHE: "@appkit/identity_cache",
        PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
        CONNECTIONS: "@appkit/connections",
        DISCONNECTED_CONNECTOR_IDS: "@appkit/disconnected_connector_ids",
        HISTORY_TRANSACTIONS_CACHE: "@appkit/history_transactions_cache",
        TOKEN_PRICE_CACHE: "@appkit/token_price_cache",
        RECENT_EMAILS: "@appkit/recent_emails",
        LATEST_APPKIT_VERSION: "@appkit/latest_version",
      };
      function n(e) {
        if (!e) throw Error("Namespace is required for CONNECTED_CONNECTOR_ID");
        return `@appkit/${e}:connected_connector_id`;
      }
      let s = {
        setItem(e, t) {
          a() && void 0 !== t && localStorage.setItem(e, t);
        },
        getItem(e) {
          if (a()) return localStorage.getItem(e) || void 0;
        },
        removeItem(e) {
          a() && localStorage.removeItem(e);
        },
        clear() {
          a() && localStorage.clear();
        },
      };
      function a() {
        return (
          "undefined" != typeof window && "undefined" != typeof localStorage
        );
      }
    },
    95230: (e, t, r) => {
      let i = r(50915);
      function n(e) {
        (this.genPoly = void 0),
          (this.degree = e),
          this.degree && this.initialize(this.degree);
      }
      (n.prototype.initialize = function (e) {
        (this.degree = e), (this.genPoly = i.generateECPolynomial(this.degree));
      }),
        (n.prototype.encode = function (e) {
          if (!this.genPoly) throw Error("Encoder not initialized");
          let t = new Uint8Array(e.length + this.degree);
          t.set(e);
          let r = i.mod(t, this.genPoly),
            n = this.degree - r.length;
          if (n > 0) {
            let e = new Uint8Array(this.degree);
            return e.set(r, n), e;
          }
          return r;
        }),
        (e.exports = n);
    },
    95789: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { L: () => s });
      let n = 256;
      function s(e = 11) {
        if (!i || n + e > 512) {
          (i = ""), (n = 0);
          for (let e = 0; e < 256; e++)
            i += ((256 + 256 * Math.random()) | 0).toString(16).substring(1);
        }
        return i.substring(n, n++ + e);
      }
    },
    97418: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { x: () => x });
      var n = r(1220),
        s = r(98866),
        a = r(45553),
        o = r(65103),
        c = r(71305),
        l = r(4768),
        d = r(73537),
        h = r(93481),
        u = r(10899),
        p = r(70417),
        f = r(81701),
        g = r(67869),
        m = r(28977),
        y = r(12319),
        w = r(58653);
      let b = {
        checkNamespaceConnectorId: (e, t) => u.a.getConnectorId(e) === t,
        isSocialProvider: (e) =>
          m.oU.DEFAULT_REMOTE_FEATURES.socials.includes(e),
        connectWalletConnect: ({
          walletConnect: e,
          connector: t,
          closeModalOnConnect: r = !0,
          redirectViewOnModalClose: i = "Connect",
          onOpen: n,
          onConnect: s,
        }) =>
          new Promise((a, c) => {
            if ((e && u.a.setActiveConnector(t), n?.(y.w.isMobile() && e), i)) {
              let e = f.W.subscribeKey("open", (t) => {
                t ||
                  (g.I.state.view !== i && g.I.replace(i),
                  e(),
                  c(Error("Modal closed")));
              });
            }
            let l = h.W.subscribeKey("activeCaipAddress", (e) => {
              e && (s?.(), r && f.W.close(), l(), a(o.C.parseCaipAddress(e)));
            });
          }),
        connectExternal: (e) =>
          new Promise((t, r) => {
            let i = h.W.subscribeKey("activeCaipAddress", (e) => {
              e && (f.W.close(), i(), t(o.C.parseCaipAddress(e)));
            });
            x.connectExternal(e, e.chain).catch(() => {
              i(), r(Error("Connection rejected"));
            });
          }),
        connectSocial({
          social: e,
          namespace: t,
          closeModalOnConnect: r = !0,
          onOpenFarcaster: i,
          onConnect: s,
        }) {
          let c = h.W.getAccountData(t),
            l = c?.socialWindow,
            d = c?.socialProvider,
            g = !1,
            m = null,
            b = t || h.W.state.activeChain,
            v = h.W.subscribeKey("activeCaipAddress", (e) => {
              e && (r && f.W.close(), v());
            });
          return new Promise((t, r) => {
            async function v(e) {
              if (e.data?.resultUri)
                if (e.origin === a.o.SECURE_SITE_SDK_ORIGIN) {
                  window.removeEventListener("message", v, !1);
                  try {
                    let i = u.a.getAuthConnector(b);
                    if (i && !g) {
                      let n = h.W.getAccountData(b);
                      l &&
                        (l.close(),
                        h.W.setAccountProp("socialWindow", void 0, b),
                        (l = n?.socialWindow)),
                        (g = !0);
                      let s = e.data.resultUri;
                      if (
                        (d &&
                          p.E.sendEvent({
                            type: "track",
                            event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                            properties: { provider: d },
                          }),
                        d)
                      ) {
                        w.i.setConnectedSocialProvider(d),
                          await x.connectExternal(
                            { id: i.id, type: i.type, socialUri: s },
                            i.chain
                          );
                        let e = h.W.state.activeCaipAddress;
                        if (!e) return void r(Error("Failed to connect"));
                        t(o.C.parseCaipAddress(e)),
                          p.E.sendEvent({
                            type: "track",
                            event: "SOCIAL_LOGIN_SUCCESS",
                            properties: { provider: d },
                          });
                      }
                    }
                  } catch (e) {
                    d &&
                      p.E.sendEvent({
                        type: "track",
                        event: "SOCIAL_LOGIN_ERROR",
                        properties: { provider: d, message: y.w.parseError(e) },
                      }),
                      r(Error("Failed to connect"));
                  }
                } else
                  d &&
                    p.E.sendEvent({
                      type: "track",
                      event: "SOCIAL_LOGIN_ERROR",
                      properties: { provider: d, message: "Untrusted Origin" },
                    });
            }
            !(async function () {
              if (e) {
                let t = h.W.getAccountData(b);
                h.W.setAccountProp("socialProvider", e, b),
                  (d = t?.socialProvider),
                  p.E.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_STARTED",
                    properties: { provider: d },
                  });
              }
              if ("farcaster" === d) {
                i?.();
                let t = f.W.subscribeKey("open", (i) => {
                    i ||
                      "farcaster" !== e ||
                      (r(Error("Popup closed")), s?.(), t());
                  }),
                  n = u.a.getAuthConnector();
                if (n) {
                  let e = h.W.getAccountData(b);
                  if (!e?.farcasterUrl)
                    try {
                      let { url: e } = await n.provider.getFarcasterUri();
                      h.W.setAccountProp("farcasterUrl", e, b);
                    } catch {
                      r(Error("Failed to connect to farcaster"));
                    }
                }
              } else {
                let e = u.a.getAuthConnector();
                m = y.w.returnOpenHref(
                  `${a.o.SECURE_SITE_SDK_ORIGIN}/loading`,
                  "popupWindow",
                  "width=600,height=800,scrollbars=yes"
                );
                try {
                  if (e && d) {
                    let { uri: t } = await e.provider.getSocialRedirectUri({
                      provider: d,
                    });
                    if (m && t) {
                      h.W.setAccountProp("socialWindow", (0, n.KR)(m), b),
                        (l = c?.socialWindow),
                        (m.location.href = t);
                      let e = setInterval(() => {
                        l?.closed &&
                          !g &&
                          (r(Error("Popup closed")), clearInterval(e));
                      }, 1e3);
                      window.addEventListener("message", v, !1);
                    } else
                      m?.close(),
                        r(Error("Failed to initiate social connection"));
                  }
                } catch {
                  r(Error("Failed to initiate social connection")), m?.close();
                }
              }
            })();
          });
        },
        connectEmail: ({
          closeModalOnConnect: e = !0,
          redirectViewOnModalClose: t = "Connect",
          onOpen: r,
          onConnect: i,
        }) =>
          new Promise((n, s) => {
            if ((r?.(), t)) {
              let e = f.W.subscribeKey("open", (r) => {
                r ||
                  (g.I.state.view !== t && g.I.replace(t),
                  e(),
                  s(Error("Modal closed")));
              });
            }
            let a = h.W.subscribeKey("activeCaipAddress", (t) => {
              t && (i?.(), e && f.W.close(), a(), n(o.C.parseCaipAddress(t)));
            });
          }),
        async updateEmail() {
          let e = w.i.getConnectedConnectorId(h.W.state.activeChain),
            t = u.a.getAuthConnector();
          if (!t) throw Error("No auth connector found");
          if (e !== a.o.CONNECTOR_ID.AUTH)
            throw Error("Not connected to email or social");
          let r = t.provider.getEmail() ?? "";
          return (
            await f.W.open({
              view: "UpdateEmailWallet",
              data: { email: r, redirectView: void 0 },
            }),
            new Promise((e, i) => {
              let n = setInterval(() => {
                  let i = t.provider.getEmail() ?? "";
                  i !== r &&
                    (f.W.close(), clearInterval(n), s(), e({ email: i }));
                }, 1e3),
                s = f.W.subscribeKey("open", (e) => {
                  e ||
                    ("Connect" !== g.I.state.view && g.I.push("Connect"),
                    clearInterval(n),
                    s(),
                    i(Error("Modal closed")));
                });
            })
          );
        },
        canSwitchToSmartAccount: (e) =>
          h.W.checkIfSmartAccountEnabled() &&
          (0, c.lj)(e) === d.Vl.ACCOUNT_TYPES.EOA,
      };
      var v = r(36964),
        C = r(24369);
      let E = (0, n.BX)({
          connections: new Map(),
          recentConnections: new Map(),
          isSwitchingConnection: !1,
          wcError: !1,
          buffering: !1,
          status: "disconnected",
        }),
        x = (0, v.X)({
          state: E,
          subscribe: (e) => (0, n.B1)(E, () => e(E)),
          subscribeKey: (e, t) => (0, s.u$)(E, e, t),
          _getClient: () => E._client,
          setClient(e) {
            E._client = (0, n.KR)(e);
          },
          initialize(e) {
            let t = e.filter((e) => !!e.namespace).map((e) => e.namespace);
            x.syncStorageConnections(t);
          },
          syncStorageConnections(e) {
            let t = w.i.getConnections();
            for (let r of e ?? Array.from(h.W.state.chains.keys())) {
              let e = t[r] ?? [],
                i = new Map(E.recentConnections);
              i.set(r, e), (E.recentConnections = i);
            }
          },
          getConnections: (e) => (e ? E.connections.get(e) ?? [] : []),
          hasAnyConnection: (e) =>
            Array.from(x.state.connections.values())
              .flatMap((e) => e)
              .some(({ connectorId: t }) => t === e),
          async connectWalletConnect({ cache: e = "auto" } = {}) {
            let t = y.w.isTelegram() || (y.w.isSafari() && y.w.isIos());
            if ("always" === e || ("auto" === e && t)) {
              if (i) {
                await i, (i = void 0);
                return;
              }
              if (!y.w.isPairingExpired(E?.wcPairingExpiry)) {
                let e = E.wcUri;
                E.wcUri = e;
                return;
              }
              (i = x
                ._getClient()
                ?.connectWalletConnect?.()
                .catch(() => void 0)),
                (x.state.status = "connecting"),
                await i,
                (i = void 0),
                (E.wcPairingExpiry = void 0),
                (x.state.status = "connected");
            } else await x._getClient()?.connectWalletConnect?.();
          },
          async connectExternal(e, t, r = !0) {
            let i = await x._getClient()?.connectExternal?.(e);
            return r && h.W.setActiveNamespace(t), i;
          },
          async reconnectExternal(e) {
            await x._getClient()?.reconnectExternal?.(e);
            let t = e.chain || h.W.state.activeChain;
            t && u.a.setConnectorId(e.id, t);
          },
          async setPreferredAccountType(e, t) {
            if (!t) return;
            f.W.setLoading(!0, h.W.state.activeChain);
            let r = u.a.getAuthConnector();
            r &&
              (h.W.setAccountProp("preferredAccountType", e, t),
              await r.provider.setPreferredAccount(e),
              w.i.setPreferredAccountTypes(
                Object.entries(h.W.state.chains).reduce((e, [t, r]) => {
                  let i = (0, c.lj)(t);
                  return void 0 !== i && (e[t] = i), e;
                }, {})
              ),
              await x.reconnectExternal(r),
              f.W.setLoading(!1, h.W.state.activeChain),
              p.E.sendEvent({
                type: "track",
                event: "SET_PREFERRED_ACCOUNT_TYPE",
                properties: {
                  accountType: e,
                  network: h.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }));
          },
          signMessage: async (e) => x._getClient()?.signMessage(e),
          parseUnits: (e, t) => x._getClient()?.parseUnits(e, t),
          formatUnits: (e, t) => x._getClient()?.formatUnits(e, t),
          updateBalance: (e) => x._getClient()?.updateBalance(e),
          sendTransaction: async (e) => x._getClient()?.sendTransaction(e),
          getCapabilities: async (e) => x._getClient()?.getCapabilities(e),
          grantPermissions: async (e) => x._getClient()?.grantPermissions(e),
          walletGetAssets: async (e) =>
            x._getClient()?.walletGetAssets(e) ?? {},
          estimateGas: async (e) => x._getClient()?.estimateGas(e),
          writeContract: async (e) => x._getClient()?.writeContract(e),
          getEnsAddress: async (e) => x._getClient()?.getEnsAddress(e),
          getEnsAvatar: async (e) => x._getClient()?.getEnsAvatar(e),
          checkInstalled: (e) => x._getClient()?.checkInstalled?.(e) || !1,
          resetWcConnection() {
            (E.wcUri = void 0),
              (E.wcPairingExpiry = void 0),
              (E.wcLinking = void 0),
              (E.recentWallet = void 0),
              (E.status = "disconnected"),
              C.W.resetTransactions(),
              w.i.deleteWalletConnectDeepLink(),
              w.i.deleteRecentWallet();
          },
          resetUri() {
            (E.wcUri = void 0), (E.wcPairingExpiry = void 0), (i = void 0);
          },
          finalizeWcConnection(e) {
            let { wcLinking: t, recentWallet: r } = x.state;
            t && w.i.setWalletConnectDeepLink(t),
              r && w.i.setAppKitRecent(r),
              e &&
                p.E.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  address: e,
                  properties: {
                    method: t ? "mobile" : "qrcode",
                    name: g.I.state.data?.wallet?.name || "Unknown",
                    view: g.I.state.view,
                    walletRank: r?.order,
                  },
                });
          },
          setWcBasic(e) {
            E.wcBasic = e;
          },
          setUri(e) {
            (E.wcUri = e), (E.wcPairingExpiry = y.w.getPairingExpiry());
          },
          setWcLinking(e) {
            E.wcLinking = e;
          },
          setWcError(e) {
            (E.wcError = e), (E.buffering = !1);
          },
          setRecentWallet(e) {
            E.recentWallet = e;
          },
          setBuffering(e) {
            E.buffering = e;
          },
          setStatus(e) {
            E.status = e;
          },
          setIsSwitchingConnection(e) {
            E.isSwitchingConnection = e;
          },
          async disconnect({ id: e, namespace: t, initialDisconnect: r } = {}) {
            try {
              await x
                ._getClient()
                ?.disconnect({
                  id: e,
                  chainNamespace: t,
                  initialDisconnect: r,
                });
            } catch (e) {
              throw new v.A("Failed to disconnect", "INTERNAL_SDK_ERROR", e);
            }
          },
          async disconnectConnector({ id: e, namespace: t }) {
            try {
              await x
                ._getClient()
                ?.disconnectConnector({ id: e, namespace: t });
            } catch (e) {
              throw new v.A(
                "Failed to disconnect connector",
                "INTERNAL_SDK_ERROR",
                e
              );
            }
          },
          setConnections(e, t) {
            let r = new Map(E.connections);
            r.set(t, e), (E.connections = r);
          },
          async handleAuthAccountSwitch({ address: e, namespace: t }) {
            let r = h.W.getAccountData(t),
              i = r?.user?.accounts?.find((e) => "smartAccount" === e.type),
              n =
                i &&
                i.address.toLowerCase() === e.toLowerCase() &&
                b.canSwitchToSmartAccount(t)
                  ? "smartAccount"
                  : "eoa";
            await x.setPreferredAccountType(n, t);
          },
          async handleActiveConnection({
            connection: e,
            namespace: t,
            address: r,
          }) {
            let i = u.a.getConnectorById(e.connectorId),
              n = e.connectorId === a.o.CONNECTOR_ID.AUTH;
            if (!i)
              throw Error(
                `No connector found for connection: ${e.connectorId}`
              );
            if (n)
              n &&
                r &&
                (await x.handleAuthAccountSwitch({ address: r, namespace: t }));
            else {
              let e = await x.connectExternal(
                {
                  id: i.id,
                  type: i.type,
                  provider: i.provider,
                  address: r,
                  chain: t,
                },
                t
              );
              return e?.address;
            }
            return r;
          },
          async handleDisconnectedConnection({
            connection: e,
            namespace: t,
            address: r,
            closeModalOnConnect: i,
          }) {
            let n,
              s = u.a.getConnectorById(e.connectorId),
              o = e.auth?.name?.toLowerCase(),
              c = e.connectorId === a.o.CONNECTOR_ID.AUTH,
              l = e.connectorId === a.o.CONNECTOR_ID.WALLET_CONNECT;
            if (!s)
              throw Error(
                `No connector found for connection: ${e.connectorId}`
              );
            if (c)
              if (o && b.isSocialProvider(o)) {
                let { address: e } = await b.connectSocial({
                  social: o,
                  closeModalOnConnect: i,
                  onOpenFarcaster() {
                    f.W.open({ view: "ConnectingFarcaster" });
                  },
                  onConnect() {
                    g.I.replace("ProfileWallets");
                  },
                });
                n = e;
              } else {
                let { address: e } = await b.connectEmail({
                  closeModalOnConnect: i,
                  onOpen() {
                    f.W.open({ view: "EmailLogin" });
                  },
                  onConnect() {
                    g.I.replace("ProfileWallets");
                  },
                });
                n = e;
              }
            else if (l) {
              let { address: e } = await b.connectWalletConnect({
                walletConnect: !0,
                connector: s,
                closeModalOnConnect: i,
                onOpen(e) {
                  let t = e ? "AllWallets" : "ConnectingWalletConnect";
                  f.W.state.open ? g.I.push(t) : f.W.open({ view: t });
                },
                onConnect() {
                  g.I.replace("ProfileWallets");
                },
              });
              n = e;
            } else {
              let e = await x.connectExternal(
                { id: s.id, type: s.type, provider: s.provider, chain: t },
                t
              );
              e && (n = e.address);
            }
            return (
              c &&
                r &&
                (await x.handleAuthAccountSwitch({ address: r, namespace: t })),
              n
            );
          },
          async switchConnection({
            connection: e,
            address: t,
            namespace: r,
            closeModalOnConnect: i,
            onChange: n,
          }) {
            let s,
              a = h.W.getAccountData(r)?.caipAddress;
            if (a) {
              let { address: e } = o.C.parseCaipAddress(a);
              s = e;
            }
            let c = l.b.getConnectionStatus(e, r);
            switch (c) {
              case "connected":
              case "active": {
                let i = await x.handleActiveConnection({
                  connection: e,
                  namespace: r,
                  address: t,
                });
                if (s && i) {
                  let e = i.toLowerCase() !== s.toLowerCase();
                  n?.({
                    address: i,
                    namespace: r,
                    hasSwitchedAccount: e,
                    hasSwitchedWallet: "active" === c,
                  });
                }
                break;
              }
              case "disconnected": {
                let s = await x.handleDisconnectedConnection({
                  connection: e,
                  namespace: r,
                  address: t,
                  closeModalOnConnect: i,
                });
                s &&
                  n?.({
                    address: s,
                    namespace: r,
                    hasSwitchedAccount: !0,
                    hasSwitchedWallet: !0,
                  });
                break;
              }
              default:
                throw Error(`Invalid connection status: ${c}`);
            }
          },
        });
    },
    98410: (e, t, r) => {
      "use strict";
      r.d(t, { MZ: () => i.M, wk: () => n.w });
      var i = r(66575),
        n = r(3515);
    },
    98502: (e, t, r) => {
      "use strict";
      r.d(t, {
        mN: () => A,
        AH: () => l,
        W3: () => C,
        Ec: () => E,
        iz: () => c,
      });
      let i = globalThis,
        n =
          i.ShadowRoot &&
          (void 0 === i.ShadyCSS || i.ShadyCSS.nativeShadow) &&
          "adoptedStyleSheets" in Document.prototype &&
          "replace" in CSSStyleSheet.prototype,
        s = Symbol(),
        a = new WeakMap();
      class o {
        constructor(e, t, r) {
          if (((this._$cssResult$ = !0), r !== s))
            throw Error(
              "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
            );
          (this.cssText = e), (this.t = t);
        }
        get styleSheet() {
          let e = this.o,
            t = this.t;
          if (n && void 0 === e) {
            let r = void 0 !== t && 1 === t.length;
            r && (e = a.get(t)),
              void 0 === e &&
                ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
                r && a.set(t, e));
          }
          return e;
        }
        toString() {
          return this.cssText;
        }
      }
      let c = (e) => new o("string" == typeof e ? e : e + "", void 0, s),
        l = (e, ...t) =>
          new o(
            1 === e.length
              ? e[0]
              : t.reduce(
                  (t, r, i) =>
                    t +
                    ((e) => {
                      if (!0 === e._$cssResult$) return e.cssText;
                      if ("number" == typeof e) return e;
                      throw Error(
                        "Value passed to 'css' function must be a 'css' function result: " +
                          e +
                          ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                      );
                    })(r) +
                    e[i + 1],
                  e[0]
                ),
            e,
            s
          ),
        d = n
          ? (e) => e
          : (e) =>
              e instanceof CSSStyleSheet
                ? ((e) => {
                    let t = "";
                    for (let r of e.cssRules) t += r.cssText;
                    return c(t);
                  })(e)
                : e,
        {
          is: h,
          defineProperty: u,
          getOwnPropertyDescriptor: p,
          getOwnPropertyNames: f,
          getOwnPropertySymbols: g,
          getPrototypeOf: m,
        } = Object,
        y = globalThis,
        w = y.trustedTypes,
        b = w ? w.emptyScript : "",
        v = y.reactiveElementPolyfillSupport,
        C = {
          toAttribute(e, t) {
            switch (t) {
              case Boolean:
                e = e ? b : null;
                break;
              case Object:
              case Array:
                e = null == e ? e : JSON.stringify(e);
            }
            return e;
          },
          fromAttribute(e, t) {
            let r = e;
            switch (t) {
              case Boolean:
                r = null !== e;
                break;
              case Number:
                r = null === e ? null : Number(e);
                break;
              case Object:
              case Array:
                try {
                  r = JSON.parse(e);
                } catch (e) {
                  r = null;
                }
            }
            return r;
          },
        },
        E = (e, t) => !h(e, t),
        x = {
          attribute: !0,
          type: String,
          converter: C,
          reflect: !1,
          useDefault: !1,
          hasChanged: E,
        };
      (Symbol.metadata ??= Symbol("metadata")),
        (y.litPropertyMetadata ??= new WeakMap());
      class A extends HTMLElement {
        static addInitializer(e) {
          this._$Ei(), (this.l ??= []).push(e);
        }
        static get observedAttributes() {
          return this.finalize(), this._$Eh && [...this._$Eh.keys()];
        }
        static createProperty(e, t = x) {
          if (
            (t.state && (t.attribute = !1),
            this._$Ei(),
            this.prototype.hasOwnProperty(e) &&
              ((t = Object.create(t)).wrapped = !0),
            this.elementProperties.set(e, t),
            !t.noAccessor)
          ) {
            let r = Symbol(),
              i = this.getPropertyDescriptor(e, r, t);
            void 0 !== i && u(this.prototype, e, i);
          }
        }
        static getPropertyDescriptor(e, t, r) {
          let { get: i, set: n } = p(this.prototype, e) ?? {
            get() {
              return this[t];
            },
            set(e) {
              this[t] = e;
            },
          };
          return {
            get: i,
            set(t) {
              let s = i?.call(this);
              n?.call(this, t), this.requestUpdate(e, s, r);
            },
            configurable: !0,
            enumerable: !0,
          };
        }
        static getPropertyOptions(e) {
          return this.elementProperties.get(e) ?? x;
        }
        static _$Ei() {
          if (this.hasOwnProperty("elementProperties")) return;
          let e = m(this);
          e.finalize(),
            void 0 !== e.l && (this.l = [...e.l]),
            (this.elementProperties = new Map(e.elementProperties));
        }
        static finalize() {
          if (this.hasOwnProperty("finalized")) return;
          if (
            ((this.finalized = !0),
            this._$Ei(),
            this.hasOwnProperty("properties"))
          ) {
            let e = this.properties;
            for (let t of [...f(e), ...g(e)]) this.createProperty(t, e[t]);
          }
          let e = this[Symbol.metadata];
          if (null !== e) {
            let t = litPropertyMetadata.get(e);
            if (void 0 !== t)
              for (let [e, r] of t) this.elementProperties.set(e, r);
          }
          for (let [e, t] of ((this._$Eh = new Map()),
          this.elementProperties)) {
            let r = this._$Eu(e, t);
            void 0 !== r && this._$Eh.set(r, e);
          }
          this.elementStyles = this.finalizeStyles(this.styles);
        }
        static finalizeStyles(e) {
          let t = [];
          if (Array.isArray(e))
            for (let r of new Set(e.flat(1 / 0).reverse())) t.unshift(d(r));
          else void 0 !== e && t.push(d(e));
          return t;
        }
        static _$Eu(e, t) {
          let r = t.attribute;
          return !1 === r
            ? void 0
            : "string" == typeof r
            ? r
            : "string" == typeof e
            ? e.toLowerCase()
            : void 0;
        }
        constructor() {
          super(),
            (this._$Ep = void 0),
            (this.isUpdatePending = !1),
            (this.hasUpdated = !1),
            (this._$Em = null),
            this._$Ev();
        }
        _$Ev() {
          (this._$ES = new Promise((e) => (this.enableUpdating = e))),
            (this._$AL = new Map()),
            this._$E_(),
            this.requestUpdate(),
            this.constructor.l?.forEach((e) => e(this));
        }
        addController(e) {
          (this._$EO ??= new Set()).add(e),
            void 0 !== this.renderRoot &&
              this.isConnected &&
              e.hostConnected?.();
        }
        removeController(e) {
          this._$EO?.delete(e);
        }
        _$E_() {
          let e = new Map();
          for (let t of this.constructor.elementProperties.keys())
            this.hasOwnProperty(t) && (e.set(t, this[t]), delete this[t]);
          e.size > 0 && (this._$Ep = e);
        }
        createRenderRoot() {
          let e =
            this.shadowRoot ??
            this.attachShadow(this.constructor.shadowRootOptions);
          return (
            ((e, t) => {
              if (n)
                e.adoptedStyleSheets = t.map((e) =>
                  e instanceof CSSStyleSheet ? e : e.styleSheet
                );
              else
                for (let r of t) {
                  let t = document.createElement("style"),
                    n = i.litNonce;
                  void 0 !== n && t.setAttribute("nonce", n),
                    (t.textContent = r.cssText),
                    e.appendChild(t);
                }
            })(e, this.constructor.elementStyles),
            e
          );
        }
        connectedCallback() {
          (this.renderRoot ??= this.createRenderRoot()),
            this.enableUpdating(!0),
            this._$EO?.forEach((e) => e.hostConnected?.());
        }
        enableUpdating(e) {}
        disconnectedCallback() {
          this._$EO?.forEach((e) => e.hostDisconnected?.());
        }
        attributeChangedCallback(e, t, r) {
          this._$AK(e, r);
        }
        _$ET(e, t) {
          let r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
          if (void 0 !== i && !0 === r.reflect) {
            let n = (
              void 0 !== r.converter?.toAttribute ? r.converter : C
            ).toAttribute(t, r.type);
            (this._$Em = e),
              null == n ? this.removeAttribute(i) : this.setAttribute(i, n),
              (this._$Em = null);
          }
        }
        _$AK(e, t) {
          let r = this.constructor,
            i = r._$Eh.get(e);
          if (void 0 !== i && this._$Em !== i) {
            let e = r.getPropertyOptions(i),
              n =
                "function" == typeof e.converter
                  ? { fromAttribute: e.converter }
                  : void 0 !== e.converter?.fromAttribute
                  ? e.converter
                  : C;
            this._$Em = i;
            let s = n.fromAttribute(t, e.type);
            (this[i] = s ?? this._$Ej?.get(i) ?? s), (this._$Em = null);
          }
        }
        requestUpdate(e, t, r) {
          if (void 0 !== e) {
            let i = this.constructor,
              n = this[e];
            if (
              !(
                ((r ??= i.getPropertyOptions(e)).hasChanged ?? E)(n, t) ||
                (r.useDefault &&
                  r.reflect &&
                  n === this._$Ej?.get(e) &&
                  !this.hasAttribute(i._$Eu(e, r)))
              )
            )
              return;
            this.C(e, t, r);
          }
          !1 === this.isUpdatePending && (this._$ES = this._$EP());
        }
        C(e, t, { useDefault: r, reflect: i, wrapped: n }, s) {
          (r &&
            !(this._$Ej ??= new Map()).has(e) &&
            (this._$Ej.set(e, s ?? t ?? this[e]), !0 !== n || void 0 !== s)) ||
            (this._$AL.has(e) ||
              (this.hasUpdated || r || (t = void 0), this._$AL.set(e, t)),
            !0 === i && this._$Em !== e && (this._$Eq ??= new Set()).add(e));
        }
        async _$EP() {
          this.isUpdatePending = !0;
          try {
            await this._$ES;
          } catch (e) {
            Promise.reject(e);
          }
          let e = this.scheduleUpdate();
          return null != e && (await e), !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          if (!this.isUpdatePending) return;
          if (!this.hasUpdated) {
            if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
              for (let [e, t] of this._$Ep) this[e] = t;
              this._$Ep = void 0;
            }
            let e = this.constructor.elementProperties;
            if (e.size > 0)
              for (let [t, r] of e) {
                let { wrapped: e } = r,
                  i = this[t];
                !0 !== e ||
                  this._$AL.has(t) ||
                  void 0 === i ||
                  this.C(t, void 0, r, i);
              }
          }
          let e = !1,
            t = this._$AL;
          try {
            (e = this.shouldUpdate(t))
              ? (this.willUpdate(t),
                this._$EO?.forEach((e) => e.hostUpdate?.()),
                this.update(t))
              : this._$EM();
          } catch (t) {
            throw ((e = !1), this._$EM(), t);
          }
          e && this._$AE(t);
        }
        willUpdate(e) {}
        _$AE(e) {
          this._$EO?.forEach((e) => e.hostUpdated?.()),
            this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
            this.updated(e);
        }
        _$EM() {
          (this._$AL = new Map()), (this.isUpdatePending = !1);
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$ES;
        }
        shouldUpdate(e) {
          return !0;
        }
        update(e) {
          (this._$Eq &&= this._$Eq.forEach((e) => this._$ET(e, this[e]))),
            this._$EM();
        }
        updated(e) {}
        firstUpdated(e) {}
      }
      (A.elementStyles = []),
        (A.shadowRootOptions = { mode: "open" }),
        (A.elementProperties = new Map()),
        (A.finalized = new Map()),
        v?.({ ReactiveElement: A }),
        (y.reactiveElementVersions ??= []).push("2.1.1");
    },
    98722: (e, t, r) => {
      "use strict";
      function i() {
        let e = () => void 0,
          t = () => void 0;
        return {
          promise: new Promise((r, i) => {
            (e = r), (t = i);
          }),
          resolve: e,
          reject: t,
        };
      }
      r.d(t, { Y: () => i });
    },
    98866: (e, t, r) => {
      "use strict";
      r.d(t, { u$: () => n, zC: () => c });
      var i = r(1220);
      function n(e, t, r, n) {
        let s = e[t];
        return (0, i.B1)(
          e,
          () => {
            let i = e[t];
            Object.is(s, i) || r((s = i));
          },
          n
        );
      }
      Symbol();
      let { proxyStateMap: s, snapCache: a } = (0, i.h2)(),
        o = (e) => s.has(e);
      function c(e) {
        let t = [],
          r = 0,
          n = new Map(),
          s = new WeakMap(),
          c = (e) => s.get(e) || n;
        if (e) {
          if ("function" != typeof e[Symbol.iterator])
            throw TypeError(
              "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
            );
          for (let [i, s] of e) n.set(i, r), (t[r++] = s);
        }
        let l = {
            data: t,
            index: r,
            epoch: 0,
            get size() {
              return (
                o(this) ||
                  (() => {
                    let e = a.get(l),
                      t = null == e ? void 0 : e[1];
                    if (t && !s.has(t)) {
                      let e = new Map(n);
                      s.set(t, e);
                    }
                  })(),
                c(this).size
              );
            },
            get(e) {
              let t = c(this).get(e);
              return void 0 === t ? void this.epoch : this.data[t];
            },
            has(e) {
              let t = c(this);
              return this.epoch, t.has(e);
            },
            set(e, t) {
              if (!o(this))
                throw Error("Cannot perform mutations on a snapshot");
              let r = n.get(e);
              return (
                void 0 === r
                  ? (n.set(e, this.index), (this.data[this.index++] = t))
                  : (this.data[r] = t),
                this.epoch++,
                this
              );
            },
            delete(e) {
              if (!o(this))
                throw Error("Cannot perform mutations on a snapshot");
              let t = n.get(e);
              return (
                void 0 !== t &&
                (delete this.data[t], n.delete(e), this.epoch++, !0)
              );
            },
            clear() {
              if (!o(this))
                throw Error("Cannot perform mutations on a snapshot");
              (this.data.length = 0), (this.index = 0), this.epoch++, n.clear();
            },
            forEach(e) {
              this.epoch,
                c(this).forEach((t, r) => {
                  e(this.data[t], r, this);
                });
            },
            *entries() {
              for (let [e, t] of (this.epoch, c(this))) yield [e, this.data[t]];
            },
            *keys() {
              for (let e of (this.epoch, c(this).keys())) yield e;
            },
            *values() {
              for (let e of (this.epoch, c(this).values())) yield this.data[e];
            },
            [Symbol.iterator]() {
              return this.entries();
            },
            get [Symbol.toStringTag]() {
              return "Map";
            },
            toJSON() {
              return new Map(this.entries());
            },
          },
          d = (0, i.BX)(l);
        return (
          Object.defineProperties(d, {
            size: { enumerable: !1 },
            index: { enumerable: !1 },
            epoch: { enumerable: !1 },
            data: { enumerable: !1 },
            toJSON: { enumerable: !1 },
          }),
          Object.seal(d),
          d
        );
      }
      let { proxyStateMap: l, snapCache: d } = (0, i.h2)();
    },
    99691: (e, t, r) => {
      "use strict";
      var i = r(83138),
        n = r(98410),
        s = r(52321);
      let a = Symbol.for(""),
        o = (e) => {
          if (e?.r === a) return e?._$litStatic$;
        },
        c = new Map(),
        l =
          (e) =>
          (t, ...r) => {
            let i,
              n,
              s = r.length,
              a = [],
              l = [],
              d,
              h = 0,
              u = !1;
            for (; h < s; ) {
              for (d = t[h]; h < s && void 0 !== (i = o((n = r[h]))); )
                (d += i + t[++h]), (u = !0);
              h !== s && l.push(n), a.push(d), h++;
            }
            if ((h === s && a.push(t[s]), u)) {
              let e = a.join("$$lit$$");
              void 0 === (t = c.get(e)) && ((a.raw = a), c.set(e, (t = a))),
                (r = l);
            }
            return e(t, ...r);
          },
        d = l(s.qy);
      l(s.JW), l(s.ej);
      let h = (0,
        i.JW)`<svg width="30" height="30" viewBox="0 0 30 30" fill="none">
  <g clip-path="url(#clip0_87_33)">
    <path d="M23.9367 2.29447e-07H6.05917C5.26333 -0.000218805 4.47526 0.156384 3.73997 0.46086C3.00469 0.765337 2.33661 1.21172 1.77391 1.7745C1.21121 2.33727 0.764917 3.00542 0.460542 3.74074C0.156167 4.47607 -0.000327963 5.26417 5.16031e-07 6.06V23.9433C4.48257e-07 24.7389 0.156744 25.5267 0.461276 26.2617C0.765808 26.9967 1.21216 27.6645 1.77484 28.2269C2.33752 28.7894 3.0055 29.2355 3.74061 29.5397C4.47573 29.8439 5.26358 30.0003 6.05917 30H23.9417C25.5486 29.9996 27.0895 29.3609 28.2257 28.2245C29.3618 27.0881 30 25.5469 30 23.94V6.06C29.9993 4.45241 29.3602 2.91091 28.2232 1.77449C27.0861 0.638064 25.5443 -0.000220881 23.9367 2.29447e-07Z" fill="url(#paint0_linear_87_33)"/>
    <path d="M14.8708 6.89259L15.4783 5.84259C15.5679 5.68703 15.6873 5.55064 15.8296 5.44122C15.9719 5.3318 16.1344 5.25148 16.3078 5.20486C16.4812 5.15824 16.662 5.14622 16.8401 5.1695C17.0181 5.19277 17.1898 5.25088 17.3453 5.34051C17.5009 5.43013 17.6373 5.54952 17.7467 5.69186C17.8561 5.83419 17.9364 5.99669 17.9831 6.17006C18.0297 6.34344 18.0417 6.5243 18.0184 6.70232C17.9952 6.88034 17.9371 7.05203 17.8474 7.20759L11.9949 17.3401H16.2283C17.5999 17.3401 18.3691 18.9526 17.7724 20.0701H5.36159C5.18215 20.0707 5.00436 20.0359 4.83845 19.9675C4.67254 19.8992 4.5218 19.7986 4.39492 19.6718C4.26803 19.5449 4.16751 19.3941 4.09915 19.2282C4.03079 19.0623 3.99593 18.8845 3.99659 18.7051C3.99659 17.9476 4.60492 17.3401 5.36159 17.3401H8.84159L13.2958 9.61926L11.9041 7.20426C11.738 6.89096 11.7 6.52543 11.7982 6.18469C11.8963 5.84395 12.1229 5.5546 12.4301 5.37763C12.7374 5.20065 13.1014 5.14987 13.4454 5.23599C13.7893 5.3221 14.0864 5.53838 14.2741 5.83926L14.8708 6.89259ZM9.60659 21.4759L8.29409 23.7526C8.20446 23.9082 8.08506 24.0446 7.94271 24.1541C7.80035 24.2636 7.63783 24.344 7.46441 24.3906C7.291 24.4373 7.11009 24.4493 6.93202 24.4261C6.75395 24.4028 6.58221 24.3447 6.42659 24.2551C6.27097 24.1655 6.13454 24.0461 6.02506 23.9037C5.91559 23.7613 5.83523 23.5988 5.78857 23.4254C5.74191 23.252 5.72986 23.0711 5.75311 22.893C5.77637 22.715 5.83446 22.5432 5.92409 22.3876L6.89909 20.7001C8.00159 20.3584 8.89742 20.6209 9.60659 21.4759ZM20.9066 17.3476H24.4583C25.2158 17.3476 25.8233 17.9551 25.8233 18.7126C25.8233 19.4701 25.2149 20.0776 24.4583 20.0776H22.4858L23.8166 22.3876C24.1916 23.0443 23.9708 23.8726 23.3149 24.2551C23.0006 24.4359 22.6274 24.4845 22.2772 24.3903C21.927 24.2961 21.6286 24.0667 21.4474 23.7526C19.2058 19.8643 17.5216 16.9534 16.4041 15.0151C15.2608 13.0426 16.0783 11.0626 16.8841 10.3909C17.7799 11.9293 19.1191 14.2501 20.9074 17.3476H20.9066Z" fill="white"/>
  </g>
  <defs>
    <linearGradient id="paint0_linear_87_33" x1="15" y1="2.29447e-07" x2="15" y2="30" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB"/>
      <stop offset="1" stop-color="#2072F3"/>
    </linearGradient>
    <clipPath id="clip0_87_33">
      <rect width="30" height="30" fill="white"/>
    </clipPath>
  </defs>
</svg>`,
        u = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
        p = (0, i.JW)`
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 8 11">
    <path
      fill="var(--apkt-tokens-theme-textPrimary)"
      d="M7.862 4.86c.159-1.064-.652-1.637-1.76-2.018l.36-1.443-.879-.218-.35 1.404c-.23-.058-.468-.112-.703-.166l.352-1.413-.877-.219-.36 1.442a29.02 29.02 0 0 1-.56-.132v-.005l-1.21-.302-.234.938s.652.15.638.158c.356.089.42.324.41.51l-.41 1.644a.715.715 0 0 1 .09.03l-.092-.024-.574 2.302c-.044.108-.154.27-.402.208.008.013-.639-.16-.639-.16L.227 8.403l1.142.285c.213.053.42.109.626.161l-.363 1.459.877.218.36-1.443c.239.065.472.125.7.182l-.36 1.436.879.219.363-1.456c1.497.283 2.623.17 3.097-1.185.381-1.09-.02-1.719-.807-2.129.574-.132 1.006-.51 1.12-1.289ZM5.856 7.673c-.272 1.09-2.107.5-2.702.353l.482-1.933c.595.149 2.503.443 2.22 1.58Zm.271-2.829c-.247.992-1.775.488-2.27.365l.436-1.753c.496.124 2.092.354 1.834 1.388Z"
    />
  </svg>
`,
        f = (0,
        i.JW)`<svg width="30" height="30" viewBox="0 0 30 30" fill="none">
<path d="M14.9978 7.80003H27.4668C26.2032 5.61107 24.3857 3.79333 22.1968 2.52955C20.008 1.26577 17.525 0.600485 14.9975 0.600586C12.47 0.600687 9.98712 1.26617 7.79838 2.53012C5.60964 3.79408 3.79221 5.61197 2.52881 7.80103L8.76281 18.599L8.76881 18.598C8.13412 17.5044 7.79906 16.2628 7.79743 14.9983C7.79579 13.7339 8.12764 12.4914 8.7595 11.3961C9.39136 10.3008 10.3009 9.39159 11.3963 8.76005C12.4918 8.12851 13.7344 7.79702 14.9988 7.79903L14.9978 7.80003Z" fill="url(#paint0_linear_87_32)"/>
<path d="M21.237 18.5981L15.003 29.3961C17.5305 29.3961 20.0134 28.7308 22.2022 27.467C24.391 26.2032 26.2086 24.3854 27.4721 22.1965C28.7356 20.0075 29.4006 17.5245 29.4003 14.997C29.3999 12.4695 28.7342 9.9867 27.47 7.7981H15.002L15 7.8041C16.2642 7.80168 17.5067 8.13257 18.6022 8.76342C19.6977 9.39428 20.6076 10.3028 21.2401 11.3974C21.8726 12.492 22.2053 13.734 22.2048 14.9982C22.2042 16.2623 21.8704 17.504 21.237 18.5981Z" fill="url(#paint1_linear_87_32)"/>
<path d="M8.76502 18.601L2.53102 7.80298C1.26664 9.99172 0.600848 12.4748 0.600586 15.0025C0.600324 17.5302 1.2656 20.0134 2.52953 22.2024C3.79345 24.3914 5.61145 26.209 7.80071 27.4725C9.98998 28.736 12.4733 29.4008 15.001 29.4L21.236 18.602L21.232 18.598C20.6022 19.6941 19.6944 20.6049 18.6003 21.2383C17.5062 21.8717 16.2644 22.2055 15.0002 22.2059C13.7359 22.2063 12.4939 21.8733 11.3994 21.2406C10.3049 20.6079 9.39657 19.6977 8.76602 18.602L8.76502 18.601Z" fill="url(#paint2_linear_87_32)"/>
<path d="M14.9998 22.2C16.9094 22.2 18.7407 21.4415 20.091 20.0912C21.4412 18.741 22.1998 16.9096 22.1998 15C22.1998 13.0905 21.4412 11.2591 20.091 9.90888C18.7407 8.55862 16.9094 7.80005 14.9998 7.80005C13.0902 7.80005 11.2589 8.55862 9.90864 9.90888C8.55837 11.2591 7.7998 13.0905 7.7998 15C7.7998 16.9096 8.55837 18.741 9.90864 20.0912C11.2589 21.4415 13.0902 22.2 14.9998 22.2Z" fill="white"/>
<path d="M14.9998 20.7C16.5115 20.7 17.9614 20.0995 19.0303 19.0306C20.0993 17.9616 20.6998 16.5118 20.6998 15C20.6998 13.4883 20.0993 12.0385 19.0303 10.9695C17.9614 9.90058 16.5115 9.30005 14.9998 9.30005C13.4881 9.30005 12.0383 9.90058 10.9693 10.9695C9.90034 12.0385 9.2998 13.4883 9.2998 15C9.2998 16.5118 9.90034 17.9616 10.9693 19.0306C12.0383 20.0995 13.4881 20.7 14.9998 20.7Z" fill="#1A73E8"/>
<defs>
  <linearGradient id="paint0_linear_87_32" x1="3.29381" y1="2.99503" x2="38.0998" y2="2.99503" gradientUnits="userSpaceOnUse">
    <stop stop-color="#D93025"/>
    <stop offset="1" stop-color="#EA4335"/>
  </linearGradient>
  <linearGradient id="paint1_linear_87_32" x1="17.953" y1="29.1431" x2="34.194" y2="-0.298904" gradientUnits="userSpaceOnUse">
    <stop stop-color="#FCC934"/>
    <stop offset="1" stop-color="#FBBC04"/>
  </linearGradient>
  <linearGradient id="paint2_linear_87_32" x1="22.873" y1="28.2" x2="6.63202" y2="-1.24102" gradientUnits="userSpaceOnUse">
    <stop stop-color="#1E8E3E"/>
    <stop offset="1" stop-color="#34A853"/>
  </linearGradient>
</defs>
</svg>`,
        g = (0, i.JW)` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`,
        m = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`,
        y = (0, i.JW)`<svg
  xmlns="http://www.w3.org/2000/svg"
  fill="none"
  viewBox="0 0 9 12"
>
  <path
    fill="var(--apkt-tokens-theme-textPrimary)"
    d="M4.666.001v4.435l3.748 1.675L4.666.001Zm0 0L.917 6.111l3.749-1.675V.001Zm0 8.984V12l3.75-5.19-3.75 2.176Zm0 3.014V8.985L.917 6.81 4.666 12Zm0-3.712 3.748-2.176-3.748-1.675v3.851Z"
  />
  <path fill="var(--apkt-tokens-theme-textPrimary)" d="m.917 6.111 3.749 2.176v-3.85L.917 6.11Z" />
</svg>`,
        w = (0, i.JW)`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`,
        b = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
        v = (0,
        i.JW)`<svg style="border-radius: 9999px; overflow: hidden;"  fill="none" viewBox="0 0 1000 1000">
  <rect width="1000" height="1000" rx="9999" ry="9999" fill="#855DCD"/>
  <path fill="#855DCD" d="M0 0h1000v1000H0V0Z" />
  <path
    fill="#fff"
    d="M320 248h354v504h-51.96V521.13h-.5c-5.76-63.8-59.31-113.81-124.54-113.81s-118.78 50-124.53 113.81h-.5V752H320V248Z"
  />
  <path
    fill="#fff"
    d="m225 320 21.16 71.46h17.9v289.09a16.29 16.29 0 0 0-16.28 16.24v19.49h-3.25a16.3 16.3 0 0 0-16.28 16.24V752h182.26v-19.48a16.22 16.22 0 0 0-16.28-16.24h-3.25v-19.5a16.22 16.22 0 0 0-16.28-16.23h-19.52V320H225Zm400.3 360.55a16.3 16.3 0 0 0-15.04 10.02 16.2 16.2 0 0 0-1.24 6.22v19.49h-3.25a16.29 16.29 0 0 0-16.27 16.24V752h182.24v-19.48a16.23 16.23 0 0 0-16.27-16.24h-3.25v-19.5a16.2 16.2 0 0 0-10.04-15 16.3 16.3 0 0 0-6.23-1.23v-289.1h17.9L775 320H644.82v360.55H625.3Z"
  />
</svg>`,
        C = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
        E = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`,
        x = (0,
        i.JW)` <svg width="27" height="30" viewBox="0 0 27 30" fill="none">
  <path d="M12.5395 14.3237L0.116699 27.5049V27.5188C0.251527 28.0177 0.49972 28.4788 0.841941 28.866C1.18416 29.2533 1.61117 29.5563 2.0897 29.7515C2.56823 29.9467 3.08536 30.0287 3.60081 29.9913C4.11625 29.9538 4.61609 29.7979 5.06139 29.5356L5.0975 29.512L19.0718 21.4519L12.5395 14.3237Z" fill="#EA4335"/>
  <path d="M25.103 12.0833L25.0919 12.0722L19.0611 8.57202L12.2607 14.6279L19.0847 21.4504L25.0919 17.9864C25.6229 17.6983 26.0665 17.2725 26.376 16.7537C26.6854 16.2349 26.8493 15.6422 26.8505 15.0381C26.8516 14.434 26.6899 13.8408 26.3824 13.3208C26.0749 12.8008 25.633 12.3734 25.103 12.0833Z" fill="#FBBC04"/>
  <path d="M0.116672 2.49553C0.047224 2.7761 0 3.05528 0 3.35946V26.6537C0 26.9565 0.0347234 27.237 0.116672 27.5162L12.959 14.6725L0.116672 2.49553Z" fill="#4285F4"/>
  <path d="M12.634 15.0001L19.0607 8.57198L5.0975 0.477133C4.65115 0.210463 4.14916 0.0506574 3.63079 0.0102139C3.11242 -0.0302296 2.59172 0.0497852 2.10941 0.244001C1.6271 0.438216 1.19625 0.741368 0.850556 1.12975C0.504864 1.51813 0.253698 1.98121 0.116699 2.48279L12.634 15.0001Z" fill="#34A853"/>
</svg>`,
        A = (0,
        i.JW)`<svg width="75" height="20" viewBox="0 0 75 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.6666 5.83334C11.6666 2.61168 14.2783 0 17.5 0H25.8334C29.055 0 31.6666 2.61168 31.6666 5.83334V14.1666C31.6666 17.3883 29.055 20 25.8334 20H17.5C14.2783 20 11.6666 17.3883 11.6666 14.1666V5.83334Z" fill="var(--apkt-tokens-theme-foregroundTertiary)"/>
<path d="M19.5068 13.7499L22.4309 5.83331H23.2895L20.3654 13.7499H19.5068Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M0 5.41666C0 2.42513 2.42513 0 5.41666 0C8.40821 0 10.8334 2.42513 10.8334 5.41666V14.5833C10.8334 17.5748 8.40821 20 5.41666 20C2.42513 20 0 17.5748 0 14.5833V5.41666Z" fill="var(--apkt-tokens-theme-foregroundTertiary)"/>
<path d="M4.89581 12.4997V11.458H5.93747V12.4997H4.89581Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M32.5 10C32.5 4.47715 36.6896 0 41.8578 0H65.6422C70.8104 0 75 4.47715 75 10C75 15.5229 70.8104 20 65.6422 20H41.8578C36.6896 20 32.5 15.5229 32.5 10Z" fill="var(--apkt-tokens-theme-foregroundTertiary)"/>
<path d="M61.7108 12.4475V7.82751H62.5266V8.52418C62.8199 8.01084 63.4157 7.70834 64.0757 7.70834C65.0749 7.70834 65.7715 8.34084 65.7715 9.56918V12.4475H64.9649V9.61503C64.9649 8.80831 64.5066 8.38668 63.8374 8.38668C63.1132 8.38668 62.5266 8.9642 62.5266 9.78001V12.4475H61.7108Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M56.5671 12.4475L55.7147 7.82748H56.4846L57.0896 11.6409L57.8871 9.12916H58.6479L59.4363 11.6134L60.0505 7.82748H60.8204L59.9679 12.4475H59.0513L58.2721 10.0458L57.4838 12.4475H56.5671Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M52.9636 12.5666C51.5611 12.5666 50.7361 11.5217 50.7361 10.1375C50.7361 8.76254 51.5611 7.70834 52.9636 7.70834C54.3661 7.70834 55.1911 8.76254 55.1911 10.1375C55.1911 11.5217 54.3661 12.5666 52.9636 12.5666ZM52.9636 11.8883C53.9719 11.8883 54.357 11.0266 54.357 10.1283C54.357 9.23914 53.9719 8.38668 52.9636 8.38668C51.9552 8.38668 51.5702 9.23914 51.5702 10.1283C51.5702 11.0266 51.9552 11.8883 52.9636 11.8883Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M47.8507 12.5666C46.494 12.5666 45.6415 11.5308 45.6415 10.1375C45.6415 8.75337 46.494 7.70834 47.8507 7.70834C48.9965 7.70834 50.0048 8.35917 49.8948 10.3483H46.4756C46.5398 11.2009 46.934 11.8975 47.8507 11.8975C48.4648 11.8975 48.8681 11.5217 49.0057 11.0908H49.8123C49.684 11.8609 48.9598 12.5666 47.8507 12.5666ZM46.494 9.73416H49.1065C49.0423 8.80831 48.6114 8.37751 47.8507 8.37751C47.0165 8.37751 46.604 8.98254 46.494 9.73416Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M41.7284 12.4475V7.82748H42.5625V8.60665C42.8559 8.09332 43.3601 7.82748 43.8825 7.82748H44.9917V8.60665H43.8184C43.0851 8.60665 42.5625 9.08331 42.5625 10.0092V12.4475H41.7284Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
</svg>

`,
        _ = (0, i.JW)`
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 8">
    <path
      fill="var(--apkt-tokens-theme-textPrimary)"
      d="m9.524 6.307-1.51 1.584A.35.35 0 0 1 7.76 8H.604a.178.178 0 0 1-.161-.103.168.168 0 0 1 .033-.186l1.51-1.583a.35.35 0 0 1 .256-.11h7.154c.034 0 .068.01.096.029a.168.168 0 0 1 .032.26Zm-1.51-3.189a.35.35 0 0 0-.255-.109H.604a.178.178 0 0 0-.161.103.168.168 0 0 0 .033.186l1.51 1.583a.35.35 0 0 0 .256.11h7.154a.178.178 0 0 0 .16-.104.168.168 0 0 0-.032-.185l-1.51-1.584ZM.605 1.981H7.76a.357.357 0 0 0 .256-.11L9.525.289a.17.17 0 0 0 .032-.185.173.173 0 0 0-.16-.103H2.241a.357.357 0 0 0-.256.109L.476 1.692a.17.17 0 0 0-.033.185.178.178 0 0 0 .16.103Z"
    />
  </svg>
`,
        I = (0,
        i.JW)`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`,
        S = (0, i.JW)`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
        k = (0, i.JW)`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`,
        N = (0, i.JW)`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`,
        T = (0, i.JW)`
<svg xmlns="http://www.w3.org/2000/svg" width="89" height="89" viewBox="0 0 89 89" fill="none">
<path d="M60.0468 39.2502L65.9116 33.3854C52.6562 20.13 36.1858 20.13 22.9304 33.3854L28.7952 39.2502C38.8764 29.169 49.9725 29.169 60.0536 39.2502H60.0468Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
<path d="M58.0927 52.9146L44.415 39.2369L30.7373 52.9146L17.0596 39.2369L11.2017 45.0949L30.7373 64.6374L44.415 50.9597L58.0927 64.6374L77.6284 45.0949L71.7704 39.2369L58.0927 52.9146Z" fill="var(--apkt-tokens-theme-textPrimary)"/>
</svg>`,
        O = (0, i.JW)`
<svg xmlns="http://www.w3.org/2000/svg" width="89" height="89" viewBox="0 0 89 89" fill="none">
<path d="M60.0468 39.2502L65.9116 33.3854C52.6562 20.13 36.1858 20.13 22.9304 33.3854L28.7952 39.2502C38.8764 29.169 49.9725 29.169 60.0536 39.2502H60.0468Z" fill="var(--apkt-tokens-theme-textInvert)"/>
<path d="M58.0927 52.9146L44.415 39.2369L30.7373 52.9146L17.0596 39.2369L11.2017 45.0949L30.7373 64.6374L44.415 50.9597L58.0927 64.6374L77.6284 45.0949L71.7704 39.2369L58.0927 52.9146Z" fill="var(--apkt-tokens-theme-textInvert)"/>
</svg>`,
        P = (0, i.JW)`
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_22274_4692)">
<path d="M0 6.64C0 4.17295 0 2.93942 0.525474 2.01817C0.880399 1.39592 1.39592 0.880399 2.01817 0.525474C2.93942 0 4.17295 0 6.64 0H9.36C11.8271 0 13.0606 0 13.9818 0.525474C14.6041 0.880399 15.1196 1.39592 15.4745 2.01817C16 2.93942 16 4.17295 16 6.64V9.36C16 11.8271 16 13.0606 15.4745 13.9818C15.1196 14.6041 14.6041 15.1196 13.9818 15.4745C13.0606 16 11.8271 16 9.36 16H6.64C4.17295 16 2.93942 16 2.01817 15.4745C1.39592 15.1196 0.880399 14.6041 0.525474 13.9818C0 13.0606 0 11.8271 0 9.36V6.64Z" fill="#C7B994"/>
<path d="M4.49038 5.76609C6.42869 3.86833 9.5713 3.86833 11.5096 5.76609L11.7429 5.99449C11.8398 6.08938 11.8398 6.24323 11.7429 6.33811L10.9449 7.11942C10.8964 7.16686 10.8179 7.16686 10.7694 7.11942L10.4484 6.80512C9.09617 5.48119 6.90381 5.48119 5.5516 6.80512L5.20782 7.14171C5.15936 7.18915 5.08079 7.18915 5.03234 7.14171L4.23434 6.3604C4.13742 6.26552 4.13742 6.11167 4.23434 6.01678L4.49038 5.76609ZM13.1599 7.38192L13.8702 8.07729C13.9671 8.17217 13.9671 8.32602 13.8702 8.4209L10.6677 11.5564C10.5708 11.6513 10.4137 11.6513 10.3168 11.5564L8.04388 9.33105C8.01965 9.30733 7.98037 9.30733 7.95614 9.33105L5.6833 11.5564C5.58638 11.6513 5.42925 11.6513 5.33234 11.5564L2.12982 8.42087C2.0329 8.32598 2.0329 8.17213 2.12982 8.07724L2.84004 7.38188C2.93695 7.28699 3.09408 7.28699 3.191 7.38188L5.46392 9.60726C5.48815 9.63098 5.52743 9.63098 5.55166 9.60726L7.82447 7.38188C7.92138 7.28699 8.07851 7.28699 8.17543 7.38187L10.4484 9.60726C10.4726 9.63098 10.5119 9.63098 10.5361 9.60726L12.809 7.38192C12.9059 7.28703 13.063 7.28703 13.1599 7.38192Z" fill="currentColor"/>
</g>
<defs>
<clipPath id="clip0_22274_4692">
<path d="M0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8Z" fill="white"/>
</clipPath>
</defs>
</svg>
`,
        R = (0, i.JW)`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="11" cy="11" r="11" transform="matrix(-1 0 0 1 23 1)" fill="#202020"/>
<circle cx="11" cy="11" r="11.5" transform="matrix(-1 0 0 1 23 1)" stroke="#C7B994" stroke-opacity="0.7"/>
<path d="M15.4523 11.0686L16.7472 9.78167C13.8205 6.87297 10.1838 6.87297 7.25708 9.78167L8.55201 11.0686C10.7779 8.85645 13.2279 8.85645 15.4538 11.0686H15.4523Z" fill="#C7B994"/>
<path d="M15.0199 14.067L12 11.0656L8.98 14.067L5.96004 11.0656L4.66663 12.3511L8.98 16.6393L12 13.638L15.0199 16.6393L19.3333 12.3511L18.0399 11.0656L15.0199 14.067Z" fill="#C7B994"/>
</svg>
`,
        $ = (0, i.JW)`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
      var D = r(20296),
        U = r(71084),
        M = r(47327);
      let L = (0, i.AH)`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    height: inherit;
    width: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
      var B = function (e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      };
      let W = {
          add: "ph-plus",
          allWallets: "ph-dots-three",
          arrowBottom: "ph-arrow-down",
          arrowBottomCircle: "ph-arrow-circle-down",
          arrowClockWise: "ph-arrow-clockwise",
          arrowLeft: "ph-arrow-left",
          arrowRight: "ph-arrow-right",
          arrowTop: "ph-arrow-up",
          arrowTopRight: "ph-arrow-up-right",
          bank: "ph-bank",
          bin: "ph-trash",
          browser: "ph-browser",
          card: "ph-credit-card",
          checkmark: "ph-check",
          checkmarkBold: "ph-check",
          chevronBottom: "ph-caret-down",
          chevronLeft: "ph-caret-left",
          chevronRight: "ph-caret-right",
          chevronTop: "ph-caret-up",
          clock: "ph-clock",
          close: "ph-x",
          coinPlaceholder: "ph-circle-half",
          compass: "ph-compass",
          copy: "ph-copy",
          desktop: "ph-desktop",
          dollar: "ph-currency-dollar",
          download: "ph-vault",
          exclamationCircle: "ph-warning-circle",
          extension: "ph-puzzle-piece",
          externalLink: "ph-arrow-square-out",
          filters: "ph-funnel-simple",
          helpCircle: "ph-question",
          id: "ph-identification-card",
          image: "ph-image",
          info: "ph-info",
          lightbulb: "ph-lightbulb",
          mail: "ph-envelope",
          mobile: "ph-device-mobile",
          more: "ph-dots-three",
          networkPlaceholder: "ph-globe",
          nftPlaceholder: "ph-image",
          plus: "ph-plus",
          power: "ph-power",
          qrCode: "ph-qr-code",
          questionMark: "ph-question",
          refresh: "ph-arrow-clockwise",
          recycleHorizontal: "ph-arrows-clockwise",
          search: "ph-magnifying-glass",
          sealCheck: "ph-seal-check",
          send: "ph-paper-plane-right",
          signOut: "ph-sign-out",
          spinner: "ph-spinner",
          swapHorizontal: "ph-arrows-left-right",
          swapVertical: "ph-arrows-down-up",
          threeDots: "ph-dots-three",
          user: "ph-user",
          verify: "ph-seal-check",
          verifyFilled: "ph-seal-check",
          warning: "ph-warning",
          warningCircle: "ph-warning-circle",
          appStore: "",
          apple: "",
          bitcoin: "",
          chromeStore: "",
          cursor: "",
          discord: "",
          ethereum: "",
          etherscan: "",
          facebook: "",
          farcaster: "",
          github: "",
          google: "",
          playStore: "",
          reown: "",
          solana: "",
          telegram: "",
          twitch: "",
          twitterIcon: "",
          twitter: "",
          walletConnect: "",
          walletConnectBrown: "",
          walletConnectLightBrown: "",
          x: "",
          wallet: "",
        },
        j = {
          "ph-arrow-circle-down": () =>
            Promise.all([r.e(6499), r.e(692)]).then(r.bind(r, 40692)),
          "ph-arrow-clockwise": () =>
            Promise.all([r.e(6499), r.e(2112)]).then(r.bind(r, 62112)),
          "ph-arrow-down": () =>
            Promise.all([r.e(6499), r.e(5608)]).then(r.bind(r, 25608)),
          "ph-arrow-left": () =>
            Promise.all([r.e(6499), r.e(2983)]).then(r.bind(r, 72983)),
          "ph-arrow-right": () =>
            Promise.all([r.e(6499), r.e(4064)]).then(r.bind(r, 34064)),
          "ph-arrow-square-out": () =>
            Promise.all([r.e(6499), r.e(7377)]).then(r.bind(r, 57377)),
          "ph-arrows-down-up": () =>
            Promise.all([r.e(6499), r.e(746)]).then(r.bind(r, 746)),
          "ph-arrows-left-right": () =>
            Promise.all([r.e(6499), r.e(9990)]).then(r.bind(r, 19990)),
          "ph-arrow-up": () =>
            Promise.all([r.e(6499), r.e(9583)]).then(r.bind(r, 29583)),
          "ph-arrow-up-right": () =>
            Promise.all([r.e(6499), r.e(7161)]).then(r.bind(r, 87161)),
          "ph-arrows-clockwise": () =>
            Promise.all([r.e(6499), r.e(5851)]).then(r.bind(r, 35851)),
          "ph-bank": () =>
            Promise.all([r.e(6499), r.e(4913)]).then(r.bind(r, 44913)),
          "ph-browser": () =>
            Promise.all([r.e(6499), r.e(9827)]).then(r.bind(r, 9827)),
          "ph-caret-down": () =>
            Promise.all([r.e(6499), r.e(1194)]).then(r.bind(r, 91194)),
          "ph-caret-left": () =>
            Promise.all([r.e(6499), r.e(1753)]).then(r.bind(r, 41753)),
          "ph-caret-right": () =>
            Promise.all([r.e(6499), r.e(1098)]).then(r.bind(r, 81098)),
          "ph-caret-up": () =>
            Promise.all([r.e(6499), r.e(9301)]).then(r.bind(r, 49301)),
          "ph-check": () =>
            Promise.all([r.e(6499), r.e(9987)]).then(r.bind(r, 69987)),
          "ph-circle-half": () =>
            Promise.all([r.e(6499), r.e(8292)]).then(r.bind(r, 28292)),
          "ph-clock": () =>
            Promise.all([r.e(6499), r.e(6281)]).then(r.bind(r, 16281)),
          "ph-compass": () =>
            Promise.all([r.e(6499), r.e(8235)]).then(r.bind(r, 18235)),
          "ph-copy": () =>
            Promise.all([r.e(6499), r.e(676)]).then(r.bind(r, 40676)),
          "ph-credit-card": () =>
            Promise.all([r.e(6499), r.e(2646)]).then(r.bind(r, 22646)),
          "ph-currency-dollar": () =>
            Promise.all([r.e(6499), r.e(8364)]).then(r.bind(r, 68364)),
          "ph-desktop": () =>
            Promise.all([r.e(6499), r.e(4275)]).then(r.bind(r, 64275)),
          "ph-device-mobile": () =>
            Promise.all([r.e(6499), r.e(2943)]).then(r.bind(r, 42943)),
          "ph-dots-three": () =>
            Promise.all([r.e(6499), r.e(3655)]).then(r.bind(r, 23655)),
          "ph-vault": () =>
            Promise.all([r.e(6499), r.e(1447)]).then(r.bind(r, 51447)),
          "ph-envelope": () =>
            Promise.all([r.e(6499), r.e(5631)]).then(r.bind(r, 85631)),
          "ph-funnel-simple": () =>
            Promise.all([r.e(6499), r.e(9729)]).then(r.bind(r, 99729)),
          "ph-globe": () =>
            Promise.all([r.e(6499), r.e(180)]).then(r.bind(r, 60180)),
          "ph-identification-card": () =>
            Promise.all([r.e(6499), r.e(7791)]).then(r.bind(r, 17791)),
          "ph-image": () =>
            Promise.all([r.e(6499), r.e(2244)]).then(r.bind(r, 72244)),
          "ph-info": () =>
            Promise.all([r.e(6499), r.e(7855)]).then(r.bind(r, 77855)),
          "ph-lightbulb": () =>
            Promise.all([r.e(6499), r.e(538)]).then(r.bind(r, 50538)),
          "ph-magnifying-glass": () =>
            Promise.all([r.e(6499), r.e(602)]).then(r.bind(r, 20602)),
          "ph-paper-plane-right": () =>
            Promise.all([r.e(6499), r.e(5857)]).then(r.bind(r, 95857)),
          "ph-plus": () =>
            Promise.all([r.e(6499), r.e(875)]).then(r.bind(r, 80875)),
          "ph-power": () =>
            Promise.all([r.e(6499), r.e(4280)]).then(r.bind(r, 44280)),
          "ph-puzzle-piece": () =>
            Promise.all([r.e(6499), r.e(1622)]).then(r.bind(r, 9241)),
          "ph-qr-code": () =>
            Promise.all([r.e(6499), r.e(1973)]).then(r.bind(r, 31973)),
          "ph-question": () =>
            Promise.all([r.e(6499), r.e(6959)]).then(r.bind(r, 56959)),
          "ph-question-circle": () =>
            Promise.all([r.e(6499), r.e(9020)]).then(r.bind(r, 79020)),
          "ph-seal-check": () =>
            Promise.all([r.e(6499), r.e(3034)]).then(r.bind(r, 23034)),
          "ph-sign-out": () =>
            Promise.all([r.e(6499), r.e(7002)]).then(r.bind(r, 77002)),
          "ph-spinner": () =>
            Promise.all([r.e(6499), r.e(6332)]).then(r.bind(r, 36332)),
          "ph-trash": () =>
            Promise.all([r.e(6499), r.e(5557)]).then(r.bind(r, 15557)),
          "ph-user": () =>
            Promise.all([r.e(6499), r.e(5154)]).then(r.bind(r, 25154)),
          "ph-warning": () =>
            Promise.all([r.e(6499), r.e(7839)]).then(r.bind(r, 27839)),
          "ph-warning-circle": () =>
            Promise.all([r.e(6499), r.e(5448)]).then(r.bind(r, 23067)),
          "ph-x": () =>
            Promise.all([r.e(6499), r.e(979)]).then(r.bind(r, 30979)),
        },
        F = {
          appStore: h,
          apple: u,
          bitcoin: p,
          chromeStore: f,
          cursor: g,
          discord: m,
          ethereum: y,
          etherscan: w,
          facebook: b,
          farcaster: v,
          github: C,
          google: E,
          playStore: x,
          reown: A,
          solana: _,
          telegram: I,
          twitch: S,
          twitter: $,
          twitterIcon: k,
          walletConnect: T,
          walletConnectInvert: O,
          walletConnectBrown: R,
          walletConnectLightBrown: P,
          x: $,
          wallet: N,
        },
        H = {
          "accent-primary": D.f.tokens.core.iconAccentPrimary,
          "accent-certified": D.f.tokens.core.iconAccentCertified,
          default: D.f.tokens.theme.iconDefault,
          success: D.f.tokens.core.iconSuccess,
          error: D.f.tokens.core.iconError,
          warning: D.f.tokens.core.iconWarning,
          inverse: D.f.tokens.theme.iconInverse,
        },
        q = class extends i.WF {
          constructor() {
            super(...arguments),
              (this.size = "md"),
              (this.name = "copy"),
              (this.weight = "bold"),
              (this.color = "inherit");
          }
          render() {
            this.style.cssText = `
      --local-width: ${
        "inherit" === this.size
          ? "inherit"
          : `var(--apkt-spacing-${
              {
                xxs: "2",
                xs: "3",
                sm: "3",
                md: "4",
                mdl: "5",
                lg: "5",
                xl: "6",
                xxl: "7",
                inherit: "inherit",
              }[this.size]
            })`
      };
      --local-color: ${"inherit" === this.color ? "inherit" : H[this.color]}
    `;
            let e = W[this.name];
            if (e && "" !== e) {
              let t = j[e];
              t && t();
              let r = { _$litStatic$: e, r: a };
              return d`<${r} size=${
                {
                  xxs: "0.5em",
                  xs: "0.75em",
                  sm: "0.75em",
                  md: "1em",
                  mdl: "1.25em",
                  lg: "1.25em",
                  xl: "1.5em",
                  xxl: "1.75em",
                }[this.size]
              } weight="${this.weight}"></${r}>`;
            }
            return F[this.name] || d``;
          }
        };
      (q.styles = [U.W5, L]),
        B([(0, n.MZ)()], q.prototype, "size", void 0),
        B([(0, n.MZ)()], q.prototype, "name", void 0),
        B([(0, n.MZ)()], q.prototype, "weight", void 0),
        B([(0, n.MZ)()], q.prototype, "color", void 0),
        (q = B([(0, M.E)("wui-icon")], q));
    },
  },
]);
